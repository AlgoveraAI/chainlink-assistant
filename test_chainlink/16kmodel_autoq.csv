question,answer,metadata,result,sources,retrieved_docs
What is the purpose of hosting encrypted secrets on AWS S3 in this tutorial?,To replace the default off-chain option and securely store the secrets.,{'source': 'https://docs.chain.link/chainlink-functions/tutorials/api-use-secrets-offchain/'},"The purpose of hosting encrypted secrets on AWS S3 in this tutorial is not mentioned in the provided content.
SOURCES:",,"Question: (Asked on: 2022-07-04 19:14:01)
Hosting Chainlink Node on AWS, can&#39;t access the Admin Portal
URL: https://stackoverflow.com/questions/72861140/hosting-chainlink-node-on-aws-cant-access-the-admin-portal

Question Body:


I've successfully deployed a chainlink node on AWS following this tutorial:

<https://aws-quickstart.github.io/quickstart-chainlinklabs-chainlink-
node/#_parameter_reference>

I'm to the part of 'Post Deployment Steps'. However, I have no idea how to
access the admin console for Chainlink. Where would I find my Application Load
Balancer Endpoint? I'm sure I'm just missing it, but I cannot find it for the
life of me.

Thanks in advance



Answers:
(Answered on: 2022-07-10 09:48:35)


Hi @harrisoncolewilkinson

This is an issue in the documentation... and a chance to improvement!

Could you make an issue on the docs?

Thank you so much.





:::NEXT DOC:::

Question: (Asked on: 2022-01-16 16:25:11)
AWS Chainlink Quickstart Error - S3 Error Access Denied
URL: https://stackoverflow.com/questions/70731937/aws-chainlink-quickstart-error-s3-error-access-denied

Question Body:


I am getting the following error when executing the Quickstart for Chainlink
during the AuroraStack execution.

S3 Error: Access Denied

Not very friendly error so I went over to the yaml file.

<https://aws-quickstart.s3.us-east-1.amazonaws.com/quickstart-chainlinklabs-
chainlink-node/submodules/quickstart-amazon-aurora-
postgresql/templates/aurora_postgres.template.yaml>

And gave it a read but I really don't see anything that even has it hitting an
S3 storage resource.

The error would lead me to believe that the previous YAML file that calls the
above is being called and can't even reach the S3 file for Aurora.

Anyone else seen / resolved this issue?

Any ideas are appreciated?

Thanks!

Chris

Ultimately, it was an S3 access issue to the Aurora file inside the chainlink
quickstart. I setup an S3 bucket, redid the files and gave myself permission
and it worked fine.



Answers:
(Answered on: 2022-01-16 19:37:15)


Ultimately, it was an S3 access issue to the Aurora file inside the chainlink
quickstart. I setup an S3 bucket, redid the files and gave myself permission
and it worked fine.



"
What was the error message received when running the run script?,opening db: failed to open db: failed to connect to `host=/tmp user=database=`: dial error (dial unix /tmp/.s.PGSQL.5432: connect: no such file or directory),{'source': 'https://stackoverflow.com/questions/70978628/chainlink-quick-start-problems-connecting-to-the-database'},"The error message received when running the run script was ""Unused function parameter.""",,"Question: (Asked on: 2022-09-15 14:41:55)
Task fails with no way to debug
URL: https://stackoverflow.com/questions/73733171/task-fails-with-no-way-to-debug

Question Body:


I have a node running two jobs - they communicate with an external adaptor and
then send the value on-chain.

One job works fine, which already tells me that the node can write on-chain.

The other job, receives the request, talks with the external adaptor (I have
verified this on the external adaptor server) and then doesn't submit anything
on-chain.

There is no way to debug this through the Operator UI. This is what it shows:

[](https://i.stack.imgur.com/z2s2t.png)

What should I do? I am running the Chainlink develop version because the most
up-to-date stable version as a critical bug.



Answers:
(Answered on: 2022-09-18 05:12:28)


In the Chainlink node version 1.8.0, there are ""Error"" and ""Runs"" tabs in your
node UI in the browser, and these 2 tabs allow you to view what's wrong with
your job run. You can find the latest chainlink docker image
[here](https://hub.docker.com/r/smartcontract/chainlink/tags).

[](https://i.stack.imgur.com/W6AxZ.png)

The error messages under the ""error"" tab are shown below, and the info can
reflect the error your job encountered in the run.

[](https://i.stack.imgur.com/IUEU0.jpg)

If there are no ""error"" and ""run"" tabs in the browser or there is nothing
shown in the UI, you can also find error info in the log file housed by the
server running the Chainlink node. The default path of the Chainlink node log
file is `/chainlink/chainlink_debug.log`, so you can log into the server that
running the node and check the log for debugging.

Hope it helps.





:::NEXT DOC:::

Question: (Asked on: 2022-01-12 16:31:18)
Remix error message &#39;Unused function parameter&#39; with fulfillRandomness using Chainlink VRF Smart Contract
URL: https://stackoverflow.com/questions/70685083/remix-error-message-unused-function-parameter-with-fulfillrandomness-using-cha

Question Body:


The issue is a repeated error message upon attempting to compile a verifiable
random number smart contract in remix. This particular function ( **line 48**
in remix or **last line** of code below) yields the error message consistently
across compiler versions (I checked the imported documents versions too),
cross brave browser+firefox, and even after checking grammar. I do not
understand what this error message is conveying (I am brand new to
programming) and I cannot find another thread with this same issue. I suspect
the function to be faulty in some sense of how it is either defined or
interacting with the other imported documents ( **VRFConsumerBase.sol** ).

    
    
    //SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here:
     * https://docs.chain.link/docs/link-token-contracts/
     */
    
    contract RandomNumberConsumer is VRFConsumerBase {
    
        bytes32 public keyHash;
        uint256 public fee;
        uint256 public randomResult;
    
        /**
         * Constructor inherits VRFConsumerBase
         * 
         * Network: Rinkeby
         * Chainlink VRF Coordinator address: 0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B
         * LINK token address:                0x01BE23585060835E02B77ef475b0Cc51aA1e0709
         * Key Hash: 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311
         */
    
        constructor() VRFConsumerBase(
            0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B, //VRF Coordinator
            0x01BE23585060835E02B77ef475b0Cc51aA1e0709) //Rinkeby LINK Token
        {
            keyHash = 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311;
            fee = 0.1 * 10 ** 18; //0.1 LINK (varies by network)
        }
    
        /**
         * Requests fulfillRandomness
         */
    
        function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
    
        /**
         * Callback function used by VRF Coordinator
         */
    
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
    }
    
    

This near identical code can be found at <https://docs.chain.link/docs/get-a-
random-number/> **(line 52)**. Here is the error message below,

    
    
            from solidity:
    Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
      --> docs.chain.link/samples/VRF/RandomNumberConsumer.sol:52:32: function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
    

I am following the 'Getting A Random Number with Chainlink VRF' tutorial from
Chainlink <https://www.youtube.com/watch?v=JqZWariqh5s> (timestamp @ 9:30)
except I am testing on the Rinkeby network not Kovan. I also double checked
with this tutorial. <https://www.youtube.com/watch?v=_aXumgdpnPU> (timestamp @
12:00) Neither tutorial encounters this specific error message and both are
able to compile and deploy the smart contract successfully. I also receive the
error message when I directly open and attempt to compile the smart contract
from the Chainlink website without touching the code.



Answers:
(Answered on: 2022-01-31 17:54:20)


i had the same error i fixed it by leaving the bytes32 parameter empty

your code (bytes32 requestId , uint256 randomness)

instead use: (bytes32, uint256 randomness)



"
What is the Monte Carlo fallacy?,The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md'},"The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. It is a fallacy because the occurrence of an event is random and independent of past events. An example of the Monte Carlo fallacy is believing that if red has appeared ten times in a row in a game of roulette, the next color is more likely to be black. However, statistically, there is no reason to assume that the next color is more likely to be black. The occurrence of the color is random.
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md,"#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let’s take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.


:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What was the error message received while executing the 'setAuthorizedSenders' method from remix?,Gas estimation errored with the following message (see below). The transaction execution will likely fail. Do you want to force sending? execution reverted: Cannot set authorized senders,{'source': 'https://stackoverflow.com/questions/75301080/unable-to-transact-operator-setauthorizedsenders-on-chainlink-goerli'},"The error message received while executing the 'setAuthorizedSenders' method from remix was ""execution reverted: Cannot set authorized senders"". 
","https://stackoverflow.com/questions/75301080/unable-to-transact-operator-setauthorizedsenders-on-chainlink-goerli

Note: There is no information provided about an error message related to the 'fulfillRandomness' method.","Question: (Asked on: 2023-01-31 17:44:37)
Unable to transact Operator.setAuthorizedSenders on Chainlink - Goerli
URL: https://stackoverflow.com/questions/75301080/unable-to-transact-operator-setauthorizedsenders-on-chainlink-goerli

Question Body:


Completed the local node setup on ubuntu 20.04, and the chainlink node is up
and running. Deployed the Operator.sol, while executing the
'setAuthorizedSenders' method from remix getting following error:

> Gas estimation errored with the following message (see below). The
> transaction execution will likely fail. Do you want to force sending?
> execution reverted: Cannot set authorized senders { ""originalError"": {
> ""code"": 3, ""data"":
> ""0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001d43616e6e6f742073657420617574686f72697a65642073656e64657273000000"",
> ""message"": ""execution reverted: Cannot set authorized senders"" } }



Answers:
(Answered on: 2023-02-01 06:55:44)


It is my mistake. Sent the node address as the admin address for owner during
the contract deployment. It is working as expected.





:::NEXT DOC:::

Question: (Asked on: 2022-01-12 16:31:18)
Remix error message &#39;Unused function parameter&#39; with fulfillRandomness using Chainlink VRF Smart Contract
URL: https://stackoverflow.com/questions/70685083/remix-error-message-unused-function-parameter-with-fulfillrandomness-using-cha

Question Body:


The issue is a repeated error message upon attempting to compile a verifiable
random number smart contract in remix. This particular function ( **line 48**
in remix or **last line** of code below) yields the error message consistently
across compiler versions (I checked the imported documents versions too),
cross brave browser+firefox, and even after checking grammar. I do not
understand what this error message is conveying (I am brand new to
programming) and I cannot find another thread with this same issue. I suspect
the function to be faulty in some sense of how it is either defined or
interacting with the other imported documents ( **VRFConsumerBase.sol** ).

    
    
    //SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here:
     * https://docs.chain.link/docs/link-token-contracts/
     */
    
    contract RandomNumberConsumer is VRFConsumerBase {
    
        bytes32 public keyHash;
        uint256 public fee;
        uint256 public randomResult;
    
        /**
         * Constructor inherits VRFConsumerBase
         * 
         * Network: Rinkeby
         * Chainlink VRF Coordinator address: 0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B
         * LINK token address:                0x01BE23585060835E02B77ef475b0Cc51aA1e0709
         * Key Hash: 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311
         */
    
        constructor() VRFConsumerBase(
            0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B, //VRF Coordinator
            0x01BE23585060835E02B77ef475b0Cc51aA1e0709) //Rinkeby LINK Token
        {
            keyHash = 0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311;
            fee = 0.1 * 10 ** 18; //0.1 LINK (varies by network)
        }
    
        /**
         * Requests fulfillRandomness
         */
    
        function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
    
        /**
         * Callback function used by VRF Coordinator
         */
    
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
    }
    
    

This near identical code can be found at <https://docs.chain.link/docs/get-a-
random-number/> **(line 52)**. Here is the error message below,

    
    
            from solidity:
    Warning: Unused function parameter. Remove or comment out the variable name to silence this warning.
      --> docs.chain.link/samples/VRF/RandomNumberConsumer.sol:52:32: function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
    

I am following the 'Getting A Random Number with Chainlink VRF' tutorial from
Chainlink <https://www.youtube.com/watch?v=JqZWariqh5s> (timestamp @ 9:30)
except I am testing on the Rinkeby network not Kovan. I also double checked
with this tutorial. <https://www.youtube.com/watch?v=_aXumgdpnPU> (timestamp @
12:00) Neither tutorial encounters this specific error message and both are
able to compile and deploy the smart contract successfully. I also receive the
error message when I directly open and attempt to compile the smart contract
from the Chainlink website without touching the code.



Answers:
(Answered on: 2022-01-31 17:54:20)


i had the same error i fixed it by leaving the bytes32 parameter empty

your code (bytes32 requestId , uint256 randomness)

instead use: (bytes32, uint256 randomness)



"
What is the purpose of the VRFv2SubscriptionManager contract?,The purpose of the VRFv2SubscriptionManager contract is to manage subscriptions for the Chainlink Verifiable Random Function (VRF) service.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-9/solution.md'},"The purpose of the VRFv2SubscriptionManager contract is not mentioned in the provided content.
SOURCES:",,"Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    





:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the correct way to mock a response using the _fulfillOracleRequest_ function in the MockOracle contract?,"The _fulfillOracleRequest_ function takes a bytes32 param for the response, so you need to encode it properly. This is how you can mock a response as part of the APIConsumer Unit Test: let mockResponse = '777'; const responseBytes = ethers.utils.formatBytes32String(mockResponse); const r = await mockOracle.fulfillOracleRequest(requestId, responseBytes);",{'source': 'https://stackoverflow.com/questions/70405858/how-to-mock-chainlink-oracle-api-responses-on-hardhat'},"To mock a response using the _fulfillOracleRequest_ function in the MockOracle contract, you need to encode the response properly. Here is an example of how to do it:

```javascript
let mockResponse = '777'
const responseBytes = ethers.utils.formatBytes32String(mockResponse)
const r = await mockOracle.fulfillOracleRequest(requestId, responseBytes)
```

This code snippet shows how to encode the response as a bytes32 value and pass it to the fulfillOracleRequest function.

","- https://stackoverflow.com/questions/70405858/how-to-mock-chainlink-oracle-api-responses-on-hardhat

Note: The answer provided is based on the information available and may not be the only possible solution.","Question: (Asked on: 2021-12-18 18:10:26)
How to mock Chainlink/oracle API responses on hardhat
URL: https://stackoverflow.com/questions/70405858/how-to-mock-chainlink-oracle-api-responses-on-hardhat

Question Body:


On the hardhat starter kit, the unit test checks if you can make an api
request. But it doesn't actually fulfill the request. In the tasks, it
requests volume data but it isn't shown how to fulfill the request.

From looking at the code for the mockOracle I found this function.

    
    
    const r = await mockOracle.fulfillOracleRequest(requestId, data)
    

I dont have any idea how to make the data be what I want it to be. For example
when I pass the following data it returns the huge seamingly random number
24516769870864860957297836120308737325622166553046088662895407649136392011776.

    
    
    const data = ethers.utils.formatBytes32String(""64"")
    

How do I mock the api response with the data I pass to fulfillOracleRequest?
Also, because I couldn't find any examples of this in the chainlink starter
kit, is this even the right way to be doing this on the local hardhat network?



Answers:
(Answered on: 2021-12-20 01:22:18)


The _fulfillOracleRequest_ function in the [MockOracle
contract](https://github.com/smartcontractkit/hardhat-starter-
kit/blob/main/contracts/test/MockOracle.sol) takes a bytes32 param for the
response, so you need to encode it properly. This is how you can mock a
response as part of the [APIConsumer Unit
Test](https://github.com/smartcontractkit/hardhat-starter-
kit/blob/main/test/unit/APIConsumer_unit_test.js):

    
    
    let mockResponse = '777'
    const responseBytes = ethers.utils.formatBytes32String(mockResponse)
    const r = await mockOracle.fulfillOracleRequest(requestId, responseBytes)
    

To answer your second question, yes this is the correct thing to do when
working with local chains that aren't integrated to Chainlink oracles. There
is actually an [open issue](https://github.com/smartcontractkit/hardhat-
starter-kit/issues/67) to implement these for the unit tests. Feel free to
take it on if you want!





:::NEXT DOC:::

Question: (Asked on: 2022-12-16 18:52:48)
Testing Chainlink API calls using Hardhat
URL: https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat

Question Body:


I am having trouble testing Chainlink API calls locally. I have a contract
which calls my API consumer contract to make an API call. However, when I try
to do that, the MockOracle (mocked oracle for local testing, from chainlink)
contract reverts (VM exception) saying ""Must use whitelisted functions"". I am
making an API call for a bytes32 get request.

This is the function modifier (inside of LinkTokenReceiver) where the
MockOracle reverts (it gets called by the MockOracle when receiving LINK
tokens):

    
    
    /**
       * @dev Reverts if the given data does not begin with the `oracleRequest` function selector
       * @param _data The data payload of the request
       */
      modifier permittedFunctionsForLINK(bytes memory _data) {
        bytes4 funcSelector;
        assembly {
          // solhint-disable-next-line avoid-low-level-calls
          funcSelector := mload(add(_data, 32))
        }
        require(funcSelector == ORACLE_REQUEST_SELECTOR, ""Must use whitelisted functions"");
        _;
      }
    

The ApiConsumer is properly funded, and the LINK token is a local deployment
of the chainlink Token. So, what am I doing wrong? Or what is the best way to
test Chainlink API calls (bytes32 get request) locally using hardhat?



Answers:
(Answered on: 2023-03-04 12:21:04)


If you are testing locally the chainlink node will not be able to detect any
requests.  
You have a few options:

  1. Deploy your APIConsumer contract to a testnet and make use of an already deployed operator contract. A list can be found on chainlinks website [https://docs.chain.link/any-api/testnet-oracles/]. Then select a jobId for a node job that can provide the API data you need e.g. bytes32, Int, multi words etc. The jobId can be specified in your APIConsumer contract.
  2. Deploy your own operator contract, setup your own node (chainlink has an option for setting up temporary development nodes), and then create a custom job for your API. You will then need to put you node address as an authorised sender in your operator contract to permit data to be returned from your node.
  3. For local testing you will need to write a function in your test script that sends a mock response to your mock operator contract. Make sure you setAuthorisedSenders for the account you use to send the fulfillOracleRequest transaction, to test properly I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:

    
    
      modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata _data) {
        require(_data.length >= 32, ""Response must be > 32 bytes""); 
        bytes memory firstDataWord = new bytes(32);
        for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript snippet for test script 
    //If local network - Set Authorised senders on Mock Oracle to account[1]
        const [owner, mockNode] = await ethers.getSigners();
        const mockNodeAccount = mockNode.address
        await mockOracle.setAuthorizedSenders([mockNodeAccount])
        
        
        const transaction: ContractTransaction = await apiConsumer.requestWithWords(ANY_ARGS_FOR_API)
        const transactionReceipt: ContractReceipt = await transaction.wait(1)
        const requestId = transactionReceipt.events[0].topics[1]
    
        const apiFilter = apiConsumer.filters.ChainlinkRequested()
        const apiEvents = await apiConsumer.queryFilter(apiFilter)
        console.log(apiEvents)
    
        const filter = mockOracle.filters.OracleRequest()
        const events = await mockOracle.queryFilter(filter)
        const {specId, requester, requestIdEvent, payment, callbackAddr, callbackFunctionId, cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
    
        const encodeRequestId = web3.eth.abi.encodeParameters(
            ['bytes32'],
            [requestId])
            
        await mockOracle.connect(mockNode).fulfillOracleRequest2(requestIdfirst, payment, callbackAddr, callbackFunctionId, cancelExpiration, encodeMwr)

To improve on this you could then look to add an API http GET call into your
test script for getting the rest of the callback data for fulfillOracleRequest
or fulfillOracleRequest2 function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I am guessing you are currently using the `oracle.sol` and
`ChainlinkClient.sol` in version v0.6. In version v0.6, AFAIK, ChainlinkClient
doesn't not help users to add function selector `oracleRequest` in the users'
Chainlink request, which means you will get the error if you doesn't manually
add the function selector in your request. In v0.7, ChainlinkClient helps you
add the selector in the request. Just check the function
`sendChainlinkRequestTo` in [ChainlinkClient
v0.6](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/ChainlinkClient.sol)
and [ChainlinkClient
v0.7](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/ChainlinkClient.sol)
by yourself.

Solutions:

  1. Use the v0.7 ChainlinkClient and [operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)(smart contract oracle.sol is renamed as operator.sol in v0.7) for your test. The document can be found [here](https://docs.chain.link/any-api/get-request/examples/single-word-response).
  2. There is a repo called [hardhat-starter-kit](https://github.com/smartcontractkit/hardhat-starter-kit) in Chainlink official github, there are sample codes you can try. Or you can directly use starterkit to test AnyApi and any other services.



"
What are events in Solidity and how can they be used?,Events in Solidity are a way to emit events that clients can listen to and react accordingly. They can also be used as a cheap form of storage. Events are write-only and cannot be read. They can be used to create an audit trail and communicate easy-to-access messages to listeners. Libraries like ethers.js allow us to listen to these events and react accordingly.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-7/course.md'},"Events in Solidity are a feature that allows developers to emit events from smart contracts. These events can be used to communicate messages to clients or other applications. Events can be listened to in real-time or historical events can be retrieved. They can also be used as a form of cheap storage. However, it is important to note that events are write-only and cannot be read. They are emitted using the `emit` keyword followed by the event name. The parameters of the event can be defined, including indexed parameters which are searchable. Libraries like ethers.js can be used to listen to these events and react accordingly.

","- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-7/description.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-7/course.md","Solidity does not offer a console.log but has events that can be used in a similar fashion. You can use it to emit events that clients can listen to react accordingly. They can also be used as a cheap form of storage as it is less expensive to emit an event than to use the storage location. But note that events are write-only. EVM does not allow to read events.


:::NEXT DOC:::

#####Chapter 7:

# Events

When learning a new language, we often write a hello world program and log a string to the console. Solidity does not offer a console.log but has events that can be used in a similar fashion. You can use it to emit events that clients can listen to react accordingly. They can also be used as a cheap form of storage as it is less expensive to emit an event than to use the storage location (see chapter 2). But note that events are write-only. EVM does not allow to read events.

Let’s learn how we can use events in Solidity:

<Highlight class=""language-javascript"">
contract Event {
 event Log(address indexed sender, string message);
 
 function foo() public {
       emit Log(msg.sender, ""Hello World!"");
       emit Log(msg.sender, ""Another message"");
 }
}
</Highlight>

On the top we have defined a name of the Event and defined it’s parameters. You can see here that we have indexed and not index parameters. Indexed parameters are called “topics” and are searchable parameters in events. We will explain why this is useful in a moment.

We can now use the keyword **emit** followed by the event name **Log** to emit an event of the type Log. These events can be read on an explorer like Etherscan. And there you will see that each event has the address of the contract or account the event is emitted from and Topics which is the indexed parameter of the event and the data itself. These are ABI-Encoded or hashed non-indexed parameters of the event. More on ABI in a future course.
Libraries like ethers.js allow us to listen to these events and react accordingly. The great thing about events is that applications not interested in writing or interacting with the blockchain can still react to events emitted from smart contracts. In other terms, you could consider events a simple way to communicate easy-to-access messages to listeners. You can either listen to them in real-time as they are written to a new block or also retrieve historical events from the past. It makes it easy to create an audit trail this way. You will often see events used to communicate that a new token was minted.
"
What is an array in programming?,An array is many related pieces of data stored together in a single variable.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-8/course.md'},"An array in programming is a data structure that allows you to store multiple related values in a single variable. Each value in the array is associated with an index, starting from 0. You can access the values in an array by calling the array variable and specifying the index of the value you want to access within square brackets. For example, if you have an array called ""myBooks"" with the values [""Mastering Ethereum"", ""Programming Rust"", ""Zombie Survival Guide""], accessing ""myBooks[0]"" will give you the first value in the array, which is ""Mastering Ethereum"". You can also assign a value from an array to another variable by specifying the index. This creates a copy of the value and assigns it to the new variable without erasing it from the original array.

","- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-13/description.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-9/course.md","The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions).


:::NEXT DOC:::

#####Chapter 9:

# Reading Array Values

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

Now that we can store multiple related values into a single array our lives organizing our data should be much easier! But how do we access those stored values later? Data stored in arrays is associated with an index which describes the order of the data. Indexing in Solidity starts at 0. So this means the first values assigned to an array has the index of 0, the second value assigned to the array has an index of 1, the third value an index of 2 and so on.

You can access the values in an array by calling the array variable and putting the index of the value you want to access within square brackets. For example:

<Highlight class=""language-javascript"">
string[] myBooks = [ “Mastering Ethereum”, “Programming Rust”, “Zombie Survival Guide”]
</Highlight>

And then

myBooks[0] will access the first value assigned to the myBooks array (since Solidity indexes at 0) which will be the value “Mastering Ethereum”.

As another example I could take a value in an array and also assign it to another variable:

<Highlight class=""language-javascript"">
string myFirstBook = myBooks[0];
</Highlight>

Which will take the value indexed at zero in the “myBooks” array (which is “Mastering Ethereum”) and assign it to the string named “myFirstBook”. This won’t erase it from the myBooks array but make a copy and assign to the new “myFirstBook” variable.

"
What is the cryptocurrency symbol for Cardano?,ADA,{'source': 'https://docs.chain.link/data-feeds/price-feeds/addresses/'},"The document does not mention the cryptocurrency symbol for Cardano.
SOURCES:",,"In programming an operator is a symbol that represents an action or process. In the case of the assignment operator whatever is to the left of the equals sign is being assigned the value of whatever is on the right of the equal sign.


:::NEXT DOC:::

Question: (Asked on: 2022-02-03 21:36:48)
Chainlink Quick Start problems connecting to the database?
URL: https://stackoverflow.com/questions/70978628/chainlink-quick-start-problems-connecting-to-the-database

Question Body:


I have gone through the AWS Chainlink quickstart successfully. I disabled the
ssl certificate and decided to use TCP enabled. The Chainlink node did not
launch on intial deployment. I used the .sh files to create .api, .password,
.env

I run the run script but get this error

opening db: failed to open db: failed to connect to `host=/tmp user=
database=`: dial error (dial unix /tmp/.s.PGSQL.5432: connect: no such file or
directory)

I have also gone through the step on the Chainlink docs to enable https
connections, and have configured the tls ports in the .env file.

I thought for sure it was the tls blocking me from the database. But still I
get this error

Here is my
DATABASE_URL=postgresql://user:password@writerendpointofcluster:5432/databasename

I used the writer endpoint of the cluster.

I don't know what to try next. Any help would be much appreciated.



Answers:
(Answered on: 2022-03-26 19:56:05)


In addition to !, * and _ can be used as the symbol requirement for the
database password.

The following characters also lead to an error: <, >, @, =. This is due to
some special characters requiring percent encoding, as discussed on this AWS
Chainlink QuickStart [GitHub issue](https://github.com/aws-
quickstart/quickstart-chainlinklabs-chainlink-
node/issues/23#issuecomment-970486800).


---
(Answered on: 2022-03-18 13:16:31)


The problem was the password for the database. There are certain characters
that throw an error.

The instructions on the AWS Chainlink quickstart on the database password
characters that are prohibited is not an exhaustive list.

In regards to AWS Chainlink quickstart, you can use the ""!"" as the symbol
requirement for the database password.

We are putting together a list of characters that throw an error, so far we
have #, ^, %, $ symbols that prevents you from connecting to the database.

*please comment which symbol gave you an error and I can add it to the list



"
What are the three different locations to store variables in Solidity?,"The three different locations to store variables in Solidity are storage, memory, and calldata.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-2/course.md'},"The three different locations to store variables in Solidity are: 
1. State variables: These variables are stored permanently on the blockchain and their values are accessible across multiple function calls.
2. Local variables: These variables are temporary and exist only within the scope of a function. They are not stored on the blockchain.
3. Function arguments: These variables are passed as parameters to a function and their values are determined when the function is called.
","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-6/description.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-5/description.md","An error will revert all changes made to the state during a transaction. There are three different ways to throw an error.


:::NEXT DOC:::

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing variables and change data by defining logic in functions. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time.
"
What is a subscription in VRFv2?,A subscription is an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to 'consumer' contracts that want to request randomness.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-5/course.md'},"The VRFv2 subscription is a method used in the Chainlink ecosystem to request random numbers. It allows users to programmatically create and manage subscriptions for requesting random values. The subscription manager contract is responsible for handling the subscription and adding consumer contracts to it. Users can modify the subscription configurations, transfer ownership of the subscription, view the subscription details, and cancel the subscription if needed. The contract also includes functions for funding the subscription balance and adding/removing consumer contracts. The VRFv2 subscription is governed by the VRFCoordinatorV2Interface contract and requires the use of LINK tokens for funding. The contract provided in the example demonstrates how to use the VRFv2 subscription manager and interact with the VRFCoordinatorV2Interface contract. It also includes functions for requesting random words and fulfilling the request. The contract can be deployed on supported networks such as Rinkeby and Kovan. However, for testing purposes, it is recommended to use the BNB testnet as both Keepers and VRFv2 are available on that network. 

","
- [Chainlink VRFv2 Subscription Guide](https://docs.chain.link/vrf/v2/subscription/examples/programmatic-subscription/)
- [Stack Overflow - How to test blockchain lottery using Chainlink VRFv2 and Chainlink Keeper?](https://stackoverflow.com/questions/71441036/how-to-test-blokchain-lottery-using-chainlink-vrfv2-and-chainlink-keeper)","# Programmatic Subscription

  * Overview
  * Modifying subscriptions and configurations
  * Subscription manager contract
  * Funding and requesting simultaneously

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

How you manage the subscription depends on your randomness needs. You can
configure your subscriptions using the [Subscription
Manager](/vrf/v2/subscription/ui), but these examples demonstrate how to
create your subscription and add your consumer contracts programmatically. For
these examples, the contract owns and manages the subscription. Any wallet can
provide funding to those subscriptions.

You can view and monitor your subscriptions in the [Subscription
Manager](/vrf/v2/subscription/ui) even if you create them programmatically. Go
to [vrf.chain.link](https://vrf.chain.link) to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    * `acceptSubscriptionOwnerTransfer(uint64 subId)`.
  * View the subscription with `getSubscription(uint64 subId)`.
  * Cancel the subscription with `cancelSubscription(uint64 subId)`.

To send LINK to the subscription balance, use the LINK token interface with
`LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(subId))`.
Any wallet can fund a subscription.

See the example in the Subscription manager contract section to learn how to
create a contract that can change your subscription configuration.

## Subscription manager contract

In this example, the contract operates as a subscription owner and can run
functions to add consuming contracts to the subscription. The consuming
contracts must include the `requestRandomWords()` function with the correct
coordinator parameters and the correct subscription ID to request random
values and use the subscription balance. The consuming contracts must also
include the `fulfillRandomWords()` function to receive the random values.

Subscription owners and consumers do not have to be separate. This contract
not only allows adding consumers with `addConsumer(address consumerAddress)`
but can also act as a consumer by running its own `requestRandomWords()`
function. This example contract includes a `createNewSubscription()` function
in the `constructor()` that creates the subscription and adds itself as a
consumer automatically when you deploy it.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that also owns and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Sepolia coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    
        // Sepolia LINK token contract. For other networks, see
        // https://docs.chain.link/docs/vrf-contracts/#configurations
        address link_token_contract = 0x779877A7B0D9E8603169DdbD7836e478b4624789;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 keyHash =
            0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;
    
        // A reasonable default is 100000, but this value could be different
        // on other networks.
        uint32 callbackGasLimit = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 requestConfirmations = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
        uint32 numWords = 2;
    
        // Storage parameters
        uint256[] public s_randomWords;
        uint256 public s_requestId;
        uint64 public s_subscriptionId;
        address s_owner;
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            LINKTOKEN = LinkTokenInterface(link_token_contract);
            s_owner = msg.sender;
            //Create a new subscription when you deploy the contract.
            createNewSubscription();
        }
    
        // Assumes the subscription is funded sufficiently.
        function requestRandomWords() external onlyOwner {
            // Will revert if subscription is not set and funded.
            s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
        }
    
        function fulfillRandomWords(
            uint256 /* requestId */,
            uint256[] memory randomWords
        ) internal override {
            s_randomWords = randomWords;
        }
    
        // Create a new subscription when the contract is initially deployed.
        function createNewSubscription() private onlyOwner {
            s_subscriptionId = COORDINATOR.createSubscription();
            // Add this contract as a consumer of its own subscription.
            COORDINATOR.addConsumer(s_subscriptionId, address(this));
        }
    
        // Assumes this contract owns link.
        // 1000000000000000000 = 1 LINK
        function topUpSubscription(uint256 amount) external onlyOwner {
            LINKTOKEN.transferAndCall(
                address(COORDINATOR),
                amount,
                abi.encode(s_subscriptionId)
            );
        }
    
        function addConsumer(address consumerAddress) external onlyOwner {
            // Add a consumer contract to the subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
        }
    
        function removeConsumer(address consumerAddress) external onlyOwner {
            // Remove a consumer contract from the subscription.
            COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
        }
    
        function cancelSubscription(address receivingWallet) external onlyOwner {
            // Cancel the subscription and send the remaining LINK to a wallet address.
            COORDINATOR.cancelSubscription(s_subscriptionId, receivingWallet);
            s_subscriptionId = 0;
        }
    
        // Transfer this contract's funds to an address.
        // 1000000000000000000 = 1 LINK
        function withdraw(uint256 amount, address to) external onlyOwner {
            LINKTOKEN.transfer(to, amount);
        }
    
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }
    

To use this contract, compile and deploy it in Remix.

  1. Open the contract in [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol).

  2. Compile and deploy the contract using the Injected Provider environment. The contract includes all of the configuration variables that you need, but you can edit them if necessary. For a full list of available configuration variables, see the [Supported Networks](/vrf/v2/subscription/supported-networks) page.

This contract automatically creates a new subscription when you deploy it.
Read the `s_subscriptionId` variable to find your subscription ID. You can use
this value to find the subscription at
[vrf.chain.link](https://vrf.chain.link).

  3. In this example, the `topUpSubscription()` function sends LINK from your contract to the subscription. Fund your contract with at least three testnet LINK. Alternatively, you can send LINK directly to the subscription at [vrf.chain.link](https://vrf.chain.link). Any address can provide funding to a subscription balance. If you need testnet LINK, you can get it from [faucets.chain.link](https://faucets.chain.link/sepolia/).

  4. Run the `topUpSubscription()` function to send LINK from your contract to your subscription balance. For this example, specify a value of `3000000000000000000`, which is equivalent to three LINK.

  5. Run the `requestRandomWords()` function. The request might take several minutes to process. Track the pending request status at [vrf.chain.link](https://vrf.chain.link).

  6. You can also add and test consumer contracts using the same programmatic subscription process:

    1. Create and deploy a consumer contract that includes the following components:

      * The `requestRandomWords()` function and the required variables and your subscription ID.
      * The `fulfillRandomWords()` callback function.

You can use the example from the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number/#analyzing-the-contract) guide.

    2. After you deploy the consumer contract, add it to the subscription as an approved consumer using the `addConsumer()` function on your subscription manager contract. Specify the address of your consumer contract.

    3. On the consumer contract, run the `requestRandomWords()` function to request and receive random values. The request might take several minutes to process. Track the pending request status at [vrf.chain.link](https://vrf.chain.link).

The consumer contract can continue to make requests until your subscription
balance runs out. The subscription manager contract must maintain sufficient
balance in the subscription so that the consumers can continue to operate.

    4. If you need to remove consumer contracts from the subscription, use the `removeConsumer()` function. Specify the address of the consumer contract to be removed.

  7. When you are done with your contracts and the subscription, run the `cancelSubscription()` function to close the subscription and send the remaining LINK to your wallet address. Specify the address of the receiving wallet.

## Funding and requesting simultaneously

You can fund a subscription and request randomness in a single transaction.
You must estimate how much the transaction might cost and determine the amount
of funding to send to the subscription yourself. See the [Subscription
billing](/vrf/v2/subscription/#subscription-limits) page to learn how to
estimate request costs.


    // Assumes this contract owns link
    // You must estimate LINK cost yourself based on the gas lane and limits.
    // 1_000_000_000_000_000_000 = 1 LINK
    function fundAndRequestRandomWords(uint256 amount) external onlyOwner {
        LINKTOKEN.transferAndCall(
            address(COORDINATOR),
            amount,
            abi.encode(s_subscriptionId)
        );
        // Will revert if subscription is not set and funded.
        s_requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
    }
    

Add this function to your contracts if you need to provide funding
simultaneously with your requests. The `transferAndCall()` function sends LINK
from your contract to the subscription, and the `requestRandomWords()`
function requests the random words. Your contract still needs the
`fulfillRandomWords()` callback function to receive the random values.

## What's next

  * [› Subscription Manager UI](/vrf/v2/subscription/ui)
  * [› Security Considerations](/vrf/v2/security)
  * [› Best Practices](/vrf/v2/best-practices)
  * [› Migrating from VRF v1 to v2](/vrf/v2/subscription/migration-from-v1)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/examples/programmatic-subscription.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-03-11 15:41:06)
How to test blokchain lottery using Chainlink VRFv2 and Chainlink Keeper?
URL: https://stackoverflow.com/questions/71441036/how-to-test-blokchain-lottery-using-chainlink-vrfv2-and-chainlink-keeper

Question Body:


Thanks to [Patrick](https://github.com/alphachainio/chainlink-lottery) and
after reading the Chainlink's [blog](https://blog.chain.link/how-to-build-a-
blockchain-lottery/) on how to build blockchain lottery, I am eager to build a
similar ""version"". It will be using the latest Chainlink's version of
**VRFv2** and **Keeper**.

However, the supported test networks for VRFv2 and Keeper are **Rinkeby** and
**Kovan** , respectively.

So any hint on how to approach this?



Answers:
(Answered on: 2022-03-14 17:39:01)


For now the one of the only testnet's both Keepers and VRF v2 are available on
is the BNB testnet. You can test your application there until VRF v2 and
keepers are available on the same Ethereum testnet.

References:  
[Keepers Supported Chains](https://docs.chain.link/docs/chainlink-
keepers/introduction/#supported-blockchain-networks)  
[VRF v2 Supported Chains](https://docs.chain.link/docs/vrf-contracts/)



"
What caused the docker container to exit after the OCR keys creation step when setting up a Chainlink node in AWS ec2 + AWS RDS?,The AWS micro instance (1GB RAM) was running out of memory when OCR keys were generated.,{'source': 'https://stackoverflow.com/questions/70053634/there-are-no-ocr-keys-creating-a-new-key-encrypted-with-given-password-crashe'},The docker container exited after the OCR keys creation step due to a memory problem. The AWS micro instance (1GB RAM) was running out of memory when OCR keys were generated. The solution is to migrate to a bigger instance with more memory.,,"Question: (Asked on: 2021-11-21 10:23:07)
&quot;There are no OCR keys; creating a new key encrypted with given password&quot; Crashes when running Chainlink node
URL: https://stackoverflow.com/questions/70053634/there-are-no-ocr-keys-creating-a-new-key-encrypted-with-given-password-crashe

Question Body:


I am setting up a chainlink node in AWS ec2 + AWS RDS (PostgreSQL) and have
followed every step in the documentation
(<https://docs.chain.link/docs/running-a-chainlink-node/>).

Everything runs smoothly until the OCR keys creation step. Once it gets here,
it shows _"" There are no OCR keys; creating a new key encrypted with given
password""_. This is supposed to happen but **the docker container exits right
after** (see image below).

[Output after OCR keys creation](https://i.stack.imgur.com/oONjU.jpg)

I have tried the following:

  * Checking whether there is a problem with the specific table these keys are stored in the PostgreSQL database: `public.encrypted_ocr_key_bundles`, which gets populated if this step succeeds. Nothing here so far.
  * Using a different version of the Chainlink docker image (see [Chainlink Docker hub](https://hub.docker.com/r/smartcontract/chainlink/tags)). I am currently using version **0.10.0**. No success either, even if using latest ones.
  * Using AWS Cloudformation to ""let AWS + Chainlink"" take care of this, but even so I have encountered similar problems, so no success.

I have thought about populating the OCR table manually with a query, but I am
far from having proper OCR key generation knowledge/script in hand so I do not
like this option.

Does anybody know what else to try/where the problem could be?

Thanks a lot in advance!



Answers:
(Answered on: 2021-12-15 10:25:40)


**UPDATE:** It was a simple memory problem. The AWS micro instance (1GB RAM)
was running out of memory when OCR keys were generated. I only got a log of
the error after switching to an updated version of the CL docker image. In
conclusion: migrate to a bigger instance. Should've thought of that but
learning never stops!





:::NEXT DOC:::

# Best Practices for Deploying Nodes on AWS

  * Overview
  * Created Resources
  * IAM Roles
  * Billable Services
  * Best Practices
  * Do not run as the root user
  * Protect your AWS account
  * Monitor your Chainlink node's health
  * Recovering or Upgrading your Chainlink Node Container
  * Generating the .env file
  * Generating the .password file
  * Generating the .api file
  * Stopping and removing the existing Chainlink node container
  * Starting the Chainlink node container in Docker
  * Backup and Restore
  * Database Backup
  * EC2 Instance Backup
  * Failover Capabilities and Disaster Recovery
  * Troubleshooting and Design Practices
  * AWS Certificate Manager
  * Amazon Devops Guru

AWS Quick Start and Chainlink node versions

The AWS Quick Start in this guide uses [version 1.12.0](/chainlink-nodes/node-versions#changes-in-v1120-nodes) and the [Legacy config](/chainlink-nodes/v1/configuration).

You can deploy a Chainlink node on the AWS Cloud using [AWS Quick
Start](https://aws.amazon.com/quickstart) to deploy a highly available and
secure Chainlink node on the AWS Cloud.

## Created Resources

The Quick Start creates the following public resources:

  * An Elastic Load Balancing (ELB) load balancer to access the Chainlink node web graphical user interface
  * A Linux bastion host in an Auto Scaling group to allow inbound Secure Shell (SSH) access to EC2 instances in public and private subnetworks
  * Managed network address translation (NAT) gateways to allow outbound internet access for the Chainlink node instances in the private subnets

Because these resources are public facing, you should review security and best
practices information on a regular basis against vulnerabilities that pose a
risk.

## IAM Roles

The Quick Start creates the following IAM roles:

  * **Administration Role:** Grants the provided administrator ID with administrator access
  * **Execution Role:** Grants cloudformation.amazonaws.com the administration role to extend the functionality of stacks by enabling create, update, or delete stacks across multiple accounts and regions with a single operation
  * **Chainlink Node Role:**
    * Enables instances to use Systems Manager core service functionality
    * Enables instances with logs and metrics functionality in CloudWatch
    * Enables instances to retrieve Chainlink node secrets created during the Quick Start

## Billable Services

The Quick Start has the following billable services. Click on each link to
learn about the pricing model for each service:

  * [**Amazon EC2**](https://aws.amazon.com/ec2/pricing/?nc2=type_a)
  * [**Amazon Virtual Private Cloud (VPC)**](https://aws.amazon.com/vpc/pricing/)
  * [**Amazon Aurora PostgreSQL-Compatible DB**](https://aws.amazon.com/rds/aurora/pricing/)
  * [**Parameter Store**](https://aws.amazon.com/systems-manager/pricing/?nc2=type_a)
  * [**AWS Secrets Manager**](https://aws.amazon.com/secrets-manager/pricing/?nc1=h_ls)
  * [**AWS Key Management Service**](https://aws.amazon.com/kms/pricing/?nc2=type_a)
  * [**Amazon CloudWatch**](https://aws.amazon.com/cloudwatch/pricing/?nc2=type_a)
  * ( _Optional_ if you are not using a public certificate with AWS Certificate Manager) [**Application Load Balancer**](https://aws.amazon.com/elasticloadbalancing/pricing/?nc=sn&loc=3)
  * ( _Optional_ ) [**Amazon Devops Guru**](https://aws.amazon.com/devops-guru/pricing/?nc=sn&loc=3&refid=0c5ce5de-7dc6-4ce5-95c9-29c9047095fc~ha_awssm-10495_event_prospect)

You are responsible for the cost of the AWS services and any third-party
licenses that you use while running this Quick Start. There is no additional
cost for using the Quick Start.

AWS maintains service limits for each account to help guarantee the
availability of AWS resources. You are responsible for monitoring and managing
the service limits of the resources that this Quick Start provisions.

For more information, visit [Manage Service
Limits](https://aws.amazon.com/premiumsupport/knowledge-center/manage-service-limits/).

## Best Practices

### Do not run as the root user

The operations on the Chainlink node do not require the root user so it is
recommended to use the default user or run as a non-root user.

### Protect your AWS account

As a best security practice, [rotate programmatic system
credentials](https://aws.amazon.com/blogs/security/how-to-rotate-access-keys-for-iam-users/) and [cryptographic
keys](https://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html).

If you enable Amazon Devops Guru, the Quick Start deploys an AWS managed
customer key (CMK) that is used for the Amazon SNS topic for DevOps Guru. The
default setting is automatically set to rotate this KMS key every year.

### Monitor your Chainlink node's health

Run regular health checks of your Chainlink node.

We recommend using a monitoring solution to track the health of your Chainlink
node, such as
[Prometheus](https://prometheus.io/docs/prometheus/latest/getting_started/) or
[Grafana](https://grafana.com/docs/grafana/latest/getting-started/getting-started-prometheus/). Chainlink exposes metrics on the `/metrics` endpoint of
the UI. By default, that's <http://localhost:6688/metrics>.


    # A scrape configuration containing exactly one endpoint to scrape:
    # Here it's Prometheus itself.
    scrape_configs:
      # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
      - job_name: 'chainlink_node'
        static_configs:
        - targets: ['127.0.0.1:6688']
        metrics_path: '/metrics'

Alternatively, you can run a health check on your node using `curl` and make
sure the checks are `passing`. You can replace `localhost:6688` with the load
balancer endpoint if you are using a domain.


    curl -XGET localhost:6688/health | jq '.'


    % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                     Dload  Upload   Total   Spent    Left  Speed
    100  1900  100  1900    0     0   927k      0 --:--:-- --:--:-- --:--:--  927k
    {
      ""data"": [
        {
          ""type"": ""checks"",
          ""id"": ""*offchainreporting.SingletonPeerWrapper"",
          ""attributes"": {
            ""name"": ""*offchainreporting.SingletonPeerWrapper"",
            ""status"": ""passing"",
            ""output"": """"
          }
        },
        {
          ""type"": ""checks"",
          ""id"": ""*job.spawner"",
          ""attributes"": {
            ""name"": ""*job.spawner"",
            ""status"": ""passing"",
            ""output"": """"
          }
        },
        {
          ""type"": ""checks"",
          ""id"": ""*fluxmonitor.concreteFluxMonitor"",
          ""attributes"": {
            ""name"": ""*fluxmonitor.concreteFluxMonitor"",
            ""status"": ""passing"",
            ""output"": """"
          }
        },
        ⋮
      ]
    }

To check the status of your Chainlink node container, use the `docker ps`
command.

## Recovering or Upgrading your Chainlink Node Container

Tag versions for Chainlink node releases are available in the [Chainlink
docker hub](https://hub.docker.com/r/smartcontract/chainlink/tags)

If the Chainlink node containers are stopped or if you need to start up a new
instance during an upgrade or recovery, you must create new `.env`,
`.password`, and `.api` files to start the Chainlink node.

### Generating the `.env` file


    cd /home/ec2-user/.chainlink/ && ./create-env.sh \
    ${chainNetwork} \
    ${blockchainNodeUrl} \
    ${psqlUser} \
    $(aws secretsmanager get-secret-value --secret-id DBSecret --query ""SecretString"" --output text) \
    ${psqlHostname} \
    ${psqlPort} \
    ${psqlDb}

### Generating the `.password` file


    cd /home/ec2-user/.chainlink/ && ./create-password.sh \
    $(aws secretsmanager get-secret-value --secret-id WalletSecret --query ""SecretString"" --output text)

### Generating the `.api` file


    cd /home/ec2-user/.chainlink/ && ./create-api.sh \
    ${apiUser} \
    $(aws secretsmanager get-secret-value --secret-id ApiSecret --query ""SecretString"" --output text)

### Stopping and removing the existing Chainlink node container

This process is required when you update the container to a newer release.


    docker stop chainlink && docker rm chainlink

### Starting the Chainlink node container in Docker


    latestimage=$(curl -s -S ""https://registry.hub.docker.com/v2/repositories/smartcontract/chainlink/tags/"" | jq -r '.""results""[][""name""]' | head -n 1)
    cd /home/ec2-user/.chainlink && docker run -d \
    --log-driver=awslogs \
    --log-opt awslogs-group=ChainlinkLogs \
    --restart unless-stopped \
    --name chainlink \
    -p 6688:6688 \
    -v /home/ec2-user/.chainlink:/chainlink \
    --env-file=/home/ec2-user/.chainlink/.env  smartcontract/chainlink:$latestimage local n \
    -p /chainlink/.password
    -a /chainlink/.api

You can find more details with maintenance and examples in the [Performing
System Maintenance](/chainlink-nodes/resources/performing-system-maintenance)
guide.

Additionally, follow the directions in the [User Guide for Linux
Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/install-updates.html) to keep your Amazon Linux instance software up to date.

## Backup and Restore

### Database Backup

The PostgreSQL database is critical because it stores most of the Chainlink
node data. Aurora automatically backs up your PostgreSQL cluster during the
backup window with a default backup retention of 7 days. You can change the
database cluster’s backup retention period to be as short as 1 day or up to 35
days. For more details, see the guide for [backing up and restoring an Aurora
cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html).

If the primary instance in your PostgreSQL cluster fails during an instance or
service failure, Aurora will automatically fail over to an existing read
replica or create a new primary instance if there are no read replicas
available.

### EC2 Instance Backup

By default, the Chainlink node does not contain any critical data other than
the logs found in the Chainlink directory. If the primary Chainlink node
instance is marked as unhealthy during an instance or service failure, the
Auto Scaling group schedules a replacement instance and the standby Chainlink
node instance will automatically fail over.

You can backup the EBS volumes attached to the Chainlink node by following the
instructions in the [Amazon EBS
snapshots](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSSnapshots.html)
guide. The [Amazon Data Lifecycle
Manager](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshot-lifecycle.html) can help to automate your EBS snapshots. To create a backup of
the entire EC2 instance, you must create an AMI from the instance.

To see how to restore resources from an Amazon EBS snapshot or an AMI, see the
[Restoring from an Amazon EBS snapshot or an
AMI](https://docs.aws.amazon.com/prescriptive-guidance/latest/backup-recovery/restore.html) guide.

## Failover Capabilities and Disaster Recovery

Chainlink node reputation depends on the uptime of the following itmes:

  * The Chainlink node
  * The database
  * The Ethereum client

To reduce downtime, failover capabilities are required on both the Chainlink
node and Ethereum clients so that the service is still online even in the
unlikely event of a virtual machine or network failure.

The [Amazon EC2 Auto Scaling](https://aws.amazon.com/ec2/autoscaling/) group
provisions both a primary Chainlink node and a standby Chainlink node. Each
node is placed in a separate Availability Zone.

If one Availability Zone becomes unhealthy or unavailable, the Amazon EC2 Auto
Scaling group launches a new instance of the Chainlink node or bastion host in
the unaffected Availability Zone. The failover happens automatically.

The data from both the Chainlink node and the Ethereum client is stored in the
PostgreSQL database. The Aurora database cluster is fault tolerant by design
and can handle an Availability Zone failure without any loss of data. There
might be only a brief interruption of service with an automatic failover,
which helps to reduce the Recovery Point Objective (RPO) and Recovery Time
Objective (RTO).

Management of AWS service limits are not required for proper disaster
recovery. The Quick Start deployment is configured with high availability in
mind.

## Troubleshooting and Design Practices

### AWS Certificate Manager

In the AWS console, if the **SSL certificate with AWS Certificate Manager** is
set to `false`, you can leave **arn:aws:acm:region:account-id:certificate** as
is. However, if your node is external facing and must be reached by the
internet, enable this feature and set it to `true`.



### Amazon Devops Guru

In the AWS console, if the **Amazon DevOps Guru** is set to `false`, you can
leave **AdministerAccountId** and **EmailAddress** as is.



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/resources/best-practices-aws.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of deprecating Data Feeds within the Chainlink ecosystem?,Deprecating Data Feeds helps preserve blockchains as public goods by optimizing blockspace usage and reduces unnecessary costs incurred by Chainlink node operators.,{'source': 'https://docs.chain.link/data-feeds/deprecating-feeds/'},"The purpose of deprecating Data Feeds within the Chainlink ecosystem is to optimize blockspace usage, reduce unnecessary costs for Chainlink node operators, and maximize the adoption of the Chainlink protocol while optimizing for cost-efficiency and long-term economic sustainability. Data Feeds without publicly known active users may be scheduled for deprecation, and new Data Feeds may be launched or relocated to alternative blockchains/layer-2s based on current user demand. 
",https://docs.chain.link/data-feeds/deprecating-feeds/,"# Deprecation of Chainlink Data Feeds

  * Overview
  * Ethereum Mainnet 

The smart contract ecosystem is constantly evolving. As a result, Data Feeds
within the Chainlink ecosystem are continuously evaluated for their usage and
economic viability across all the blockchains and layer-2 networks they are
deployed on.

Data Feeds without publicly known active users may be scheduled for
deprecation. Doing so not only helps preserve blockchains as public goods by
optimizing blockspace usage, but it helps reduce unnecessary costs incurred by
Chainlink node operators. This process is part of a broader ecosystem shift
towards Chainlink Economics 2.0, designed to maximize the adoption of the
Chainlink protocol while optimizing for cost-efficiency and long-term economic
sustainability. Over time, new Data Feeds may be launched or relocated to
alternative blockchains/layer-2s that better reflect current user demand.

For status updates regarding Data Feeds, users should join the official
Chainlink Discord and subscribe to the [data-feeds-user-notifications
channel](https://discord.gg/Dqy5N9UbsR).

Users with additional questions are encouraged to reach out
[here](https://chainlinkcommunity.typeform.com/s/dataFeedQs).

A list of data feeds designated for deprecation along with their corresponding
shutdown date can be found below.

## Ethereum Mainnet

| Pair                                       | Asset        | Type   | Deviation   | Heartbeat   |   Dec | Address                                    |
|:-------------------------------------------|:-------------|:-------|:------------|:------------|------:|:-------------------------------------------|
| ⭕BCH / USDDeprecating: May 10th, 2023     | Bitcoin Cash | Crypto | 1%          | 86400s      |     8 | 0x9F0F69428F923D6c95B781F89E165C9b2df9789D |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | Euro (EUR)   | Fiat   | 10%         | 432000s     |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67A |
| ⭕REN / USDDeprecating: May 10th, 2023     | Ren          | Crypto | 1%          | 86400s      |     8 | 0x0f59666EDE214281e956cb3b2D0d69415AfF4A01 |
| ⭕XMR / USDDeprecating: May 10th, 2023     | Monero       | Crypto | 1%          | 86400s      |     8 | 0xFA66458Cce7Dd15D8650015c4fce4D278271618F |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/deprecating-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like [AAVE](https://aave.com/) use Data Feeds to ensure the total
value of the collateral.

Data Feeds aggregate many data sources and publish them on-chain using a
combination of the [Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) and [Off-Chain
Reporting](/architecture-overview/off-chain-reporting?parent=dataFeeds).

To learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility Feeds](/data-feeds/rates-feeds)
documentation.

See the [Rate and Volatility Contract Addresses](/data-feeds/rates-feeds/addresses) page for a list of available networks and addresses.

### L2 sequencer uptime feeds

L2 sequencer feeds track the last known status of the sequencer on an L2
network at a given point in time. This helps you prevent mass liquidations by
providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds feeds, see the [L2 Sequencer
Uptime Feeds](/data-feeds/l2-sequencer-feeds) documentation.

## Components of a data feed

Data Feeds are an example of a decentralized oracle network and include the
following components:

  * **Consumer** : A consumer is an on-chain or off-chain application that uses Data Feeds. Consumer contracts use the [`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) to call functions on the proxy contract and retrieve information from the aggregator contract. For a complete list of functions available in the `AggregatorV3Interface`, see the [Data Feeds API Reference](/data-feeds/api-reference/#aggregatorv3interface).
  * **Proxy contract** : Proxy contracts are on-chain proxies that point to the aggregator for a particular data feed. Using proxies enables the underlying aggregator to be upgraded without any service interruption to consuming contracts. Proxy contracts can vary from one data feed to another, but the [`AggregatorProxy.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol) on Github is a common example.
  * **Aggregator contract** : An aggregator is a contract that receives periodic data updates from the oracle network. Aggregators store aggregated data on-chain so that consumers can retrieve it and act upon it within the same transaction. For a complete list of functions and variables available on most aggregator contracts, see the [Data Feeds API Reference](/data-feeds/api-reference/#accesscontrolledoffchainaggregator).

To learn how to create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

## Reading proxy and aggregator configurations

Because the proxy and aggregator contracts are all on-chain, you can see the
current configuration by reading the variables through an
[ABI](https://docs.soliditylang.org/en/latest/abi-spec.html) or using a
blockchain explorer for your network. For example, you can see the [BTC/USD
proxy
configuration](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#readContract)
on the Ethereum network using Etherscan.

If you read the BTC/USD proxy configuration, you can query all of the
functions and variables that are publicly accessible for that contract
including the `aggregator` address, `latestRoundData()` function,
`latestAnswer` variable, `owner` address, `latestTimestamp` variable, and
several others. To see descriptions for the proxy contract variables and
functions, see the source code for your specific data feed on
[Etherscan](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#code#L568).

The proxy contract points to an aggregator. This allows you to retrieve data
through the proxy even if the aggregator is upgraded. If you view the
`aggregator` address defined in the proxy configuration, you can see the
aggregator and its configuration. For example, see the [BTC/USD aggregator
contract](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#code)
in Etherscan. This contract includes several variables and functions,
including another `latestRoundData()`. To see descriptions for the aggregator
variables and functions, see the source code on
[GitHub](https://github.com/smartcontractkit/libocr/blob/master/contract/AccessControlledOffchainAggregator.sol)
or
[Etherscan](https://etherscan.io/address/0xae74faa92cb67a95ebcab07358bc222e33a34da7#code#F1#L1).

You can call the `latestRoundData()` function directly on the aggregator, but
it is a best practice to use the proxy instead so that changes to the
aggregator do not affect your application. Similar to the proxy contract, the
aggregator contract has a `latestAnswer` variable, `owner` address,
`latestTimestamp` variable, and several others.

## Components of an aggregator

The aggregator contract has several variables and functions that might be
useful for your application. Although aggregator contracts are similar for
each data feed, some aggregators have different variables. Use the
`typeAndVersion()` function on the aggregator to identify what type of
aggregator it is and what version it is running.

Always check the contract source code and configuration to understand how
specific data feeds operate. For example, the [aggregator contract for BTC/USD
on
Arbitrum](https://arbiscan.io/address/0x942d00008d658dbb40745bbec89a93c253f9b882#code)
is different from the aggregators on other networks.

For examples of the contracts that are typically used in aggregator
deployments, see the [libocr
repository](https://github.com/smartcontractkit/libocr/blob/master/contract/)
on GitHub.

For a complete list of functions and variables available on most aggregator
contracts, see the [Data Feeds API Reference](/data-feeds/api-reference/#accesscontrolledoffchainaggregator).

## Updates to proxy and aggregator contracts

To accommodate the dynamic nature of off-chain environments, Chainlink Data
Feeds are updated from time to time to add new features and capabilities as
well as respond to externalities such as token migrations, protocol rebrands,
extreme market events, and upstream issues with data or node operations.

These updates include changes to the aggregator configuration or a complete
replacement of the aggregator that the proxy uses. If you consume data feeds
through the proxy, your applications can continue to operate during these
changes.

Proxy and aggregator contracts all have an `owner` address that has permission
to change variables and functions. For example, if you read the [BTC/USD proxy
contract](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#readContract)
in Etherscan, you can see the `owner` address. This address is a [multi-
signature safe](https://docs.gnosis-safe.io/introduction/the-programmable-account/gnosis-safe) (multisig) that you can also inspect.

If you [view the multisig
contract](https://etherscan.io/address/0x21f73d42eb58ba49ddb685dc29d3bf5c0f0373ca#readProxyContract)
in Etherscan using the _Read as Proxy_ feature, you can see the full details
of the multisig including the list of addresses that can sign and the number
of signers required for the multisig to approve actions on any contracts that
it owns.

The multisig-coordinated upgradability of Chainlink Data Feeds involves time-
tested processes that balance collusion-resistance with the flexibility
required to implement improvements and swiftly react to external conditions.
The approach taken to upgradability will continue to evolve over time to meet
user requirements.

## Monitoring data feeds

When you build applications and protocols that depend on data feeds, include
monitoring and safeguards to protect against the negative impact of extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, and outages.

Create your own monitoring alerts based on deviations in the answers that data
feeds provide. This will notify you when potential issues occur so you can
respond to them.

### Check the latest answer against reasonable limits

The data feed aggregator includes both [`minAnswer` and `maxAnswer`
values](https://github.com/smartcontractkit/libocr/blob/9e4afd8896f365b964bdf769ca28f373a3fb0300/contract/AccessControlledOffchainAggregator.sol#L33).
These variables prevent the aggregator from updating the `latestAnswer`
outside the agreed range of acceptable values, but they do not stop your
application from reading the most recent answer.

Configure your application to detect when the reported answer is close to
reaching `minAnswer` or `maxAnswer` and issue an alert so you can respond to a
potential market event. Separately, configure your application to detect and
respond to extreme price volatility or prices that are outside of your
acceptable limits.

### Check the timestamp of the latest answer

Chainlink Data Feeds do not provide streaming data. Rather, the aggregator
updates its `latestAnswer` when the value deviates beyond a specified
threshold or when the heartbeat idle time has passed. You can find the
heartbeat and deviation values for each data feed at
[data.chain.link](https://data.chain.link/) or in the [Contract
Addresses](/data-feeds/price-feeds/addresses) lists.

Your application should track the `latestTimestamp` variable or use the
`updatedAt` value from the `latestRoundData()` function to make sure that the
latest answer is recent enough for your application to use it. If your
application detects that the reported answer is not updated within the
heartbeat or within time limits that you determine are acceptable for your
application, pause operation or switch to an alternate operation mode while
identifying the cause of the delay.

During periods of low volatility, the heartbeat triggers updates to the latest
answer. Some heartbeats are configured to last several hours, so your
application should check the timestamp and verify that the latest answer is
recent enough for your application.

Users should build applications with the understanding that data feeds for
wrapped or liquid staking assets might have different heartbeat and deviation
thresholds than that of the underlying asset. Heartbeat and deviation
thresholds can also differ for the same asset across different blockchains.
Combining data from multiple feeds, even those with a common denominator,
might result in a margin of error that users must account for in their risk
mitigation practices.

To learn more about the heartbeat and deviation threshold, read the
[Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds#aggregator) page.

## What's next

  * [› Using Data Feeds](/data-feeds/using-data-feeds)
  * [› Read the API reference for using Data Feeds](/data-feeds/api-reference)
  * [› Price Feed Addresses](/data-feeds/price-feeds/addresses)
  * [› Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
  * [› NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the Chainlink Data Feeds?,The Chainlink Data Feeds are used to provide price feed data to smart contracts.,{'source': 'https://docs.chain.link/any-api/introduction/'},"The purpose of the Chainlink Data Feeds is to provide real-world data, such as asset prices, reserve balances, NFT floor prices, and L2 sequencer health, to smart contracts. The Price Feeds, in particular, are used by platforms like Synthetix and AAVE to determine asset prices and ensure the value of collateral. The Data Feeds aggregate data from multiple sources and publish them on-chain using a decentralized data model. The feeds are updated periodically and can be monitored for deviations and timestamps to ensure the accuracy and timeliness of the data. 
",https://docs.chain.link/data-feeds/price-feeds/,"# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like [AAVE](https://aave.com/) use Data Feeds to ensure the total
value of the collateral.

Data Feeds aggregate many data sources and publish them on-chain using a
combination of the [Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) and [Off-Chain
Reporting](/architecture-overview/off-chain-reporting?parent=dataFeeds).

To learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility Feeds](/data-feeds/rates-feeds)
documentation.

See the [Rate and Volatility Contract Addresses](/data-feeds/rates-feeds/addresses) page for a list of available networks and addresses.

### L2 sequencer uptime feeds

L2 sequencer feeds track the last known status of the sequencer on an L2
network at a given point in time. This helps you prevent mass liquidations by
providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds feeds, see the [L2 Sequencer
Uptime Feeds](/data-feeds/l2-sequencer-feeds) documentation.

## Components of a data feed

Data Feeds are an example of a decentralized oracle network and include the
following components:

  * **Consumer** : A consumer is an on-chain or off-chain application that uses Data Feeds. Consumer contracts use the [`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) to call functions on the proxy contract and retrieve information from the aggregator contract. For a complete list of functions available in the `AggregatorV3Interface`, see the [Data Feeds API Reference](/data-feeds/api-reference/#aggregatorv3interface).
  * **Proxy contract** : Proxy contracts are on-chain proxies that point to the aggregator for a particular data feed. Using proxies enables the underlying aggregator to be upgraded without any service interruption to consuming contracts. Proxy contracts can vary from one data feed to another, but the [`AggregatorProxy.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol) on Github is a common example.
  * **Aggregator contract** : An aggregator is a contract that receives periodic data updates from the oracle network. Aggregators store aggregated data on-chain so that consumers can retrieve it and act upon it within the same transaction. For a complete list of functions and variables available on most aggregator contracts, see the [Data Feeds API Reference](/data-feeds/api-reference/#accesscontrolledoffchainaggregator).

To learn how to create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

## Reading proxy and aggregator configurations

Because the proxy and aggregator contracts are all on-chain, you can see the
current configuration by reading the variables through an
[ABI](https://docs.soliditylang.org/en/latest/abi-spec.html) or using a
blockchain explorer for your network. For example, you can see the [BTC/USD
proxy
configuration](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#readContract)
on the Ethereum network using Etherscan.

If you read the BTC/USD proxy configuration, you can query all of the
functions and variables that are publicly accessible for that contract
including the `aggregator` address, `latestRoundData()` function,
`latestAnswer` variable, `owner` address, `latestTimestamp` variable, and
several others. To see descriptions for the proxy contract variables and
functions, see the source code for your specific data feed on
[Etherscan](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#code#L568).

The proxy contract points to an aggregator. This allows you to retrieve data
through the proxy even if the aggregator is upgraded. If you view the
`aggregator` address defined in the proxy configuration, you can see the
aggregator and its configuration. For example, see the [BTC/USD aggregator
contract](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#code)
in Etherscan. This contract includes several variables and functions,
including another `latestRoundData()`. To see descriptions for the aggregator
variables and functions, see the source code on
[GitHub](https://github.com/smartcontractkit/libocr/blob/master/contract/AccessControlledOffchainAggregator.sol)
or
[Etherscan](https://etherscan.io/address/0xae74faa92cb67a95ebcab07358bc222e33a34da7#code#F1#L1).

You can call the `latestRoundData()` function directly on the aggregator, but
it is a best practice to use the proxy instead so that changes to the
aggregator do not affect your application. Similar to the proxy contract, the
aggregator contract has a `latestAnswer` variable, `owner` address,
`latestTimestamp` variable, and several others.

## Components of an aggregator

The aggregator contract has several variables and functions that might be
useful for your application. Although aggregator contracts are similar for
each data feed, some aggregators have different variables. Use the
`typeAndVersion()` function on the aggregator to identify what type of
aggregator it is and what version it is running.

Always check the contract source code and configuration to understand how
specific data feeds operate. For example, the [aggregator contract for BTC/USD
on
Arbitrum](https://arbiscan.io/address/0x942d00008d658dbb40745bbec89a93c253f9b882#code)
is different from the aggregators on other networks.

For examples of the contracts that are typically used in aggregator
deployments, see the [libocr
repository](https://github.com/smartcontractkit/libocr/blob/master/contract/)
on GitHub.

For a complete list of functions and variables available on most aggregator
contracts, see the [Data Feeds API Reference](/data-feeds/api-reference/#accesscontrolledoffchainaggregator).

## Updates to proxy and aggregator contracts

To accommodate the dynamic nature of off-chain environments, Chainlink Data
Feeds are updated from time to time to add new features and capabilities as
well as respond to externalities such as token migrations, protocol rebrands,
extreme market events, and upstream issues with data or node operations.

These updates include changes to the aggregator configuration or a complete
replacement of the aggregator that the proxy uses. If you consume data feeds
through the proxy, your applications can continue to operate during these
changes.

Proxy and aggregator contracts all have an `owner` address that has permission
to change variables and functions. For example, if you read the [BTC/USD proxy
contract](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#readContract)
in Etherscan, you can see the `owner` address. This address is a [multi-
signature safe](https://docs.gnosis-safe.io/introduction/the-programmable-account/gnosis-safe) (multisig) that you can also inspect.

If you [view the multisig
contract](https://etherscan.io/address/0x21f73d42eb58ba49ddb685dc29d3bf5c0f0373ca#readProxyContract)
in Etherscan using the _Read as Proxy_ feature, you can see the full details
of the multisig including the list of addresses that can sign and the number
of signers required for the multisig to approve actions on any contracts that
it owns.

The multisig-coordinated upgradability of Chainlink Data Feeds involves time-
tested processes that balance collusion-resistance with the flexibility
required to implement improvements and swiftly react to external conditions.
The approach taken to upgradability will continue to evolve over time to meet
user requirements.

## Monitoring data feeds

When you build applications and protocols that depend on data feeds, include
monitoring and safeguards to protect against the negative impact of extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, and outages.

Create your own monitoring alerts based on deviations in the answers that data
feeds provide. This will notify you when potential issues occur so you can
respond to them.

### Check the latest answer against reasonable limits

The data feed aggregator includes both [`minAnswer` and `maxAnswer`
values](https://github.com/smartcontractkit/libocr/blob/9e4afd8896f365b964bdf769ca28f373a3fb0300/contract/AccessControlledOffchainAggregator.sol#L33).
These variables prevent the aggregator from updating the `latestAnswer`
outside the agreed range of acceptable values, but they do not stop your
application from reading the most recent answer.

Configure your application to detect when the reported answer is close to
reaching `minAnswer` or `maxAnswer` and issue an alert so you can respond to a
potential market event. Separately, configure your application to detect and
respond to extreme price volatility or prices that are outside of your
acceptable limits.

### Check the timestamp of the latest answer

Chainlink Data Feeds do not provide streaming data. Rather, the aggregator
updates its `latestAnswer` when the value deviates beyond a specified
threshold or when the heartbeat idle time has passed. You can find the
heartbeat and deviation values for each data feed at
[data.chain.link](https://data.chain.link/) or in the [Contract
Addresses](/data-feeds/price-feeds/addresses) lists.

Your application should track the `latestTimestamp` variable or use the
`updatedAt` value from the `latestRoundData()` function to make sure that the
latest answer is recent enough for your application to use it. If your
application detects that the reported answer is not updated within the
heartbeat or within time limits that you determine are acceptable for your
application, pause operation or switch to an alternate operation mode while
identifying the cause of the delay.

During periods of low volatility, the heartbeat triggers updates to the latest
answer. Some heartbeats are configured to last several hours, so your
application should check the timestamp and verify that the latest answer is
recent enough for your application.

Users should build applications with the understanding that data feeds for
wrapped or liquid staking assets might have different heartbeat and deviation
thresholds than that of the underlying asset. Heartbeat and deviation
thresholds can also differ for the same asset across different blockchains.
Combining data from multiple feeds, even those with a common denominator,
might result in a margin of error that users must account for in their risk
mitigation practices.

To learn more about the heartbeat and deviation threshold, read the
[Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds#aggregator) page.

## What's next

  * [› Using Data Feeds](/data-feeds/using-data-feeds)
  * [› Read the API reference for using Data Feeds](/data-feeds/api-reference)
  * [› Price Feed Addresses](/data-feeds/price-feeds/addresses)
  * [› Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
  * [› NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the EVM?,The EVM stands for Ethereum Virtual Machine and it is responsible for executing smart contracts on the Ethereum blockchain.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-2/description.md'},"The EVM stands for Ethereum Virtual Machine. It is what reads and executes Solidity code when it is deployed to a blockchain. Solidity code is compiled into EVM bytecode, which is a set of commands that the EVM can understand and act upon. The EVM is used by blockchains such as Ethereum, Polygon, and Avalanche. Other languages that can compile to EVM bytecode, such as Vyper, can also be used to write smart contracts on EVM-based blockchains. The EVM is an important component in understanding how Solidity and smart contracts work.
","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-2/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-2/description.md","#####Chapter 2:

# EVM Intro

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Having a basic understanding of what’s going on under the hood in Solidity is important so let’s learn about the EVM!
    </div>
  </div>
</ContentWrapp>

Not so quick! I know you are ready to learn Solidity, but there is one other important subject you should know before moving on: the Ethereum Virtual Machine or EVM. The EVM is what reads your code when it is deployed to a blockchain. When Solidity code is compiled, it is turned into EVM bytecode. EVM bytecode is commands that the EVM can read and act on. When a smart contract is deployed to Ethereum, its bytecode lives there forever; always accessible. Any language other than Solidity that can compile to EVM bytecode can also be used to write smart contracts on blockchains that utilize the EVM. Another language that compiles to EVM bytecode is Vyper. Examples of blockchains that run the EVM are Ethereum, Polygon, and Avalanche (among many others). Many blockchains now use the EVM making Solidity an even more powerful smart contract language! 

Some blockchains have virtual machines other than the EVM and thus have different programming languages and bytecode compilation targets, but for this course, we’ll stick with Solidity and the EVM.

<!-- <MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact legal contracts have become so notorousily difficult to enforce, more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a style=""color:green"" href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the american bar association </a>.
    </div>
</MissionContainer> -->


:::NEXT DOC:::

Having a basic understanding of what’s going on under the hood in Solidity is important so let’s learn about the EVM!
"
What is the issue that is causing the failure of the NFT transfer when using Chainlink automation?,The `allowance` issue is causing the failure of the NFT transfer when using Chainlink automation.,{'source': 'https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu'},"The document does not mention any specific issue causing the failure of the NFT transfer when using Chainlink automation.
SOURCES:",,"# Chainlink Automation Architecture

  * Overview
  * Automation Contracts
  * How it works
  * Internal monitoring
  * Supported Networks and Cost

Chainlink Automation enable you to execute smart contract functions based on
conditions that you specify without having to create and maintain your own
centralized stack. Chainlink Automation is highly reliable and decentralized,
supported by an industry leading team, and enables developers to deploy
applications faster.

There are three main actors in the ecosystem:

  * **Upkeeps** : These are the jobs or tasks that you execute on-chain. For example, you can call a smart contract function if a specific set of conditions are met.
  * **Automation registry** : The contract that you use to [register](/chainlink-automation/register-upkeep) and manage **upkeeps**.
  * **Automation Nodes** : Nodes in the Chainlink Automation Network that service registered and funded upkeeps in the Automation registry. Automation Nodes use the same Node Operators as Chainlink Data Feeds.

The following diagram describes the architecture of the Chainlink Automation
Network. The Chainlink Automation Registry governs the actors on the network
and compensates Automation Nodes for performing successful upkeeps. Developers
can register their Upkeeps, and Node Operators can register as Automation
Nodes.

## Automation Contracts

Automation Nodes use these contracts. You can find them in the [Chainlink
repository](https://github.com/smartcontractkit/chainlink/tree/develop/contracts/src/v0.8).
For details about how to use them, see the [Creating Compatible
Contracts](/chainlink-automation/compatible-contracts) guide.

  * `AutomationCompatible.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/AutomationCompatible.sol): Imports the following contracts: 
    * `AutomationBase.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/AutomationBase.sol): Enables the use of the `cannotExecute` modifier. Import this contract if you need for this modifier. See the [`checkUpkeep` function](/chainlink-automation/compatible-contracts#checkupkeep-function) for details.
    * `AutomationCompatibleInterface.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol): The interface to be implemented in order to make your contract compatible. Import this contract for type safety.
  * `AutomationRegistry1_2.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/AutomationRegistry1_2.sol): The registry contract that tracks all registered Upkeeps and the Automation Nodes that can perform them.
  * `KeeperRegistrar.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/KeeperRegistrar.sol): The Registrar contract coverns the registration of new Upkeeps on the associated `KeeperRegistry` contract. Users who want to register Upkeeps by directly calling the deployed contract have to call the Transfer-and-Call function on the respective ERC-677 LINK contract configured on the Registrar and ensure they pass the correct encoded function call and inputs.

## How it works

Automation Nodes follow a turn-taking algorithm to service upkeeps. A turn is
a number of blocks and you can find the block count per turn for your network
in the [configuration](/chainlink-automation/supported-networks/#configurations) section. During a turn a Upkeeps on the registry are
randomly split, ordered into buckets, and assigned to an Automation Node to
service them. Even if an Automation Node goes down, the network has built-in
redundancy and your Upkeep will be performed by the next Automation Node in
line.

During every block, the Automation Node reviews all of the upkeeps in its
bucket to determine which upkeeps are eligible. This check is done off-chain
using a geth simulation. The Automation Node checks both the `checkUpkeep` and
`performUpkeep` conditions independently using simulation. If both are true
(eligible), and the upkeep is funded, the Automation Node proceeds to execute
the transaction on-chain.

While only one Automation Node monitors an upkeep at any point during a turn,
an upkeep can have multiple on-chain transaction executions per turn. This is
accomplished with a buddy-system. After a transaction is confirmed, the next
Automation Node in the line monitors the upkeep. After a new transaction is
confirmed, the previous Automation Node steps in again to monitor the upkeep
until the end of the turn or until another transaction confirmation is
complete. This creates a system that is secure and highly available. If a node
becomes faulty and executes a transaction that is not eligible, the next node
does not execute a transaction, which breaks the process.

Chainlink Automation use the same transaction manager mechanism built and used
by Chainlink Data Feeds. This creates a hyper-reliable automation service that
can execute and confirm transactions even during intense gas spikes or on
chains with significant reorgs. This mechanism has been in use in Chainlink
Labs for multiple years, is battle hardened, and the team continuously
improves on it.

## Internal monitoring

Internally, Chainlink Automation also uses its own monitoring and alerting
mechanisms to maintain a health network and ensure developers get the
reliability that they expect.

## Supported Networks and Cost

For a list of blockchains that is supported by Chainlink Automation, please
review the [supported networks page](/chainlink-automation/supported-networks). To learn more about the cost of using Chainlink Automation, please
review the [Automation economics](/chainlink-automation/automation-economics)
page.

## What's next

  * [› FAQs](/chainlink-automation/faqs/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Frequently Asked Questions

  * Overview
  * Will Chainlink Automation work for my use case?
  * I registered my upkeep successfully, but I can't see it. How can I find my upkeeps?
  * Is the Chainlink Automation Network available on platforms other than Ethereum?
  * How much does it cost to use Chainlink Automation?
  * How do I determine the Gas Limit for my Upkeep?
  * What is the maximum Gas that my checkUpkeep can use?
  * What is the maximum Gas that my performUpkeep can use?
  * How often will my Upkeep be checked off-chain to see if it should be executed on-chain?
  * How long will it take for my performUpkeep to be executed once it has been broadcasted on-chain?
  * Which contract will call my performUpkeep function on-chain?
  * Will the address of the Automation Registry always stay the same?
  * Can I require that performUpkeep is only callable by the Automation Registry?
  * What gas price does Automation Node use to trigger the function?
  * How do you prevent Automation Nodes from racing against each other and escalating execution costs?
  * How is the Upkeep minimum balance determined?
  * How do I fund my Upkeep?
  * How do I withdraw funds?
  * My Upkeep stopped performing. How can I debug it?
  * How do I join the Chainlink Automation Network as a node operator?
  * Why won't the Chainlink Automation App recognize the LINK in my wallet?

## Will Chainlink Automation work for my use case?

For help with your specific use case, [contact
us](https://chain.link/contact?ref_id=Automation) to connect with one of our
Solutions Architects. You can also ask questions about Chainlink Automation on
[Stack Overflow](https://stackoverflow.com/questions/ask?tags=chainlink) or
the [#automation
channel](https://discord.com/channels/592041321326182401/821350860302581771)
in our [Discord server](https://discord.gg/qj9qarT). [Utility
contracts](/chainlink-automation/utility-contracts) can also help you get
started quickly.

## I registered my upkeep successfully, but I can't see it. How can I find my
upkeeps?

Open the [Chainlink Automation app](https://automation.chain.link/) and ensure
your wallet is connected. Also ensure that the wallet is set to use the
network where you registered the Upkeep. Your Upkeep should be under the My
Upkeeps tab.

## Is the Chainlink Automation Network available on platforms other than
Ethereum?

Chainlink Automation is available on the networks listed in the [Supported
Blockchain Networks](/chainlink-automation/supported-networks) page. To see
when we integrate with other platforms, [follow us on
Twitter](https://twitter.com/chainlink) or [join our community on
Discord](https://discord.com/channels/592041321326182401/821350860302581771).

## How much does it cost to use Chainlink Automation?

See the [Automation Economics](/chainlink-automation/automation-economics)
page to learn more about the cost of using Chainlink Automation.

## How do I determine the Gas Limit for my Upkeep?

The **Gas Limit** specified during Upkeep Registration is the maximum amount
of gas that will be used to execute your function on-chain. We simulate
`performUpkeep` and if the gas exceeds this limit the function will not
execute on-chain. One method to determine your Upkeep's Gas Limit is to
simulate the `performUpkeep` function and add enough overhead to take into
account increases that might happen due to changes in `performData` or on-
chain data.

## What is the maximum Gas that my `checkUpkeep` can use?

`checkUpkeep` is subject to the `checkGasLimit` in the [configuration of the
registry](/chainlink-automation/supported-networks/#configurations).

## What is the maximum Gas that my `performUpkeep` can use?

`performUpkeep` is subject to the `performGasLimit` in the [configuration of
the registry](/chainlink-automation/supported-networks/#configurations).

## How often will my Upkeep be checked off-chain to see if it should be
executed on-chain?

See [How it works](/chainlink-automation/overview/#how-it-works).

## How long will it take for my `performUpkeep` to be executed once it has
been broadcasted on-chain?

This depends on the network congestion, the amount of gas used by the
`performUpkeep`, and the gas price specified when the transaction is
broadcasted. See the [Price Selection and Gas Bumping](/chainlink-automation/automation-economics/#price-selection-and-gas-bumping)
documentation to learn about optimizing the chances of executing your
`performUpkeep` function.

## Which contract will call my `performUpkeep` function on-chain?

The **Automation Registry** will call the `performUpkeep` function on-chain.

## Will the address of the Automation Registry always stay the same?

No. As we add new functionality we have to upgrade our contract and deploy a
new **Automation Registry**. We will work with all our users to ensure Upkeeps
are migrated without causing business interruptions.

## Can I require that `performUpkeep` is only callable by the `Automation
Registry`?

Our preferred and recommended route before locking access to `performUpkeep`is
[revalidation](/chainlink-automation/compatible-contract-best-practice#revalidate-performupkeep-on-automation-compatible-contracts). We
understand you might want to add a require statement, but then recommend that
you make the **Automation Registry** address configurable otherwise you will
need to deploy a new contract when the Registry address changes. If you add a
require statement to `performUpkeep` you will have to update the Registry
Address in your contract when the Registry Address changes. We also recommend
that the `owner` can always call `performUpkeep`.

## What gas price does Automation Node use to trigger the function?

See the [Price Selection and Gas Bumping](/chainlink-automation/automation-economics/#price-selection-and-gas-bumping) section to learn about the gas
price used to trigger the function.

## How do you prevent Automation Nodes from racing against each other and
escalating execution costs?

See [How it works](/chainlink-automation/overview/#how-it-works).

## How is the Upkeep minimum balance determined?

See [Minimum balance](/chainlink-automation/automation-economics/#minimum-balance).

## How do I fund my Upkeep?

See [Fund your Upkeep](/chainlink-automation/manage-upkeeps/#fund-your-upkeep).

## How do I withdraw funds?

See [Withdraw funds](/chainlink-automation/manage-upkeeps/#withdraw-funds).

## My Upkeep stopped performing. How can I debug it?

The simplest way to test your function is to call it yourself and see if it
executes. To do so, deploy the contract to a testnet and debug the function.
If you can call the function successfully, then Chainlink Automation will also
be able to call it. If your function is working, but the Upkeep is not
executing, your Upkeep might be underfunded. See the [Fund your
Upkeep](/chainlink-automation/manage-upkeeps/#fund-your-upkeep) section to
learn how to fund your Upkeep.

## How do I join the Chainlink Automation Network as a node operator?

We are not accepting new Automation Nodes at this time, but be sure to sign up
for our [mailing list](/resources/developer-communications), or join our
[Discord server](https://discord.gg/qj9qarT) to be notified when this becomes
available.

## Why won't the Chainlink Automation App recognize the LINK in my wallet?

For registration on Mainnet, you need ERC-677 LINK. Many token bridges give
you ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be
ERC-677 compatible](https://pegswap.chain.link/). To register on a supported
testnet, get [LINK](/resources/link-token-contracts) for the testnet that you
want to use from our faucet.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/faqs.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
How can you loop through two arrays in one for loop?,You should make sure that they both have the same length first. Then you can use a for loop and iterate over both arrays simultaneously.,{'source': 'https://stackoverflow.com/questions/69440832/loop-through-2-arrays-in-one-for-loop'},"To loop through two arrays in one for loop, you can use the following code:

```
require(arrayOne.length == arrayTwo.length)
for (i; arrayOne.length > i; i++) {
    arrayOne[i] = ....;
    arrayTwo[i] = ....;
}
```

Make sure that both arrays have the same length before looping through them together.

","- [Stack Overflow](https://stackoverflow.com/questions/69440832/loop-through-2-arrays-in-one-for-loop)
- [Solidity 102 Course](https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-4/course.md)","Question: (Asked on: 2021-10-04 18:34:58)
Loop through 2 arrays in one for loop?
URL: https://stackoverflow.com/questions/69440832/loop-through-2-arrays-in-one-for-loop

Question Body:


anyone know how we can loop through two arrays in one for loop?

    
    
    function setwinner() internal returns(address){
            for (uint stime = 0 ; stime < squareStartTimeArray.length; stime++ & uint etime = 0; etime = squareEndTimeArray.length etime++) {
                if (winningTime >= stime & winningTime <= etime) {
                    winningIndex = stime;
                    if (assert(stime == etime) == true) {
                        winningAddress = playerArray[stime];
                    }
                }
            }
        }
    



Answers:
(Answered on: 2021-10-04 18:47:12)


To loop through multiple arrays in the same loop you should make sure that
they both have the same length first. then you can use this:

    
    
    require(arrayOne.length == arrayTwo.length)
    for (i; arrayOne.length > i; i++) {
        arrayOne[i] = ....;
        arrayTwo[i] = ....;
    }
    





:::NEXT DOC:::

#####Chapter 4:

# Conditional statements and loops

While we are now familiar with storage and basic data types in Solidity, we still have to learn about flow control. We will often run into situations where we need to decide the next step based on the value of a variable. This is where we can use conditional statements. The syntax is very similar to languages like JavaScript. Let’s have a look:

<Highlight class=""language-javascript"">
function foo(int x) public pure returns (uint) {
 if (x < 5) {
   return 0;
 } else if (x < 10) {
   return 1;
 } else {
   return 2;
 }
}
</Highlight>

As you can see, this allows us to execute different codes based on if a condition is met. If we do not have an else if case but a simple if/else case, Solidity also supports the ternary operator.

<Highlight class=""language-javascript"">
function bar(uint x) public pure returns (uint) {
  return x < 5 ? 0 : 1;
}
</Highlight>

The question mark **?** is called the ternary operator (learn more about operators in chapter 10). The expression means if x is smaller than 5 then return 0 otherwise return 1. We can also use these conditional statements to assign values to a variable:

<Highlight class=""language-javascript"">
function bar(uint x) public pure returns (uint) {
  uint conditionalResult = x < 5 ? 0 : 1;
  return conditionalResult;
}
</Highlight>

Here we are using the ternary expression to assign the value to the local variable called **conditionalResult**.

Next, to flow control, we often encounter a situation where repetition is needed. Loops are useful when we must repeat a block of code several times. Solidity offers two types of loops. For Loops and While Loops.

<Highlight class=""language-javascript"">
function forLoopExample() public returns (uint) {
  uint counter = 0;
  for (uint i = 0; i < 4; i++) {
      if (i == 0) {
          continue;
      }
      if (counter == 4) {
          break;
      }
      counter = counter + 2;
  }

return counter;
}
</Highlight>

As in JavaScript, we have the same syntax for the for loop: (initialization; condition; increment). The condition is an expression checked at the end of each loop cycle. You can also see that we are using the keywords **continue** and **break** here. They allow us to control the flow inside the loop. If a particular condition is met, we can skip the rest of the loop by using **continue**. So everything that would be executed after **continue** will be ignored. We can also completely exit the loop by using **break**. This is useful when we are looking for a specific condition to be met and do not need to run the loop anymore.

Next to the for loop, we also have a while loop that can be used. It is similar to the for loop that it has a condition that is tested each time the loop repeats. But the variable declaration is happening outside the loop header and incrementation is happening inside the loop body. One must be very careful not to forget to increment the index to meet the defined condition, or the loop may run forever.

<Highlight class=""language-javascript"">
function whileLoopExample() public {
  uint index;
  while (index < 4) {
      index++;
  }
}
</Highlight>

Always ensure you do not create a situation where your contract might get stuck when using loops. Imagine you have a dynamic array in storage that will grow over time as new values are added to it and some function is using a loop to iterate through the full array. You might run into a situation where loop iteration will hit the block's gas limit. This would result in an error and make it impossible for that function to complete that loop except you can somehow reduce the array size. So always take care when updating storage values in a loop!

You might think that for view and pure functions, you do not have to worry about this aspect, as nothing is added to a block and the state is read from the blockchain. And this is true as long as you call them directly. But if a non-pure/non-view function calls such a function, then gas is consumed and we might run into the same problem we just described.
"
What is the recommended version of Solidity to use in the given code?,The recommended version of Solidity to use in the given code is >=0.4.22 <0.9.0.,{'source': 'https://stackoverflow.com/questions/70905645/parsererror-source-file-requires-different-compiler-version-current-compiler-i'},"The recommended version of Solidity to use in the given code is 0.8.7.
",https://docs.chain.link/getting-started/conceptual-overview/,"# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-01-29 12:59:09)
ParserError: Source file requires different compiler version (current compiler is 0.8.7+commit.e28d00a7.Emscripten.clang)
URL: https://stackoverflow.com/questions/70905645/parsererror-source-file-requires-different-compiler-version-current-compiler-i

Question Body:


I was eventually trying to run this code in remix IDE, where I was running
this using 0.6.6 version of Solidity and ran into this error. I've tried using
some other versions like 0.8 and 0.6 as well.

    
    
    // SPDX-License-Identifier: MIT
    
    pragma solidity =0.8.7;
    
    import ""@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol"";
    
    contract myContract{
        using SafeMathChainlink for uint256;
        mapping(address => uint256) public payTo;
    
        function Payment() public payable {
            uint256 minimumUSD = 50 * 10 ** 18;
            require(getConversionRate(msg.value) >= minimumUSD, ""Doesn't satisfy the minimum condition"");
            payTo[msg.sender] += msg.value;
        }
    }
    



Answers:
(Answered on: 2023-04-08 20:32:35)


use this:

    
    
    pragma solidity >=0.5.0 < 0.9.0
    


---
(Answered on: 2022-08-04 12:56:43)


I was able to use pragma solidity ^0.8.0; as I fixed the issue by changing the
version in brownie-config.yaml

version: 0.8.0


---
(Answered on: 2022-05-17 07:41:56)


Now we can use this line of code to include a range of version of solidity to
use. I faced the similar issue and got fixed by doing this:

    
    
    pragma solidity >=0.4.22 <0.9.0;
    


---
(Answered on: 2022-01-29 13:14:02)


Your code requires Solidity 0.8.7, but the imported
[SafeMathChainlink.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/vendor/SafeMathChainlink.sol)
requires Solidity 0.6.*.

An easy solution is to change your code to require v0.6 as well and compile
with this version.

    
    
    pragma solidity ^0.6.0;
    

Or you can remove the `import` and `using ... for` of the SafeMath library, as
it's not needed on 0.8 anymore. All validations performed in the library are
now performed on the language level since version 0.8.0.



"
What is the purpose of the imported LinkTokenInterface and VRFCoordinatorV2Interface in this Solidity code?,The imported LinkTokenInterface and VRFCoordinatorV2Interface are used to interact with the Chainlink oracle network for generating random numbers in the VRFConsumerBaseV2 contract.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-4/solution.md'},"The purpose of the imported LinkTokenInterface and VRFCoordinatorV2Interface in this Solidity code is to interact with the Chainlink network. The LinkTokenInterface is used to interact with the LINK token contract, while the VRFCoordinatorV2Interface is used to interact with the VRF Coordinator contract. These interfaces allow the contract to perform functions such as transferring LINK tokens and making requests to the VRF Coordinator for random number generation.
","https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-9/course.md, https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-9/exercise.md","#####Chapter 9: Building a Basic Contract

# The Constructor

Constructors are logic that is run whenever a smart contract is first deployed to a blockchain. We will set the constructor to the following values:

<Highlight class=""language-javascript"">
constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
    LINKTOKEN = LinkTokenInterface(link);
    s_owner = msg.sender;
    s_subscriptionId = subscriptionId;
  }
</Highlight>

Let's break down this constructor. It takes one parameter, subscriptionId, which is the ID of the subscription we will set up in a later chapter. It then passes in the address stored in the vrfCoordinator to the VRFConsumerBaseV2 contract's constructor to set it up. 

The COORDINATOR variable is set to the VRFCoordinatorV2Interface also initialized to the address stored in the vrfCoordinator.

The LINKTOKEN variable is set to LinkTokenInterface that we imported and the interface is initialized with the link token address we specificied earlier.

The s\_owner variable is set to msg.sender which is the address of the wallet account which will deploy the contract.

The s\_subscriptionId is set to subscriptionId which we fed into the constructor as a parameter.

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface();
    LINKTOKEN = LinkTokenInterface();
    s_owner = ;
    s_subscriptionId = ;
  }
"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-2/hints.md'},"The topic of Chapter 1 is not provided in the given information.
SOURCES:",,"#####Chapter 1:

Video


:::NEXT DOC:::

#####Chapter 1:

Video
"
What does the Chainlink documentation specify about checking for a request before continuing?,The Chainlink documentation specifies that you should check that a request for a given `_requestId` exists before continuing.,{'source': 'https://stackoverflow.com/questions/76160005/what-are-the-chances-the-chainlink-oracle-will-respond-to-a-non-existent-request'},"The Chainlink documentation specifies that you should check that a request for a given `_requestId` exists before continuing. This is to ensure that the request has been instantiated before attempting to fulfill it. The documentation recommends using the `require` statement in the fulfillment function to check if the requestId is valid. 
Source: https://stackoverflow.com/questions/76160005/what-are-the-chances-the-chainlink-oracle-will-respond-to-a-non-existent-request",,"Question: (Asked on: 2023-05-03 02:12:22)
What are the chances the Chainlink oracle will respond to a non-existent request?
URL: https://stackoverflow.com/questions/76160005/what-are-the-chances-the-chainlink-oracle-will-respond-to-a-non-existent-request

Question Body:


The Chainlink
[documentation](https://docs.chain.link/vrf/v2/subscription/examples/get-a-
random-number#analyzing-the-contract) specifies that you should check that a
request for a given `_requestId` exists before continuing.

[Chainlink Docs](https://i.stack.imgur.com/aLpGT.png)

I'm curious to further understand why this is, is it wrong to assume that the
Oracle should never attempt to fulfil a request that has never been
instantiated? For reference, I have reviewed the best practices section of the
documentation and all attached code snippets do not follow this behaviour.

Thanks :)

Whilst developing the contract I am working on, I noticed this and wanted to
gain a better understanding as to why the documentation validates a given
request exists before fulfilling it.



Answers:
(Answered on: 2023-05-07 09:49:35)


When the a randomness request is sent from VRFConsumer contract, a new
requestId is generated:

    
    
            requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
    

The contract has a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`.

After the oracle returns the random values to your contract, the mapping
`s_requests` is supposed to be updated, and the `RequestStatus` of a specific
request can be found by a specific `requestId`.

require statement in the fulfillment function is used to check if the
requestId is indeed sent from the vrfConsumer contract.





:::NEXT DOC:::

# ChainlinkClient API Reference

  * Overview
  * Index
  * Methods
  * Events
  * Modifiers
  * Constants
  * Structs
  * Methods
  * setChainlinkOracle
  * setChainlinkToken
  * buildChainlinkRequest
  * buildOperatorRequest
  * sendChainlinkRequest
  * sendChainlinkRequestTo
  * sendOperatorRequest
  * sendOperatorRequestTo
  * validateChainlinkCallback
  * addChainlinkExternalRequest
  * cancelChainlinkRequest
  * useChainlinkWithENS
  * updateChainlinkOracleWithENS
  * chainlinkTokenAddress
  * chainlinkOracleAddress
  * Events
  * ChainlinkRequested
  * ChainlinkFulfilled
  * ChainlinkCancelled
  * Constants
  * LINK_DIVISIBILITY
  * Modifiers
  * recordChainlinkFulfillment
  * Chainlink.Request
  * Attributes
  * Methods

API reference for ChainlinkClient

`ChainlinkClient`
[contracts](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol)
can communicate with legacy `Oracle`
[contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or `Operator`
[contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).

## Index

### Methods

| Name                         | Description                                                                                                                    |
|:-----------------------------|:-------------------------------------------------------------------------------------------------------------------------------|
| setChainlinkOracle           | Sets the stored address for the oracle contract                                                                                |
| setChainlinkToken            | Sets the stored address for the LINK token                                                                                     |
| buildChainlinkRequest        | Instantiates a Request object with the required parameters                                                                     |
| buildOperatorRequest         | Instantiates a Request object with the required parameters. Note the oracle must be an Operator contract                       |
| sendChainlinkRequest         | Sends the request payload to the stored address stored as chainlinkOracleAddress                                               |
| sendChainlinkRequestTo       | Sends a request to the oracle address specified                                                                                |
| sendOperatorRequest          | Sends the request payload to the stored address stored as chainlinkOracleAddress. Note the oracle must be an Operator contract |
| sendOperatorRequestTo        | Sends a request to the oracle address specified. Note the oracle must be an Operator contract                                  |
| validateChainlinkCallback    | Secures the fulfillment callback to make sure it is only called by permissioned senders                                        |
| addChainlinkExternalRequest  | Allows a Chainlinked contract to track unfulfilled requests that it hasn't created itself                                      |
| cancelChainlinkRequest       | Cancels Chainlink requests attempting to contact an unresponsive node                                                          |
| useChainlinkWithENS          | Looks up the addresses of the LINK token and Oracle contract through ENS                                                       |
| updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS                                                 |
| chainlinkTokenAddress        | Returns the stored address of the LINK token                                                                                   |
| chainlinkOracleAddress       | Returns the stored address of the oracle contract                                                                              |
### Events

| Name               | Description                                                                  |
|:-------------------|:-----------------------------------------------------------------------------|
| ChainlinkRequested | Emitted from a Chainlinked contract when a request is sent to an oracle      |
| ChainlinkFulfilled | Emitted from a Chainlinked contract when a request is fulfilled by an oracle |
| ChainlinkCancelled | Emitted from a Chainlinked contract when a request is cancelled              |
### Modifiers

| Name                       | Description                                                                                                                                              |
|:---------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------|
| recordChainlinkFulfillment | Used on fulfillment callbacks to ensure that the caller and requestId are valid. This is the modifier equivalent of the method validateChainlinkCallback |
### Constants

| Name              | Description                                                                       |
|:------------------|:----------------------------------------------------------------------------------|
| LINK_DIVISIBILITY | Helper uint256 to represent the divisibility of a LINK token. Equivalent to 10^18 |
### Structs

| Name              | Description                                                          |
|:------------------|:---------------------------------------------------------------------|
| Chainlink.Request | All of the parameters that can be passed over in a Chainlink request |
## Methods

Below you'll find each helper explained in greater detail alongside respective
implementation examples to help you leverage these methods once you start
building your own Chainlinked contract.

After the function signature and a short description, two code examples are
provided, one focusing on the exact usage of the method and one where the
helper is presented in the context of a full contract.

### setChainlinkOracle


    function setChainlinkOracle(
      address _oracle
    )

Sets a private storage variable provided for convenience if your contract only
needs to talk to one oracle and you do not want to specify it on every
request. Once an oracle is set with `setChainlinkOracle` that is the address
used with sendChainlinkRequest.

Retrieve the oracle address using chainlinkOracleAddress. These getters and
setters are provided to enforce that changes to the oracle are explicitly made
in the code.


    constructor(address _oracle)
    {
      setChainlinkOracle(_oracle);
    }

### setChainlinkToken


    setChainlinkToken(
      address _link
    )

Sets the stored address for the LINK token which is used to send requests to
Oracles. There are different token addresses on different network. See [LINK
Token Contracts](/resources/link-token-contracts) for the address of the LINK
token on the network you're deploying to.


    constructor(address _link)
      public
    {
      setChainlinkToken(_link);
    }

### buildChainlinkRequest

Use `buildOperatorRequest` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function buildChainlinkRequest(
        bytes32 _jobId,
        address _callbackAddress,
        bytes4 _callbackFunctionSignature
    ) returns (Chainlink.Request memory request)

Instantiates a Request from the Chainlink contract. A Request is a struct
which contains the necessary parameters to be sent to the oracle contract. The
`buildChainlinkRequest` function takes an ID, which can be a [Job
ID](/chainlink-nodes/oracle-jobs/jobs), a callback address to receive the
resulting data, and a callback function signature to call on the callback
address.


    function requestPrice()
      public
    {
      bytes32 jobId = ""493610cff14346f786f88ed791ab7704"";
      bytes4 selector = this.myCallback.selector;
      // build a request that calls the myCallback function defined
      //   below by specifying the address of this contract and the function
      //   selector of the myCallback
      Chainlink.Request memory request = buildChainlinkRequest(
        jobId,
        address(this),
        selector);
    }

### buildOperatorRequest

This function is similar to `buildChainlinkRequest`function. One major
difference is that `buildOperatorRequest` does not allow setting up the
address of the callback. The callback address is set to the address of the
calling contract.

It is recommended to use `buildOperatorRequest` but make sure the oracle you
are contacting is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function buildOperatorRequest(
        bytes32 _jobId,
        bytes4 _callbackFunctionSignature
    ) returns (Chainlink.Request memory request)

Instantiates a _Request_ from the Chainlink contract. A Request is a struct
that contains the necessary parameters to be sent to the oracle contract. The
`buildOperatorRequest` function takes an ID, which can be a [Job
ID](/chainlink-nodes/oracle-jobs/jobs), and a callback function signature to
call on the calling contract address.


    function requestPrice()
      public
    {
      bytes32 jobId = ""493610cff14346f786f88ed791ab7704"";
      bytes4 selector = this.myCallback.selector;
      // build a request that calls the myCallback function defined
      //   below by specifying the function selector of myCallback
      Chainlink.Request memory request = buildOperatorRequest(
        jobId,
        selector);
    }

### sendChainlinkRequest

Use `sendOperatorRequest` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequest(
        Chainlink.Request memory _req,
        uint256 _payment
    ) returns (bytes32 requestId)

Sends the request payload to the stored oracle address. It takes a
Chainlink.Request and the amount of LINK to send amount as parameters. The
request is serialized and calls `oracleRequest` on the address stored in
`chainlinkOracleAddress` via the LINK token's `transferAndCall` method.

`sendChainlinkRequest` returns the ID of the request. If your application
needs to, your contract can store that ID, but you don't need to. The
ChainlinkClient helpers will store the ID under the hood, along with the
oracle address, and use them when you call `recordChainlinkFulfillment` in
your callback function to make sure only that the address you want can call
your Chainlink callback function.

`sendChainlinkRequest` emits a ChainlinkRequested event containing the request
ID, if you would like to use it in your Web3 application.


    function requestPrice()
      public
    {
      Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.callback.selector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK
    
      // send the request that you just built
      sendChainlinkRequest(request, paymentAmount);
    }

### sendChainlinkRequestTo

Use `sendOperatorRequestTo` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequestTo(
      address _oracle,
      Chainlink.Request memory _req,
      uint256 _payment
    ) returns (bytes32 requestId)

Similar to sendChainlinkRequest, `sendChainlinkRequestTo` sends a Request but
allows the target oracle to be specified. It requires an address, a Request,
and an amount, and returns the `requestId`. This allows a requesting contract
to create and track requests sent to multiple oracle contract addresses.

`sendChainlinkRequestTo` emits a ChainlinkRequested event containing the
request ID, if you would like to use it in your Web3 application.


    function requestPriceFrom(address _oracle)
      public
    {
      Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.callback.callbackSelector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK
    
      // send the request that you just built to a specified oracle
      sendChainlinkRequestTo(_oracle, request, paymentAmount);
    }

### sendOperatorRequest

This function is similar to `sendChainlinkRequest`function. It is recommended
to use `sendOperatorRequest` but make sure the oracle you are contacting is an
`Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendOperatorRequest(
        Chainlink.Request memory _req,
        uint256 _payment
    ) returns (bytes32 requestId)

The `sendOperatorRequest` function sends the request payload to the stored
oracle address. It takes a Chainlink.Request and the amount of LINK to send
amount as parameters. The request is serialized and calls `operatorRequest` on
the address stored in `chainlinkOracleAddress` using the LINK token's
`transferAndCall` method.

`sendOperatorRequest` returns the ID of the request. Optionally, your contract
can store the ID if your application needs it. The `ChainlinkClient` helpers
store the ID and the oracle address and use them when you call
`recordChainlinkFulfillment` in your callback function. This ensures that only
the specified address can call your Chainlink callback function.

`sendOperatorRequest` emits a ChainlinkRequested event containing the request
ID that you can use in your Web3 application.


    function requestPrice()
      public
    {
      Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.selector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK
    
      // send the request that you just built
      sendOperatorRequest(request, paymentAmount);
    }

### sendOperatorRequestTo

This function is similar to `sendChainlinkRequestTo`function. It is
recommended to use `sendOperatorRequestTo`, but make sure the oracle you are
contacting is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequestTo(
      address _oracle,
      Chainlink.Request memory _req,
      uint256 _payment
    ) returns (bytes32 requestId)

Similar to sendOperatorRequest, `sendOperatorRequestTo` sends a Request but
allows the target oracle to be specified. It requires an address, a Request,
and an amount, and returns the `requestId`. This allows a requesting contract
to create and track requests sent to multiple oracle contract addresses.

`sendOperatorRequestTo` emits a ChainlinkRequested event containing a request
ID that you can use in your Web3 application.


    function requestPriceFrom(address _oracle)
      public
    {
      Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.callbackSelector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK
    
      // send the request that you just built to a specified oracle
      sendOperatorRequestTo(_oracle, request, paymentAmount);
    }

### validateChainlinkCallback


    function validateChainlinkCallback(
        bytes32 _requestId
    )

Used on fulfillment callbacks to ensure that the caller and `requestId` are
valid. They protect ChainlinkClient callbacks from being called by malicious
callers. `validateChainlinkCallback` allows for a request to be called

This is the method equivalent of the modifier `recordChainlinkFulfillment`.
Either `validateChainlinkCallback` or `recordChainlinkFulfillment` should be
used on all fulfillment functions to ensure that the caller and `requestId`
are valid. Use the modifier or the method, not both.

`validateChainlinkCallback` emits a ChainlinkFulfilled event.


    function myCallback(bytes32 _requestId, uint256 _price)
      public
    {
      validateChainlinkCallback(_requestId);
      currentPrice = _price;
    }

Do not call multiple times

Do not call `validateChainlinkCallback` multiple times. The nature of
validating the callback is to ensure the response is only received once and
not replayed. Calling a second time with the same method ID will trigger a
revert. Similarly, your callback should validate using either
`validateChainlinkCallback` or `recordChainlinkFulfillment`, not both.

### addChainlinkExternalRequest


    function addChainlinkExternalRequest(
      address _oracle,
      bytes32 _requestId
    )

`addChainlinkExternalRequest` allows a Chainlink contract to track unfulfilled
requests that it hasn't created itself. For example, contract A creates a
request and sets the callback for contract B. Contract B needs to know about
the request created by contract A so that it can validate the callback when it
is executed.


    function expectResponseFor(bytes32 _requestId)
      public
    {
      addChainlinkExternalRequest(chainlinkOracleAddress(), _requestId);
    }

Be careful adding external requests

Being able to change a request means that you can change the data fed into a
contract. Permissioning someone to make external requests can allow them to
change the outcome of your contract. You should be sure to make sure that they
are a trusted to do so. If they are not trusted to do so, you should put the
request making logic on-chain where it is auditable and tamperproof.

### cancelChainlinkRequest


    function cancelChainlinkRequest(bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    )

In case an oracle node does not respond, it may be necessary to retrieve the
LINK used to pay for the unfulfilled request. The `cancelChainlinkRequest`
will send the cancel request to the address used for the request, which
transfers the amount of LINK back to the requesting contract, and delete it
from the tracked requests.

The default expiration for a request is five minutes, after which it can be
cancelled. The cancellation must be sent by the address which was specified as
the callback location of the contract.

For the sake of efficient gas usage, only a hash of the request's parameters
are stored on-chain. In order to validate the terms of the request and that it
can be calculated, the request parameters must be provided. Additionally,
cancellation must be called by the address which the callback would otherwise
have been called on.

`cancelChainlinkRequest` emits a ChainlinkCancelled event.


    function cancelRequest(
        bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    ) public {
      cancelChainlinkRequest(_requestId, _payment, _callbackFunc, _expiration);
    }

### useChainlinkWithENS


    function useChainlinkWithENS(
      address _ens,
      bytes32 _node
    )

Allows a Chainlink contract to store the addresses of the LINK token and
oracle contract addresses without supplying the addresses themselves. We use
ENS where available to resolve these addresses. It requires the address of the
ENS contract and the node (which is a hash) for the domain.

If your Oracle provider supports using ENS for rolling upgrades to their
oracle contract, once you've pointed your Chainlinked contract to the ENS
records then you can update the records using updateChainlinkOracleWithENS.


    address constant ROPSTEN_ENS = 0x112234455C3a32FD11230C42E7Bccd4A84e02010;
    bytes32 constant ROPSTEN_CHAINLINK_ENS = 0xead9c0180f6d685e43522fcfe277c2f0465fe930fb32b5b415826eacf9803727;
    
    constructor(){
      useChainlinkWithENS(ROPSTEN_ENS, ROPSTEN_CHAINLINK_ENS);
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Oracle.sol)
or trust whoever can update the records.

### updateChainlinkOracleWithENS


    function updateChainlinkOracleWithENS()

Updates the stored oracle contract address with the latest address resolved
through the ENS contract. This requires the oracle provider to support listing
their address on ENS.

This method only works after useChainlinkWithENS has been called on the
contract.


    function updateOracleAddressToLatest() public {
      updateChainlinkOracleWithENS();
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or trust whoever can update the records.

### chainlinkTokenAddress


    function chainlinkTokenAddress() returns (address)

The `chainlinkTokenAddress` function is a helper used to return the stored
address of the Chainlink token. This variable is protected and so only made
available through getters and setters.


    function withdrawLink() public {
      LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
    
      require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
    }

### chainlinkOracleAddress

The `chainlinkOracleAddress` function is a helper used to return the stored
address of the oracle contract.


    function getOracle() public view returns (address) {
      return chainlinkOracleAddress();
    }
    

## Events

### ChainlinkRequested


    event ChainlinkRequested(
      bytes32 indexed id
    )

Emitted when sendChainlinkRequest and sendChainlinkRequestTo are called.
Includes the request ID as an event topic.

### ChainlinkFulfilled


    event ChainlinkFulfilled(
      bytes32 indexed id
    )

Emitted when validateChainlinkCallback or recordChainlinkFulfillment are
called. Includes the request ID as an event topic.

### ChainlinkCancelled


    event ChainlinkCancelled(
      bytes32 indexed id
    )

Emitted when cancelChainlinkRequest is called. Includes the request ID as an
event topic.

## Constants

### LINK_DIVISIBILITY

`LINK_DIVISIBILITY` is a uint256 constant to represent one whole unit of the
LINK token (1000000000000000000). It can be used with another value to specify
payment in an easy-to-read format, instead of hardcoding magic numbers.


    uint256 constant private ORACLE_PAYMENT = 100 * LINK_DIVISIBILITY; // = 100 LINK

## Modifiers

### recordChainlinkFulfillment

`recordChainlinkFulfillment` is used on fulfillment callbacks to ensure that
the caller and `requestId` are valid. This is the method equivalent of the
method `validateChainlinkCallback`.

Either `validateChainlinkCallback` or `recordChainlinkFulfillment` should be
used on all Chainlink callback functions to ensure that the sender and
`requestId` are valid. They protect ChainlinkClient callbacks from being
called by malicious callers. Do not call both of them, or your callback may
revert before you can record the reported response.


    function myCallback(bytes32 _requestId, uint256 _price)
      public
      recordChainlinkFulfillment(_requestId) // always validate callbacks
    {
      currentPrice = _price;
    }

## Chainlink.Request


    library Chainlink {
      struct Request {
        bytes32 id;
        address callbackAddress;
        bytes4 callbackFunctionId;
        uint256 nonce;
        Buffer.buffer buf;
      }
    }

The Chainlink Request struct encapsulates all of the fields needed for a
Chainlink request and its corresponding response callback.

The Chainlink protocol aims to be flexible and not restrict application
developers. The Solidity Chainlink Request model is a great example of that.
It is exceptionally flexible, given the limitations of Solidity. The request
can contain an arbitrary amount of keys and values to be passed off-chain to
the oracles for each request. It does so by converting the parameters into
CBOR, and then storing them in a buffer. This allows for any number of
parameters all of different types to be encoded on-chain.

The request's ID is generated by hashing the sender's address and the
request's nonce. This scheme ensures that only the requester can generate
their request ID, and no other contract can trigger a response from an oracle
with that ID. New requests whose IDs match an unfulfilled request ID will not
be accepted by the oracle.

Intended for memory

The Request object was intended to be stored in memory. If you have a reason
to persist the struct in storage, it is recommended that you do so by copying
each attribute over and explicitly copying the bytes in the buffer.

### Attributes

| Name               | Description                                                                                             |
|:-------------------|:--------------------------------------------------------------------------------------------------------|
| id                 | Identifier for the request                                                                              |
| callbackAddress    | Address that the response will be sent to upon fulfillment                                              |
| callbackFunctionId | Selector of the function on the callbackAddress that will be invoked with the response upon fulfillment |
| nonce              | Used to generate the request ID                                                                         |
| buf                | Buffer that stores additional user defined parameters as CBOR                                           |
### Methods

| Name           | Description                                                      |
|:---------------|:-----------------------------------------------------------------|
| add            | Add a string value to the run request parameters                 |
| addBytes       | Add a bytes value to the run request parameters                  |
| addInt         | Add an integer value to the run request parameters               |
| addUint        | Add an unsigned integer to the run request parameters            |
| addStringArray | Add an array of strings as a value in the run request parameters |
| setBuffer      | Directly set the CBOR of the run request parameters              |
#### add


    function add(
      Request memory self,
      string _key,
      string _value
    )

Add a string value to the run request parameters. Commonly used for `get` with
jobs using `httpGet` tasks.


    function requestEthereumPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.add(""get"", ""https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY"");
    
      sendChainlinkRequest(req, 1 * LINK_DIVISIBILITY); // =1 LINK
    }

#### addBytes


    function addBytes(
      Request memory self,
      string _key,
      bytes _value
    )

Add a CBOR bytes type value to the run request parameters.


    function requestEmojiPopularity(bytes _unicode)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addBytes(""emojiUnicode"", _unicode);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

Note that this can also be used as a workaround to pass other data types like
arrays or addresses. For instance, to add an _address_ , one would first
encode it using `abi.encode` then pass the result to `addBytes`:


    Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
    req.addBytes(""address"", abi.encode(msg.sender)); // msg.sender used in this example. Replace it with your address
    

#### addInt


    function addInt(
      Request memory self,
      string _key,
      int256 _value
    )

Add a CBOR signed integer type value to the run request parameters. Commonly
used with the `times` parameter of any job using a `multiply` task.


    function requestPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addInt(""times"", 100);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

#### addUint


    function addUint(
      Request memory self,
      string _key,
      uint256 _value
    )

Add a CBOR unsigned integer type value to the run request parameters. Commonly
used with the `times` parameter of any job using a `multiply` task.


    function requestPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addUint(""times"", 100);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

#### addStringArray


    function addStringArray(
      Request memory self,
      string _key,
      string[] memory _values
    )

Add a CBOR array of strings to the run request parameters. Commonly used with
the `path` parameter for any job including a `jsonParse` task.


    function requestPrice(string _currency)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
      string[] memory path = new string[](2);
      path[0] = _currency;
      path[1] = ""recent"";
    
      // specify templated fields in a job specification
      req.addStringArray(""path"", path);
    
      sendChainlinkRequest(req, PAYMENT);
    }

#### setBuffer


    function setBuffer(
      Request memory self,
      bytes _data
    )

Set the CBOR payload directly on the request object, avoiding the cost of
encoding the parameters in CBOR. This can be helpful when reading the bytes
from storage or having them passed in from off-chain where they were pre-
encoded.


    function requestPrice(bytes _cbor)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
    
      req.setBuffer(_cbor);
    
      sendChainlinkRequest(req, PAYMENT);
    }

Be careful setting the request buffer directly

Moving the CBOR encoding logic off-chain can save some gas, but it also opens
up the opportunity for people to encode parameters that not all parties agreed
to. Be sure that whoever is permissioned to call `setBuffer` is trusted or
auditable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/api-reference.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are the two steps involved in billing for Chainlink Functions requests?,The two steps involved in billing for Chainlink Functions requests are the Request step and the Receive step.,{'source': 'https://docs.chain.link/chainlink-functions/resources/billing/'},"The two steps involved in billing for Chainlink Functions requests are:

1. Start Billing: The FunctionsOracle contract calls the FunctionsBillingRegistry's `startBilling` function to estimate the fulfillment costs and block the amount in the Reservation balance.

2. Fulfill and Bill: After receiving the API response, the FunctionsOracle contract calls the FunctionsBillingRegistry's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing.

",https://docs.chain.link/chainlink-functions/resources/billing,"# Chainlink Functions Resources

  * Overview
  * Topics

## Topics

  * [Concepts](/chainlink-functions/resources/concepts)
  * [Architecture](/chainlink-functions/resources/architecture)
  * [Managing Subscriptions](/chainlink-functions/resources/subscriptions)
  * [Billing](/chainlink-functions/resources/billing)
  * [Supported Networks](/chainlink-functions/supported-networks)
  * [Service Limits](/chainlink-functions/resources/service-limits)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates with the _Functions Billing Registry_ , which
assigns a unique identifier (aka _Subscription ID_ ).

### Fund Subscription

You must fund your subscription accounts with enough LINK tokens:

  1. Connect your EOA to the _Subscription App_.
  2. Fund your subscription account. The _Subscriptions App_ abstracts the following: 
    1. Call `transferAndCall` on the LINK token contract, transferring LINK tokens along with the _Subscription ID_ in the payload.
    2. The _Functions Billing Registry_ contract implements `onTokenTransfer`: It parses the _Subscription ID_ from the payload and funds the subscription account with the transferred LINK amount.

### Add Consumer

You must allowlist your consumers' contracts on your subscription account
before they can make Chainlink Functions requests. To do so:

  1. Connect your EOA to the _Subscription App_.
  2. Add the address of your consumer contract to your subscription account.
  3. The _Subscription App_ calls the _Functions Billing Registry_ contract to add the consumer contract address to your subscription account.

### Remove Consumer

To remove a consumer contract:

  1. Connect your EOA to the _Subscription App_.
  2. Remove the address of your consumer contract from the allowlist.
  3. The _Subscription App_ calls the _Functions Billing Registry_ contract to remove the consumer contract address from your subscription account.

**Note** : You can still remove consumers from your subscription if there are
in-flight requests. Your consumer contract will still be called back, and your
_Subscription Account_ will be charged.

### Cancel Subscription

To cancel a subscription:

  1. Connect your EOA to the _Subscription App_.
  2. Cancel your subscription, passing the _Subscription Balance_ receiver account address. The _Subscriptions App_ abstracts the following: 
    1. Call the `cancelSubscription` function on the _Functions Billing Registry_ contract, deleting the _Subscription ID_ and removing any existing consumers.
    2. The outstanding _Subscription Balance_ is sent to the receiver account.

**Note** : You cannot cancel a subscription if there are in-flight requests.

### Transferring ownership of a Subscription

Transferring ownership works as follows:

  1. Connect your EOA to the _Subscription App_.
  2. Initiate the ownership transfer by specifying the new owner's address.
  3. The new owner must connect their EOA to the _Subscription App_ and accept the ownership.

## What's next

  * [› Billing](/chainlink-functions/resources/billing)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/architecture.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Why does calling an external API in Chainlink not cause inconsistency?,"Because oracle responses are stored on-chain. Chainlink oracle network places the data on-chain in a transaction, and then it goes through the same validation process as every other transaction.",{'source': 'https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency'},"Calling an external API in Chainlink does not cause inconsistency because oracle responses are stored on-chain. When fetching external data, the Chainlink oracle network places the data on-chain in a transaction, which then goes through the same validation process as every other transaction. This ensures that all nodes reach a consensus and prevents inconsistent states. The use of external adapters in Chainlink also enables easy integration of custom computations and specialized APIs. 

","- https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency
- https://docs.chain.link/chainlink-nodes/external-adapters/external-adapters/","Question: (Asked on: 2021-11-26 22:39:12)
Why does calling an external API in chainlink not cause inconsistency?
URL: https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency

Question Body:


Suppose I have a smart contract that uses Chainlink's ""Call Any External API""
capability to get some data from an external URL. My understanding is that
each Ethereum full node runs each smart contract to verify the status; it does
so to verify the latest block. But what if, between the time one full node
runs the contract and another one does, the data returned by calling tha
external API changes. Then it would seem that different full nodes would get
different results for that smart contract, resulting in inconsistent states.
Why does that not happen?



Answers:
(Answered on: 2021-12-10 18:05:16)


Because oracle responses are stored on-chain.

You are right, if fetching external data was part of the validation process,
no nodes would be able to reach a consensus. So instead, a Chainlink oracle
network places the data on-chain in a transaction, and then it goes through
the same validation process as every other transaction.

You can read more about how Chainlink's [Basic Request
Model](https://docs.chain.link/docs/architecture-request-model/) looks, but
this is basically the reason why having an oracle system built into a
blockchain is impossible.





:::NEXT DOC:::

# External Adapters Introduction

  * Overview

External adapters are how Chainlink enables easy integration of custom
computations and specialized APIs. External adapters are services which the
core of the Chainlink node communicates via its API with a simple JSON
specification. If you want a step by step, be sure to check out our [blog
post](https://blog.chain.link/build-and-use-external-adapters/).

Information on external adapters is broken up into three main categories:
contract creators, developers, and node operators.

  * [Contract Creators](/chainlink-nodes/external-adapters/contract-creators) will need to know how to specify an external adapter in their request for external data.
  * [Developers](/chainlink-nodes/external-adapters/developers) will need to know how to implement an external adapter for an API.
  * [Node Operators](/chainlink-nodes/external-adapters/node-operators) will need to know how to add an external adapter to their node so that they can provide specialized services to smart contracts.

## What's next

  * [› External Adapters in Solidity](/chainlink-nodes/external-adapters/contract-creators)
  * [› Building External Adapters](/chainlink-nodes/external-adapters/developers)
  * [› Bridges: Adding External Adapters to Nodes](/chainlink-nodes/external-adapters/node-operators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/external-adapters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the `cacheTTL` parameter in the Bridge task?,The `cacheTTL` parameter is a duration-formatted string indicating the maximum acceptable staleness for cached bridge responses in case of intermittent failures.,{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/all-tasks/'},"The purpose of the `cacheTTL` parameter in the Bridge task is to specify the maximum acceptable staleness for cached bridge responses in case of intermittent failures. It is an optional parameter and is disabled by default. The `cacheTTL` parameter is a duration-formatted string. 
",https://docs.chain.link/chainlink-nodes/oracle-jobs/all-tasks/,"# Task Types

  * Overview
  * 'Any' task
  * Base64 Decode task
  * Base64 Encode task
  * Bridge task
  * CBOR Parse task
  * Divide task
  * ETH ABI Decode Log task
  * ETH ABI Decode task
  * ETH ABI Encode task
  * ETH Call task
  * ETH Tx task
  * Hex Decode task
  * Hex Encode task
  * HTTP task
  * JSON Parse task
  * Length task
  * Less Than task
  * Lowercase task
  * Mean task
  * Median task
  * Memo task
  * Merge task
  * Mode task
  * Multiply task
  * Sum Task
  * Uppercase task

This guide outlines different task types.

## 'Any' task

Returns a random value from the set of inputs passed in.

**Parameters**

None.

**Inputs**

Can be anything.

**Outputs**

A randomly-selected value from the set of inputs.

**Example**


    fetch1   [type=""http"" ...]
    fetch2   [type=""http"" ...]
    fetch3   [type=""http"" ...]
    pick_any [type=""any""]
    
    fetch1 -> pick_any
    fetch2 -> pick_any
    fetch3 -> pick_any

`pick_any` will return either the result of `fetch1`, `fetch2`, or `fetch3`.

## Base64 Decode task

Accepts a base64 encoded string and returns decoded bytes.

**Parameters**

  * `input`: a base64 encoded string.

**Outputs**

Decoded bytes.

**Example**


    my_base64decode_task [type=""base64decode"" input=""SGVsbG8sIHBsYXlncm91bmQ=""]

Given the input `SGVsbG8sIHBsYXlncm91bmQ=`, the task will return `Hello,
playground` (as ASCII bytes).

## Base64 Encode task

Encodes bytes/string into a Base64 string.

**Parameters**

  * `input`: Byte array or string to be encoded.

**Outputs**

String with Base64 encoding of input.

**Example**


    my_base64encode_task [type=""base64encode"" input=""Hello, playground""]

Given the input string ""Hello, playground"", the task will return
""SGVsbG8sIHBsYXlncm91bmQ="".

## Bridge task

Bridge tasks make HTTP POST requests to pre-configured URLs. Bridges can be
configured via the UI or the CLI, and are referred to by a simple user-
specified name. This is the way that most jobs interact with [External
Adapters](/chainlink-nodes/external-adapters/external-adapters).

**Parameters**

  * `name`: an arbitrary name given to the bridge by the node operator.
  * `requestData` (optional): a statically-defined payload to be sent to the external adapter.
  * `cacheTTL` (optional): a duration-formatted string indicating the maximum acceptable staleness for cached bridge responses in case of intermittent failures. This is disabled by default.
  * `headers` (optional): an array of strings. The number of strings must be even. Example: `foo [type=""bridge"" name=""foo"" headers=""[\\""X-Header-1\\"", \\""value1\\"", \\""X-Header-2\\"", \\""value2\\""]""]`

**Outputs**

A string containing the response body.

**Example**


    my_bridge_task [type=""bridge""
                    name=""some_bridge""
                    requestData=""{\\""data\\"":{\\""foo\\"": $(foo), \\""bar\\"": $(bar)}}""
                    ]

## CBOR Parse task

CBOR Parse tasks parse a CBOR payload, typically as part of a Direct Request
workflow. In Direct Request, a user makes an on-chain request using a
`ChainlinkClient` contract, which encodes the request parameters as CBOR. See
below for an example.

**Parameters**

  * `data`: A byte array containing the CBOR payload.
  * `mode`: An optional parameter that specifies how to parse the incoming CBOR. The default mode is `diet`, which expects the input to be a map. Set the mode to `standard` to pass literal values through ""as-is"". Empty inputs return nil.

**Outputs**

A map containing the request parameters. Parameters can be individually
accessed using `$(dot.accessors)`.

**Example**


    // First, we parse the request log and the CBOR payload inside of it
    decode_log  [type=""ethabidecodelog""
                 data=""$(jobRun.logData)""
                 topics=""$(jobRun.logTopics)""
                 abi=""SomeContractEvent(bytes32 requestID, bytes cborPayload)""]
    
    decode_cbor [type=""cborparse""
                 data=""$(decode_log.cborPayload)""]
    
    // Then, we use the decoded request parameters to make an HTTP fetch
    fetch [type=""http"" url=""$(decode_cbor.fetchURL)"" method=GET]
    parse [type=""jsonparse"" path=""$(decode_cbor.jsonPath)"" data=""$(fetch)""]
    
    // ... etc ...

See the [Direct Request page](/chainlink-nodes/oracle-jobs/all-jobs/#direct-request-jobs) for a more comprehensive example.

## Divide task

Divides the provided `input` by the `divisor` and returns the result with a
number of decimal places defined in the `precision` value.

**Parameters**

  * `input`: The value to be divided 
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`
  * `divisor`: The value by which to divide the `input`
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`
  * `precision`: The number of decimal places to retain in the result 
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`

**Outputs**

The result of the division.

**Example**


    my_divide_task [type=""divide""
                    input=""$(json_parse_result)""
                    divisor=""3""
                    precision=""2""]

Given the input `10`, this example returns `3.33`.

## ETH ABI Decode Log task

Decodes a log emitted by an ETH contract.

**Parameters**

  * `abi`: a canonical ETH log event definition. Should be formatted exactly as in Solidity. Each argument must be named. Examples: 
    * `NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt)`
    * `AuthorizedSendersChanged(address[] senders)`
  * `data`: the ABI-encoded log data. Can be: 
    * a byte array
    * a hex-encoded string beginning with `0x`
    * ... but generally should just be set to `$(jobRun.logData)` (see the [Direct Request page](/chainlink-nodes/oracle-jobs/all-jobs/#direct-request-jobs))
  * `topics`: the ABI-encoded log topics (i.e., the `indexed` parameters) 
    * an array of bytes32 values
    * an array of hex-encoded bytes32 values beginning with `0x`
    * ... but generally should just be set to `$(jobRun.logTopics)` (see the [Direct Request page](/chainlink-nodes/oracle-jobs/all-jobs/#direct-request-jobs))

**Outputs**

A map containing the decoded values.

**Example**


    decode [type=""ethabidecodelog""
            abi=""NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt)""
            data=""$(jobRun.logData)""
            topics=""$(jobRun.logTopics)""]

This task will return a map with the following schema:


    {
        ""roundId"": ...,   // a number
        ""startedBy"": ..., // an address
        ""startedAt"": ..., // a number
    }

## ETH ABI Decode task

Decodes a ETH ABI-encoded payload, typically the result of an [ETH Call
task](/chainlink-nodes/oracle-jobs/all-tasks/#eth-call-task).

**Parameters**

  * `abi`: a canonical ETH ABI argument string. Should be formatted exactly as in Solidity. Each argument must be named. Examples: 
    * `uint256 foo, bytes32 bar, address[] baz`
    * `address a, uint80[3][] u, bytes b, bytes32 b32`
  * `data`: the ABI-encoded payload to decode. Can be: 
    * a byte array
    * a hex-encoded string beginning with `0x`

**Outputs**

A map containing the decoded values.

**Example**


    decode [type=""ethabidecode""
            abi=""bytes32 requestID, uint256 price, address[] oracles""
            data=""$(eth_call_result)""]

This task will return a map with the following schema:


    {
        ""requestID"": ..., // [32]byte value
        ""price"": ...,     // a number
        ""oracles"": [
            ""0x859AAa51961284C94d970B47E82b8771942F1980"",
            ""0x51DE85B0cD5B3684865ECfEedfBAF12777cd0Ff8"",
            ...
        ]
    }

## ETH ABI Encode task

Encodes a bytes payload according to ETH ABI encoding, typically in order to
perform an [ETH Call](/chainlink-nodes/oracle-jobs/all-tasks/#eth-call-task)
or an [ETH Tx](/chainlink-nodes/oracle-jobs/all-tasks/#eth-tx-task).

**Parameters**

  * `abi`: a canonical ETH ABI argument string. Should be formatted exactly as in Solidity. Each argument must be named. If a method name is provided, the 4-byte method signature is prepended to the result. Examples: 
    * `uint256 foo, bytes32 bar, address[] baz`
    * `fulfillRequest(bytes32 requestID, uint256 answer)`
  * `data`: a map of the values to be encoded. The task will make a best effort at converting values to the appropriate types.

**Outputs**

A byte array.

**Example**


    encode [type=""ethabiencode""
            abi=""fulfillRequest(bytes32 requestID, uint256 answer)""
            data=""{\\""requestID\\"": $(foo), \\""answer\\"": $(bar)}""
            ]

## ETH Call task

Makes a non-mutating contract call to the specified contract with the
specified data payload.

**Parameters**

  * `contract`: the address of the contract to call.
  * `data`: the data to attach to the call (including the function selector).
  * `gas`: the amount of gas to attach to the transaction.
  * `from`: The from address with which the call should be made. Defaults to zero address.
  * `gasPrice`: The gasPrice for the call. Defaults to zero.
  * `gasTipCap`: The gasTipCap (EIP-1559) for the call. Defaults to zero.
  * `gasFeeCap`: The gasFeeCap (EIP-1559) for the call. Defaults to zero.
  * `gasUnlimited`: A boolean indicating if unlimited gas should be provided for the call. If set to true, do not pass the `gas` parameter.
  * `evmChainID`: Set this optional parameter to transmit on the given chain. You must have the chain configured with RPC nodes for this to work. If left blank, it will use the default chain.

**Outputs**

An ABI-encoded byte array containing the return value of the contract
function.

**Example**


    encode_call  [type=""ethabiencode""
                  abi=""checkUpkeep(bytes data)""
                  data=""{ \\""data\\"": $(upkeep_data) }""]
    
    call          [type=""ethcall""
                   contract=""0xa36085F69e2889c224210F603D836748e7dC0088""
                   data=""$(encode_call)""
                   gas=""1000""]
    
    decode_result [type=""ethabidecode""
                   abi=""bool upkeepNeeded, bytes performData""
                   data=""$(call)""]
    
    encode_call -> call -> decode_result

## ETH Tx task

Makes a mutating transaction to the specified contract with the specified data
payload. The transaction is guaranteed to succeed eventually.

**Parameters**

  * `from`: one or more addresses of the externally-owned account from which to send the transaction. If left blank, it will select a random address on every send for the given chain ID.
  * `to`: the address of the contract to make a transaction to.
  * `data`: the data to attach to the call (including the function selector). Most likely, this will be the output of an `ethabiencode` task.
  * `gasLimit`: the amount of gas to attach to the transaction.
  * `txMeta`: a map of metadata that is saved into the database for debugging.
  * `minConfirmations`: minimum number of confirmations required before this task will continue. Set to zero to continue immediately. Note that this does not affect transaction inclusion. All transactions will always be included in the chain up to the configured finality depth.
  * `evmChainID`: set this optional parameter to transmit on the given chain. You must have the chain configured with RPC nodes for this to work. If left blank, it will use the default chain.
  * `failOnRevert`: an optional parameter, a boolean, that allows a ChainLink node operator's UI to display and color the status of the task within a job's pipeline depending on a transaction status. _default_ : false.

**Outputs**

The hash of the transaction attempt that eventually succeeds (after
potentially going through a gas bumping process to ensure confirmation).

**Example**


    encode_tx    [type=""ethabiencode""
                  abi=""performUpkeep(bytes performData)""
                  data=""{ \\""data\\"": $(upkeep_data) }""]
    
    submit_tx    [type=""ethtx""
                   to=""0xa36085F69e2889c224210F603D836748e7dC0088""
                   data=""$(encode_tx)""
                   failOnRevert=""true""]
    
    encode_tx -> submit_tx

## Hex Decode task

Accepts a hexadecimal encoded string and returns decoded bytes.

**Parameters**

  * `input`: a hexadecimal encoded string, must have prefix `0x`.

**Outputs**

Decoded bytes.

**Example**


    my_hexdecode_task [type=""hexdecode"" input=""0x12345678""]

Given the input `0x12345678`, the task will return `[0x12, 0x34, 0x56, 0x78]`.

## Hex Encode task

Encodes bytes/string/integer into a hexadecimal string.

**Parameters**

  * `input`: Byte array, string or integer to be encoded.

**Outputs**

Hexadecimal string prefixed with ""0x"" (or empty string if input was empty).

**Example**


    my_hexencode_task [type=""hexencode"" input=""xyz""]

Given the input string ""xyz"", the task will return ""0x78797a"", which are the
ascii values of characters in the string.

## HTTP task

HTTP tasks make HTTP requests to arbitrary URLs.

**Parameters**

  * `method`: the HTTP method that the request should use.
  * `url`: the URL to make the HTTP request to.
  * `requestData` (optional): a statically-defined payload to be sent to the external adapter.
  * `allowUnrestrictedNetworkAccess` (optional): permits the task to access a URL at `localhost`, which could present a security risk. Note that Bridge tasks allow this by default.
  * `headers` (optional): an array of strings. The number of strings must be even. Example: `foo [type=http headers=""[\\""X-Header-1\\"", \\""value1\\"", \\""X-Header-2\\"", \\""value2\\""]""]`

**Outputs**

A string containing the response body.

**Example**


    my_http_task [type=""http""
                  method=PUT
                  url=""http://chain.link""
                  requestData=""{\\""foo\\"": $(foo), \\""bar\\"": $(bar), \\""jobID\\"": 123}""
                  allowUnrestrictedNetworkAccess=true
                  ]

## JSON Parse task

JSON Parse tasks parse a JSON payload and extract a value at a given keypath.

**Parameters**

  * `data`: the JSON string. Can be: 
    * string
    * byte array
  * `path`: the keypath to extract. Must be a comma-delimited list of keys, or specify a custom `separator` alternative.
  * `separator`: (optional) custom `path` key separator. Defaults to comma (`,`).
  * `lax` (optional): if false (or omitted), and the keypath doesn't exist, the task will error. If true, the task will return `nil` to the next task.

**Outputs**

The value at the provided keypath.

**Example**


    my_json_task [type=""jsonparse""
                  data=""$(http_fetch_result)""
                  path=""data,0,price""]

This task returns `123.45` (float64) when given the following example `data`
value:


    {
      ""data"": [{ ""price"": 123.45 }, { ""price"": 678.9 }]
    }

## Length task

Returns the length of a byte array or string.

**Parameters**

  * `input`: Byte array, or string to get the length for.

**Outputs**

The length of the byte array or string.

**Note** : For strings containing multi-byte unicode characters, the output is
the length in bytes and not number of characters.

**Example**


    my_length_task [type=""length"" input=""xyz""]

Given the input string ""xyz"", the task will return 3, length of the string.

## Less Than task

Returns a boolean, result of computing `left < right`.

**Parameters**

  * `left`: the left hand side of comparison. Possible values: 
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`
  * `right`: the right hand side of comparison. Possible values: 
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`

**Outputs**

The result of less than comparison.

**Example**


    my_lessthan_task [type=""lessthan"" left=""3"" right=""10""]

the task will return true which is the result of `3 < 10`

## Lowercase task

Accepts a string and returns a lowercase string.

**Parameters**

  * `input`: a string.

**Outputs**

Lowercase string.

**Example**


    my_lowercase_task [type=""lowercase"" input=""Hello World!""]

Given the input `Hello World!`, the task will return `hello world!`.

## Mean task

Accepts multiple numerical inputs and returns the mean (average) of them.

**Parameters**

  * `values`: an array of values to be averaged.
  * `allowedFaults` (optional): the maximum number of input tasks that can error without the Mean task erroring. If not specified, this value defaults to `N - 1`, where `N` is the number of inputs.
  * `precision`: the number of decimal places in the result.

**Outputs**

The average of the values in the `values` array.

**Example**


    my_mean_task [type=""mean""
                  values=<[ $(fetch1), $(fetch2), $(fetch3) ]>
                  precision=2
                  allowedFaults=1]

Given the inputs `2`, `5`, and `20`, the task will return `9`.

## Median task

Accepts multiple numerical inputs and returns the median of them.

**Parameters**

  * `values`: an array of values from which to select a median.
  * `allowedFaults` (optional): the maximum number of input tasks that can error without the Median task erroring. If not specified, this value defaults to `N - 1`, where `N` is the number of inputs.

**Outputs**

The median of the values in the `values` array.

**Example**


    my_median_task [type=""median""
                    values=<[ $(fetch1), $(fetch2), $(fetch3) ]>
                    allowedFaults=1]

Given the inputs `2`, `5`, and `20`, the task will return `5`.

## Memo task

The `memo` task returns its value as a result.

**Parameters**

  * `value`: value to return. Possible values: 
    * number
    * boolean
    * float
    * string
    * array

**Outputs**

The value.

**Example**


    memo [type=""memo"" value=""10""]

The task will return the value `10`

## Merge task

Merge task returns the merged value of two maps.

**Parameters**

  * `left`: The left map.
  * `right`: The right map, which overwrites the left side.

**Outputs**

Returns the combined map of left and right. If the merged map is invalid, it
returns `null`.

**Example**


    merge [type=""merge"" left=""{\\""foo\\"":\\""abc\\"", \\""bar\\"":\\""123\\""}"" right=""{\\""bar\\"":\\""xyz\\"", \\""biz\\"":\\""buzz\\""}""]

This example task returns the following map:


    { ""foo"": ""abc"", ""bar"": ""xyz"", ""biz"": ""buzz"" }

## Mode task

Accepts multiple numerical inputs and returns the mode (most common) of them.
If more than one value occur the maximum number of times, it returns all of
them.

**Parameters**

  * `values`: an array of values from which to select a mode.
  * `allowedFaults` (optional): the maximum number of input tasks that can error without the Mode task erroring. If not specified, this value defaults to `N - 1`, where `N` is the number of inputs.

**Outputs**

A map containing two keys:


    {
        ""results"": [ ... ], // An array containing all of the values that occurred the maximum number of times
        ""occurrences"": ..., // The number of times those values occurred
    }

**Example**


    my_mode_task [type=""mode""
                    values=<[ $(fetch1), $(fetch2), $(fetch3), $(fetch4), $(fetch5), $(fetch6), $(fetch7), $(fetch8) ]>
                    allowedFaults=3]

Given a `values` array containing `[ 2, 5, 2, ""foo"", ""foo"" ""bar"", ""foo"", 2 ]`,
the task will return:


    {
      ""results"": [2, ""foo""],
      ""occurrences"": 3
    }

## Multiply task

Multiplies the provided `input` and `times` values.

**Parameters**

  * `input`: the value to be multipled. Possible values: 
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`
  * `times`: the value to multiply the input with. 
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`

**Outputs**

The result of the multiplication.

**Example**


    my_multiply_task [type=""multiply"" input=""$(json_parse_result)"" times=3]

Given the input `10`, the task will return `30`.

## Sum Task

Accepts multiple numerical inputs and returns the sum of them.

**Parameters**

  * `values`: an array of values to sum.
  * `allowedFaults` (optional): the maximum number of input tasks that can error without the Sum task erroring. If not specified, this value defaults to `N - 1`, where `N` is the number of inputs.

**Outputs**

The sum of the values in the `values` array.

**Example**


    my_sum_task [type=""sum""
                 values=<[ $(fetch1), $(fetch2), $(fetch3) ]>
                 allowedFaults=1]

Given the inputs `2`, `5`, and `20`, the task will return `27`.

## Uppercase task

Accepts a string and returns an uppercase string.

**Parameters**

  * `input`: a string.

**Outputs**

Uppercase string.

**Example**


    my_uppercase_task [type=""uppercase"" input=""Hello World!""]

Given the input `Hello World!`, the task will return `HELLO WORLD!`.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/all-tasks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Bridges: Adding External Adapters to Nodes

  * Overview
  * Testing External Adapters and Bridges

You can add external adapters to a Chainlink node by creating a bridge in the
Node Operators Interface. Each bridge must have a unique name and a URL for
the external adapter. If a job has a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task), the node searches for a bridge by name and uses
that bridge as your external adapter. Bridge names are case insensitive.

To create a bridge on the node, go to the **Create Bridge** tab in the Node
Operators Interface. Specify a name for the bridge, the URL for your external
adapter, and optionally specify the minimum contract payment and number of
confirmations for the bridge. Minimum contract payment is a fee paid in LINK
for the Chainlink node making a call to the external adapter via the bridge.
This fee is in addition to the fee specified at the global node level for
processing job requests.



The bridge name must be unique to the local node. The bridge URL is the URL of
your external adapter, which can be local or on a separate machine.

To add jobs that use the bridge, add a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task) to your job. The `bridge` task defined in the
example below is defined as `fetch` and the name of the bridge is `soccer-
data`.


    type = ""directrequest""
    schemaVersion = 1
    name = ""Soccer-Data-EA""
    contractAddress = ""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""soccer-data"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""playerId\\"": $(decode_cbor.playerId)}}""]
        parse        [type=jsonparse path=""data,0,Games"" data=""$(fetch)""]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(parse) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx
    """"""

Since `soccer-data` is a bridge task, each node that has this job defined
needs to have a bridge defined with the name `soccer-data` in order to
sucessfully fulfill the request.

## Testing External Adapters and Bridges

The easiest way to test if your external adapter is working is to use a
[Webhook Job](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs).

As an example, assume you have an external adapter named `soccer-data` that is
registered in the `bridges` section and it takes one parameter named
`playerId`. In solidity, you would pass the parameter with the following
request:


    request.add(""playerId"",""12345678"")

How can you test the adapter on your node?

The easiest way is to setup a [Webhook Job](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) that uses the external adapter, and manually set the
parameter.

note

You might need to set the [configuration variable](/chainlink-nodes/v1/configuration) `FEATURE_WEBHOOK_V2=true` in your `.env` file.


    type = ""webhook""
    schemaVersion = 1
    name = ""Soccer-Data-EA-Web""
    observationSource = """"""
    fetch        [type=bridge name=""soccer-data"" requestData=""{\\""id\\"": \\""0\\"", \\""data\\"": { \\""playerId\\"": \\""12345678\\""}}""]
    
        fetch
    """"""

Adding the following into the TOML spec manually sets the parameters passed
into the bridge task. It is equivalent to using `request.add` as shown above
or adding the data with the `--d` flag if you're using
[curl](https://curl.se/).


    requestData=""{\\""id\\"": \\""0\\"", \\""data\\"": { \\""playerId\\"": \\""12345678\\""}}""

There will be a big `Run` button on your job definition, which you can use to
kick off the job.



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/node-operators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the `performUpkeep` function?,"The `performUpkeep` function is called by the Automation Nodes to increase all elements whose balances are lower than the LIMIT, and to rebalance the elements if necessary.",{'source': 'https://docs.chain.link/chainlink-automation/flexible-upkeeps/'},"The purpose of the `performUpkeep` function is to contain the logic that should be executed on-chain when the `checkUpkeep` function returns `true`. It is called by the Automation Registry contract. The `performUpkeep` function in the provided example contract increments a counter if the specified time interval has passed since the last increment. It is important to note that the `performUpkeep` function should be idempotent and revalidate conditions at the start to avoid multiple executions of the same work. 

","
- https://docs.chain.link/chainlink-automation/compatible-contracts/","# Creating Compatible Contracts

  * Overview
  * Example contract
  * Functions
  * checkUpkeep function
  * performUpkeep function
  * Vyper example

Use custom logic to allow Chainlink Automation to determine when to execute
your smart contract functions.

Learn how to make smart contracts that are compatible with the
`AutomationCompatibleInterface` contract and its functions. To understand the
best practices when working with Chainlink Automation, click
[here](/chainlink-automation/compatible-contract-best-practice).

Considerations and Best Practices

Before you deploy contracts to use with Chainlink Automation, read the [Best
Practices](/chainlink-automation/compatible-contract-best-practice) guide.
These best practices are important for using Chainlink Automation securely and
reliably. You can also read more about the Chainlink Automation architecture
[here](/chainlink-automation/overview).

## Example contract

To use Chainlink Automation, contracts must meet the following requirements:

  * Import `AutomationCompatible.sol`. You can refer to the [Chainlink Contracts](https://github.com/smartcontractkit/chainlink/tree/develop/contracts/src) on GitHub to find the latest version.
  * Use the `AutomationCompatibleInterface` from the library to ensure your `checkUpkeep` and `performUpkeep`function definitions match the definitions expected by the Chainlink Automation Network.
  * Include a `checkUpkeep` function that contains the logic that will be executed off-chain to see if `performUpkeep` should be executed. `checkUpkeep` can use on-chain data and a specified `checkData` parameter to perform complex calculations off-chain and then send the result to `performUpkeep` as `performData`.
  * Include a `performUpkeep` function that will be executed on-chain when `checkUpkeep` returns `true`. Because `performUpkeep` is external, users are advised to revalidate conditions and performData.

Use these elements to create a compatible contract that will automatically
increment a counter after every `updateInterval` seconds. After you register
the contract as an upkeep, the Chainlink Automation Network simulates our
`checkUpkeep` off-chain during every block to determine if the
`updateInterval` time has passed since the last increment (timestamp). When
`checkUpkeep` returns true, the Chainlink Automation Network calls
`performUpkeep` on-chain and increments the counter. This cycle repeats until
the upkeep is cancelled or runs out of funding.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    // AutomationCompatible.sol imports the functions from both ./AutomationBase.sol and
    // ./interfaces/AutomationCompatibleInterface.sol
    import ""@chainlink/contracts/src/v0.8/AutomationCompatible.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract Counter is AutomationCompatibleInterface {
        /**
         * Public counter variable
         */
        uint public counter;
    
        /**
         * Use an interval in seconds and a timestamp to slow execution of Upkeep
         */
        uint public immutable interval;
        uint public lastTimeStamp;
    
        constructor(uint updateInterval) {
            interval = updateInterval;
            lastTimeStamp = block.timestamp;
    
            counter = 0;
        }
    
        function checkUpkeep(
            bytes calldata /* checkData */
        )
            external
            view
            override
            returns (bool upkeepNeeded, bytes memory /* performData */)
        {
            upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
            // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
        }
    
        function performUpkeep(bytes calldata /* performData */) external override {
            //We highly recommend revalidating the upkeep in the performUpkeep function
            if ((block.timestamp - lastTimeStamp) > interval) {
                lastTimeStamp = block.timestamp;
                counter = counter + 1;
            }
            // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
        }
    }
    

Compile and deploy your own Automation Counter onto a [supported
Testnet](/chainlink-automation/supported-networks).

  1. In the Remix example, select the compile tab on the left and press the compile button. Make sure that your contract compiles without any errors. Note that the Warning messages in this example are acceptable and will not block the deployment.
  2. Select the **Deploy** tab and deploy the `Counter` smart contract in the `injected web3` environment. When deploying the contract, specify the `updateInterval` value. For this example, set a short interval of 60. This is the interval at which the `performUpkeep` function will be called.
  3. After deployment is complete, copy the address of the deployed contract. This address is required to register your upkeep.

To see more complex examples, go to the [utility contracts](/chainlink-automation/utility-contracts) page.

We will now look at each function in a compatible contract in detail.

## Functions

| Function Name   | Description                                                                                         |
|:----------------|:----------------------------------------------------------------------------------------------------|
| checkUpkeep     | Runs off-chain at every block to determine if the performUpkeep function should be called on-chain. |
| performUpkeep   | Contains the logic that should be executed on-chain when checkUpkeep returns true.                  |
### `checkUpkeep` function

This function contains the logic that runs off-chain during every block as an
`eth_call`[(link)](https://eth.wiki/json-rpc/API#eth_call) to determine if
`performUpkeep` should be executed on-chain. To reduce on-chain gas usage,
attempt to do your gas intensive calculations off-chain in `checkUpkeep` and
pass the result to `performUpkeep` on-chain.

Gas limits for checkUpkeep

The `checkUpkeep` function is subject to the `checkGasLimit` in the [registry
configuration](/chainlink-automation/supported-networks/#configurations).

Because `checkUpkeep` is only off-chain in simulation it is best to treat this
as a `view` function and not modify any state. This might not always be
possible if you want to use more advanced Solidity features like
`DelegateCall`[(link)](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries). It is a best
practice to import the
`AutomationCompatible.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/AutomationCompatible.sol)
contract and use the `cannotExecute` modifier to ensure that the method can be
used only for simulation purposes.


    function checkUpkeep(
      bytes calldata checkData
    ) external view override returns (bool upkeepNeeded, bytes memory performData);
    

Below are the parameters and return values of the `checkUpkeep` function.
Click each value to learn more about its design patterns and best practices:

**Parameters:**

  * `checkData`: Fixed and specified at upkeep registration and used in every `checkUpkeep`. Can be empty (0x).

**Return Values:**

  * `upkeepNeeded`: Boolean that when True will trigger the on-chain `performUpkeep` call.
  * `performData`: Bytes that will be used as input parameter when calling `performUpkeep`. If you would like to encode data to decode later, try `abi.encode`.

#### `checkData`

You can pass information into your `checkUpkeep` function from your [upkeep
registration](/chainlink-automation/register-upkeep) to execute different code
paths. For example, to check the balance on an specific address, set the
`checkData` to abi encode of the address. To learn how to create flexible
upkeeps with checkData, please see out [flexible upkeeps](/chainlink-automation/flexible-upkeeps) page.


    function checkUpkeep(
        bytes calldata checkData
    ) public view returns (bool, bytes memory) {
        address wallet = abi.decode(checkData, (address));
        return (wallet.balance < 1 ether, bytes(""""));
    }
    

Tips on using `checkData`:

  * **Managing unbounded upkeeps** : Limit the problem set of your on-chain execution by creating a range bound for your upkeep to check and perform. This allows you to keep within predefined gas limits, which creates a predictable upper bound gas cost on your transactions. Break apart your problem into multiple upkeep registrations to limit the scope of work.

**Example** : You could create an upkeep for each subset of addresses that you
want to service. The ranges could be 0 to 49, 50 to 99, and 100 to 149.

  * **Managing code paths** : Pass in data to your `checkUpkeep` to make your contract logic go down different code paths. This can be used in creative ways based on your use case needs.

**Example** : You could support multiple types of upkeep within a single
contract and pass a function selector through the `checkData` function.

#### `performData`

The response from `checkUpkeep` is passed to the `performUpkeep` function as
`performData`. This allows you to perform complex and gas intensive
calculations as a simulation off-chain and only pass the needed data on-chain.

You can create a highly flexible off-chain computation infrastructure that can
perform precise actions on-chain by using `checkData` and `performData`. Both
of these computations are entirely programmable.

### `performUpkeep` function

When `checkUpkeep` returns `upkeepNeeded == true`, the Automation node
broadcasts a transaction to the blockchain to execute your `performUpkeep`
function on-chain with `performData` as an input.

Gas limits for performUpkeep

During registration you have to specify the maximum gas limit that we should
allow your contract to use. We simulate `performUpkeep`during `checkUpkeep`
and if the gas exceeds this limit the function will not execute on-chain. One
method to determine your upkeep's gas limit is to simulate the `performUpkeep`
function and add enough overhead to take into account increases that might
happen due to changes in `performData` or on-chain data. The gas limit you
specify cannot exceed the `performGasLimit` in the [configuration of the
registry](/chainlink-automation/supported-networks/#configurations).

Ensure that your `performUpkeep` is _idempotent_. Your `performUpkeep`
function should change state such that `checkUpkeep` will not return `true`
for the same subset of work once said work is complete. Otherwise the Upkeep
will remain eligible and result in multiple performances by the Chainlink
Automation Network on the exactly same subset of work. As a best practice,
always [revalidate](/chainlink-automation/compatible-contract-best-practice#revalidate-performupkeep-on-automation-compatible-contracts)
conditions for your upkeep at the start of your `performUpkeep` function.


    function performUpkeep(bytes calldata performData) external override;
    

**Parameters:**

  * `performData`: Data which was passed back from the `checkData` simulation. If it is encoded, it can easily be decoded into other types by calling `abi.decode`. This data should always be validated against the contract's current state.

#### `performData`

You can perform complex and broad off-chain computation, then execute on-chain
state changes on a subset that meet your conditions. This can be done by
passing the appropriate inputs within `performData` based on the results from
your `checkUpkeep`. This pattern can greatly reduce your on-chain gas usage by
narrowing the scope of work intelligently in your own Solidity code.

  * **Identify a list of addresses that require work** : You might have a number of addresses that you are validating for conditions before your contract takes an action. Doing this on-chain can be expensive. Filter the list of addresses by validating the necessary conditions within your `checkUpkeep` function. Then, pass the addresses that meets the condition through the `performData` function.

For example, if you have a ""top up"" contract that ensures several hundred
account balances never decrease below a threshold, pass the list of accounts
that meet the conditions so that the `performUpkeep` function validates and
tops up only a small subset of the accounts.

  * **Identify the subset of states that must be updated** : If your contract maintains complicated objects such as arrays and structs, or stores a lot of data, you should read through your storage objects within your `checkUpkeep` and run your proprietary logic to determine if they require updates or maintenance. After that is complete, you can pass the known list of objects that require updates through the `performData` function.

## Vyper example

Note on arrays

Make sure the checkdata array size is correct. Vyper does not support dynamic
arrays.

You can find a `KeepersConsumer` example
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/KeepersConsumer.vy). Read the _**apeworx-starter-
kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to
learn how to run the example.

## What's next

  * [› Build flexible contracts](/chainlink-automation/flexible-upkeeps/)
  * [› Manage your Upkeeps](/chainlink-automation/manage-upkeeps/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/compatible-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2023-01-20 18:44:13)
Which is the address that runs requestRandomWords if I&#39;m using Chainlink automation?
URL: https://stackoverflow.com/questions/75188193/which-is-the-address-that-runs-requestrandomwords-if-im-using-chainlink-automat

Question Body:


Helloo aall!! I'm having some troubles when using time-based automation with
request random numbers. What I'm trying to do is to request random numbers
every 10 mins. I'm using the subscription mode in my VRFConsumerBaseV2
contract and I think the problem is that I don't know what is
ConfirmedOwner... which is the address I should set there if
requestRandomWords is being run by an automation oracle? The registry address,
the upkeep address, ...? This is the constructor of my VRFConsumerBaseV2
contract:

    
    
    constructor(address _consumer, uint64 _subscriptionId, address _oracle)
            VRFConsumerBaseV2(_consumer)
            ConfirmedOwner(_oracle)
        {
            COORDINATOR = VRFCoordinatorV2Interface(
                _consumer
            );
            s_subscriptionId = _subscriptionId;
        }
    

And well this is the requestRandomWords, with the onlyOwner that is set with
the ConfirmedOwner in the constructor, no?:

    
    
    function requestRandomWords(uint32 _numWords) public onlyOwner returns (uint256) {
            // Will revert if subscription is not set and funded.
            requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                _numWords
            );
            emit RequestSent(requestId, _numWords);
            return requestId;
        }
    

Thank yooouuu so muuch!!!



Answers:
(Answered on: 2023-01-23 14:48:25)


A few of the FAQ from the [Chainlink Docs](https://docs.chain.link/chainlink-
automation/faqs/) should help clear this up.

## Which contract will call my `performUpkeep` function on-chain?

The [Automation Registry](https://docs.chain.link/chainlink-
automation/supported-networks/) will call the `performUpkeep` function on-
chain.

## Will the address of the Automation Registry always stay the same?

No. As we add new functionality we have to upgrade our contract and deploy a
new Automation Registry. We will work with all our users to ensure Upkeeps are
migrated without causing business interruptions.

## Can I require that `performUpkeep` is only callable by the Automation
Registry?

Our preferred and recommended route before locking access to `performUpkeep`
is [revalidation](https://docs.chain.link/chainlink-automation/compatible-
contracts/#revalidate-performupkeep). We understand you might want to add a
require statement, but then recommend that you make the Automation Registry
address configurable otherwise you will need to deploy a new contract when the
Registry address changes. If you add a `require` statement to `performUpkeep`
you will have to update the Registry Address in your contract when the
Registry Address changes. We also recommend that the owner can always call
`performUpkeep`.


---
(Answered on: 2023-01-20 19:15:00)


It's the upkeep address that you can see in the console of Chainlink oracles.



"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-13/hints.md'},"The topic of Chapter 1 is not provided in the given information.
SOURCES:",,"#####Chapter 1:

Video


:::NEXT DOC:::

#####Chapter 1:

Video
"
What is a constructor in Solidity?,A constructor is a special function executed upon contract creation that allows us to set initial values for the state variables.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-9/course.md'},"A constructor in Solidity is a special function that is executed upon contract creation. It allows for the setting of initial values for state variables. There can only be one constructor per contract and it is defined using the constructor keyword. The arguments for the constructor are passed during contract creation. If a constructor is not defined, there is a default constructor in place. Child contracts can also call their parent constructors. Parent constructors are always called in order of inheritance, from right to left. It is important to be aware of the order of inheritance when using constructors. 
","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-9/course.md","#####Chapter 9:

# Constructors

It is likely that you want to deploy the same contract with different initial values. Until now, you only learned how to set initial values. So you would always need to write a new contract with updated initial values in the Solidity code. This is unpractical. Fortunately, Solidity offers a constructor, a special function executed upon contract creation.

<Highlight class=""language-javascript"">
contract Foo {
uint public amount;
   constructor(uint _amount) {
       amountFoo = _amount;
   }
}
 
contract Bar {
uint public amount;
   constructor(uint _amount) {
       amountBar = _amount;
   }
}
</Highlight>

There can only be one constructor per contract and a constructor is defined using the constructor keyword. The arguments are passed during contract creation, allowing us to set initial values for the state variables. There is always a constructor in place. If you do not define one, there is a default constructor. Once the contract is created, the code is deployed on the blockchain.

Child contracts inhering from a parent contract can also call their parent constructors. You can do this either directly when defining the contract or in the child contract constructor:

<Highlight class=""language-javascript"">
contract A is Foo(42) {
}
 
contract B is Bar {
  constructor(uint \_amount) Bar(\_amount) {}
}
</Highlight>

It is important to note that parent constructors are always called in order of inheritance. So if you use the child constructor to pass the values, you should always check the order of inheritance They are always called from right to left. Let’s look at an example:

<Highlight class=""language-javascript"">
contract C is Foo, Bar {
 constructor() Bar(5) Foo(42) {}
}
</Highlight>

So here the constructor of Bar is called first with the value 5, then the Foo constructor is called with the value 42 and then the constructor of C is called. Remember this when using constructors because it might introduce weird behavior to your contracts if you have a different assumption.


:::NEXT DOC:::

pragma solidity ;
"
What does Chainlink VRF allow you to customize?,Several randomness parameters.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-7/description.md'},"Chainlink VRF allows you to customize several randomness parameters.
","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-7/description.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-7/description.md","Learn how Chainlink VRF allows you to customize several randomness parameters.


:::NEXT DOC:::

Learn how Chainlink VRF allows you to customize several randomness parameters.
"
What issue is the user facing when integrating Chainlink into their contract?,The API call doesn't work for them.,{'source': 'https://stackoverflow.com/questions/69816494/requesting-data-with-chainlink-response-not-what-expected'},"The user is facing the issue of not finding a Chainlink smart contract in the CELO network. Currently, there isn't a popular Chainlink network on the Celo network. However, the user has the option to run their own node on the Celo network and start their own network. 
",https://stackoverflow.com/questions/74914660/integrating-celo-with-chainlink,"# Contributing to Chainlink

  * Overview
  * Contributing to Software and Tooling
  * Raising an Issue
  * Requesting a new Feature
  * Submitting a Pull Request
  * Contributing to the documentation
  * Creating Community Content
  * Becoming a Developer Expert
  * Joining the Chainlink Community Advocate program
  * Running a Chainlink Focused Developer Bootcamp
  * Running an In-Person Meetup or Watch Party
  * Participate in a Hackathon
  * Applying for a Grant

Chainlink is an open-source project licensed [under the MIT
license](https://github.com/smartcontractkit/chainlink/blob/master/LICENSE),
and we encourage contributions from all developers and community members.

# What It Means to Contribute

When you contribute to the Chainlink project, you as a developer or community
member contribute your time and effort to help improve and grow Chainlink.
Your contribution can be from various methods:

  * Building and maintaining the Chainlink software and tools
  * Improving and maintaining the documentation, including translations into other languages
  * Creating Chainlink focused content (blog posts, tutorials, videos etc)
  * Becoming a developer expert
  * Becoming a community advocate
  * Running a Chainlink focused developer Bootcamp (in person or online)
  * Running an in-person meetup or watch party
  * Participate in a hackathon
  * Applying for a grant

# Why Should You Contribute

[Open source software](https://en.wikipedia.org/wiki/Open-source_software) is
a model that brings multiple benefits for both the project and the
contributors. As a developer or community member, contributing to Chainlink
helps you to gain valuable skills and experience, improve the software that
you use, and grow your personal brand in the community which can lead to
future employment opportunities. On top of these awesome things, contributing
to open source is fun. It can give you a sense of community involvement, and
gives you a personal sense of satisfaction knowing that you're part of an
effort to build something that will enable a fairer, more transparent, and
efficient new world.

# Ways to Contribute

## Contributing to Software and Tooling

The most direct way you can contribute to Chainlink is to contribute to the
core code or the various tooling found in our [GitHub
repository](https://github.com/smartcontractkit/). Contributing to code or
code-based tools can generally be split into a few different categories:

  * Raising an issue
  * Requesting a new feature
  * Submitting a Pull Request (PR) for a fix, improvement, or new tool

### Raising an Issue

During the course of using Chainlink software or tools, you might encounter
errors or unexpected behavior that leads you to believe the software isn't
behaving correctly. You can bring this to the attention of the Chainlink Labs
team as well as the wider developer community by raising an issue in the
project’s GitHub repository. The 'Issues' tab lists all of the open issues for
the repository.

After an issue is raised and tagged, the Chainlink Labs team and the wider
community can address it. This gives the issue the visibility required for
someone to investigate it and resolve the issue.

When you first create an issue, you must also categorize it. This prefixes the
issue name to give viewers an indication of what category the issue relates
to:

  * [NODE]: The issue relates to the core node software
  * [DEVEL]: The issue is a result of working on code found in the current repository
  * [FEAT]: The issue relates to a new feature request
  * [SMRT]: The issue related to using Chainlink smart contracts
  * [EXPL]: The issue related to using the Chainlink Explorer
  * [FAUC]: The issue related to using the Chainlink Faucet



After you select a category, enter the details for the issue. Include as much
detail about the issue as possible. Provide a thorough description,
environment, and software version details. Also provide detailed steps that
describe how to reproduce the issue. The more thorough you make your
description, the better the chances are that someone will be able to pick up
the issue and resolve it.

Once a team member acknowledges that the issue has been received, they will
tag it with an appropriate label. You should then monitor the state of the
open issue for any questions or updates.

### Requesting a new Feature

Have you thought of an improvement or an awesome new feature that you think
should be implemented into Chainlink? Request a new feature to bring it to the
attention of the team and the wider community. You can request new features by
creating a new GitHub issue in the correct repository and tagging that issue
with the [FEAT] prefix (Feature request). The process for doing this is
covered in the Raising an Issue section. Provide as much detail as possible in
your feature request, including any benefits, risks, or considerations that
you can think of.

#### Voting on new features

Sometimes a new feature is put to a vote to decide if it's something that the
team and wider community should implement. When a feature is put to a vote,
the issue is tagged with the 'needs votes' label. You can contribute to the
voting process by reacting to the first post in the feature request with a
thumbs up or thumbs down emoji. This will help drive the decision. You can
also contribute your thoughts by replying directly to the feature request with
a new post in the thread.



### Submitting a Pull Request

The best way to contribute to Chainlink is to submit a [pull request
(PR)](https://docs.github.com/en/github/collaborating-with-pull-
requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests). PRs can be submitted for various reasons, such as fixing an
identified issue, adding a feature or improvement to the project, or even
adding an entirely new repository to the Chainlink source code for a new tool
or feature. If you're looking for something to pick up and create a PR for,
you can search through the Chainlink repositories to find open issues, and
approved feature requests.

If you're new to contributing to open-source software or Chainlink, we've
tagged some [good first
issues](https://github.com/smartcontractkit/chainlink/issues?q=is%3Aissue+label%3A%22good+first+issue%22)
against the main node software and smart contracts that you can tackle. Each
major repository in the Chainlink GitHub should also have some good first
issues tagged for developers to be able to take on.

All code changes must follow the [style guide]
(<https://github.com/smartcontractkit/chainlink/wiki/Code-Style-Guide>), All
PRs must be in an appropriately named branch with a format like 'feat/feature-
description' or 'devel/issue-description'. After you submit a PR, you should
get a response by a team member within a day or two acknowledging that the PR
has been received. After that, monitor the PR for any additional questions or
updates that come up while the team and the community review the changes.

## Contributing to the documentation

The [Chainlink documentation](https://docs.chain.link/) is the go-to place for
developers who want to learn how to build applications using Chainlink, and
node operators wanting useful information on running a Chainlink node. The
documentation is [open
source](https://github.com/smartcontractkit/documentation), allowing for other
developers and community members to contribute to adding or improving it. You
can contribute to the Chainlink documentation in various ways:

  * Improving the readability of pages
  * Fixing typos or grammar errors
  * Adding new guides or tutorials that you would find useful
  * Translating the documentation into other languages

The process for contributing to the documentation follows the process defined
earlier in the Submitting a Pull Request section. Each page also has a
'Suggest Edits' link on the top right, and will directly take you to the page
in the [documentation
repository](https://github.com/smartcontractkit/documentation), where you can
create a new PR with the suggested changes. Before you create a PR for the
documentation, read the [contributing
guidelines](https://github.com/smartcontractkit/documentation/blob/main/CONTRIBUTING.md).

If you want to translate the documentation into a new language that is not yet
supported, feel free to [reach out to the
team](mailto:devrel@smartcontract.com) beforehand, so we can make sure you get
the support you need.

## Creating Community Content

Chainlink has a strong and vibrant community of developers and community
advocates. Community members often create Chainlink-focused content in various
forms and publish it for the wider community on various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually hosted](https://blog.chain.link/smart-contract-developer-bootcamp-on-demand/) the first [Chainlink Developer
Bootcamp](http://chain.link/bootcamp). If you're passionate about educating
others about smart contracts and Chainlink, you can contribute by running your
own developer Bootcamp. You can also contribute by translating an existing
Bootcamp and running it in another language. Before you run your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-12-25 16:55:37)
Integrating Celo with Chainlink
URL: https://stackoverflow.com/questions/74914660/integrating-celo-with-chainlink

Question Body:


I have participated in a hackathon. So, we decided to use Celo + Chainlink.
But in Chianlink I saw there they don't have any smart contract in CELO
network.

Expect: A chainlink smart contract link like one of these:
<https://docs.chain.link/resources/link-token-contracts>.



Answers:
(Answered on: 2022-12-27 20:27:56)


Currently, there isn't a popular Chainlink network on the Celo network. You
could run your own node there if you'd like and [start a network
yourself](https://docs.chain.link/chainlink-nodes/).



"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-10/hints.md'},"The topic of Chapter 1 is not provided in the given information.
SOURCES:",,"#####Chapter 1:

Video


:::NEXT DOC:::

#####Chapter 1:

Video
"
What are the three methods used to provide off-chain reserves data?,"The three methods used to provide off-chain reserves data are third-party attestation, custodian, and self-attestation.",{'source': 'https://docs.chain.link/data-feeds/proof-of-reserve/'},"The three methods used to provide off-chain reserves data are:

1. Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
2. Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
3. Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

",https://docs.chain.link/data-feeds/proof-of-reserve/,"# Proof of Reserve Feeds

  * Overview
  * Types of Proof of Reserve Feeds
  * Off-chain reserves
  * Cross-chain reserves
  * Using Proof of Reserve Feeds

Chainlink Proof of Reserve Feeds provide the status of the reserves for
several assets. You can read these feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

To find a list of available Proof of Reserve Feeds, see the [Proof of Reserve
Feed Addresses](/data-feeds/proof-of-reserve/addresses) page.

## Types of Proof of Reserve Feeds

Reserves are available for both cross-chain assets and off-chain assets. This
categorization describes the data attestation variations of Proof of Reserve
feeds and helps highlight some of the inherent market risks surrounding the
data quality of these feeds.

Reserves are available for both off-chain assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
  * ⚠️ Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

### Cross-chain reserves

Cross-chain reserves are sourced from the network where the reserves are held.
Chainlink node operators can report cross-chain reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Decentralized Data Model

  * Overview
  * Data Aggregation
  * Shared Data Resource
  * Decentralized Oracle Network
  * Components of a Decentralized Oracle Network
  * Consumer
  * Proxy
  * Aggregator

This page describes how data aggregation is applied to produce Chainlink Data
Feeds and provides more insight as to how Data Feeds are updated.

## Data Aggregation

Each data feed is updated by multiple, independent Chainlink oracle operators.
The
[AccessControlledOffchainAggregator](https://github.com/smartcontractkit/libocr/blob/master/contract/AccessControlledOffchainAggregator.sol)
aggregates the data on-chain.

Off-Chain Reporting (OCR) further enhances the aggregation process. To learn
more about OCR and how it works, see the [Off-Chain Reporting](/architecture-overview/off-chain-reporting) page.

## Shared Data Resource

Each data feed is built and funded by the community of users who rely on
accurate, up-to-date data in their smart contracts. As more users rely on and
contribute to a data feed, the quality of the data feed improves. For this
reason, each data feed has its own properties depending on the needs of its
community of users.

## Decentralized Oracle Network

Each data feed is updated by a decentralized oracle network. Each oracle
operator is rewarded for publishing data. The number of oracles contributing
to each feed varies. In order for an update to take place, the data feed
aggregator contract must receive responses from a minimum number of oracles or
the latest answer will not be updated. You can see the minimum number of
oracles for the corresponding feed at
[data.chain.link](https://data.chain.link).

Each oracle in the set publishes data during an aggregation round. That data
is validated and aggregated by a smart contract, which forms the feed's latest
and trusted answer.

## Components of a Decentralized Oracle Network

Data Feeds are an example of a decentralized oracle network, and include the
following components:

  * A consumer contract
  * A proxy contract
  * An aggregator contract

To learn how to create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

### Consumer

A Consumer contract is any contract that uses Chainlink Data Feeds to consume
aggregated data. Consumer contracts must reference the correct
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract and call one of the exposed functions.


    ...
    AggregatorV3Interface feed = AggregatorV3Interface(address);
    return feed.latestRoundData();

Off-chain applications can also consume data feeds. See the Javascript and
Python example code on the [Using Data Feeds](/data-feeds/price-feeds) page to
learn more.

### Proxy

Proxy contracts are on-chain proxies that point to the aggregator for a
particular data feed. Using proxies enables the underlying aggregator to be
upgraded without any service interruption to consuming contracts.

Proxy contracts can vary from one data feed to another, but the
[`AggregatorProxy.sol`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol)
on Github is a common example.

### Aggregator

An aggregator is the contract that receives periodic data updates from the
oracle network. Aggregators store aggregated data on-chain so that consumers
can retrieve it and act upon it within the same transaction.

You can access this data using the Data Feed address and the
[`AggregatorV3Interface`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol).

Aggregators receive updates from the oracle network only when the **Deviation
Threshold** or **Heartbeat Threshold** triggers an update during an
aggregation round. The first condition that is met triggers an update to the
data.

  * Deviation Threshold: A new aggregation round starts when a node identifies that the off-chain values deviate by more than the defined deviation threshold from the on-chain value. Individual nodes monitor one or more data providers for each feed.
  * Heartbeat Threshold: A new aggregation round starts after a specified amount of time from the last update.

## What's next

  * [› Using Data Feeds](/data-feeds/price-feeds/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-decentralized-model.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are the two steps involved in billing for Chainlink Functions requests?,The two steps involved in billing for Chainlink Functions requests are the Request step and the Receive step.,{'source': 'https://docs.chain.link/chainlink-functions/resources/billing/'},"The two steps involved in billing for Chainlink Functions requests are:

1. Start Billing: The FunctionsOracle contract calls the FunctionsBillingRegistry's `startBilling` function to estimate the fulfillment costs and block the amount in the Reservation balance.

2. Fulfill and Bill: After receiving the API response, the FunctionsOracle contract calls the FunctionsBillingRegistry's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing.

",https://docs.chain.link/chainlink-functions/resources/billing,"# Chainlink Functions Resources

  * Overview
  * Topics

## Topics

  * [Concepts](/chainlink-functions/resources/concepts)
  * [Architecture](/chainlink-functions/resources/architecture)
  * [Managing Subscriptions](/chainlink-functions/resources/subscriptions)
  * [Billing](/chainlink-functions/resources/billing)
  * [Supported Networks](/chainlink-functions/supported-networks)
  * [Service Limits](/chainlink-functions/resources/service-limits)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates with the _Functions Billing Registry_ , which
assigns a unique identifier (aka _Subscription ID_ ).

### Fund Subscription

You must fund your subscription accounts with enough LINK tokens:

  1. Connect your EOA to the _Subscription App_.
  2. Fund your subscription account. The _Subscriptions App_ abstracts the following: 
    1. Call `transferAndCall` on the LINK token contract, transferring LINK tokens along with the _Subscription ID_ in the payload.
    2. The _Functions Billing Registry_ contract implements `onTokenTransfer`: It parses the _Subscription ID_ from the payload and funds the subscription account with the transferred LINK amount.

### Add Consumer

You must allowlist your consumers' contracts on your subscription account
before they can make Chainlink Functions requests. To do so:

  1. Connect your EOA to the _Subscription App_.
  2. Add the address of your consumer contract to your subscription account.
  3. The _Subscription App_ calls the _Functions Billing Registry_ contract to add the consumer contract address to your subscription account.

### Remove Consumer

To remove a consumer contract:

  1. Connect your EOA to the _Subscription App_.
  2. Remove the address of your consumer contract from the allowlist.
  3. The _Subscription App_ calls the _Functions Billing Registry_ contract to remove the consumer contract address from your subscription account.

**Note** : You can still remove consumers from your subscription if there are
in-flight requests. Your consumer contract will still be called back, and your
_Subscription Account_ will be charged.

### Cancel Subscription

To cancel a subscription:

  1. Connect your EOA to the _Subscription App_.
  2. Cancel your subscription, passing the _Subscription Balance_ receiver account address. The _Subscriptions App_ abstracts the following: 
    1. Call the `cancelSubscription` function on the _Functions Billing Registry_ contract, deleting the _Subscription ID_ and removing any existing consumers.
    2. The outstanding _Subscription Balance_ is sent to the receiver account.

**Note** : You cannot cancel a subscription if there are in-flight requests.

### Transferring ownership of a Subscription

Transferring ownership works as follows:

  1. Connect your EOA to the _Subscription App_.
  2. Initiate the ownership transfer by specifying the new owner's address.
  3. The new owner must connect their EOA to the _Subscription App_ and accept the ownership.

## What's next

  * [› Billing](/chainlink-functions/resources/billing)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/architecture.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are the trade-offs that bridge designs must compromise between?,"Bridge designs must compromise between trust-minimization, generalizability, extensibility, latency, and costs.",{'source': 'https://docs.chain.link/resources/bridge-risks/'},"Bridge designs for cross-chain interoperability must compromise between several trade-offs, including trust-minimization, generalizability, extensibility, latency, and costs. Trust-minimization refers to the system not introducing new trust or security assumptions beyond those of the underlying blockchains. Generalizability refers to the system's ability to transfer complex arbitrary data. Extensibility refers to how easy it is to integrate a new blockchain. Latency refers to the time it takes to complete a transaction, and costs refer to the expenses associated with transferring data across chains via a bridge. These trade-offs must be considered when designing and using bridges for cross-chain communication. 
",https://docs.chain.link/resources/bridge-risks/,"# Cross-chain bridges and associated risks

  * Overview
  * What is a Cross-chain bridge
  * Trade-offs
  * Risks
  * Smart contract risks
  * Systemic financial risks
  * Early stage
  * Trust-minimization (Counterparty risk)

When working with Chainlink on layer-2 chains and sidechains, you must export
your LINK tokens from Ethereum to the target chain using a cross-chain bridge.
Follow this [video](https://www.youtube.com/watch?v=WKvIGkBWRUA) for an
example of moving LINK tokens from Ethereum to Polygon.

Cross-chain bridges come with their own risks. In fact, bridge attacks
constitute some of the [largest cryptocurrency
hacks](https://rekt.news/leaderboard/) by value. When moving your LINK tokens
or any asset across chains, understand the risks that you are taking with your
assets. Chainlink Labs does not endorse any bridge. Ultimately, you are
responsible for assessing the bridge that you use to move your assets.

Read the What is a cross-chain bridge, Trade-offs, and Risks sections to learn
more about bridges and trust assumptions in their designs. After you read
these sections, you will have a better understanding of bridge risks and which
aspects you should evaluate when using a bridge.

## What is a Cross-chain bridge

With the [proliferation](https://defillama.com/chains) of layer-1 blockchains
and layer-2 scaling solutions, the web3 ecosystem has become multi-chain. Each
blockchain comes with its own approach to scalability, security, and trust.

However, blockchains are not natively capable of communicating with each
other, which makes [blockchain interoperability
protocols](https://blog.chain.link/blockchain-interoperability/) critical for
allowing dApps to interact with any on-chain environment and tap into each
blockchain's unique assets and features.

A [bridge](https://blog.chain.link/cross-chain-bridge/) is a core element of
cross-chain interoperability. Bridges exist to connect blockchain networks and
enable connectivity between them.

Bridges enable the following:

  * Cross-chain transfer of assets and information
  * dApps can leverage the strengths and benefits of different chains
  * Collaboration between developers from different blockchain ecosystems to build new platforms and products for users

As an analogy, you can use [the blockchains as cities mental
model](https://medium.com/dragonfly-research/blockchains-are-cities-564327013f86):

  * Layer-1 blockchains are like cities.
  * Layer-2 solutions are equivalent to skyscrapers. As described in the mental model, “Each rollup is like a vertical blockchain that extends from the ground L1”.
  * Bridges are like roads and streets that connect different cities and skyscrapers.

## Trade-offs

With the growing number of layer-1 and layer-2 chains, the number of bridges
has also grown, [surpassing one hundred](https://debridges.com/). So, how do
you choose the correct bridge?

When choosing a bridge, there is no perfect solution, only trade-offs. As
explained in the [interoperability trilemma](https://blog.connext.network/the-interoperability-trilemma-657c2cf69f17) and [Ethereum foundation
docs](https://ethereum.org/en/developers/docs/bridges/#trade-offs), bridge
designs must compromise between the following characteristics:

  * **Trust-minimization:** The system does not introduce new trust or security assumptions beyond those of the underlying blockchains. Read trust-minimization for more details.
  * **Generalizability:** The system enables the transfer of complex arbitrary data. Data could be messages or assets/funds.
  * **Extensibility:** How hard is it to integrate a new blockchain?
  * **Latency:** How long does it take to complete a transaction?
  * **Costs:** How much does it cost to transfer data across chains via a bridge?

## Risks

When choosing a bridge, be aware of the following risks.

### Smart contract risks

Bugs and vulnerabilities can expose users' assets to different kinds of
exploits. Read this [detailed analysis](https://certik.medium.com/qubit-bridge-collapse-exploited-to-the-tune-of-80-million-a7ab9068e1a0) for an
example of a bridge exploit where the attacker could leverage a logical error
in the bridge’s smart contract.

### Systemic financial risks

To transfer tokens cross-chain, many bridges lock tokens on the source chain
and mint derivative or wrapped tokens on the destination chain representing
the locked tokens. A hack of the locked tokens or an infinite mint attack on
the wrapped tokens can make all wrapped tokens worthless and expose entire
blockchains to risk.

### Early stage

Given that bridges are relatively new, there are many unanswered questions
related to how bridges will perform in different market conditions.

### Trust-minimization (Counterparty risk)

To overcome cross-chain interoperability challenges, some bridges use off-
chain actors or validators. These actors introduce new trust assumptions in
addition to the underlying blockchain trust assumptions. These bridges act as
a custodian and are, therefore, trust-based. In contrast, some bridge designs
rely on underlying blockchains' validators and, therefore, do not add any
trust assumptions. To summarize:

  * Trusted (custodial) bridges require a third party to validate movements over the bridge. Users are required to give up control of their crypto assets, so trust is involved as they rely on the bridge operator's reputation.
  * Trustless (non-custodial) bridges leverage smart contracts to store and release funds on either side of the bridge. These bridges are trust-minimized because they don't make new trust assumptions beyond the underlying blockchains.

Trustlessness in bridges does not exist in an absolute form (trusted vs.
trustless). As explained in the blockchain-interoperability
[blog](https://blog.chain.link/blockchain-interoperability/), there are four
general interoperability solutions for validating the state of a source
blockchain and relaying the subsequent transaction to the destination
blockchain:

#### Web2 Verification

Web2 verification is when someone uses a web2 service to execute a cross-chain
transaction. The most common example in practice is when users leverage
centralized exchanges to swap or bridge their own tokens. The user simply
deposits their assets into an address on the source chain that's under the
control of the exchange and then withdraws the same tokens or different tokens
(via a swap on the exchange) to an address on a destination chain controlled
by the user.

Web2 verification can be fairly convenient for personal transactions and
requires less technical expertise. However, it is limited only to swapping and
bridging tokens which requires trust in a centralized custodian.

#### External verification

External verification is where a group of validator nodes are responsible for
verifying transactions. These validators do not belong to either of the two
blockchains’ validator sets and they also have their trust assumptions
irrespective of the underlying blockchains.

External verification typically requires an honest majority assumption, where
a majority of the external validator nodes must behave honestly for the
integrity of the cross-chain interaction to be upheld. However, additional
techniques can be used to increase trust-minimization, such as:

  * optimistic bridge verification.
  * anti-fraud networks.
  * cryptoeconomic staking.

Despite an additional trust assumption, external verification is currently the
only practical way to perform cross-chain contract calls between certain types
of blockchains while still providing trust-minimized guarantees. It’s also a
highly generalized and extensible form of cross-chain computation that is
capable of supporting more complex cross-chain applications.

Cryptography risk

Some externally verified bridges are secured by multisig wallets.
[Ronin](https://whitepaper.axieinfinity.com/technology/ronin-ethereum-sidechain) is one example. Multisig wallets are also referred to as m-of-n
multisigs, with M being the required number of signatures or keys and N being
the total number of signatures or keys (m≤n). This means that an attacker only
needs to exploit M keys to be able to hack the whole system. In this case,
users must trust that the third party is decentralized enough, signers are
independent of each other, and that each signer has proper key management in
place. Read this [detailed analysis](https://rekt.news/ronin-rekt/) for an
example of a bridge exploit where the attacker could compromise M keys.

Optimistic bridges

Optimistic bridges rely on honest watchers to monitor the bridges' operations
and report any fraud. Because the watchers of an optimistic system are
permissionless, there is no way to know if there is not at least one single
watcher monitoring the system. Therefore, the cost of a successful attack is
limitless as it requires an attacker to know who the watchers are and hack all
of them.

Here are some examples of externally verified bridges that use different
techniques to increase trust-minimization :

  * [Binance bridge](https://www.binance.com/en/blog/ecosystem/introducing-binance-bridge-20-421499824684903626) is a trusted bridge using the security standards of Binance.
  * [Polygon POS bridge](https://wiki.polygon.technology/docs/develop/ethereum-polygon/pos/getting-started/) uses a proof of stake (PoS) consensus algorithm for network security.
  * [Nomad](https://docs.nomad.xyz/nomad-101/introduction) is an optimistic bridge. It uses [optimistic verification](https://docs.nomad.xyz/the-nomad-protocol/verification-mechanisms/optimistic-verification) where messages are optimistically signed on the origin chain and a timeout period is enforced on the destination. During this period, a set of actors called watchers can inspect the messages and flag any detected fraud.

#### Local verification

Local verification is when the counterparties in a cross-chain interaction
verify the state of one another. If both deem the other valid, the cross-chain
transaction is executed, resulting in peer-to-peer cross-chain transactions.
Cross-chain swaps using local verification are often referred to as atomic
swaps.

This model has a high level of trust-minimization given reasonable blockchain
assumptions, as the swap either happens or both transactions fail.
Furthermore, the model works so long as both parties are economically
adversarial: they cannot collude to steal funds during atomic swaps.

Note that local verification is not very generalizable to a variety of cross-
chain contract calls, and comes with tradeoffs like the [inadvertent call
option problem](https://blog.bitmex.com/atomic-swaps-and-distributed-exchanges-the-inadvertent-call-option/) — a situation where the second party
in an atomic swap can either act or not act on the swap, giving them an
inadvertent call option for a certain period of time. Thus, local verification
is mostly used in cross-chain liquidity protocols involving liquidity pools
that exist independently on each chain.

[Hop](https://docs.hop.exchange/faq#what-is-hop-protocol) or [Connext
legacy](https://docs.connext.network/0.1.x-legacy/developers/intro) are
examples of locally verified bridges.

#### Native verification

In this design, the validators of the destination blockchains are responsible
for verifying the state of the source blockchain to confirm a given
transaction. This is typically done by running a light client of the source
chain in the virtual machine of the destination chain or running them both
side-by-side. Native verification is the most trust-minimized form of cross-
chain communication, but it is more expensive, offers less development
flexibility, and is more suited to blockchains with similar state machines,
such as between Ethereum and EVM-based layer-2 networks or only among Cosmos
SDK-based blockchains.

The [NEAR Rainbow Bridge](https://near.org/blog/eth-near-rainbow-bridge/) is
an example of a natively verified bridge. A smart contract with Ethereum light
client functionality is deployed on the NEAR blockchain and a smart contract
with NEAR protocol light client functionality is deployed on Ethereum. These
light clients hold the latest block headers and verify that cross-chain
transactions are done across both chains. The trust model relies only on
Ethereum and Near validators.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/bridge-risks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Bridges: Adding External Adapters to Nodes

  * Overview
  * Testing External Adapters and Bridges

You can add external adapters to a Chainlink node by creating a bridge in the
Node Operators Interface. Each bridge must have a unique name and a URL for
the external adapter. If a job has a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task), the node searches for a bridge by name and uses
that bridge as your external adapter. Bridge names are case insensitive.

To create a bridge on the node, go to the **Create Bridge** tab in the Node
Operators Interface. Specify a name for the bridge, the URL for your external
adapter, and optionally specify the minimum contract payment and number of
confirmations for the bridge. Minimum contract payment is a fee paid in LINK
for the Chainlink node making a call to the external adapter via the bridge.
This fee is in addition to the fee specified at the global node level for
processing job requests.



The bridge name must be unique to the local node. The bridge URL is the URL of
your external adapter, which can be local or on a separate machine.

To add jobs that use the bridge, add a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task) to your job. The `bridge` task defined in the
example below is defined as `fetch` and the name of the bridge is `soccer-
data`.


    type = ""directrequest""
    schemaVersion = 1
    name = ""Soccer-Data-EA""
    contractAddress = ""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""soccer-data"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""playerId\\"": $(decode_cbor.playerId)}}""]
        parse        [type=jsonparse path=""data,0,Games"" data=""$(fetch)""]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(parse) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx
    """"""

Since `soccer-data` is a bridge task, each node that has this job defined
needs to have a bridge defined with the name `soccer-data` in order to
sucessfully fulfill the request.

## Testing External Adapters and Bridges

The easiest way to test if your external adapter is working is to use a
[Webhook Job](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs).

As an example, assume you have an external adapter named `soccer-data` that is
registered in the `bridges` section and it takes one parameter named
`playerId`. In solidity, you would pass the parameter with the following
request:


    request.add(""playerId"",""12345678"")

How can you test the adapter on your node?

The easiest way is to setup a [Webhook Job](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) that uses the external adapter, and manually set the
parameter.

note

You might need to set the [configuration variable](/chainlink-nodes/v1/configuration) `FEATURE_WEBHOOK_V2=true` in your `.env` file.


    type = ""webhook""
    schemaVersion = 1
    name = ""Soccer-Data-EA-Web""
    observationSource = """"""
    fetch        [type=bridge name=""soccer-data"" requestData=""{\\""id\\"": \\""0\\"", \\""data\\"": { \\""playerId\\"": \\""12345678\\""}}""]
    
        fetch
    """"""

Adding the following into the TOML spec manually sets the parameters passed
into the bridge task. It is equivalent to using `request.add` as shown above
or adding the data with the `--d` flag if you're using
[curl](https://curl.se/).


    requestData=""{\\""id\\"": \\""0\\"", \\""data\\"": { \\""playerId\\"": \\""12345678\\""}}""

There will be a big `Run` button on your job definition, which you can use to
kick off the job.



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/node-operators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are some ways to automatically purchase LINK tokens for a smart contract?,"Some ways to automatically purchase LINK tokens for a smart contract include: programatically swapping on a DEX like Uniswap, pre-funding the contract with LINK, doing it external to the blockchain, making use of meta-transactions, or paying an upfront cost to ensure the coordinator contracts are well funded with LINK.",{'source': 'https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically'},"There are several ways to automatically purchase LINK tokens for a smart contract:

1. Swap on a DEX like Uniswap programmatically.
2. Pre-fund the contract with LINK tokens beforehand.
3. Use an external process to fund the contract with LINK tokens periodically.
4. Implement meta-transactions so that users don't need to purchase LINK themselves.
5. Pay an upfront cost to ensure the coordinator contracts are well funded with LINK and manually top them up as needed.

Source: https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically

","https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically, https://docs.chain.link/getting-started/conceptual-overview/","Question: (Asked on: 2021-05-09 12:01:16)
How to make a Smart Contract purchase LINK (or other ERC20) tokens automatically?
URL: https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically

Question Body:


I am trying to interact with the Chainlink VRF function.

I have a Coordinator contract that needs random numbers to draw cards out of a
deck. The Coordinator calls a Random Number Generation Oracle that implements
Chainlink's VRFConsumerBase contract.

I want my Coordinator/Oracle to purchase LINK tokens automatically using the
Ether that the user sent for the draw price so that it can always provide the
required LINK fee to the VRF function and it does not need a human to manually
top up the contract with LINK.

Is there any working example/tutorial on how one could achieve this? I really
wish to avoid forcing the users of my contract to purchase LINK themselves.

Thanks!



Answers:
(Answered on: 2021-05-09 12:37:13)


A contract itself can't 'automatically have LINK transferred to it', because
to transfer LINK from one account to another, the owner of the LINK must be
the one that signs the transaction, however, there are a few other ways to
achieve the end result you're looking for.

1 - Rather than a straight transfer, you can do a swap on a DEX like Uniswap
programatically, ie <https://docs.uniswap.org/protocol/V2/guides/smart-
contract-integration/trading-from-a-smart-contract>

2 - If you know how much LINK will be required for the contract, you can
simply pre-fund it beforehand, or when it's created. Am guessing this isn't
the case for you though.

3 - Do it external to the blockchain. ie you can have a process running that
funds the contract with link every so often, checking if its empty or near
empty

4 - You can make use of meta-transactions so that the people playing the game
don't need any LINK. See [this example](https://github.com/pappas999/Link-Gas-
Station). Take note this still uses an external relayer like I mentioned in
the last point

5 - I've seen examples where others just pay an upfront cost to ensure the
coordinator contracts are well funded with LINK, and then they manually just
top them up as needed, using users deposited eth/funds as a kind of payment to
offset them having to send LINK to the contract.





:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the 'validateMultiWordResponseId' modifier in the mock operator contract?,The 'validateMultiWordResponseId' modifier is used to ensure that the first word of the response matches the requestId.,{'source': 'https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat'},"The purpose of the 'validateMultiWordResponseId' modifier in the mock operator contract is to ensure that the response ID for a multi-value API call matches the expected value. It compares the response ID from the fulfillOracleRequest2 function arguments with the response ID extracted from the calldata. If the response IDs match, the modifier passes. This is necessary because Solidity does not allow direct comparison of strings or different data types. The modifier is used to validate the response ID before fulfilling the request.

","
- https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat
- https://docs.chain.link/chainlink-nodes/v1/fulfilling-requests/","Question: (Asked on: 2022-12-16 18:52:48)
Testing Chainlink API calls using Hardhat
URL: https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat

Question Body:


I am having trouble testing Chainlink API calls locally. I have a contract
which calls my API consumer contract to make an API call. However, when I try
to do that, the MockOracle (mocked oracle for local testing, from chainlink)
contract reverts (VM exception) saying ""Must use whitelisted functions"". I am
making an API call for a bytes32 get request.

This is the function modifier (inside of LinkTokenReceiver) where the
MockOracle reverts (it gets called by the MockOracle when receiving LINK
tokens):

    
    
    /**
       * @dev Reverts if the given data does not begin with the `oracleRequest` function selector
       * @param _data The data payload of the request
       */
      modifier permittedFunctionsForLINK(bytes memory _data) {
        bytes4 funcSelector;
        assembly {
          // solhint-disable-next-line avoid-low-level-calls
          funcSelector := mload(add(_data, 32))
        }
        require(funcSelector == ORACLE_REQUEST_SELECTOR, ""Must use whitelisted functions"");
        _;
      }
    

The ApiConsumer is properly funded, and the LINK token is a local deployment
of the chainlink Token. So, what am I doing wrong? Or what is the best way to
test Chainlink API calls (bytes32 get request) locally using hardhat?



Answers:
(Answered on: 2023-03-04 12:21:04)


If you are testing locally the chainlink node will not be able to detect any
requests.  
You have a few options:

  1. Deploy your APIConsumer contract to a testnet and make use of an already deployed operator contract. A list can be found on chainlinks website [https://docs.chain.link/any-api/testnet-oracles/]. Then select a jobId for a node job that can provide the API data you need e.g. bytes32, Int, multi words etc. The jobId can be specified in your APIConsumer contract.
  2. Deploy your own operator contract, setup your own node (chainlink has an option for setting up temporary development nodes), and then create a custom job for your API. You will then need to put you node address as an authorised sender in your operator contract to permit data to be returned from your node.
  3. For local testing you will need to write a function in your test script that sends a mock response to your mock operator contract. Make sure you setAuthorisedSenders for the account you use to send the fulfillOracleRequest transaction, to test properly I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:

    
    
      modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata _data) {
        require(_data.length >= 32, ""Response must be > 32 bytes""); 
        bytes memory firstDataWord = new bytes(32);
        for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript snippet for test script 
    //If local network - Set Authorised senders on Mock Oracle to account[1]
        const [owner, mockNode] = await ethers.getSigners();
        const mockNodeAccount = mockNode.address
        await mockOracle.setAuthorizedSenders([mockNodeAccount])
        
        
        const transaction: ContractTransaction = await apiConsumer.requestWithWords(ANY_ARGS_FOR_API)
        const transactionReceipt: ContractReceipt = await transaction.wait(1)
        const requestId = transactionReceipt.events[0].topics[1]
    
        const apiFilter = apiConsumer.filters.ChainlinkRequested()
        const apiEvents = await apiConsumer.queryFilter(apiFilter)
        console.log(apiEvents)
    
        const filter = mockOracle.filters.OracleRequest()
        const events = await mockOracle.queryFilter(filter)
        const {specId, requester, requestIdEvent, payment, callbackAddr, callbackFunctionId, cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
    
        const encodeRequestId = web3.eth.abi.encodeParameters(
            ['bytes32'],
            [requestId])
            
        await mockOracle.connect(mockNode).fulfillOracleRequest2(requestIdfirst, payment, callbackAddr, callbackFunctionId, cancelExpiration, encodeMwr)

To improve on this you could then look to add an API http GET call into your
test script for getting the rest of the callback data for fulfillOracleRequest
or fulfillOracleRequest2 function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I am guessing you are currently using the `oracle.sol` and
`ChainlinkClient.sol` in version v0.6. In version v0.6, AFAIK, ChainlinkClient
doesn't not help users to add function selector `oracleRequest` in the users'
Chainlink request, which means you will get the error if you doesn't manually
add the function selector in your request. In v0.7, ChainlinkClient helps you
add the selector in the request. Just check the function
`sendChainlinkRequestTo` in [ChainlinkClient
v0.6](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/ChainlinkClient.sol)
and [ChainlinkClient
v0.7](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/ChainlinkClient.sol)
by yourself.

Solutions:

  1. Use the v0.7 ChainlinkClient and [operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)(smart contract oracle.sol is renamed as operator.sol in v0.7) for your test. The document can be found [here](https://docs.chain.link/any-api/get-request/examples/single-word-response).
  2. There is a repo called [hardhat-starter-kit](https://github.com/smartcontractkit/hardhat-starter-kit) in Chainlink official github, there are sample codes you can try. Or you can directly use starterkit to test AnyApi and any other services.





:::NEXT DOC:::

# Fulfilling Requests

  * Overview
  * Requirements
  * Address Types
  * Setup your Operator contract
  * Deploy your own Operator contract
  * Whitelist your node address in the Operator contract
  * Add a job to the node
  * Create a request to your node
  * Withdrawing LINK

Run a Chainlink node

This guide assumes you have a running Chainlink node. To learn how to run a
node, see the [Running a Chainlink Node locally](/chainlink-nodes/v1/running-a-chainlink-node) guide.

You can use your Chainlink nodes to fulfill requests. This guide shows you how
to deploy your own operator contract and add jobs to your node so that it can
provide data to smart contracts.

Chainlink nodes can fulfill requests from open or unauthenticated APIs without
the need for [External Adapters](/chainlink-nodes/external-adapters/external-adapters) as long as you've added the jobs to the node. For these requests,
requesters supply the URL to the open API that they want each node to
retrieve. The Chainlink node will use [tasks](/chainlink-nodes/oracle-jobs/tasks) to fulfill the request.

Some APIs require authentication by providing request headers for the
operator's API key, which the Chainlink node supports. If you would like to
provide access to an API that requires authentication, you must create a job
that is specific for that API either using an [external adapter](/chainlink-nodes/external-adapters/external-adapters) or by using the parameters of the
[HTTP task](/chainlink-nodes/oracle-jobs/all-tasks/#http-task).

## Requirements

Before you begin this guide, complete the following tasks to make sure you
have all of the tools that you need:

  * [Set up MetaMask](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) and [obtain testnet LINK](/resources/acquire-link).

  * [Run a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node).

  * Fund the Ethereum address that your Chainlink node uses. You can find the address in the node Operator GUI under the **Key Management** configuration. The address of the node is the `Regular` type. You can obtain test ETH from several [faucets](/resources/link-token-contracts). For this tutorial to work, you will have to fund the node's Ethereum address with Sepolia ETH. Here is an example:

## Address Types

Your node works with several different types of addresses. Each address type
has a specific function:

  * **Node address:** This is the address for your Chainlink node wallet. The node requires native blockchain tokens at all times to respond to requests. For this example, the node uses Sepolia ETH. When you start a Chainlink node, it automatically generates this address. You can find this address on the Node Operator GUI under **Key Management > EVM Chain Accounts**.
  * **Oracle contract address:** This is the address for contracts like `Operator.sol` or `Oracle.sol` that are deployed to a blockchain. Do not fund these addresses with native blockchain tokens such as ETH. When you make API call requests, the funds pass through this contract to interact with your Chainlink node. This will be the address that smart contract developers point to when they choose a node for an API call.
  * **Admin wallet address:** This is the address that owns your `Operator.sol` or `Oracle.sol` contract addresses. If you're on OCR, this is the wallet address that receives LINK tokens.

## Setup your Operator contract

### Deploy your own Operator contract

  1. Go to Remix and open the [`Operator.sol` smart contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkNodes/Operator.sol).

  2. On the **Compile** tab, click the **Compile** button for `Operator.sol`. Remix automatically selects the compiler version and language from the `pragma` line unless you select a specific version manually.

  3. On the **Deploy and Run** tab, configure the following settings:

    * Select ""Injected Provider"" as your **Environment**. The Javascript VM environment cannot access your oracle node. Make sure your Metamask is connected to Sepolia testnet.

    * Select the ""Operator"" contract from the **Contract** menu.

    * Copy the [LINK token contract address](/resources/link-token-contracts) for the network you are using and paste it into the `LINK` field next to the **Deploy** button. For Sepolia, you can use this address:
        
                0x779877A7B0D9E8603169DdbD7836e478b4624789

    * Copy the _Admin wallet address_ into the `OWNER` field.

  4. Click **transact**. MetaMask prompts you to confirm the transaction.

MetaMask doesn't pop up?

If MetaMask does not prompt you and instead displays the error below, disable
""Privacy Mode"" in MetaMask. You can do this by clicking on your unique account
icon at the top-right, then go to the Settings. Privacy Mode will be a switch
near the bottom.

  

Error: **Send transaction failed: Invalid address. If you use an injected
provider, please check it is properly unlocked.**

  5. If the transaction is successful, a new address displays in the **Deployed Contracts** section.

  6. Keep note of the Operator contract address. You need it later for your consuming contract.

### Whitelist your node address in the Operator contract

  1. In the Chainlink node GUI, find and copy the address of your chainlink node. see Requirements.

  2. In Remix, call the `setAuthorizedSenders` function with the address of your node. Note the function expects an array.

  3. Click the `transact` function to run it. Approve the transaction in MetaMask and wait for it to confirm on the blockchain.

  4. Call `isAuthorizedSender` function with the address of your node to verify that your chainlink node address can call the operator contract. The function must return `true`.

## Add a job to the node

You will create a job that calls an OpenAPI , parses the response and then
return a `uint256`.

  1. In the Chainlink Operator UI on the **Jobs** tab, click **New Job**.

  2. Paste the job specification from above into the text field.
    
        # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    name = ""Get > Uint256 - (TOML)""
    schemaVersion = 1
    type = ""directrequest""
    # Optional External Job ID: Automatically generated if unspecified
    # externalJobID = ""b1d42cd5-4a3a-4200-b1f7-25a68e48aad8""
    contractAddress = ""YOUR_OPERATOR_CONTRACT_ADDRESS""
    maxTaskDuration = ""0s""
    minIncomingConfirmations = 0
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=""cborparse"" data=""$(decode_log.data)""]
        fetch        [type=""http"" method=GET url=""$(decode_cbor.get)"" allowUnrestrictedNetworkAccess=""true""]
        parse        [type=""jsonparse"" path=""$(decode_cbor.path)"" data=""$(fetch)""]
    
        multiply     [type=""multiply"" input=""$(parse)"" times=""$(decode_cbor.times)""]
    
        encode_data  [type=""ethabiencode"" abi=""(bytes32 requestId, uint256 value)"" data=""{ \\""requestId\\"": $(decode_log.requestId), \\""value\\"": $(multiply) }""]
        encode_tx    [type=""ethabiencode""
                      abi=""fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes calldata data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"":   $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                      ]
        submit_tx    [type=""ethtx"" to=""YOUR_OPERATOR_CONTRACT_ADDRESS"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> multiply -> encode_data -> encode_tx -> submit_tx
    """"""
    

  3. Replace `YOUR_OPERATOR_CONTRACT_ADDRESS` with the address of your deployed operator contract address from the previous steps.

  4. Click **Create Job**. If the node creates the job successfully, a notice with the job number appears.

  5. Click the job number to view the job details. You can also find the job listed on the **Jobs** tab in the Node Operators UI. Save the `externalJobID` value because you will need it later to tell your consumer contract what job ID to request from your node.

## Create a request to your node

After you add jobs to your node, you can use the node to fulfill requests.
This section shows what a requester does when they send requests to your node.
It is also a way to test and make sure that your node is functioning
correctly.

  1. Open [ATestnetConsumer.sol in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol).

  2. Note that `setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789)` is configured for _Sepolia_.

  3. On the **Compiler** tab, click the **Compile** button for `ATestnetConsumer.sol`.

  4. On the **Deploy and Run** tab, configure the following settings:

    * Select _Injected Provider_ as your environment. Make sure your metamask is connected to Sepolia.
    * Select _ATestnetConsumer_ from the **Contract** menu.
  5. Click **Deploy**. MetaMask prompts you to confirm the transaction.

  6. Fund the contract by sending LINK to the contract's address. See the [Fund your contract](/resources/fund-your-contract) page for instructions. The address for the `ATestnetConsumer` contract is on the list of your deployed contracts in Remix. You can fund your contract with 1 LINK.

  7. After you fund the contract, create a request. Input your operator contract address and the job ID for the `Get > Uint256` job into the `requestEthereumPrice` request method **without dashes**. The job ID is the `externalJobID` parameter, which you can find on your job's definition page in the Node Operators UI.

  8. Click the **transact** button for the `requestEthereumPrice` function and approve the transaction in Metamask. The `requestEthereumPrice` function asks the node to retrieve `uint256` data specifically from [https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD](https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD).

  9. After the transaction processes, you can see the details for the complete the job run the **Runs** page in the Node Operators UI.

  10. In Remix, click the `currentPrice` variable to see the current price updated on your consumer contract.

## Withdrawing LINK

You can withdraw LINK from the operator contract. In Remix under the list of
deployed contracts, click on your Operator contract and find the `withdraw`
function in the function list. Note that only the admin (see Admin wallet
address) can withdraw LINK.



Paste the address you want to withdraw to, and specify the amount of LINK that
you want to withdraw. Then, click `withdraw`. Confirm the transaction in
MetaMask when the popup appears.

## What's next

  * [› Performing System Maintenance](/chainlink-nodes/resources/performing-system-maintenance)
  * [› v2 Jobs](/chainlink-nodes/oracle-jobs/jobs)
  * [› Security and Operation Best Practices](/chainlink-nodes/resources/best-security-practices)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/fulfilling-requests.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the benefit of smart contracts over traditional agreements?,"Smart contracts are transparent and open to the public by default, reducing counterparty risk since neither party has control over the execution of an agreement, and can create more efficient, automated processes that save business cost.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-4/course.md'},"The benefit of smart contracts over traditional agreements is that smart contracts are self-executing contracts with the terms of the agreement directly written into computer code. This eliminates the need for intermediaries and ensures that the terms of the agreement are automatically enforced without the need for costly legal proceedings. Smart contracts also provide transparency, security, and efficiency in the execution of agreements. 
","https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-3/course.md, https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-4/description.md","#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

Smart contracts result from the evolution of digital agreements. A Smart contract is a self-executing contract with the terms of the agreement being directly written into computer code.
"
What is the LINK token address for BNB Chain?,0x404460C6A5EdE2D891e8297795264fDe62ADBB75,{'source': 'https://docs.chain.link/vrf/v2/subscription/supported-networks/'},"The LINK token address for BNB Chain is 0x404460C6A5EdE2D891e8297795264fDe62ADBB75.
",https://docs.chain.link/vrf/v1/supported-networks/,"# Chainlink VRF Supported Networks [v1]

  * Overview
  * Polygon (Matic) Mainnet
  * Polygon (Matic) Mumbai Testnet
  * BNB Chain Mainnet
  * BNB Chain Testnet
  * Ethereum Mainnet
  * Goerli

Chainlink VRF allows you to integrate provably-fair and verifiably random data
in your smart contract.

For implementation details, read [Introduction to Chainlink
VRF](/vrf/v1/introduction).

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

## Polygon (Matic) Mainnet

Important

The LINK provided by the [Polygon (Matic)
Bridge](https://wallet.polygon.technology/bridge) is not ERC-677 compatible,
so cannot be used with Chainlink oracles. However, it can be [**converted to
the official LINK token on Polygon (Matic) using Chainlink's PegSwap
service**](https://pegswap.chain.link/)

| Item            | Value                                                              |
|:----------------|:-------------------------------------------------------------------|
| LINK Token      | 0xb0897686c545045aFc77CF20eC7A532E3120E0F1                         |
| VRF Coordinator | 0x3d2341ADb2D31f1c5530cDC622016af293177AE0                         |
| Key Hash        | 0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da |
| Fee             | 0.0001 LINK                                                        |
VRF Response Times on Polygon

VRF responses are generated after 10 block confirmations on Polygon by
default.

## Polygon (Matic) Mumbai Testnet

Mumbai Faucet

Testnet LINK and MATIC are available from [the official Matic
faucet](https://faucet.polygon.technology/) and
<https://faucets.chain.link/mumbai>.

| Item            | Value                                                              |
|:----------------|:-------------------------------------------------------------------|
| LINK Token      | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB                         |
| VRF Coordinator | 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255                         |
| Key Hash        | 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4 |
| Fee             | 0.0001 LINK                                                        |
## BNB Chain Mainnet

Important

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
cannot be used with Chainlink oracles. However, it can be [**converted to the
official LINK token on BNB Chain using Chainlink's PegSwap
service**](https://pegswap.chain.link/).

| Item            | Value                                                                                |
|:----------------|:-------------------------------------------------------------------------------------|
| LINK Token      | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75                                           |
| VRF Coordinator | 0x747973a5A2a4Ae1D3a8fDF5479f1514F65Db9C31                                           |
| Key Hash        | 0xc251acd21ec4fb7f31bb8868288bfdbaeb4fbfec2df3735ddbd4f7dc8d60103c                   |
| Fee             | 0.2 LINK - initial fees on BNB Chain are meant to cover the highest gas cost prices. |
## BNB Chain Testnet

BNB Chain Faucet

Testnet LINK is available from <https://faucets.chain.link/chapel>

| Item            | Value                                                              |
|:----------------|:-------------------------------------------------------------------|
| LINK            | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06                         |
| VRF Coordinator | 0xa555fC018435bef5A13C6c6870a9d4C11DEC329C                         |
| Key Hash        | 0xcaf3c3727e033261d383b315559476f48034c13b18f8cafed4d871abe5049186 |
| Fee             | 0.1 LINK                                                           |
## Ethereum Mainnet

| Item            | Value                                                                             |
|:----------------|:----------------------------------------------------------------------------------|
| LINK Token      | 0x514910771AF9Ca656af840dff83E8264EcF986CA                                        |
| VRF Coordinator | 0xf0d54349aDdcf704F77AE15b96510dEA15cb7952                                        |
| Key Hash        | 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445                |
| Fee             | 2 LINK - initial fees on Ethereum are meant to cover the highest gas cost prices. |
## Goerli

Goerli Faucets

Testnet LINK is available from <https://faucets.chain.link/goerli>

Testnet ETH is available from <https://goerlifaucet.com/> or faucets listed at
<https://faucetlink.to/goerli>

| Item            | Value                                                              |
|:----------------|:-------------------------------------------------------------------|
| LINK            | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB                         |
| VRF Coordinator | 0x2bce784e69d2Ff36c71edcB9F88358dB0DfB55b4                         |
| Key Hash        | 0x0476f9a745b61ea5c0ab224d3a6e4c99f0b02fce4da01143a4f70aa80ae76e8a |
| Fee             | 0.1 LINK                                                           |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/supported-networks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Acquire testnet LINK

  * Overview
  * Configure MetaMask to use LINK tokens
  * Get testnet LINK from a faucet

The Getting Started guides show you how to send ETH on the Sepolia testnet,
but some contracts might require you to use LINK token instead. This page
shows you how to obtain testnet LINK and send it to your MetaMask wallet.

## Configure MetaMask to use LINK tokens

To see your LINK token balance in MetaMask, you must manually add the token.

  1. Open up MetaMask.

  2. At the bottom of the MetaMask windows, click **Import tokens**.

  3. Find the LINK token contract address for the network that you want to use. On Sepolia, the LINK token address is: `0x779877A7B0D9E8603169DdbD7836e478b4624789`. See the [LINK Token Contracts](/resources/link-token-contracts) page to find the addresses for different testnets.

  4. Paste the token contract address into MetaMask in the Token Address input. The token symbol and decimals of precision will auto-populate.

  5. Click **Next**. A new window will appear, showing the LINK token details.

  6. Click **Import Tokens** to confirm adding the new token.

MetaMask should now display the new LINK token balance.

## Get testnet LINK from a faucet

  1. Go to <https://faucets.chain.link/>.
  2. In Metamask, select the network where you want to receive testnet LINK.
  3. Click **Connect wallet** so the faucet app can detect the network and wallet address.
  4. If you want to receive testnet funds at a different address, paste it in the **Wallet address** section. This field defaults to your connected wallet address.
  5. In the **Request type** section, select the testnet funds that you want to receive.
  6. Complete the Captcha and click **Send request**. The funds are transferred from the faucet to the wallet address that you specified.

After the transaction is confirmed on-chain, the faucet app shows ""Request
complete"" and the transaction hash of your request.



## What's next

  * [› Deploy your first contract](/getting-started/deploy-your-first-contract)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/acquire-link.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the code shown?,The code is a jobspec for a Chainlink node that fetches data from a YouTube channel and fulfills an oracle request with the data.,{'source': 'https://stackoverflow.com/questions/70017509/reverted-transaction-on-chainlink-node-while-fulfilling-request'},"The purpose of the code shown is to debug a task that fails in a Chainlink node. The code provides instructions on how to view error messages and logs to identify the issue. Additionally, the code explains the purpose of the ""path"" variable in the ATestnetConsumer.sol example, which is used to specify the path for the chainlink node to retrieve data from a JSON response.
","
- https://stackoverflow.com/questions/73733171/task-fails-with-no-way-to-debug
- https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example","Question: (Asked on: 2022-09-15 14:41:55)
Task fails with no way to debug
URL: https://stackoverflow.com/questions/73733171/task-fails-with-no-way-to-debug

Question Body:


I have a node running two jobs - they communicate with an external adaptor and
then send the value on-chain.

One job works fine, which already tells me that the node can write on-chain.

The other job, receives the request, talks with the external adaptor (I have
verified this on the external adaptor server) and then doesn't submit anything
on-chain.

There is no way to debug this through the Operator UI. This is what it shows:

[](https://i.stack.imgur.com/z2s2t.png)

What should I do? I am running the Chainlink develop version because the most
up-to-date stable version as a critical bug.



Answers:
(Answered on: 2022-09-18 05:12:28)


In the Chainlink node version 1.8.0, there are ""Error"" and ""Runs"" tabs in your
node UI in the browser, and these 2 tabs allow you to view what's wrong with
your job run. You can find the latest chainlink docker image
[here](https://hub.docker.com/r/smartcontract/chainlink/tags).

[](https://i.stack.imgur.com/W6AxZ.png)

The error messages under the ""error"" tab are shown below, and the info can
reflect the error your job encountered in the run.

[](https://i.stack.imgur.com/IUEU0.jpg)

If there are no ""error"" and ""run"" tabs in the browser or there is nothing
shown in the UI, you can also find error info in the log file housed by the
server running the Chainlink node. The default path of the Chainlink node log
file is `/chainlink/chainlink_debug.log`, so you can log into the server that
running the node and check the log for debugging.

Hope it helps.





:::NEXT DOC:::

Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    



"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-8/hints.md'},"The topic of Chapter 1 is not provided in the given information.
SOURCES:",,"#####Chapter 1:

Video


:::NEXT DOC:::

#####Chapter 1:

Video
"
What are NFT Floor Price Feeds and what are they used for?,"NFT Floor Price Feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink’s oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. They can be used for use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.",{'source': 'https://docs.chain.link/data-feeds/nft-floor-price/'},"NFT Floor Price Feeds provide a conservative and risk averse floor price estimate for an NFT collection. They are used for various use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more. NFT Floor Price Feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink's oracle infrastructure to eliminate extreme price outliers and resist market manipulation. To use NFT Floor Price Feeds, you can read the answers from these feeds the same way you read other Data Feeds. You need to specify the NFT Floor Price Feed Address that you want to read. Solidity smart contracts should reference the AggregatorV3Interface, which defines the external functions implemented by Data Feeds. The president did not mention Michael Jackson. 
","
- https://docs.chain.link/data-feeds/nft-floor-price/
- https://docs.chain.link/data-feeds/nft-floor-price/addresses/","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = nftFloorPriceFeed.latestRoundData();
            return nftFloorPrice;
        }
    }
    

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for NFT Floor Price Feeds](/data-feeds/nft-floor-price/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
| ⚫VeeFriends Floor Price                 | ETH           | 2%          |       86400 |    18 | 0x35bf6767577091E7f04707c0290b3f889e968307 |
| ⚫World of Women Floor Price             | ETH           | 2%          |       86400 |    18 | 0xDdf0B85C600DAF9e308AFed9F597ACA212354764 |
## Goerli Testnet

| NFT Floor Pricing Feed     | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:---------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| Azuki Floor Price          | ETH           | 2%          |        3600 |    18 | 0x9F6d70CDf08d893f0063742b51d3E9D1e18b7f74 |
| BAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xB677bfBc9B09a3469695f40477d05bc9BcB15F50 |
| CloneX Floor Price         | ETH           | 2%          |        3600 |    18 | 0xE42f272EdF974e9c70a6d38dCb47CAB2A28CED3F |
| CoolCats Floor Price       | ETH           | 2%          |        3600 |    18 | 0x13F38938A18ff26394c5ac8df94E349A97AaAb4e |
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price      | ETH           | 2%          |        3600 |    18 | 0x870bc8BfEe8A7Bbd63Dc1ef09F2fF37DeBCfEF35 |
| Doodles Floor Price        | ETH           | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the ternary operator in Solidity and how is it used?,"The ternary operator is represented by the symbol '?'. It is used to assign a value to a variable based on a condition. For example, in the given code, if x is smaller than 5 then return 0 otherwise return 1.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-4/course.md'},"The Operator implementation is only available in version 0.7 of Chainlink. In version 0.8, the OperatorInterface is used instead. To migrate to version 0.8, you can deploy the Operator contract using version 0.7 and interact with it using the OperatorInterface in version 0.8. It is recommended to use Hardhat instead of Truffle for this migration, as Hardhat supports multiple solc versions in a project.
","
- https://stackoverflow.com/questions/71105822/chainlink-how-to-deploy-an-operator-with-v0-8
- https://stackoverflow.com/questions/72045203/what-is-the-oracle-sol-equivalent-of-v0-6-in-v0-8","Question: (Asked on: 2022-02-13 23:38:07)
chainlink: how to deploy an Operator with v0.8?
URL: https://stackoverflow.com/questions/71105822/chainlink-how-to-deploy-an-operator-with-v0-8

Question Body:


I started with v0.6 and connected my node to an operator (called Oracle at the
time)

    
    
    pragma solidity ^0.6.0;
    import ""@chainlink/contracts/src/v0.6/Oracle.sol"";
    contract MyOperator is Oracle {
        constructor(address _link) Oracle(_link) public {}
    }
    

My client contract using those libs

    
    
    pragma solidity ^0.6.6;
    import ""@chainlink/contracts/src/v0.6/ChainlinkClient.sol"";
    import ""@openzeppelin/contracts/access/Ownable.sol"";
    

I had to connect them using setFulfiullmentPermissions at the time:

    
    
        await operator.setFulfillmentPermission(nodeAddress, true, {
          from: owner,
        });
    

======= I then moved to v0.7 with my Operator being

    
    
    pragma solidity ^0.7.0;
    import ""@chainlink/contracts/src/v0.7/dev/Operator.sol"";
    contract MyOperator is Operator {
        constructor(address _link, address owner) Operator(_link, owner) public {}
    }
    

My client contract using those libs

    
    
    pragma solidity ^0.7.0;
    import ""@chainlink/contracts/src/v0.7/ChainlinkClient.sol"";
    import ""@openzeppelin/contracts/access/Ownable.sol"";
    

this time the authorization code looked like this

    
    
        let tx = await operator.setAuthorizedSenders([nodeAddress], { from: owner });
    

===== Now trying to migrate to chainlink v0.8

I see an OperatorInterface but not a real contract here in develop:
<https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/OperatorInterface.sol>

Why isn't the Operator implementation part of the v0.8 ?

If I am including a contract Operator v0.7 in my project, truffle is all
confused with versions mismatch.

I couldn't find a resource online about someone deploying a node with v0.8.

How should I go about migrating to v0.8, what should I deploy as an Operator
for my node, please?



Answers:
(Answered on: 2022-02-16 18:56:27)


The Operator is only implemented in ^0.7. version currently.

You can use Hardhat instead of Truffle, which supports multiple solc versions
in a project, and then deploy the Operator using ^0.7 and deploy clients which
interact with it in v0.8.





:::NEXT DOC:::

Question: (Asked on: 2022-04-28 14:09:31)
What is the Oracle.sol equivalent of V0.6 in V0.8?
URL: https://stackoverflow.com/questions/72045203/what-is-the-oracle-sol-equivalent-of-v0-6-in-v0-8

Question Body:


Chainlink V0.8 no longer includes the `Oracle.sol` class that I used in V0.6
to register the chainlink node. It seems `Operator.sol` replaced that in V0.7
(which I never used). However, the only implementation of
`ChainlinkRequestInterface` in V0.8 seems to be `OperatorInterface.sol`.

How to deploy the node operator contract using V0.8 properly?



Answers:
(Answered on: 2022-05-02 14:31:20)


You'd use `Operator.sol` in `v0.7` and `v0.8`. You can use the interface to
interact with a `v0.7` edition of `Operator.sol` in `v0.8`



"
What is the purpose of the 'callbackGasLimit' parameter in the 'requestRandomWords()' function?,The 'callbackGasLimit' parameter specifies the limit for how much gas to use for the callback request to the contract's 'fulfillRandomWords()' function.,{'source': 'https://docs.chain.link/vrf/v2/subscription/examples/get-a-random-number/'},"The 'callbackGasLimit' parameter in the 'requestRandomWords()' function is used to specify the maximum amount of gas that can be used for the callback function. 
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-10/course.md,"#####Chapter 10: Building a Basic Contract

## Requesting Randomness

Now that our contract is configured and the constructor is defined, lets set up the function that will send a request for random numbers. To send a request you need to call the “coordinator variable we set up earlier and call the requestRandomWords function from it:

<Highlight class=""language-javascript"">
s_requestId = COORDINATOR.requestRandomWords(
    keyHash,
    s_subscriptionId,
    requestConfirmations,
    callbackGasLimit,
    numWords
  );
</Highlight>


:::NEXT DOC:::

Question: (Asked on: 2023-01-20 18:44:13)
Which is the address that runs requestRandomWords if I&#39;m using Chainlink automation?
URL: https://stackoverflow.com/questions/75188193/which-is-the-address-that-runs-requestrandomwords-if-im-using-chainlink-automat

Question Body:


Helloo aall!! I'm having some troubles when using time-based automation with
request random numbers. What I'm trying to do is to request random numbers
every 10 mins. I'm using the subscription mode in my VRFConsumerBaseV2
contract and I think the problem is that I don't know what is
ConfirmedOwner... which is the address I should set there if
requestRandomWords is being run by an automation oracle? The registry address,
the upkeep address, ...? This is the constructor of my VRFConsumerBaseV2
contract:

    
    
    constructor(address _consumer, uint64 _subscriptionId, address _oracle)
            VRFConsumerBaseV2(_consumer)
            ConfirmedOwner(_oracle)
        {
            COORDINATOR = VRFCoordinatorV2Interface(
                _consumer
            );
            s_subscriptionId = _subscriptionId;
        }
    

And well this is the requestRandomWords, with the onlyOwner that is set with
the ConfirmedOwner in the constructor, no?:

    
    
    function requestRandomWords(uint32 _numWords) public onlyOwner returns (uint256) {
            // Will revert if subscription is not set and funded.
            requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                _numWords
            );
            emit RequestSent(requestId, _numWords);
            return requestId;
        }
    

Thank yooouuu so muuch!!!



Answers:
(Answered on: 2023-01-23 14:48:25)


A few of the FAQ from the [Chainlink Docs](https://docs.chain.link/chainlink-
automation/faqs/) should help clear this up.

## Which contract will call my `performUpkeep` function on-chain?

The [Automation Registry](https://docs.chain.link/chainlink-
automation/supported-networks/) will call the `performUpkeep` function on-
chain.

## Will the address of the Automation Registry always stay the same?

No. As we add new functionality we have to upgrade our contract and deploy a
new Automation Registry. We will work with all our users to ensure Upkeeps are
migrated without causing business interruptions.

## Can I require that `performUpkeep` is only callable by the Automation
Registry?

Our preferred and recommended route before locking access to `performUpkeep`
is [revalidation](https://docs.chain.link/chainlink-automation/compatible-
contracts/#revalidate-performupkeep). We understand you might want to add a
require statement, but then recommend that you make the Automation Registry
address configurable otherwise you will need to deploy a new contract when the
Registry address changes. If you add a `require` statement to `performUpkeep`
you will have to update the Registry Address in your contract when the
Registry Address changes. We also recommend that the owner can always call
`performUpkeep`.


---
(Answered on: 2023-01-20 19:15:00)


It's the upkeep address that you can see in the console of Chainlink oracles.



"
What is the purpose of this chapter?,The purpose of this chapter is to teach the reader how to get a verifiably secure random number for use in a smart contract.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-13/course.md'},"The purpose of this chapter is to cover the content of the course.
","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-1/video.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-7/hints.md","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What error message did the user receive when calling the getVersion function in the FundMe smart contract?,The user received the error message 'call to FundMe.getVersion errored: execution reverted'.,{'source': 'https://stackoverflow.com/questions/69182406/solidiy-fundme-smart-contract-remix-chainlink-call-to-fundme-getversion-err'},"The user received the error message ""call to FundMe.getVersion errored: execution reverted"" when calling the getVersion function in the FundMe smart contract.
","
- https://stackoverflow.com/questions/69182406/solidiy-fundme-smart-contract-remix-chainlink-call-to-fundme-getversion-err","Question: (Asked on: 2021-09-14 17:49:25)
Solidiy FundMe Smart Contract - Remix - Chainlink `call to FundMe.getVersion errored: execution reverted`
URL: https://stackoverflow.com/questions/69182406/solidiy-fundme-smart-contract-remix-chainlink-call-to-fundme-getversion-err

Question Body:


I am learning to use Chain Link to get price conversions and also to implement
other functions provided by Chainlink. I have 2.9992 ETH on Rinkeby Test Net
and I am successfully able to compile and deploy the code using Remix IDE
using Injected Web3 Environment.

Whenever I call the function **getVersion** or any other function defined in
ChainLink. I get an error like this

> `""call to FundMe.getVersion errored: execution reverted""`
    
    
        pragma solidity >=0.6.6 <0.9.0;
        
        import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
        
        contract FundMe {
            
            mapping(address => uint256) public addressToAmountFunded;
            function fund() public payable {
                addressToAmountFunded[msg.sender] += msg.value;
            }
            
            function getVersion() public view returns(uint256) {
                AggregatorV3Interface priceFeed = AggregatorV3Interface(0x01BE23585060835E02B77ef475b0Cc51aA1e0709);
                return priceFeed.version();
            }
        }
    



Answers:
(Answered on: 2021-09-14 18:04:06)


So I found an answer to my question. I was using the wrong Ethereum Data Feed
Address. I updated address to **0x8A753747A1Fa494EC906cE90E9f37563A8AF630e**
which is for ETH/USD on Rinkeby Test Net and it compiles and deploys perfectly
with no errors





:::NEXT DOC:::

# Deploy Your First Smart Contract

  * Overview
  * Install and fund your MetaMask wallet
  * Write, compile, and deploy your first smart contract
  * Run functions in your contract

You can write your first smart contract and run it in your browser without any
knowledge about Ethereum or blockchains. This guide shows you how easy it is
to develop smart contracts using the [Solidity
language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io)
and the [Remix Development Environment](https://remix.ethereum.org/). You can
use all of these tools in your browser for free with no signup required.

Already know Solidity and have MetaMask configured?

If you are already familiar with how to deploy Smart Contracts and use
MetaMask, you can skip to the [Consuming Data Feeds](/getting-started/consuming-data-feeds) guide to learn how to connect your smart
contracts to Chainlink data feeds.

In general, you create and deploy your smart contracts operate using the
following process:

  1. **Write:** Write a contract to define how the contract functions, what data it can store, what other contracts it interacts with, and what external APIs it might call.

  2. **Compile:** Pass your smart contract code through a compiler to translate the contract into byte code that the blockchain can understand. For example, [Solidity](https://soliditylang.org) code must be compiled before it can run in the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/).

  3. **Deploy:** Send the compiled smart contract to the blockchain. From that point forward, the contract cannot be altered. However, you can still interact with the contract in several ways.

  4. **Run functions:** When you run the functions that you defined for the contract, the network processes those functions and modifies the state of your contract. For some functions, the network charges a small fee to complete the work. Your contract can also have functions that transfer funds to other contracts or wallets.

This guide walks you through each step, but you must install and fund your
MetaMask wallet first.

## Install and fund your MetaMask wallet

Deploying smart contracts on-chain requires a wallet and ETH. The ETH pays for
the work required by the Ethereum network to add the contract to the
blockchain and store the variables. The wallet holds the ETH that you need to
pay for the transaction. Install MetaMask, configure it to use the [Sepolia
testnet](https://sepolia.dev/), and fund your wallet with free testnet ETH.

  1. [Install and configure the MetaMask extension](https://metamask.io/download) in your browser.

  2. After you install the extension, open your browser extension list and click MetaMask to open MetaMask.

  3. Follow the instructions in MetaMask to create a new MetaMask wallet. The new wallet includes a 12-word mnemonic phrase. This phrase is the key to your wallet. Copy that phrase down in a very secure location that only you can access. You can use this phrase to retrieve your wallet later or add it to another browser.

  4. Set MetaMask to use the Sepolia test network.

  5. Choose a Sepolia ETH [faucet](https://faucetlink.to/sepolia) and follow the steps to send testnet ETH to your MetaMask wallet address. You can copy your wallet address by clicking your account name in MetaMask. After the faucet completes the transaction, you should have testnet ETH in your MetaMask wallet on the Sepolia testnet.

Now that you configured your wallet and funded it with testnet ETH, you can
write, compile, and deploy your contract.

## Write, compile, and deploy your first smart contract

Your first contract is a simple `HelloWorld.sol` example. This example shows
you how to set and retrieve variables in a smart contract on-chain.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol) in the Remix IDE. Remix opens and shows the contents of the smart contract. You can modify the code in this editor when you write your own contract.

[ Open in Remix
](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol)
[What is Remix?](/getting-started/conceptual-overview#what-is-remix)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. For this contract, use the default compiler settings. Click the **Compile HelloWorld.sol** button to compile the contract. This converts the contract from Solidity into bytecode that the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/) can understand. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract.

  4. After Remix compiles the contract, deploy it. On the left side of Remix, click the **Deploy and Run** tab to view the deployment settings.

  5. In the deployment settings, select the **Injected Provider** environment. This tells Remix that you want to deploy your contract to the blockchain that you configured in MetaMask. You could optionally use one of the Javascript VM options, but they run in a virtual environment with no connection to an actual blockchain or Chainlink oracles.

  6. Next to the **Deploy** button, enter a message that you want to send with the smart contract when you deploy it. This contract has a constructor that sets an initial message when you deploy the contract.

  7. Click the **Deploy** button to deploy the contract and its initial message to the blockchain network. MetaMask opens and asks you to confirm payment to deploy the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  8. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  9. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  10. Click the `message` variable. Remix retrieves and prints the initial message that you set.

The contract has an address just like your wallet address. If you save this
address, you can return to your deployed contract at any time to retrieve
variables or execute functions. To see details about your deployed contract,
copy the contract address from the list in Remix and search for it in the
[Etherscan Sepolia Testnet Explorer](https://sepolia.etherscan.io/).

## Run functions in your contract

Because you deployed the contract to an actual blockchain, several nodes on
the test network confirmed your payment for the smart contract. The contract,
its variables, and its functions remain in the blockchain permanently. To
change the `message` variable that is stored with your contract, run the
`updateMessage` function.

  1. In your deployed contract, enter a new message next to the `updateMessage` function.

  2. Click the `updateMessage` button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.

  3. In the new MetaMask prompt, click **Confirm** to approve the transaction.

  4. Click the `message` variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

Now you know how to deploy example contracts to a test network and run the
functions in those contracts. You can write your own contracts and test them
using this same process.

Next, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds)
guide to learn how to connect your smart contracts to Chainlink Data Feeds and
retrieve on-chain data that your smart contracts can act on.

## What's next

  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/deploy-your-first-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the error message that the user gets when trying to call the function AaveLendingPool.borrow()?,TypeError: Type int256 is not implicitly convertible to expected type uint256.,{'source': 'https://stackoverflow.com/questions/69783472/get-chainlink-eth-usd-price-feed-answer-as-uint256-instead-of-int-solidity'},"The error message that the user gets when trying to call the function AaveLendingPool.borrow() is ""TypeError: Type int256 is not implicitly convertible to expected type uint256.""
",https://stackoverflow.com/questions/69783472/get-chainlink-eth-usd-price-feed-answer-as-uint256-instead-of-int-solidity,"Question: (Asked on: 2021-10-31 02:06:28)
Get Chainlink ETH/USD Price Feed answer as uint256 instead of int solidity
URL: https://stackoverflow.com/questions/69783472/get-chainlink-eth-usd-price-feed-answer-as-uint256-instead-of-int-solidity

Question Body:


I want to use the latest ETH price in USD to calculate how much USDC I can
borrow from AAVE.

I followed all the tutorials:

    
    
    interface AggregatorV3Interface {
      function decimals() external view returns (uint8);
    
      function description() external view returns (string memory);
    
      function version() external view returns (uint256);
    
      // getRoundData and latestRoundData should both raise ""No data present""
      // if they do not have data to report, instead of returning unset values
      // which could be misinterpreted as actual reported values.
      function getRoundData(uint80 _roundId)
        external
        view
        returns (
          uint80 roundId,
          int256 answer,
          uint256 startedAt,
          uint256 updatedAt,
          uint80 answeredInRound
        );
    
      function latestRoundData()
        external
        view
        returns (
          uint80 roundId,
          int256 answer,
          uint256 startedAt,
          uint256 updatedAt,
          uint80 answeredInRound
        );
    
    }
    

Used the contract for ETH/USD price feed:

<https://etherscan.io/address/0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419>

    
    
    AggregatorV3Interface internal priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
    

Created the function to get the price:

    
    
     function getLatestPrice() public view returns (int) {
            (
                uint80 roundID, 
                int price,
                uint startedAt,
                uint timeStamp,
                uint80 answeredInRound
            ) = priceFeed.latestRoundData();
            return price;
        }
    

And the function I want to call is this one:

    
    
     AaveLendingPool.borrow(address(USDT),getLatestPrice(), 1, 0, address(this));
    

this is the error I get:

    
    
    TypeError: Type int256 is not implicitly convertible to expected type uint256.
    

I need to convert the int to unit



Answers:
(Answered on: 2021-11-01 02:09:56)


You can typecast the `int` to `uint` using this syntax: `uint256(input)`

Example:

    
    
    pragma solidity ^0.8;
    
    contract MyContract {
        function foo() external {
            borrow(uint256(getLatestPrice()));
        }
        
        function getLatestPrice() internal returns (int256) {
            return 1;
        }
        
        function borrow(uint256 _number) internal {
        }
    }
    





:::NEXT DOC:::

# Deploy Your First Smart Contract

  * Overview
  * Install and fund your MetaMask wallet
  * Write, compile, and deploy your first smart contract
  * Run functions in your contract

You can write your first smart contract and run it in your browser without any
knowledge about Ethereum or blockchains. This guide shows you how easy it is
to develop smart contracts using the [Solidity
language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io)
and the [Remix Development Environment](https://remix.ethereum.org/). You can
use all of these tools in your browser for free with no signup required.

Already know Solidity and have MetaMask configured?

If you are already familiar with how to deploy Smart Contracts and use
MetaMask, you can skip to the [Consuming Data Feeds](/getting-started/consuming-data-feeds) guide to learn how to connect your smart
contracts to Chainlink data feeds.

In general, you create and deploy your smart contracts operate using the
following process:

  1. **Write:** Write a contract to define how the contract functions, what data it can store, what other contracts it interacts with, and what external APIs it might call.

  2. **Compile:** Pass your smart contract code through a compiler to translate the contract into byte code that the blockchain can understand. For example, [Solidity](https://soliditylang.org) code must be compiled before it can run in the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/).

  3. **Deploy:** Send the compiled smart contract to the blockchain. From that point forward, the contract cannot be altered. However, you can still interact with the contract in several ways.

  4. **Run functions:** When you run the functions that you defined for the contract, the network processes those functions and modifies the state of your contract. For some functions, the network charges a small fee to complete the work. Your contract can also have functions that transfer funds to other contracts or wallets.

This guide walks you through each step, but you must install and fund your
MetaMask wallet first.

## Install and fund your MetaMask wallet

Deploying smart contracts on-chain requires a wallet and ETH. The ETH pays for
the work required by the Ethereum network to add the contract to the
blockchain and store the variables. The wallet holds the ETH that you need to
pay for the transaction. Install MetaMask, configure it to use the [Sepolia
testnet](https://sepolia.dev/), and fund your wallet with free testnet ETH.

  1. [Install and configure the MetaMask extension](https://metamask.io/download) in your browser.

  2. After you install the extension, open your browser extension list and click MetaMask to open MetaMask.

  3. Follow the instructions in MetaMask to create a new MetaMask wallet. The new wallet includes a 12-word mnemonic phrase. This phrase is the key to your wallet. Copy that phrase down in a very secure location that only you can access. You can use this phrase to retrieve your wallet later or add it to another browser.

  4. Set MetaMask to use the Sepolia test network.

  5. Choose a Sepolia ETH [faucet](https://faucetlink.to/sepolia) and follow the steps to send testnet ETH to your MetaMask wallet address. You can copy your wallet address by clicking your account name in MetaMask. After the faucet completes the transaction, you should have testnet ETH in your MetaMask wallet on the Sepolia testnet.

Now that you configured your wallet and funded it with testnet ETH, you can
write, compile, and deploy your contract.

## Write, compile, and deploy your first smart contract

Your first contract is a simple `HelloWorld.sol` example. This example shows
you how to set and retrieve variables in a smart contract on-chain.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol) in the Remix IDE. Remix opens and shows the contents of the smart contract. You can modify the code in this editor when you write your own contract.

[ Open in Remix
](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol)
[What is Remix?](/getting-started/conceptual-overview#what-is-remix)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. For this contract, use the default compiler settings. Click the **Compile HelloWorld.sol** button to compile the contract. This converts the contract from Solidity into bytecode that the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/) can understand. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract.

  4. After Remix compiles the contract, deploy it. On the left side of Remix, click the **Deploy and Run** tab to view the deployment settings.

  5. In the deployment settings, select the **Injected Provider** environment. This tells Remix that you want to deploy your contract to the blockchain that you configured in MetaMask. You could optionally use one of the Javascript VM options, but they run in a virtual environment with no connection to an actual blockchain or Chainlink oracles.

  6. Next to the **Deploy** button, enter a message that you want to send with the smart contract when you deploy it. This contract has a constructor that sets an initial message when you deploy the contract.

  7. Click the **Deploy** button to deploy the contract and its initial message to the blockchain network. MetaMask opens and asks you to confirm payment to deploy the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  8. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  9. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  10. Click the `message` variable. Remix retrieves and prints the initial message that you set.

The contract has an address just like your wallet address. If you save this
address, you can return to your deployed contract at any time to retrieve
variables or execute functions. To see details about your deployed contract,
copy the contract address from the list in Remix and search for it in the
[Etherscan Sepolia Testnet Explorer](https://sepolia.etherscan.io/).

## Run functions in your contract

Because you deployed the contract to an actual blockchain, several nodes on
the test network confirmed your payment for the smart contract. The contract,
its variables, and its functions remain in the blockchain permanently. To
change the `message` variable that is stored with your contract, run the
`updateMessage` function.

  1. In your deployed contract, enter a new message next to the `updateMessage` function.

  2. Click the `updateMessage` button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.

  3. In the new MetaMask prompt, click **Confirm** to approve the transaction.

  4. Click the `message` variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

Now you know how to deploy example contracts to a test network and run the
functions in those contracts. You can write your own contracts and test them
using this same process.

Next, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds)
guide to learn how to connect your smart contracts to Chainlink Data Feeds and
retrieve on-chain data that your smart contracts can act on.

## What's next

  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/deploy-your-first-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What was the issue with the code that caused the error when running the call through the External Adapter?,The issue was with the line that made the artist ID uppercase.,{'source': 'https://stackoverflow.com/questions/69321235/trouble-with-chainlink-external-adapter-making-an-api-call-to-spotify'},"The issue with the code that caused the error when running the call through the External Adapter is not mentioned in the provided content.
SOURCES:",,"# Building External Adapters

  * Overview
  * Requesting data
  * Returning Data
  * Returning Errors
  * Asynchronous callbacks
  * Example

Developers of external adapters will need to know how the Chainlink node
requests data from it, and how the data should be formatted for a response.
External adapters can be written in any language, and even run on separate
machines, to include serverless functions.

The [**Official Chainlink External Adapter Monorepo
(NodeJS)**](https://github.com/smartcontractkit/external-adapters-js) contains
many examples to help get you started.

### Requesting data

When an external adapter receives a request from the Chainlink node, the JSON
payload will include the following objects:

  * `data` (guaranteed to be present but may be empty)
  * `meta` (optional, depends on job type)
  * `responseURL` (optional, will be supplied if job supports asynchronous callbacks)
  * `id` (optional, can be nice to use for EA logging to help debug job runs)

#### Examples


    { ""data"": {} }


    {
      ""data"": {},
      ""responseURL"": ""http://localhost:6688/v2/runs/278c97ffadb54a5bbb93cfec5f7b5503""
    }


    {
      ""data"": { ""foo"": 42 },
      ""meta"": { ""bar"": ""baz"" },
      ""id"": ""2d38ecdb-975c-4f99-801c-b916a429947c""
    }

Additional data may be specified in the spec to be utilized by the adapter.
This can be useful for requesting data from a REST endpoint where the keys and
values can be specified by the requester. For example, if the REST endpoint
supports the following:


    https://example.com/api/:parent/:child

Then the payload to the external adapter would need:


    {
      ""data"": {
        ""parent"": ""myParentValue"",
        ""child"": ""myChildValue""
      }
    }

The values for `:parent` and `:child` can be used within the adapter to
dynamically build the URL for the request. This same concept can also be
applied to URLs with query values. For example:


    https://example.com/api/?parent=myParentValue&child=myChildValue

### Returning Data

When the external adapter wants to return data immediately, it must include
`data` in the returned JSON.

An example of the response data can look like:


    {
      ""data"": {
        ""symbol"": ""ETH-USD"",
        ""last"": {
          ""price"": 467.85,
          ""size"": 0.01816561,
          ""timestamp"": 1528926483463
        }
      }
    }

### Returning Errors

If the endpoint gave a known error, the `error` field should be included in
the external adapter's response back to the Chainlink node.

An example of what the error response payload should look like:


    {
      ""error"": ""The endpoint is under maintenance.""
    }

### Asynchronous callbacks

Some job types support external callbacks. When supported, Chainlink will
provide a non-null `responseURL` alongside the request payload.

If the external adapter wants to return data immediately it can simply respond
with data directly as normal.

If the external adapter wants to use the response URL to send data later, it
may initially return a response like this:


    {
      ""pending"": true
    }

In this case, the job run on Chainlink side will be put into a `pending`
state, awaiting data which can be delivered at a later date.

When the external adapter is ready, it should callback to the node to resume
the JobRun using an HTTP PATCH request to the `responseURL` field. This will
resume the job on the Chainlink side.


    {
      ""data"": {
        ""symbol"": ""ETH-USD"",
        ""last"": {
          ""price"": 467.85,
          ""size"": 0.01816561,
          ""timestamp"": 1528926483463
        }
      }
    }

Or, for the error case:


    {
      ""error"": ""something went wrong""
    }

### Example

Here is a complete example of a simple external adapter written as a
serverless function. This external adapter takes two input fields, inserts the
API key as a header, and returns the resulting payload to the node.


    let request = require(""request"")
    
    exports.myExternalAdapter = (req, res) => {
      const url = ""https://some-api.example.com/api""
      const coin = req.body.data.coin || """"
      const market = req.body.data.market || """"
      let requestObj = {
        coin: coin,
        market: market,
      }
      let headerObj = {
        API_KEY: ""abcd-efgh-ijkl-mnop-qrst-uvwy"",
      }
      let options = {
        url: url,
        headers: headerObj,
        qs: requestObj,
        json: true,
      }
    
      request(options, (error, response, body) => {
        if (error || response.statusCode >= 400) {
          let errorData = {
            jobRunID: req.body.id,
            status: ""errored"",
            error: body,
          }
          res.status(response.statusCode).send(errorData)
        } else {
          let returnData = {
            jobRunID: req.body.id,
            data: body,
          }
          res.status(response.statusCode).send(returnData)
        }
      })
    }

If given ""ETH"" as the value for `coin` and ""USD"" as the value for `market`,
this external adapter will build the following URL for the request:


    https://some-api.example.com/api?coin=ETH&market=USD

The headers in this case would include the API key, but that could just as
easily be added to the `requestObj` if an API requires the key in the URL.

## What's next

  * [› Bridges: Adding External Adapters to Nodes](/chainlink-nodes/external-adapters/node-operators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/developers.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-09-15 14:41:55)
Task fails with no way to debug
URL: https://stackoverflow.com/questions/73733171/task-fails-with-no-way-to-debug

Question Body:


I have a node running two jobs - they communicate with an external adaptor and
then send the value on-chain.

One job works fine, which already tells me that the node can write on-chain.

The other job, receives the request, talks with the external adaptor (I have
verified this on the external adaptor server) and then doesn't submit anything
on-chain.

There is no way to debug this through the Operator UI. This is what it shows:

[](https://i.stack.imgur.com/z2s2t.png)

What should I do? I am running the Chainlink develop version because the most
up-to-date stable version as a critical bug.



Answers:
(Answered on: 2022-09-18 05:12:28)


In the Chainlink node version 1.8.0, there are ""Error"" and ""Runs"" tabs in your
node UI in the browser, and these 2 tabs allow you to view what's wrong with
your job run. You can find the latest chainlink docker image
[here](https://hub.docker.com/r/smartcontract/chainlink/tags).

[](https://i.stack.imgur.com/W6AxZ.png)

The error messages under the ""error"" tab are shown below, and the info can
reflect the error your job encountered in the run.

[](https://i.stack.imgur.com/IUEU0.jpg)

If there are no ""error"" and ""run"" tabs in the browser or there is nothing
shown in the UI, you can also find error info in the log file housed by the
server running the Chainlink node. The default path of the Chainlink node log
file is `/chainlink/chainlink_debug.log`, so you can log into the server that
running the node and check the log for debugging.

Hope it helps.



"
What is the difference between an agreement and a contract?,"Contracts are agreements that are enforceable in a court of law, while agreements are oftentimes informal and not legally binding.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md'},"An agreement is a mutual understanding or arrangement between two or more parties, while a contract is a legally binding agreement that is enforceable by law. A contract typically includes specific terms and conditions that outline the rights and obligations of each party involved. Smart contracts, on the other hand, are self-executing contracts that are written in computer code and automatically enforce the terms of the agreement. They are a type of digital agreement that utilizes blockchain technology for transparency and security.
","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-4/description.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/description.md","Smart contracts result from the evolution of digital agreements. A Smart contract is a self-executing contract with the terms of the agreement being directly written into computer code.


:::NEXT DOC:::

When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
"
What is the purpose of the 'requestVolumeData' function?,To create a Chainlink request to retrieve API response and find the target data.,{'source': 'https://stackoverflow.com/questions/69297267/chainlink-api-get-request-isnt-returning-a-value'},"The purpose of the 'requestVolumeData' function is to send a request to the Chainlink node to retrieve volume data from a specified API endpoint. The function builds a Chainlink request using the provided job ID and the contract's address as the callback address. It then adds the necessary parameters to the request, such as the API endpoint and the desired data path in the JSON response. Finally, it sends the request to the specified oracle address. The function is used to fetch volume data for Ethereum from the Cryptocompare API in the provided example.

","
- https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example","Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    





:::NEXT DOC:::

Question: (Asked on: 2023-01-06 09:55:44)
ParserError: Source &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot; not found: File outside of allowed directories
URL: https://stackoverflow.com/questions/75029401/parsererror-source-chainlink-contracts-src-v0-8-interfaces-aggregatorv3interf

Question Body:


I'm trying to compile a ""FundMe.sol"" contract: the issue is that when I try to
compile it I keep getting the following Compiler Error:

    
    
    Brownie v1.19.2 - Python development framework for Ethereum
    
    New compatible solc version available: 0.8.0
    Compiling contracts...
      Solc version: 0.8.0
      Optimizer: Enabled  Runs: 200
      EVM Version: Istanbul
    CompilerError: solc returned the following errors:
    
    ParserError: Source ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
      --> contracts/FundMe.sol:15:1:
       |
    15 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    

The contract is included inside of the ""contracts"" folder (initted by
brownie), moreover I have created the ""brownie-config.yaml"" file which should
remap @chainlink - I feel as it might have contain some kind of error aswell.

I'm including all the mentioned files down below:

**Project Folder** : [brownie_fund_me](https://i.stack.imgur.com/HEeeo.png)

**FundMe.sol** :

    
    
    //SPDX-License-Identifier: MIT
    //Last update: 25/12/2022
    
    /* ***** ABI = Application Binary Interface *****
     * Interfaces compile down to an ABI. 
     *
     * ABI tells Solidity and other coding languages
     * how it can interact with other contracts. 
     *
     * Anytime you want to interact with another
     * deployed contract, you will need that contracts' ABI.
     */
    
    pragma solidity >=0.6.0 <0.9.0;
    
    // ***** Imports *****
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";   //The following library is shown below
    /*
     *
     *      interface AggregatorV3Interface 
     *      {
     *       function decimals() external view returns (uint8);
     *
     *       function description() external view returns (string memory);
     *
     *       function version() external view returns (uint256);    <-------------- Version
     *
     *       function getRoundData(uint80 _roundId) external view returns 
     *       (
     *           uint80 roundId,
     *           int256 answer,          
     *           uint256 startedAt,
     *           uint256 updatedAt,
     *           uint80 answeredInRound
     *       );
     *
     *       function latestRoundData() external view returns 
     *       (
     *           uint80 roundId,
     *           int256 answer,             <---------- Value in USD
     *           uint256 startedAt,
     *           uint256 updatedAt,
     *           uint80 answeredInRound
     *       );
     *      }
     *
     */
    
    // ***** FundMe *****
    // The following contract allows the end users to send a minimum amount
    // of ETH without being able to retrive it.
    // This contract is a good example of crowd funding.
    contract FundMe{
        
        // ***** AddressToAmountFunded *****
        // The following mapping allows the user to access the amount funded
        // by somebody, provided the address.
        mapping (address => uint256) public AddressToAmountFunded;
    
        // Array of addresses where the address of each funder will be stored in a temporary way
        // Every time the owner calls the withdraw function, the array is being reset
        address[] public funders;
    
        // Owners' address: this will be the only address being able to withdraw
        address public owner;
    
        // Constructor is called automatically and istantly when the contract is being deployed
        // Such thing allows the deployer of the contract to be the owner
        constructor() public
        {
            owner = msg.sender;     // msg.sender is who calls a function, in the constructor case, who deploys the contract
        }
    
        // ***** onlyOwner *****
        // The following modifier is used in the declaration of functions, such as withdraw, 
        // in order to allow the function, to be called only by the owner.
        modifier onlyOwner
        {
            require(msg.sender == owner);      // Whoever calls the function (msg.sender) must be the owner
            _;                                 // The ""_;"" means that we call the instruction after we check that the address of the caller is equal to owner
        }
    
        // ***** fund *****
        // The following function allows the users to fund the contract with a minimum amount of money ""minimumUSD""
        // to this date (25/12/2022) 50$ = 0,041ETH = 41000000000000000Wei = (41 * 10^15)Wei - to update the value, check the USD/ETH change and convert to Wei here https://eth-converter.com/
        // If the amount funded is <= minimumUSD the transaction will not go through and will lead to an inversion of the
        // transaction
        // ! ! ! ! ! Please notice that the amount funded cannot be retrived in any way ! ! ! ! !
        function fund() public payable
        {
            uint256 minimumUSD = 41 * 10 ** 15;                                                                                        // Minimum amount transferable
            require(msg.value >= minimumUSD, ""The amount of ETH you sent is less then 50$ - Transaction is being inverted"");           // ""msg.value"" is a keyword that stays for the amount of Wei sent
    
            AddressToAmountFunded[msg.sender] += msg.value;             // Given an address, the mapping will return the amount funded by such account - Note that these values will be reset every time withdraw is called
            funders.push(msg.sender);                                   // The funders' address will be added to the funders array - Note that these values will be reset every time withdraw is called
        }
    
        // ***** getVersion *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current version of the contract/library AggregatorV3Interface
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getVersion() public view returns(uint256)
        {      
            return AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e).version();     // .version method is contained inside of AggregatorV3Interface, the address can be find here
            //                                                                                                                                                                                 |
            // The function works also if written like this:                                                                                                                                   |
            // AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);  <--- Address                                                              |
            // return priceFeed.version();                                                                           <--- ABI                                                                 /
            // You can find the Addresses for AggregatorV3Interface here ---> https://docs.chain.link/data-feeds/price-feeds/addresses/ <----------------------------------------------------
        }
    
        // ***** getPrice *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current value of 1ETH in USD, please note that you will get an apporximate value 
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getPrice() public view returns(uint256)
        {
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);    // .latestRoundData method is contained inside of AggregatorV3Interface, the address can be found above
            (,int256 answer,,,) = priceFeed.latestRoundData();                                                      // The method returns 5 different values, we exclude all of them but answer, for further understanding check at AggregatorV3Interface under imports
            return uint256(answer / 10 ** 8);                                                                       // Answer is divided by 10^8 so that the value in USD has no decimals and is easier to read
            
            // Historical:
            // 23/12/2022 - 1,226.67395017
            // 25/12/2022 - 1,220.00000000
        }
    
        // ***** getConvertionRate *****
        // The following function could be considered an extension of getPrice : given
        // the amount of ETH, the function will return the current value of such amount of ETH
        // in USD
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getConvertionRate(uint256 ETH_Amount) public view returns(uint256)
        {
            uint256 ETH_Price = getPrice();                         // Calls getPrice function
            uint256 ETH_AmountInUSD = ETH_Price * ETH_Amount;       // Current ETH pirce * ETH amount
            return ETH_AmountInUSD;                                 // Returns the value of amount ETH in USD
        }
    
        // ***** withdraw *****
        // The following function allows the deployer of the contract (owner) to withdraw
        // the amount of ETH funded to the contract, moreover when the function is called,
        // the funders array will be reset
        function withdraw() payable onlyOwner public                // Check for onlyOwner modifier description at line 77
        {
            payable(msg.sender).transfer(address(this).balance);    // This line of code allows the withdrawal, this refers to the contract
    
            for(uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++)   // The following cycle allows the reset of the money
            {                                                                           // value sent by the funders, accessible through mapping
                address funder = funders[funderIndex];
                AddressToAmountFunded[funder] = 0;
            }
    
            funders = new address[] (0);                            // funders array gets reset, so that it's able to store new values starting from 0
        }
    }
    
    

**brownie-config.yaml** :

    
    
    dependencies:
      # - <organization/repo@version>
      - smartcontractkit/chainlink-brownie-contracts@0.5.1
      
    compiler:
      solc:
        remappings:
          - '@chainlink = smartcontractkit/chainlink-brownie-contracts@0.5.1' 
    

I'm quiet new to ""python-solidity"" coding, but so far I had managed to
overcome all the issues that were popping up. I have spent over 2 days tring
to find a solution to this problem - it's becoming really frustrating. I'm
really thankful to whoever - at least - tries helping me!

**Solutions I tried:**

  * Changing versions of pragma solidity, imports and repo;
  * Adding a .vscode folder --> setting.json containing a path to solidity remappings
  * Updating solc and brownie



Answers:
(Answered on: 2023-01-07 09:23:18)


Can you try `npm install @chainlink/contracts` or `pip3 install
@chainlink/contracts` again and compile it?



"
What is the purpose of the contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code?,The contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code is a Chainlink Aggregator contract.,{'source': 'https://stackoverflow.com/questions/73734527/create-an-oracle-on-a-new-chain'},"The purpose of the contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code is to create a Chainlink Aggregator contract. It is used to fetch token price data in a contract by using the AggregatorInterface and fetching data from the Aggregator contract deployed by Chainlink. More information and instructions can be found at https://docs.chain.link/docs/get-the-latest-price/.
",https://stackoverflow.com/questions/73734527/create-an-oracle-on-a-new-chain,"Question: (Asked on: 2022-09-15 16:22:42)
Create an oracle on a new chain
URL: https://stackoverflow.com/questions/73734527/create-an-oracle-on-a-new-chain

Question Body:


If I deploy a contract like this one on a new chain:

<https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code>

Then I will still need some way to feed it data. How would I do this?



Answers:
(Answered on: 2022-09-16 05:24:19)


What you deployed is a Chainlink Aggregator contract, you do not need to
deploy Aggregator contract to get the token price data.

If you want to get some token price data in your contract, you should use
AggregatorInterface in your contract and then fetch price data from the
Aggregator contract deployed by Chainlink team. Instructions can be found
[here](https://docs.chain.link/docs/get-the-latest-price/).





:::NEXT DOC:::

Question: (Asked on: 2022-05-11 08:55:38)
No job show up in Runs page while trying to run a Chainlink node locally
URL: https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally

Question Body:


I am trying to fulfil requests on my local test chainlink node on rinkeby
(following <https://docs.chain.link/docs/fulfilling-requests/>) but can't see
any job runs appear on my operator ui.

The Oracle contract is at
[0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C](https://rinkeby.etherscan.io/address/0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C)

The ATestnetConsumer contract is at
[0x977129EE2f404F4327A2A60C5fD9E57890D85FD0](https://rinkeby.etherscan.io/address/0x977129ee2f404f4327a2a60c5fd9e57890d85fd0)

My job toml screenshot below [](https://i.stack.imgur.com/uabGd.png)

Have confirmed my .env that it is running the rinkeby wss url from infura and
the chain is 4 and the link token contract address is
0x01BE23585060835E02B77ef475b0Cc51aA1e0709

My node wallet has ETH and LINK. Both the contracts have Link too (but no
ETH).

I run the setFulfillmentPermission function in remix with my Node wallet
address and true

[](https://i.stack.imgur.com/tqQGo.png)

When I execute the requestEthereumPrice function with my oracle address and
job id, I can see the LINK being sent by the [ATestnetConsumer contract to the
Oracle
contract](https://rinkeby.etherscan.io/tx/0xd1b71dd8ec83b7e204de5d2d0a95fdde2be41d0eadb181231ee21596ef661f78)
but no job run gets created in my local Chainlink node.

[](https://i.stack.imgur.com/wK7ha.png)

Confirming that the job hasn't run, I get the 0 value when I run the
currentPrice function on ATestnetConsumer.

Can anyone please point me to where I am going wrong? Thanks in advance!



Answers:
(Answered on: 2022-05-11 12:13:48)


Finally got it to work. Posting my two findings as I do think the
documentation needs an update to account for these.

  1. The external job id in the Jobs screen on the Operator UI has dashes in them. To use them in the ATestnetConsumer contract you need to remove the dashes (so 0e84f38985eb4edb98c2e2a09b589666 and not 0e84f389-85eb-4edb-98c2-e2a09b589666).

  2. The direct request toml doesn't seem to work as is. I had to append allowunrestrictednetworkaccess=""true"" to the fetch section so it becomes

fetch [type=""http"" method=GET url=""$(decode_cbor.get)""
allowunrestrictednetworkaccess=""true""]



"
What is the recommended way to match randomness requests with their corresponding fulfillments?,We recommend using the `requestID` to match randomness requests with their corresponding fulfillments.,{'source': 'https://docs.chain.link/vrf/v1/security/'},"The recommended way to match randomness requests with their corresponding fulfillments is to use the `requestId` parameter. This ensures that the order in which the fulfillments arrive cannot be manipulated by miners or validators. It is important to use the `requestId` to match randomness requests with their corresponding fulfillments in order to maintain the integrity of the contract's user-significant behavior. 
",https://docs.chain.link/vrf/v2/security/,"# VRF Security Considerations

  * Overview
  * Use requestId to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * fulfillRandomWords must not revert
  * Use VRFConsumerBaseV2 in your contract, to interact with the VRF service
  * Use VRFv2WrapperConsumer.sol in your contract, to interact with the VRF service

Gaining access to high quality randomness on-chain requires a solution like
Chainlink's VRF, but it also requires you to understand some of the ways that
miners or validators can potentially manipulate randomness generation. Here
are some of the top security considerations you should review in your project.

  * Use `requestId` to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * The `fulfillRandomWords` function must not revert
  * Use `VRFConsumerBaseV2` in your contract to interact with the VRF service

## Use `requestId` to match randomness requests with their fulfillment in
order

If your contract could have multiple VRF requests in flight simultaneously,
you must ensure that the order in which the VRF fulfillments arrive cannot be
used to manipulate your contract's user-significant behavior.

Blockchain miners/validators can control the order in which your requests
appear on-chain, and hence the order in which your contract responds to them.

For example, if you made randomness requests `A`, `B`, `C` in short
succession, there is no guarantee that the associated randomness fulfillments
will also be in order `A`, `B`, `C`. The randomness fulfillments might just as
well arrive at your contract in order `C`, `A`, `B` or any other order.

We recommend using the `requestID` to match randomness requests with their
corresponding fulfillments.

## Choose a safe block confirmation time, which will vary between blockchains

In principle, miners/validators of your underlying blockchain could rewrite
the chain's history to put a randomness request from your contract into a
different block, which would result in a different VRF output. Note that this
does not enable a miner to determine the random value in advance. It only
enables them to get a fresh random value that might or might not be to their
advantage. By way of analogy, they can only re-roll the dice, not predetermine
or predict which side it will land on.

You must choose an appropriate confirmation time for the randomness requests
you make. Confirmation time is how many blocks the VRF service waits before
writing a fulfillment to the chain to make potential rewrite attacks
unprofitable in the context of your application and its value-at-risk.

## Do not re-request randomness

Any re-request of randomness is an incorrect use of VRFv2. Doing so would give
the VRF service provider the option to withhold a VRF fulfillment if the
outcome is not favorable to them and wait for the re-request in the hopes that
they get a better outcome, similar to the considerations with block
confirmation time.

Re-requesting randomness is easily detectable on-chain and should be avoided
for use cases that want to be considered as using VRFv2 correctly.

## Don't accept bids/bets/inputs after you have made a randomness request

Consider the example of a contract that mints a random NFT in response to a
user's actions.

The contract should:

  1. Record whatever actions of the user may affect the generated NFT.
  2. **Stop accepting further user actions that might affect the generated NFT** and issue a randomness request.
  3. On randomness fulfillment, mint the NFT.

Generally speaking, whenever an outcome in your contract depends on some user-
supplied inputs and randomness, the contract should not accept any additional
user-supplied inputs after it submits the randomness request.

Otherwise, the cryptoeconomic security properties may be violated by an
attacker that can rewrite the chain.

## `fulfillRandomWords` must not revert

If your `fulfillRandomWords()` implementation reverts, the VRF service will
not attempt to call it a second time. Make sure your contract logic does not
revert. Consider simply storing the randomness and taking more complex follow-
on actions in separate contract calls made by you, your users, or an
[Automation Node](/chainlink-automation/introduction).

## Use `VRFConsumerBaseV2` in your contract, to interact with the VRF service

If you implement the [subscription method](/vrf/v2/subscription), use
`VRFConsumerBaseV2`. It includes a check to ensure the randomness is fulfilled
by `VRFCoordinatorV2`. For this reason, it is a best practice to inherit from
`VRFConsumerBaseV2`. Similarly, don't override `rawFulfillRandomness`.

## Use `VRFv2WrapperConsumer.sol` in your contract, to interact with the VRF
service

If you implement the [direct funding method](/vrf/v2/direct-funding), use
`VRFv2WrapperConsumer`. It includes a check to ensure the randomness is
fulfilled by the `VRFV2Wrapper`. For this reason, it is a best practice to
inherit from `VRFv2WrapperConsumer`. Similarly, don't override
`rawFulfillRandomWords`.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/security.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# VRF Security Considerations [v1]

  * Overview
  * Use requestId to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * fulfillRandomness must not revert
  * Use VRFConsumerBase in your contract, to interact with the VRF service

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

Gaining access to high quality randomness on-chain requires a solution like
Chainlink's VRF, but it also requires you to understand some of the ways that
randonmess generation can be manipulated by miners/validators. Here are some
of the top security considerations you should review in your project.

  * Use `requestId` to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * `fulfillRandomness` must not revert
  * Use `VRFConsumerBase` in your contract, to interact with the VRF service

## Use `requestId` to match randomness requests with their fulfillment in
order

If your contract could have multiple VRF requests in flight simultaneously,
you must ensure that the order in which the VRF fulfillments arrive cannot be
used to manipulate your contract's user-significant behavior.

Blockchain miners/validators can control the order in which your requests
appear on-chain, and hence the order in which your contract responds to them.

For example, if you made randomness requests `A`, `B`, `C` in short
succession, there is no guarantee that the associated randomness fulfillments
will also be in order `A`, `B`, `C`. The randomness fulfillments might just as
well arrive at your contract in order `C`, `A`, `B` or any other order.

We recommend using the `requestID` to match randomness requests with their
corresponding fulfillments.

## Choose a safe block confirmation time, which will vary between blockchains

In principle, miners and validators of your underlying blockchain could
rewrite the chain's history to put a randomness request from your contract
into a different block, which would result in a different VRF output. Note
that this does not enable a miner to determine the random value in advance. It
only enables them to get a fresh random value that may or not be to their
advantage. By way of analogy, they can only re-roll the dice, not predetermine
or predict which side it will land on.

You must choose an appropriate confirmation time for the randomness requests
you make (i.e. how many blocks the the VRF service waits before writing a
fulfillment to the chain) to make such rewrite attacks unprofitable in the
context of your application and its value-at-risk.

On proof-of-stake blockchains (e.g. BSC, Polygon), what block confirmation
time is considered secure depends on the specifics of their consensus
mechanism and whether you're willing to trust any underlying assumptions of
(partial) honesty of validators.

For further details, take a look at the consensus documentation for the chain
you want to use:

  * [Ethereum Consensus Mechanisms](https://ethereum.org/en/developers/docs/consensus-mechanisms/)
  * [BNB Chain Consensus Docs](https://docs.binance.org/smart-chain/guides/concepts/consensus.html)
  * [Polygon Consensus Docs](https://docs.matic.network/docs/contribute/bor/consensus/)

Understanding the blockchains you build your application on is very important.
You should take time to understand [chain
reorganization](https://blog.ethereum.org/2015/08/08/chain-reorganisation-depth-expectations/) which will also result in a different VRF output, which
could be exploited.

## Do not re-request randomness

Any re-request of randomness is an incorrect use of VRF. Doing so would give
the VRF service provider the option to withhold a VRF fulfillment if the
outcome is not favorable to them and wait for the re-request in the hopes that
they get a better outcome, similar to the considerations with block
confirmation time.

Re-requesting randomness is easily detectable on-chain and should be avoided
for use cases that want to be considered as using VRF correctly.

## Don't accept bids/bets/inputs after you have made a randomness request

Consider the example of a contract that mints a random NFT in response to a
users' actions.

The contract should:

  1. record whatever actions of the user may affect the generated NFT
  2. **stop accepting further user actions that may affect the generated NFT** and issue a randomness request
  3. on randomness fulfillment, mint the NFT

Generally speaking, whenever an outcome in your contract depends on some user-
supplied inputs and randomness, the contract should not accept any additional
user-supplied inputs once the randomness request has been issued.

Otherwise, the cryptoeconomic security properties may be violated by an
attacker that can rewrite the chain.

## `fulfillRandomness` must not revert

If your fulfillRandomness implementation reverts, the VRF service will not
attempt to call it a second time. Make sure your contract logic does not
revert. Consider simply storing the randomness and taking more complex follow-
on actions in separate contract calls made by you or your users.

## Use `VRFConsumerBase` in your contract, to interact with the VRF service

`VRFConsumerBase` tracks important state which needs to be synchronized with
the `VRFCoordinator` state. Some users fold `VRFConsumerBase` into their own
contracts, but this means taking on significant extra complexity, so we advise
against doing so.

Along the same lines, don't override `rawFulfillRandomness`.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/security.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
