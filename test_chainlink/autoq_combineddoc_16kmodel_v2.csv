question,answer,metadata,result,sources,retrieved_docs
Why does calling an external API in chainlink not cause inconsistency?,"Because oracle responses are stored on-chain. Instead of fetching external data during the validation process, Chainlink oracle network places the data on-chain in a transaction. This ensures that all nodes go through the same validation process and reach a consensus. Having an oracle system built into a blockchain is not possible.",{'source': 'https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency'},"Calling an external API in Chainlink does not cause inconsistency because oracle responses are stored on-chain. The data fetched from the external API is placed on-chain in a transaction, and it goes through the same validation process as every other transaction. This ensures that all nodes reach a consensus on the data, preventing inconsistent states. The use of external adapters in Chainlink enables easy integration of custom computations and specialized APIs. External adapters are services that communicate with the core of the Chainlink node via its API using a simple JSON specification. For more information, you can refer to the Chainlink documentation on external adapters.

","- https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency
- https://docs.chain.link/chainlink-nodes/external-adapters/external-adapters/","Question: (Asked on: 2021-11-26 22:39:12)
Why does calling an external API in chainlink not cause inconsistency?
URL: https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency

Question Body:


Suppose I have a smart contract that uses Chainlink's ""Call Any External API""
capability to get some data from an external URL. My understanding is that
each Ethereum full node runs each smart contract to verify the status; it does
so to verify the latest block. But what if, between the time one full node
runs the contract and another one does, the data returned by calling tha
external API changes. Then it would seem that different full nodes would get
different results for that smart contract, resulting in inconsistent states.
Why does that not happen?



Answers:
(Answered on: 2021-12-10 18:05:16)


Because oracle responses are stored on-chain.

You are right, if fetching external data was part of the validation process,
no nodes would be able to reach a consensus. So instead, a Chainlink oracle
network places the data on-chain in a transaction, and then it goes through
the same validation process as every other transaction.

You can read more about how Chainlink's [Basic Request
Model](https://docs.chain.link/docs/architecture-request-model/) looks, but
this is basically the reason why having an oracle system built into a
blockchain is impossible.





:::NEXT DOC:::

# External Adapters Introduction

  * Overview

External adapters are how Chainlink enables easy integration of custom
computations and specialized APIs. External adapters are services which the
core of the Chainlink node communicates via its API with a simple JSON
specification. If you want a step by step, be sure to check out our [blog
post](https://blog.chain.link/build-and-use-external-adapters/).

Information on external adapters is broken up into three main categories:
contract creators, developers, and node operators.

  * [Contract Creators](/chainlink-nodes/external-adapters/contract-creators) will need to know how to specify an external adapter in their request for external data.
  * [Developers](/chainlink-nodes/external-adapters/developers) will need to know how to implement an external adapter for an API.
  * [Node Operators](/chainlink-nodes/external-adapters/node-operators) will need to know how to add an external adapter to their node so that they can provide specialized services to smart contracts.

## What's next

  * [› External Adapters in Solidity](/chainlink-nodes/external-adapters/contract-creators)
  * [› Building External Adapters](/chainlink-nodes/external-adapters/developers)
  * [› Bridges: Adding External Adapters to Nodes](/chainlink-nodes/external-adapters/node-operators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/external-adapters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
How do I install dependencies for Yarn?,"To install dependencies for Yarn, you can use the command 'yarn install' in the main node's folder.",{'source': 'https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn'},"To install dependencies for Yarn, you can use the command ""yarn install"" in the main node's folder. Additionally, if you encounter errors related to locked yarn packages, you can try running ""yarn install"" before proceeding with the installation steps. 
","
- https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn
- https://stackoverflow.com/questions/70099478/chainlink-node-step-5-build-and-install-getting-error-code-137-for-yarn","Question: (Asked on: 2021-11-30 19:30:53)
How do I install dependencies for Yarn?
URL: https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn

Question Body:


trying to install yarn for my chainlink node. This is the error I'm getting.
Any thoughts?

    
    
    node -e ""if(process.env.npm_execpath.indexOf('yarn') === -1) throw new Error('Please use yarn to install dependencies\n\n')""
    



Answers:
(Answered on: 2021-12-01 16:51:27)


Did you try

    
    
    yarn install
    

in the main node's folder?





:::NEXT DOC:::

Question: (Asked on: 2021-11-24 16:18:20)
Chainlink Node step 5. Build and Install: getting error code 137 for yarn
URL: https://stackoverflow.com/questions/70099478/chainlink-node-step-5-build-and-install-getting-error-code-137-for-yarn

Question Body:


I am trying to run a [chainlink node from
source](https://github.com/smartcontractkit/chainlink#install) and am
following the install instructions.

I'm currently running `make install`

It looks like the error code says there is not enough memory on my machine,
but my linux container on my chrome duet has 50GB. I don't know the problem. I
ran the command:

These are the errors

    
    
    error Command failed with exit code 137.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 137.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
     | `yarn setup` failed with exit code 137
    Stopping 2 active children
    Aborted execution due to previous error
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    

What do I do?



Answers:
(Answered on: 2021-11-24 21:02:02)


Per the
[documentation](https://github.com/smartcontractkit/chainlink#install):

> If you got any errors regarding locked yarn package, try running yarn
> install before this step

So run `yarn install`



"
How can I change the price feed token from ETH/USD to BUSD/USD using the Chainlink oracle?,"If you are trying to get BUSD/USD via a price feed on Kovan testnet, it is not available on that specific network. It is available on Ethereum mainnet however. If you are testing using the price feed, you can always use a mock contract to mock the behavior of the feeds for testing purposes only.",{'source': 'https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin'},"To change the price feed token from ETH/USD to BUSD/USD using the Chainlink oracle, you need to update the contract code with the correct address for the BUSD/USD price feed on the Kovan testnet. However, BUSD/USD is not available on the Kovan testnet. It is only available on the Ethereum mainnet. If you are testing, you can use a mock contract to simulate the behavior of the price feed for testing purposes. Make sure to use the correct Chainlink address for the ETH/USD price feed on the Kovan testnet. 

",- https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin,"Question: (Asked on: 2021-09-23 11:16:52)
how do i change the price feed token from eth /usd to busd/usd with the chainlink oracle?
URL: https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin

Question Body:


I am trying to get the price feed for BUSD/USD using the chainlink pricefeed
oracle but it tells me that the code was reverted. this is also happening when
i switch to any other token, i am using the kovan test net

this is the error i get

> call to PriceConsumerV3.getLatestPrice call to
> PriceConsumerV3.getLatestPrice errored: VM execution error. Reverted 0x

and this is my code

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.7;
    
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
    
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Kovan
         * Aggregator: ETH/USD
         * Address: 0x9326BFA02ADD2366b30bacB125260Af641031331
         */
        constructor() public {
            priceFeed = AggregatorV3Interface(0xcBb98864Ef56E9042e7d2efef76141f15731B82f);
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            (
                uint80 roundID, 
                int price,
                uint startedAt,
                uint timeStamp,
                uint80 answeredInRound
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    



Answers:
(Answered on: 2021-09-27 03:10:51)


If you are trying to get BUSD/USD via a price feed on Kovan testnet, [it is
not available on that specific network](https://docs.chain.link/docs/ethereum-
addresses/#Kovan%20Testnet). It is [available on Ethereum
mainnet](https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet)
however.

If you are testing using the price feed, you can always use a mock contract to
mock the behavior of the feeds for testing purposes only.


---
(Answered on: 2021-09-23 22:11:12)


You have set incorrect ChainLink address!

correct ETH/USD address: `0x9326BFA02ADD2366b30bacB125260Af641031331`

Address you are using in on BSC network, not Kovan network!





:::NEXT DOC:::

Question: (Asked on: 2023-05-15 09:46:33)
Find price feed contracts Addresses of chainlink within smart contracts
URL: https://stackoverflow.com/questions/76252825/find-price-feed-contracts-addresses-of-chainlink-within-smart-contracts

Question Body:


I am developing a contract in which I have to check whether the incoming token
is paired with USD to get the price feed of Chainlink from the smart contract.
Only such tokens are going to be added to my smart contract. Does Chainlink
have any functions to get the verified or registered list of pairs from a
smart contract?

I have gone through <https://docs.chain.link/data-feeds/feed-registry>, which
supports only a few tokens on the Ethereum Mainnet. I am developing my
application on the Polygon mainnet.

  1. I have to only accept tokens that are verified feed pairs with USD on the Polygon Mainnet.
  2. Query Chainlink data feeds of such pairs from asset addresses directly from the smart contract.



Answers:
(Answered on: 2023-05-18 10:06:40)


The [Feed Registry](https://docs.chain.link/data-feeds/feed-registry) is only
avaiable on [Ethereum Mainnet](https://docs.chain.link/data-feeds/feed-
registry#contract-addresses)

I suggest you create your own table to manage it on Polygon.



"
Why are no job runs appearing on my local Chainlink node when trying to fulfill requests?,"There are a couple of possible reasons why no job runs are appearing on your local Chainlink node. First, make sure that the external job id in the Jobs screen on the Operator UI does not contain dashes. If it does, remove the dashes when using it in the ATestnetConsumer contract. Additionally, the direct request toml may not work as is. Try appending 'allowunrestrictednetworkaccess=""true""' to the fetch section in the toml file.",{'source': 'https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally'},"There could be several reasons why job runs are not appearing on your local Chainlink node. One possible reason is that the external job ID in the Jobs screen on the Operator UI has dashes in them, and you need to remove the dashes when using them in the ATestnetConsumer contract. Another possible reason is that the direct request toml may not work as is, and you may need to append ""allowunrestrictednetworkaccess=true"" to the fetch section. As for the issue of log files not being generated by Chainlink, you can try setting ""LOG_TO_DISK=true"" in your .env file. 
","
- https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally
- https://stackoverflow.com/questions/74962763/log-files-not-being-generated-by-chainlink","Question: (Asked on: 2022-05-11 08:55:38)
No job show up in Runs page while trying to run a Chainlink node locally
URL: https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally

Question Body:


I am trying to fulfil requests on my local test chainlink node on rinkeby
(following <https://docs.chain.link/docs/fulfilling-requests/>) but can't see
any job runs appear on my operator ui.

The Oracle contract is at
[0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C](https://rinkeby.etherscan.io/address/0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C)

The ATestnetConsumer contract is at
[0x977129EE2f404F4327A2A60C5fD9E57890D85FD0](https://rinkeby.etherscan.io/address/0x977129ee2f404f4327a2a60c5fd9e57890d85fd0)

My job toml screenshot below [](https://i.stack.imgur.com/uabGd.png)

Have confirmed my .env that it is running the rinkeby wss url from infura and
the chain is 4 and the link token contract address is
0x01BE23585060835E02B77ef475b0Cc51aA1e0709

My node wallet has ETH and LINK. Both the contracts have Link too (but no
ETH).

I run the setFulfillmentPermission function in remix with my Node wallet
address and true

[](https://i.stack.imgur.com/tqQGo.png)

When I execute the requestEthereumPrice function with my oracle address and
job id, I can see the LINK being sent by the [ATestnetConsumer contract to the
Oracle
contract](https://rinkeby.etherscan.io/tx/0xd1b71dd8ec83b7e204de5d2d0a95fdde2be41d0eadb181231ee21596ef661f78)
but no job run gets created in my local Chainlink node.

[](https://i.stack.imgur.com/wK7ha.png)

Confirming that the job hasn't run, I get the 0 value when I run the
currentPrice function on ATestnetConsumer.

Can anyone please point me to where I am going wrong? Thanks in advance!



Answers:
(Answered on: 2022-05-11 12:13:48)


Finally got it to work. Posting my two findings as I do think the
documentation needs an update to account for these.

  1. The external job id in the Jobs screen on the Operator UI has dashes in them. To use them in the ATestnetConsumer contract you need to remove the dashes (so 0e84f38985eb4edb98c2e2a09b589666 and not 0e84f389-85eb-4edb-98c2-e2a09b589666).

  2. The direct request toml doesn't seem to work as is. I had to append allowunrestrictednetworkaccess=""true"" to the fetch section so it becomes

fetch [type=""http"" method=GET url=""$(decode_cbor.get)""
allowunrestrictednetworkaccess=""true""]





:::NEXT DOC:::

Question: (Asked on: 2022-12-30 14:45:23)
Log files not being generated by chainlink
URL: https://stackoverflow.com/questions/74962763/log-files-not-being-generated-by-chainlink

Question Body:


I build my v 1.1.1 nodes from source and cannot find the logs when I run the
executable - logs in user friendly format are supposed to generate in the
$ROOT directory, according to the configuration settings here
<https://docs.chain.link/chainlink-nodes/v1/configuration#logging> but without
$ROOT set and with $ROOT set, no logs are appearing. (They should show in
~/.chainlink - which is autogenned and has the secret in it when chainlink
runs)

Not sure why there are no logs?

I also tried this by setting $ROOT to another directory ( ~/chainlinlops )
when I restarted the server still no logs (tho the secret file was generated
there )



Answers:
(Answered on: 2022-12-30 16:22:36)


In your `.env` set `LOG_TO_DISK=true`



"
Is it possible for Chainlink VRF to return two same randomnesses in one request?,Chainlink VRF generates one or more random values and cryptographic proof for each request. It is unlikely for Chainlink VRF to return the same randomness in one request.,{'source': 'https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request'},"It is unlikely for Chainlink VRF to return the same randomness in one request. Each request generates one or more random values and cryptographic proof, making it highly improbable for duplicates to occur. 
",https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request,"Question: (Asked on: 2023-01-19 03:22:56)
Possible Chainlink VRF returns two same randomnesses in one request?
URL: https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request

Question Body:


as the title, i am thinking if it's possible that Chainlink VRF returns two
same randomnesses in one request? As of ""random"", i assume the answer is YES.
Thanks.



Answers:
(Answered on: 2023-01-19 08:57:48)


For each request, Chainlink VRF generates one or more random values and
cryptographic proof of how those values were determined. It is unlikely that a
Chainlink VRF would return the same randomness in one request.





:::NEXT DOC:::

# Direct Funding Method

  * Overview
  * VRF direct funding
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to generate random numbers using the _direct funding_
method. This method doesn't require a subscription and is optimal for one-off
requests for randomness. This method also works best for applications where
your end-users must pay the fees for VRF because the cost of the request is
determined at request time.

## VRF direct funding

Unlike the [subscription method](/vrf/v2/subscription), the direct funding
method does not require you to create subscriptions and pre-fund them.
Instead, you must directly fund consuming contracts with LINK tokens before
they request randomness. Because the consuming contract directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Wrapper (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol).

  2. Your contract must implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling the `requestRandomness` function in the [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) contract. Include the following parameters in your request:

    * `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2/direct-funding/supported-networks/#configurations).
    * `callbackGasLimit`: The maximum amount of gas to pay for completing the callback VRF function.
    * `numWords`: The number of random numbers to request. You can find the maximum number of random values per request for your network in the [Supported networks](/vrf/v2/direct-funding/supported-networks/#configurations) page.

### How VRF processes your request

After you submit your request, it is processed using the Request & Receive
Data cycle:

  1. The consuming contract calls the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `calculateRequestPrice` function to estimate the total transaction cost to fulfill randomness. Learn [how to estimate transaction costs](/vrf/v2/estimating-costs).

  2. The consuming contract calls the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/LinkToken.sol) `transferAndCall` function to pay the wrapper with the calculated request price. This method sends LINK tokens and executes the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `onTokenTransfer` logic.

  3. The VRFV2Wrapper's `onTokenTransfer` logic triggers the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) `requestRandomWords` function to request randomness.

  4. The VRF coordinator emits an event.

  5. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

  6. The VRF coordinator verifies the proof on-chain, then it calls back the wrapper contract's `fulfillRandomWords` function.

  7. Finally, the VRF Wrapper calls back your consuming contract.

## Limits

You can see the configuration for each network on the [Supported
networks](/vrf/v2/direct-funding/supported-networks) page. You can also view
the full configuration for each VRF v2 Wrapper contract directly in Etherscan.
As an example, view the [Ethereum Mainnet VRF v2 Wrapper
contract](https://etherscan.io/address/0x5A861794B927983406fCE1D062e00b9368d97Df6#readContract)
configuration by calling `getConfig` function.

  * Each wrapper has a `maxNumWords` parameter that limits the maximum number of random values you can receive in each request.
  * The maximum allowed `callbackGasLimit` value for your requests is defined in the [Coordinator contract supported networks](/vrf/v2/subscription/supported-networks) page. Because the VRF v2 Wrapper adds an overhead, your `callbackGasLimit` must not exceed `maxGasLimit - wrapperGasOverhead`. Learn more about [estimating costs](/vrf/v2/estimating-costs).

## What's next

  * [› Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/direct-funding/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
How can I ensure that `performUpkeep` is not called again before it finishes performing work?,"In the given scenario, there is no waiting or asynchronous behavior in the EVM. One suggestion is to use the `block.number` to create an additional entry condition. This can be done by adding a requirement in the `checkUpkeep` function that checks if the current block number is greater than or equal to the last upkeep block number plus a certain value. Another option is to use OpenZeppelin's `nonReentrant` modifier to prevent reentrancy issues. These approaches can help ensure that `performUpkeep` is not called again before it finishes performing work.",{'source': 'https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per'},"To ensure that `performUpkeep` is not called again before it finishes performing work, you can implement the following practices:

1. Revalidate the conditions and data in `performUpkeep` before performing any work. This ensures that the state change occurs only when necessary.

2. Perform actions only when specific conditions are met. Check all preconditions within `performUpkeep` to prevent state changes or effects when the conditions are not met.

3. Validate the `performData` before executing any actions. Ensure that the data received via `performData` is allowed and meets the necessary criteria.

4. Consider short-circuiting expensive and unnecessary on-chain processing when conditions are not met. This can help optimize the execution of the contract.

It is important to thoroughly test your contract to ensure it operates as intended and to stress-test it under various conditions.

","- https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per
- https://docs.chain.link/chainlink-automation/compatible-contract-best-practice/","Question: (Asked on: 2021-11-04 03:31:44)
Is there a way to ensure performUpkeep isn&#39;t called again before it finishes performing work?
URL: https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per

Question Body:


I have a keeper that calls checkUpkeep and it returns true, however in
performUpkeep, the condition that would cause checkUpkeep to return false is
not set until data is returned from offchain (this is bc I want to make sure
that if for some reason that fails, the checkUpkeep will return true again to
retry)

How would I handle this so that checkUpkeep is not called again while data is
being retrieved triggering a second performUpkeep?

ex:

    
    
      function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
        requestVolumeData(); // latestDateChecked is updated once requestVolumeData successfully receives data offchain and calls fulfill function
      }
    



Answers:
(Answered on: 2021-11-09 18:59:39)


I am not sure if what you are concerned about is possible.

In the EVM a transaction either succeeds or fails. There is no waiting or
async. Or maybe there's some chainlink magic (involving transactions that do
not occur in the same block) happening that I have not learned about yet.

My suggestion: use blocknumber (block.number) to create an aditional entry
condition. That's what I'm using for a keeper to call a function approx. once
a day.

    
    
        function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        **require(block.number >= lastUpkeepBlock + 10 )** //if you can afford artificial constraint
    
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
        
        **uint lastUpkeepBlock = block.number;**
        
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
        requestVolumeData(); // latestDateChecked is updated once requestVolumeData successfully receives data offchain and calls fulfill function
      }
    

or OpenZeppelin's
[nonReentrant](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard)
modifier.

Related Concepts: [Reentrancy](https://swcregistry.io/docs/SWC-107) [Race
condition](https://swcregistry.io/docs/SWC-114)





:::NEXT DOC:::

# Best Practices for Compatible Contracts

  * Overview
  * Revalidate performUpkeep on Automation-compatible contracts
  * Performing actions ONLY when conditions are met in performUpkeep
  * Perform upkeep ONLY when data is verified via performData
  * When performing actions in Automation-compatible contracts is not harmful
  * Always test your contract

This guide outlines the best practices when using Chainlink Automation. These
best practices are important for using Chainlink Automation securely and
reliably when you [Create Compatible Contracts](/chainlink-automation/compatible-contracts).

### Revalidate `performUpkeep` on Automation-compatible contracts

We recommend that you revalidate the conditions and data in `performUpkeep`
before work is performed. By default the `performUpkeep` is `external` and
thus any party can call it, so revalidation is recommended. If you send data
from your `checkUpkeep` to your `performUpkeep` and this data drives a
critical function, please ensure you put adequate checks in place.

### Performing actions ONLY when conditions are met in `performUpkeep`

Some actions must be performed only when specific conditions are met. Check
all of the preconditions within `performUpkeep` to ensure that state change
occurs only when necessary.

In this pattern, it is undesirable for the state change to occur until the
next time the Upkeep is checked by the network and the conditions are met. It
is a best practice to stop any state change or effects by performing the same
checks or similar checks that you use in `checkUpkeep`. These checks validate
the conditions before doing the work.

For example, if you have a contract where you create a timer in `checkUpkeep`
that is designed to start a game at a specific time, validate the condition to
ensure third-party calls to your `performUpkeep` function do not start the
game at a different time.

### Perform upkeep ONLY when data is verified via `performData`

Some actions must be performed using data you intend to use. Revalidate that
the `performData` is allowed before execution.

For example, if you have a `performUpkeep` that funds a wallet and the address
of the wallet is received via the `performData` parameter, ensure you have a
list of permissable addresses to compare against to prevent third-party
calling your function to send money to their address.

### When performing actions in Automation-compatible contracts is not harmful

Sometimes actions must be performed when conditions are met, but performing
actions when conditions are not met is still acceptable. Condition checks
within `performUpkeep` might not be required, but it can still be a good
practice to short circuit expensive and unnecessary on-chain processing when
it is not required.

It might be desirable to call `performUpkeep` when the `checkUpkeep`
conditions haven't yet been tested by Chainlink Automation, so any specific
checks that you perform are entirely use case specific.

### Always test your contract

As with all smart contract testing, it is important to test the boundaries of
your smart contract in order to ensure it operates as intended. Similarly, it
is important to make sure the compatible contract operates within the
parameters of the `KeeperRegistry`.

Test all of your mission-critical contracts, and stress-test the contract to
confirm the performance and correct operation of your use case under load and
adversarial conditions. The Chainlink Automation Network will continue to
operate under stress, but so should your contract. For a list of supported
testnet blockchains, please review the [supported networks page](/chainlink-automation/supported-networks).

## What's next

  * [› Build flexible contracts](/chainlink-automation/flexible-upkeeps/)
  * [› Manage your Upkeeps](/chainlink-automation/manage-upkeeps/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/compatible-contract-best-practice.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Why is the value of volume always returning 0 in the Chainlink example?,"The value of volume is always returning 0 in the Chainlink example because there is an error in the code. The line `request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");` should be `request.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR"");` (notice the commas instead of dots). Chainlink nodes 1.0.0 and later support this new ""comma based"" format. Chainlink nodes prior to 1.0.0 support the ""dots based"" format. The official docs have been updated to include this change.",{'source': 'https://stackoverflow.com/questions/71619589/chainlink-example-not-updating-value'},"The value of volume is always returning 0 in the Chainlink example because the API response is not being properly parsed. The path specified in the request is incorrect, and the result is not being multiplied by the necessary amount to remove decimals. By modifying the path and adding the correct multiplication factor, the issue can be resolved. 

","
- https://stackoverflow.com/questions/67756089/get-api-chainlink-not-returning-value
- https://stackoverflow.com/questions/75584355/chainlinkclient-statevariable-volume-is-not-updated","Question: (Asked on: 2021-05-29 22:10:11)
GET API Chainlink not returning value
URL: https://stackoverflow.com/questions/67756089/get-api-chainlink-not-returning-value

Question Body:


I posted my code below. I tried amending the [basic chainlink
example](https://remix.ethereum.org/#version=soljson-v0.6.7+commit.b8d736ae.js&optimize=false&evmVersion=null&gist=8a173a65099261582a652ba18b7d96c1&runs=200)
to use another API. I used the [dummy
API](http://www.dummy.restapiexample.com/), made sure to change the path so
that I would get a uint and sent LINK to the smart contract, but it does not
end up returning the employee age (I don't think this needs the multiply
action as there are no decimals). Any help would be appreciated!

    
    
    // This example code is designed to quickly deploy an example contract using Remix.
    
    pragma solidity ^0.6.0;
    
    import ""https://raw.githubusercontent.com/smartcontractkit/chainlink/master/evm-contracts/src/v0.6/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
      
        uint256 public volume;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Kovan
         * Chainlink - 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e
         * Chainlink - 29fa9aa13bf1468788b7cc4a500a45b8
         * Fee: 0.1 LINK
         */
        constructor() public {
            setPublicChainlinkToken();
            oracle = 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e;
            jobId = ""29fa9aa13bf1468788b7cc4a500a45b8"";
            fee = 0.1 * 10 ** 18; // 0.1 LINK
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         ************************************************************************************
         *                                    STOP!                                         * 
         *         THIS FUNCTION WILL FAIL IF THIS CONTRACT DOES NOT OWN LINK               *
         *         ----------------------------------------------------------               *
         *         Learn how to obtain testnet LINK and fund this contract:                 *
         *         ------- https://docs.chain.link/docs/acquire-link --------               *
         *         ---- https://docs.chain.link/docs/fund-your-contract -----               *
         *                                                                                  *
         ************************************************************************************/
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""http://dummy.restapiexample.com/api/v1/employees"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //      {""ETH"":
            //          {""USD"":
            //              {
            //                  ...,
            //                  ""VOLUME24HOUR"": xxx.xxx,
            //                  ...
            //              }
            //          }
            //      }
            //  }
            request.add(""path"", ""data.0.employee_age"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
          //  int timesAmount = 10**18;
        //    request.addInt(""times"", timesAmount);
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId)
        {
            volume = _volume;
        }
        
        /**
         * Withdraw LINK from this contract
         * 
         * NOTE: DO NOT USE THIS IN PRODUCTION AS IT CAN BE CALLED BY ANY ADDRESS.
         * THIS IS PURELY FOR EXAMPLE PURPOSES ONLY.
         */
        function withdrawLink() external {
            LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());
            require(linkToken.transfer(msg.sender, linkToken.balanceOf(address(this))), ""Unable to transfer"");
        }
    }
    



Answers:
(Answered on: 2022-09-22 10:01:19)


According to the [documentation](https://docs.chain.link/docs/any-api/get-
request/examples/single-word-response/) The req.addInt('times', timesAmount)
is mandatory, If the API that you call returns a number without any decimals
then provide 1as timesAmount :

> The req.addInt('times', timesAmount) request parameter provides the oracle
> node with the multiplier timesAmount by which the fetched volume is
> multiplied. Use this to remove any decimals from the volume. Note: _**The
> times parameter is mandatory**_. If the API that you call returns a number
> without any decimals then provide 1as timesAmount. The APIConsumer in the
> example above is flexible enough to call any public API as long as the URL
> in get, path, and timesAmounnt are correct.


---
(Answered on: 2021-05-31 01:13:08)


I took the standard APIConsumer from the CL docs, changed the URL of the GET
request to yours, set the path to `data.0.employee_age`, then commented out
the line that adds the 'times' to the request, and it worked successfully, I
got back 61


---
(Answered on: 2021-05-29 22:19:12)


Sorry for the spam, I ended up multiplying the value and it started returning.
Why is this the case?

    
    
    request.add(""path"", ""data.0.employee_age"");
    
    // Multiply the result by 1000000000000000000 to remove decimals
    int timesAmount = 10**5;
    request.addInt(""times"", timesAmount);
    





:::NEXT DOC:::

Question: (Asked on: 2023-02-27 18:40:30)
ChainlinkClient: StateVariable &quot;volume&quot; is not updated
URL: https://stackoverflow.com/questions/75584355/chainlinkclient-statevariable-volume-is-not-updated

Question Body:


I am following official chainlink [bootcamp](https://docs.chain.link/getting-
started/advanced-tutorial). The demo is based on `Kovan` network and `solc:
0.6`. However asof now in 2023 I am using `GoerliTestnet`, `solc: 0.8` and
chainlink client `@chainlink/contracts/src/v0.8/ChainlinkClient.sol` .

The issue is that, when I call `requestVolumeData()` the transaction is
confirmed successfully but somehow the `callback` named `fulfillment` is not
executed somehow (this is just my findings so far) hence as a result the state
variable `volume` is not updated.

Below is my code and deployed contract address is also mentioned in it:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
    
        using Chainlink for Chainlink.Request;
      
        uint256 public volume;
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Goerli
         * Chainlink - 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7
         * Chainlink - ca98366cc7314957b8c012c72f05aeeb
         * Fee: 0.1 LINK
         */
        constructor() {
            // setPublicChainlinkToken();
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            oracle = 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7;
            jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
            fee = 0.1 * 10 ** 18; // 0.1 LINK
        }
        
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
            
            request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
            int timesAmount = 10**18;
            request.addInt(""times"", timesAmount);
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId)
        {
            volume = _volume;
        }
        
        function withdrawLink() external {
            LinkTokenInterface linkToken = LinkTokenInterface(chainlinkTokenAddress());
            require(linkToken.transfer(msg.sender, linkToken.balanceOf(address(this))), ""Unable to transfer"");
        }
    }
    
    // contract deployed on GoerliTestnet at address: 0xF4d2279148183c2eE39Bf35130F567f5C51c402C
    

I tried executing the smart contract on goerli.etherscan.io and closely
inspected the function calls and inputs.

I am expecting the state variable to be updated.



Answers:
(Answered on: 2023-02-27 23:19:45)


After communicating with the chainlink official on the discord channel, the
problem is sorted out.

The change is in `request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");` , all I
needed to do is to replace dot(.) with comma(,) so the modified version will
be like `request.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR"");`

And boomm!! it worked and the state variable `volume` is updated.

Newly deployed contract on goerliTestnet is at address:
0xB70d35AF31E12Cc8b199139014C417694c08eC25



"
Why does Chainlink VRF take a long time to get random numbers?,"Chainlink VRF follows a request and receive cycle to get a random number, which involves two transactions: the requesting transaction and the response transaction. This is necessary to look outside the blockchain and ensure randomness. The speed at which the random number is returned depends on the block time of the blockchain being used. For Ethereum, the fastest time possible is 2 times the block time, which is around 30 seconds. On faster chains like Polygon, the time is significantly lower.",{'source': 'https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers'},"Chainlink VRF takes a long time to get random numbers because it follows a request and receive cycle, which involves two transactions. The speed at which the random number is returned is dictated by the block time of the blockchain being used. On Ethereum, the fastest time possible for a random number to be returned is 2 * block time, or about 30ish seconds. On faster chains like Polygon, the time is significantly lower.
",https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers,"# Introduction to Chainlink VRF [v1]

  * Overview
  * Generate Random Numbers in your Smart Contracts
  * On-chain Verification of Randomness

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

## Generate Random Numbers in your Smart Contracts

Chainlink VRF (Verifiable Random Function) is a provably-fair and verifiable
source of randomness designed for smart contracts. Smart contract developers
can use Chainlink VRF as a tamper-proof random number generator (RNG) to build
reliable smart contracts for any applications which rely on unpredictable
outcomes:

  * Blockchain games and NFTs
  * Random assignment of duties and resources (e.g. randomly assigning judges to cases)
  * Choosing a representative sample for consensus mechanisms

Learn how to write smart contracts that consume random numbers: [Get a Random
Number](/vrf/v1/examples/get-a-random-number).

## On-chain Verification of Randomness

Chainlink VRF enables smart contracts to access randomness without
compromising on security or usability. With every new request for randomness,
Chainlink VRF generates a random number and cryptographic proof of how that
number was determined. The proof is published and verified on-chain before it
can be used by any consuming applications. This process ensures that the
results cannot be tampered with nor manipulated by anyone, including oracle
operators, miners, users and even smart contract developers.

Read more about Chainlink VRF in [our announcement
post](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/).

## What's next

  * [› Get a Random Number](/vrf/v1/examples/get-a-random-number)
  * [› API Reference](/vrf/v1/api-reference)
  * [› Supported Networks](/vrf/v1/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-06-23 23:02:20)
Chain Link VRF takes a long time to get random numbers
URL: https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers

Question Body:


**Description**

Getting a random number takes a really long time. After executing the
getRandomNumber function, a few minutes go by before I can interact with my
random number.

Basically I click getRandomNumber and have to wait 2-3 minutes until the
random number shows up in the randomResult variable.

**Steps to Reproduce**

  1. Head over to the documentation here : <https://docs.chain.link/docs/get-a-random-number/>
  2. Scroll down and click on ""Deploy this contract using Remix"" (blue outline btn)
  3. Click on one of the folders that looks like 536123b61468ad4442cfc4278e8de577 then RandomNumberConsumer.sol
  4. Replace the LINK Token, VRF Coordinator, and Key Hash to be unique to rinkeby <https://docs.chain.link/docs/vrf-contracts/>
  5. Navigation to the Solidity Compiler Tab and click on Compile RandomNumber.sol.
  6. Deploy the contract on Rinkeby
  7. Copy to contract address and send LINK token to fund the contract.
  8. Click on the orange getRandomNumber btn in remix
  9. Click on randomResult and observe how long it takes for the value in randomResult to change. (Keep clicking until it finally changes)

**Additional Information**

I am not sure if this behavior is intentional or if I need to change up the
code. Ideally I would like to have the value of randomResult once the
getRandomNumber function finishes executing. Right now I don't know when the
value of randomResult will show up.



Answers:
(Answered on: 2021-06-23 23:24:42)


Chainlink VRF follows the [request and
receive](https://docs.chain.link/docs/intermediates-tutorial/#1-request--
receive) cycle of getting a number. This means, it has to look outside the
blockchain to get a response.

So, 2 transactions actually take place:

  1. Your requesting transaction
  2. The response transaction

This is necessary to look outside the blockchain like this, otherwise you'll
get a deterministic number as opposed to random. The speed at which the random
number is returned, is dictated by the block time of the blockchain you're
using.

So for Ethereum, the fastest time possible for a Random Number to be returned
is 2 * block time, or about 30ish seconds.

On faster chains like polygon, this is drastically lower.



"
How can I make my Chainlink node wait longer for a response from an external adapter?,You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by referring to the documentation for Chainlink nodes configuration at https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout.,{'source': 'https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response'},"To make your Chainlink node wait longer for a response from an external adapter, you can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by following the instructions provided in the Chainlink documentation [here](https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout).

Source: [Stack Overflow](https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response), [Chainlink Documentation](https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout)",,"Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

# External Adapters in Solidity

  * Overview
  * Using parameters with an external adapter
  * Using the Copy adapter with an external adapter

### Using parameters with an external adapter

As a contract creator, using an external adapter is no different than creating
a request for any other job spec. You will simply need to know which
parameters are supported by the adapter. Notice the method below uses
`req.add` to create a run parameter for each required value.


    function requestMWAPrice(string _coin, string _market)
      public
      onlyOwner
      returns (bytes32 requestId)
    {
      Chainlink.Request memory req = buildChainlinkRequest(SPEC_ID, this, this.fulfill.selector);
      req.add(""endpoint"", ""mwa-historic"");
      req.add(""coin"", _coin);
      req.add(""market"", _market);
      req.add(""copyPath"", ""data.-1.1"");
      req.addInt(""times"", 100);
      requestId = sendChainlinkRequest(req, oraclePayment);
    }

### Using the Copy adapter with an external adapter

The [Copy](/chainlink-nodes/oracle-jobs/v1/adapters/#copy) adapter allows for
the same functionality of the [JsonParse](/chainlink-nodes/oracle-jobs/v1/adapters/#jsonparse) adapter but for getting data from the external
adapter's response.

For example, if an adapter returns JSON data like what is below:


    {
      ""firstValue"": ""SomeValue"",
      ""details"": {
        ""close"": ""100"",
        ""open"": ""110"",
        ""current"": ""111""
      },
      ""other"": ""GetData""
    }

And you wanted the value in the field ""open"", you would specify the path for
the adapter to walk through the JSON object to your desired field.


    ""copyPath"": [""details"", ""open""]

In Solidity, this would look like:


    string[] memory path = new string[](2);
    path[0] = ""details"";
    path[1] = ""open"";
    run.addStringArray(""copyPath"", path);

Or you can use dot-notation [JSONPath](https://jsonpath.com/) to simplify it:


    run.add(""copyPath"", ""details.open"")

## What's next

  * [› Building External Adapters](/chainlink-nodes/external-adapters/developers)
  * [› Bridges: Adding External Adapters to Nodes](/chainlink-nodes/external-adapters/node-operators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/contract-creators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
How can I make my Chainlink node wait longer for a response from an external adapter?,You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by referring to the documentation for Chainlink nodes configuration at https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout.,{'source': 'https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response'},"To make your Chainlink node wait longer for a response from an external adapter, you can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by following the instructions provided in the Chainlink documentation [here](https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout).

Source: [Stack Overflow](https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response), [Chainlink Documentation](https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout)",,"Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

# External Adapters in Solidity

  * Overview
  * Using parameters with an external adapter
  * Using the Copy adapter with an external adapter

### Using parameters with an external adapter

As a contract creator, using an external adapter is no different than creating
a request for any other job spec. You will simply need to know which
parameters are supported by the adapter. Notice the method below uses
`req.add` to create a run parameter for each required value.


    function requestMWAPrice(string _coin, string _market)
      public
      onlyOwner
      returns (bytes32 requestId)
    {
      Chainlink.Request memory req = buildChainlinkRequest(SPEC_ID, this, this.fulfill.selector);
      req.add(""endpoint"", ""mwa-historic"");
      req.add(""coin"", _coin);
      req.add(""market"", _market);
      req.add(""copyPath"", ""data.-1.1"");
      req.addInt(""times"", 100);
      requestId = sendChainlinkRequest(req, oraclePayment);
    }

### Using the Copy adapter with an external adapter

The [Copy](/chainlink-nodes/oracle-jobs/v1/adapters/#copy) adapter allows for
the same functionality of the [JsonParse](/chainlink-nodes/oracle-jobs/v1/adapters/#jsonparse) adapter but for getting data from the external
adapter's response.

For example, if an adapter returns JSON data like what is below:


    {
      ""firstValue"": ""SomeValue"",
      ""details"": {
        ""close"": ""100"",
        ""open"": ""110"",
        ""current"": ""111""
      },
      ""other"": ""GetData""
    }

And you wanted the value in the field ""open"", you would specify the path for
the adapter to walk through the JSON object to your desired field.


    ""copyPath"": [""details"", ""open""]

In Solidity, this would look like:


    string[] memory path = new string[](2);
    path[0] = ""details"";
    path[1] = ""open"";
    run.addStringArray(""copyPath"", path);

Or you can use dot-notation [JSONPath](https://jsonpath.com/) to simplify it:


    run.add(""copyPath"", ""details.open"")

## What's next

  * [› Building External Adapters](/chainlink-nodes/external-adapters/developers)
  * [› Bridges: Adding External Adapters to Nodes](/chainlink-nodes/external-adapters/node-operators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/contract-creators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Why am I unable to create external initiators from the Chainlink CLI?,"To create external initiators from the Chainlink CLI, you need to ensure that the `FEATURE_EXTERNAL_INITIATORS` environment variable is set to true in your .env file. Once this variable is set, you will have access to the `initiators` command in the Chainlink CLI and can proceed with the instructions.",{'source': 'https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli'},"The user is unable to create external initiators from the Chainlink CLI because the `FEATURE_EXTERNAL_INITIATORS` environment variable needs to be set to true in the .env file. Once this variable is set, the user will have access to the `initiators` command in the Chainlink CLI. 
","https://docs.chain.link/chainlink-nodes/external-initiators/external-initiators-introduction/, https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli","# Introduction

  * Overview

External initiators allow jobs in a node to be initiated depending on some
external condition. The ability to create and add external initiators to
Chainlink nodes enables blockchain agnostic cross-chain compatibility.

note

At this time of writing, external initiators do not show up in the bridges
tab. However, they act exactly the same as if they did.

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

Initiator Bridges handle the authentication to and from the External Initiator
and where to send the messages. When creating a Bridge two parameters are
required:

Only the [webhook](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) job
type can be initiated using an External Initiator.

The external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators to
nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes).

## What's next

  * [› Building External Initiators](/chainlink-nodes/external-initiators/building-external-initiators)
  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-09-22 09:33:38)
Can&#39;t create external initiators from chainlink CLI
URL: https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli

Question Body:


We're trying to set external initiators to our chainlink containers deployed
in GKE cluster according to the docs: <https://docs.chain.link/docs/external-
initiators-in-nodes/>

I log into the the pod:

`kubectl exec -it -n chainlink chainlink-75dd5b6bdf-b4kwr -- /bin/bash`

And there I attempt to create external initiators:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink initiators create xxx xxx
    No help topic for 'initiators'
    

I don’t even see initiators in chainlink cli options:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink
    NAME:
       chainlink - CLI for Chainlink
    
    USAGE:
       chainlink [global options] command [command options] [arguments...]
    
    VERSION:
       0.9.10@7cd042c1a94c57219ed826a6eab46752d63fa67a
    
    COMMANDS:
       admin           Commands for remotely taking admin related actions
       attempts, txas  Commands for managing Ethereum Transaction Attempts
       bridges         Commands for Bridges communicating with External Adapters
       config          Commands for the node's configuration
       job_specs       Commands for managing Job Specs (jobs V1)
       jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json, -j     json output as opposed to table
       --help, -h     show help
       --version, -v  print the version
    

Chainlink version 0.9.10.

Could you please clarify what am I doing wrong?



Answers:
(Answered on: 2021-09-28 21:51:21)


You need to make sure you have the `FEATURE_EXTERNAL_INITIATORS` environment
variable set to true in your .env file as such:

`FEATURE_EXTERNAL_INITIATORS=true`

This will open up access to the `initiators` command in the Chainlink CLI and
you can resume the instructions from there.



"
How can I transfer NFTs using Chainlink's Automation/Keeper (checkUpkeep & performUpKeep)?,"The issue with the `upkeepNeeded` returning false is because the auction end time is set to 0. To transfer NFTs using Chainlink's Automation/Keeper, you need to ensure that the `endTime` is properly set for each auction. Make sure that the `endTime` is a valid timestamp and is greater than the current block timestamp. Additionally, check that the `listed` flag is properly set to `true` when the NFT is listed for auction. Double-check your code to ensure that these conditions are met for the automation to work correctly.",{'source': 'https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu'},"To transfer NFTs using Chainlink's Automation/Keeper, you need to use the checkUpkeep and performUpkeep functions. If checkUpkeep returns true, it indicates that the upkeep needs to be performed. However, if performUpkeep is not executing when checkUpkeep returns true, there are a few things you can do to debug the issue:

1. Check your automation subscription in the Chainlink Automation app and ensure that the contract address is correct.
2. Make sure that there is a minimum balance of LINK in your subscription to cover the gas fees.
3. Test if checkUpkeep is working as expected by calling it manually and checking if it returns true.
4. Test if performUpkeep is working by calling it manually and checking if it executes properly.

By following these steps, you can identify and resolve any issues with the execution of checkUpkeep and performUpkeep functions.

","- https://stackoverflow.com/questions/74384621/peformupkeep-does-not-execute-when-checkupkeep-returns-true-using-chainlink-auto
- https://docs.chain.link/chainlink-automation/faqs/","Question: (Asked on: 2022-11-10 05:44:34)
PeformUpkeep does not execute when checkUpkeep returns true using Chainlink automation
URL: https://stackoverflow.com/questions/74384621/peformupkeep-does-not-execute-when-checkupkeep-returns-true-using-chainlink-auto

Question Body:


We are using a custom logic automation. when checking checkUpkeep the boolean
returns true (pic attached) but our perform upkeep doesn't run. It is calling
another function to run that cost rougly 50k to 100k in gas (when run
manually) What are we missing? (p.s. when we do a simple toggle function call
the performUpkeep works - but not our function). I've even put the gas up to
2,500,000 for testing using a timebased option as well (calling a specific
function to execute same logic). Here is the repo
<https://github.com/billyjitsu/expir3/tree/main/packages/backend/contracts>

WE are expecting when the checkUpkeep returns true to execute the upkeep



Answers:
(Answered on: 2022-11-12 04:08:40)


In order to solve the problem like ""Why Chainlink checkUpkeep does not
execute"", I suggest doing the following things to debug your upkeep.

  1. Since `checkUpkeep` and `performUpkeep` are both triggered by [Chainlink automation](https://automation.chain.link/), you need to check your automation subscription first. In the automation app, double check the contract address is correct.
  2. Because the chainlink node has to change the state of blockchain(call `performUpkeep` in your consumer contract), it has to pay the gas fee. It is important to make sure there is a minimum balance of LINK in your subscription.
  3. Test if `checkUpkeep` works as expected. If the pre-defined condition for automation is satisfied in your smart contract, `checkUpkeep` should return true. Chainlink automation only calls `performUpkeep` when `checkUpkeep` returns `true`, so the upkeep does not work if `checkUpkeep` cannot return true. Call `checkUpkeep` by yourself to test if it works properly. If you cannot get `true` as returned value, automation cannot get `true` either.
  4. Test if `performUpkeep` works as expected. The mechanism of Chainlink automation is to call `performUpkeep` when `checkUpkeep` returns `true`, so you must make sure the `performUpkeep` can be called by automation. Try to call the `performUpkeep` manually to see if it works properly.

Hope it helps!





:::NEXT DOC:::

# Frequently Asked Questions

  * Overview
  * Will Chainlink Automation work for my use case?
  * I registered my upkeep successfully, but I can't see it. How can I find my upkeeps?
  * Is the Chainlink Automation Network available on platforms other than Ethereum?
  * How much does it cost to use Chainlink Automation?
  * How do I determine the Gas Limit for my Upkeep?
  * What is the maximum Gas that my checkUpkeep can use?
  * What is the maximum Gas that my performUpkeep can use?
  * How often will my Upkeep be checked off-chain to see if it should be executed on-chain?
  * How long will it take for my performUpkeep to be executed once it has been broadcasted on-chain?
  * Which contract will call my performUpkeep function on-chain?
  * Will the address of the Automation Registry always stay the same?
  * Can I require that performUpkeep is only callable by the Automation Registry?
  * What gas price does Automation Node use to trigger the function?
  * How do you prevent Automation Nodes from racing against each other and escalating execution costs?
  * How is the Upkeep minimum balance determined?
  * How do I fund my Upkeep?
  * How do I withdraw funds?
  * My Upkeep stopped performing. How can I debug it?
  * How do I join the Chainlink Automation Network as a node operator?
  * Why won't the Chainlink Automation App recognize the LINK in my wallet?

## Will Chainlink Automation work for my use case?

For help with your specific use case, [contact
us](https://chain.link/contact?ref_id=Automation) to connect with one of our
Solutions Architects. You can also ask questions about Chainlink Automation on
[Stack Overflow](https://stackoverflow.com/questions/ask?tags=chainlink) or
the [#automation
channel](https://discord.com/channels/592041321326182401/821350860302581771)
in our [Discord server](https://discord.gg/qj9qarT). [Utility
contracts](/chainlink-automation/utility-contracts) can also help you get
started quickly.

## I registered my upkeep successfully, but I can't see it. How can I find my
upkeeps?

Open the [Chainlink Automation app](https://automation.chain.link/) and ensure
your wallet is connected. Also ensure that the wallet is set to use the
network where you registered the Upkeep. Your Upkeep should be under the My
Upkeeps tab.

## Is the Chainlink Automation Network available on platforms other than
Ethereum?

Chainlink Automation is available on the networks listed in the [Supported
Blockchain Networks](/chainlink-automation/supported-networks) page. To see
when we integrate with other platforms, [follow us on
Twitter](https://twitter.com/chainlink) or [join our community on
Discord](https://discord.com/channels/592041321326182401/821350860302581771).

## How much does it cost to use Chainlink Automation?

See the [Automation Economics](/chainlink-automation/automation-economics)
page to learn more about the cost of using Chainlink Automation.

## How do I determine the Gas Limit for my Upkeep?

The **Gas Limit** specified during Upkeep Registration is the maximum amount
of gas that will be used to execute your function on-chain. We simulate
`performUpkeep` and if the gas exceeds this limit the function will not
execute on-chain. One method to determine your Upkeep's Gas Limit is to
simulate the `performUpkeep` function and add enough overhead to take into
account increases that might happen due to changes in `performData` or on-
chain data.

## What is the maximum Gas that my `checkUpkeep` can use?

`checkUpkeep` is subject to the `checkGasLimit` in the [configuration of the
registry](/chainlink-automation/supported-networks/#configurations).

## What is the maximum Gas that my `performUpkeep` can use?

`performUpkeep` is subject to the `performGasLimit` in the [configuration of
the registry](/chainlink-automation/supported-networks/#configurations).

## How often will my Upkeep be checked off-chain to see if it should be
executed on-chain?

See [How it works](/chainlink-automation/overview/#how-it-works).

## How long will it take for my `performUpkeep` to be executed once it has
been broadcasted on-chain?

This depends on the network congestion, the amount of gas used by the
`performUpkeep`, and the gas price specified when the transaction is
broadcasted. See the [Price Selection and Gas Bumping](/chainlink-automation/automation-economics/#price-selection-and-gas-bumping)
documentation to learn about optimizing the chances of executing your
`performUpkeep` function.

## Which contract will call my `performUpkeep` function on-chain?

The **Automation Registry** will call the `performUpkeep` function on-chain.

## Will the address of the Automation Registry always stay the same?

No. As we add new functionality we have to upgrade our contract and deploy a
new **Automation Registry**. We will work with all our users to ensure Upkeeps
are migrated without causing business interruptions.

## Can I require that `performUpkeep` is only callable by the `Automation
Registry`?

Our preferred and recommended route before locking access to `performUpkeep`is
[revalidation](/chainlink-automation/compatible-contract-best-practice#revalidate-performupkeep-on-automation-compatible-contracts). We
understand you might want to add a require statement, but then recommend that
you make the **Automation Registry** address configurable otherwise you will
need to deploy a new contract when the Registry address changes. If you add a
require statement to `performUpkeep` you will have to update the Registry
Address in your contract when the Registry Address changes. We also recommend
that the `owner` can always call `performUpkeep`.

## What gas price does Automation Node use to trigger the function?

See the [Price Selection and Gas Bumping](/chainlink-automation/automation-economics/#price-selection-and-gas-bumping) section to learn about the gas
price used to trigger the function.

## How do you prevent Automation Nodes from racing against each other and
escalating execution costs?

See [How it works](/chainlink-automation/overview/#how-it-works).

## How is the Upkeep minimum balance determined?

See [Minimum balance](/chainlink-automation/automation-economics/#minimum-balance).

## How do I fund my Upkeep?

See [Fund your Upkeep](/chainlink-automation/manage-upkeeps/#fund-your-upkeep).

## How do I withdraw funds?

See [Withdraw funds](/chainlink-automation/manage-upkeeps/#withdraw-funds).

## My Upkeep stopped performing. How can I debug it?

The simplest way to test your function is to call it yourself and see if it
executes. To do so, deploy the contract to a testnet and debug the function.
If you can call the function successfully, then Chainlink Automation will also
be able to call it. If your function is working, but the Upkeep is not
executing, your Upkeep might be underfunded. See the [Fund your
Upkeep](/chainlink-automation/manage-upkeeps/#fund-your-upkeep) section to
learn how to fund your Upkeep.

## How do I join the Chainlink Automation Network as a node operator?

We are not accepting new Automation Nodes at this time, but be sure to sign up
for our [mailing list](/resources/developer-communications), or join our
[Discord server](https://discord.gg/qj9qarT) to be notified when this becomes
available.

## Why won't the Chainlink Automation App recognize the LINK in my wallet?

For registration on Mainnet, you need ERC-677 LINK. Many token bridges give
you ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be
ERC-677 compatible](https://pegswap.chain.link/). To register on a supported
testnet, get [LINK](/resources/link-token-contracts) for the testnet that you
want to use from our faucet.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/faqs.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Is there a way in blockchain to get the randomResult?,"No, there is no way to get the randomResult in one transaction. The Chainlink VRF process requires two transactions: one to request the random number and another to retrieve the random number. The `letsgo` function in your code will not work.",{'source': 'https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction'},"No, there is no way to get the randomResult in one transaction in blockchain. The Chainlink VRF process requires two transactions: one to request the random number and another to receive the random number. The random number cannot be obtained in a single transaction. 
","
- https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction","Question: (Asked on: 2021-06-23 23:02:20)
Chain Link VRF takes a long time to get random numbers
URL: https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers

Question Body:


**Description**

Getting a random number takes a really long time. After executing the
getRandomNumber function, a few minutes go by before I can interact with my
random number.

Basically I click getRandomNumber and have to wait 2-3 minutes until the
random number shows up in the randomResult variable.

**Steps to Reproduce**

  1. Head over to the documentation here : <https://docs.chain.link/docs/get-a-random-number/>
  2. Scroll down and click on ""Deploy this contract using Remix"" (blue outline btn)
  3. Click on one of the folders that looks like 536123b61468ad4442cfc4278e8de577 then RandomNumberConsumer.sol
  4. Replace the LINK Token, VRF Coordinator, and Key Hash to be unique to rinkeby <https://docs.chain.link/docs/vrf-contracts/>
  5. Navigation to the Solidity Compiler Tab and click on Compile RandomNumber.sol.
  6. Deploy the contract on Rinkeby
  7. Copy to contract address and send LINK token to fund the contract.
  8. Click on the orange getRandomNumber btn in remix
  9. Click on randomResult and observe how long it takes for the value in randomResult to change. (Keep clicking until it finally changes)

**Additional Information**

I am not sure if this behavior is intentional or if I need to change up the
code. Ideally I would like to have the value of randomResult once the
getRandomNumber function finishes executing. Right now I don't know when the
value of randomResult will show up.



Answers:
(Answered on: 2021-06-23 23:24:42)


Chainlink VRF follows the [request and
receive](https://docs.chain.link/docs/intermediates-tutorial/#1-request--
receive) cycle of getting a number. This means, it has to look outside the
blockchain to get a response.

So, 2 transactions actually take place:

  1. Your requesting transaction
  2. The response transaction

This is necessary to look outside the blockchain like this, otherwise you'll
get a deterministic number as opposed to random. The speed at which the random
number is returned, is dictated by the block time of the blockchain you're
using.

So for Ethereum, the fastest time possible for a Random Number to be returned
is 2 * block time, or about 30ish seconds.

On faster chains like polygon, this is drastically lower.





:::NEXT DOC:::

Question: (Asked on: 2021-10-05 09:57:27)
Retrieve the random number generated by Chainlink VRF in 1 transaction
URL: https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction

Question Body:


I am trying to get a random number in solidity in 1 transaction with Chainlink
VRF.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    contract RandomNumberConsumer is VRFConsumerBase {
        
        bytes32 internal keyHash;
        uint256 internal fee;
        
        uint256 internal randomResult;
        
        constructor() 
            VRFConsumerBase(
                0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, // VRF Coordinator
                0xa36085F69e2889c224210F603D836748e7dC0088  // LINK Token
            )
        {
            keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
        }
        function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
        function letsGo() public {
            bytes32 requestId;
            requestId = getRandomNumber();
            fulfillRandomness(requestId, 123456);
        }
    }
    

Is there a way in blockchain to get the randomResult?

I'm looking specifically at my `letsGo` function.



Answers:
(Answered on: 2021-10-07 12:29:29)


The chainlink VRF is a 2 transaction process.

The first transaction requests the random number, and the second to have the
random number returned. You can't get the random number in 1 go.

You can read more about the [basic request
model](https://docs.chain.link/docs/architecture-request-model/) in the
documentation.

You're `letsgo` function will not work.



"
What is a gas lane in chainlink and blockchain?,"A gas lane in chainlink and blockchain is a concept used to set a limit on how much to spend on each request. It is important for setting the ceiling limit of each request, similar to an entry into a bet.",{'source': 'https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain'},"A gas lane in chainlink and blockchain refers to the maximum gas price that a user is willing to pay for a request in wei. It is used to set the ceiling limit for each request and handle gas price spikes. The gas lane is specified by the keyHash in the request. The gas lane is important for determining the cost of the request and ensuring that it is processed within the specified limit. The concept of a gas lane is specific to chainlink and blockchain systems.
","https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain, https://docs.chain.link/vrf/v2/estimating-costs/","Question: (Asked on: 2022-03-09 20:02:05)
What is a gas lane in chainlink and blockchain?
URL: https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain

Question Body:


I do understand the concept of gas in the ethereum blockchain and why gas is
needed to compensate miners for providing computing power to the network.
However, when I was reading up on the chainlink vrf get a random number
documentation it says that the keyhash tells you the gas lane to use. It would
be really helpful if someone could further explain what a gas lane in
blockchain is.

Any help would be appreciated :)



Answers:
(Answered on: 2022-03-10 06:17:54)


So we know that Eth gas is always subject to change and with chainlink vrf
there will be random values with your request, so you need to set a limit to
how much to spend on each request. The reason chainlink uses a Gas lane is
because the lanes are important for setting the ceiling limit of each
request... think of it as your entry into the bet.





:::NEXT DOC:::

# Estimating VRF Costs

  * Overview
  * Understanding transaction costs
  * Estimate gas costs
  * Add LINK premium
  * Ethereum example
  * Arbitrum example

This guide explains how to estimate VRF costs for both the subscription and
direct funding methods.

## Understanding transaction costs

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends on current network conditions. The callback gas depends
on your callback function, and the number of random values in your request.
The cost of each request is final only after the transaction is complete, but
you define the limits you are willing to spend for the request with the
following variables:

  * **Gas lane:** The maximum gas price you are willing to pay for a request in wei. Define this limit by specifying the appropriate `keyHash` in your request. The limits of each gas lane are important for handling gas price spikes when Chainlink VRF bumps the gas price to fulfill your request quickly.

  * **Callback gas limit:** Specifies the maximum amount of gas you are willing to spend on the callback request. Define this limit by specifying the `callbackGasLimit` value in your request.

For Chainlink VRF v2 to fulfill your requests, you must have a sufficient
amount of LINK in your consuming contract. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values. The callback gas depends on your callback function and the number of random values in your request. Set the **callback gas limit** to specify the maximum amount of gas you are willing to spend on the callback request.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

  * **Wrapper overhead gas:** The amount of gas used by the VRF Wrapper contract. See the [Request and Receive Data](/vrf/v2/direct-funding#request-and-receive-data) section for details about the VRF v2 Wrapper contract design.

Because the consuming contract directly pays the LINK for the request, the
cost is calculated during the request and not during the callback when the
randomness is fulfilled. Test your callback function to learn how to correctly
estimate the callback gas limit.

  * If the gas limit is underestimated, the callback fails and the consuming contract is still charged for the work done to generate the requested random values.
  * If the gas limit is overestimated, the callback function will be executed but your contract is not refunded for the excess gas amount that you paid.

Make sure that your consuming contracts are funded with enough LINK tokens to
cover the transaction costs. If the consuming contract doesn't have enough
LINK tokens, your request will revert.

### Estimate gas costs

You need to pre-fund your subscription enough to meet the [minimum
subscription balance](/vrf/v2/subscription#minimum-subscription-balance) in
order to have a buffer against gas volatility.

After the request is complete, the final gas cost is recorded based on how
much gas is used for the verification and callback. The actual cost of the
request is deducted from your subscription balance.

The total gas cost in wei for your request uses the following formula:


    (Gas price * (Verification gas + Callback gas)) = total gas cost

The total gas cost is converted to LINK using the ETH/LINK data feed. In the
unlikely event that the data feed is unavailable, the VRF coordinator uses the
`fallbackWeiPerUnitLink` value for the conversion instead. The
`fallbackWeiPerUnitLink` value is defined in the [coordinator
contract](/vrf/v2/subscription/supported-networks/#configurations) for your
selected network.

The final gas cost to fulfill randomness is estimated based on how much gas is
expected for the verification and callback. The total gas cost in wei uses the
following formula:


    (Gas price * (Verification gas
                  + Callback gas limit
                  + Wrapper gas overhead)) = total gas cost

The total gas cost is converted to LINK using the ETH/LINK data feed. In the
unlikely event that the data feed is unavailable, the VRF Wrapper uses the
`fallbackWeiPerUnitLink` value for the conversion instead. The
`fallbackWeiPerUnitLink` value is defined in the [VRF v2 Wrapper
contract](/vrf/v2/direct-funding/supported-networks/#configurations) for your
selected network.

The maximum allowed `callbackGasLimit` value for your requests is defined in
the [Coordinator contract supported networks](/vrf/v2/subscription/supported-networks) page. Because the VRF v2 Wrapper adds a gas overhead, your
`callbackGasLimit` must not exceed `maxGasLimit - wrapperGasOverhead`.

### Add LINK premium

The LINK premium is added to the total gas cost. The premium is defined in the
[coordinator contract](/vrf/v2/subscription/supported-networks/#configurations) with the `fulfillmentFlatFeeLinkPPMTier1` parameter
in millionths of LINK.


    (total gas cost + LINK premium) = total request cost

The total request cost is charged to your subscription balance.

A LINK premium is then added to the total gas cost. The premium is divided in
two parts:

  * Wrapper premium: The premium percentage. You can find the percentage for your network in the [Supported networks](/vrf/v2/direct-funding/supported-networks/#configurations) page.
  * Coordinator premium: A flat fee. This premium is defined in the `fulfillmentFlatFeeLinkPPMTier1` parameter in millionths of LINK. You can find the flat fee of the coordinator for your network in the [Supported networks](/vrf/v2/direct-funding/supported-networks/#configurations) page.


    (Coordinator premium
      + (total gas cost * (1 + Wrapper premium percentage)) = total request cost

### Ethereum example

This is an example calculation of a VRF request on the Ethereum network. The
values for other supported networks are available on the [Supported
Networks](/vrf/v2/subscription/supported-networks) page.

#### Estimate minimum subscription balance

You need to have the [minimum subscription
balance](/vrf/v2/subscription#minimum-subscription-balance) for your requests
to be processed. This provides a buffer in case gas prices go higher when
processing the request. The actual cost of the request is usually lower than
the minimum subscription balance.

| Parameter            | Value     |
|:---------------------|:----------|
| Gas lane             | 500 gwei  |
| Callback gas limit   | 100000    |
| Max verification gas | 200000    |
| LINK premium         | 0.25 LINK |
  1. Calculate the total gas cost, using the maximum possible gas price for the selected gas lane, the estimated maximum verification gas, and the full callback gas limit:

Gas cost calculation| Total gas cost  
---|---  
Gas price x (Verification gas + Callback gas)|  
500 gwei x (200000 + 100000)| 150000000 gwei (0.15 ETH)  
  2. Convert the gas cost to LINK using the [LINK/ETH feed](https://data.chain.link/ethereum/mainnet/crypto-eth/link-eth). For this example, assume the feed returns a conversion value of Ξ0.004 ETH per 1 LINK.

ETH to LINK cost conversion| Total gas cost (LINK)  
---|---  
0.15 ETH / 0.004 ETH/LINK| 37.5 LINK  
  3. Add the LINK premium to get the total maximum cost of a request:

Adding LINK premium| Maximum request cost (LINK)  
---|---  
Total gas cost (LINK) + LINK premium|  
37.5 LINK + 0.25 LINK| 37.75 LINK  

This example request requires a minimum subscription balance of 37.75 LINK.
Check the **Max Cost** in the Subscription Manager to view the minimum
subscription balance for all your contracts. When your request is processed,
the actual cost of the request is deducted from your subscription balance.

#### Estimate VRF request cost

This example reflects an estimate of how much a VRF request costs. Check
[Etherscan](https://etherscan.io/gastracker) for current gas prices.

| Parameter             | Value     |
|:----------------------|:----------|
| Actual gas price      | 50 gwei   |
| Callback gas used     | 95000     |
| Verification gas used | 115000    |
| LINK premium          | 0.25 LINK |
  1. Calculate the total gas cost:

Gas cost calculation| Total gas cost  
---|---  
Gas price x (Verification gas + Callback gas)|  
50 gwei x (115000 + 95000)| 10500000 gwei (0.0105 ETH)  
  2. Convert the gas cost to LINK using the [LINK/ETH feed](https://data.chain.link/ethereum/mainnet/crypto-eth/link-eth). For this example, assume the feed returns a conversion value of Ξ0.004 ETH per 1 LINK.

ETH to LINK cost conversion| Total gas cost (LINK)  
---|---  
0.0105 ETH / 0.004 ETH/LINK| 2.625 LINK  
  3. Add the LINK premium to get the total cost of a request:

Adding LINK premium| Total request cost (LINK)  
---|---  
Total gas cost (LINK) + LINK premium|  
2.625 LINK + 0.25 LINK| 2.875 LINK  

This example request would cost 2.875 LINK, which is deducted from your
subscription balance.

This is an example calculation of a VRF request on the Ethereum network. The
values for other supported networks are available on the [Supported
Networks](/vrf/v2/direct-funding/supported-networks) page.

| Parameter                                   | Value     |
|:--------------------------------------------|:----------|
| Gas price                                   | 50 gwei   |
| Callback gas limit                          | 100000    |
| Coordinator gas overhead (Verification gas) | 90000     |
| Wrapper gas overhead                        | 40000     |
| Coordinator premium                         | 0.25 LINK |
| Wrapper premium percentage                  | 0         |
#### Steps

  1. Calculate the total gas cost:

Gas cost calculation| Total gas cost  
---|---  
Gas price x (Verification gas + Callback gas limit + Wrapper gas overhead)|  
50 gwei x (90000 + 100000 + 40000)| 11500000 gwei (0.0115 ETH)  
  2. Convert the gas cost to LINK using the [LINK/ETH feed](https://data.chain.link/ethereum/mainnet/crypto-eth/link-eth). For this example, assume the feed returns a conversion value of Ξ0.004 ETH per 1 LINK.

ETH to LINK cost conversion| Total gas cost (LINK)  
---|---  
0.0115 ETH / 0.004 ETH/LINK| 2.875 LINK  
  3. Add the LINK premium to get the total cost of a request:

Adding LINK premium| Total request cost (LINK)  
---|---  
Coordinator premium + (Total gas cost x (1 + Wrapper premium percentage))|  
0.25 LINK + (2.875 x (1 + 0))| 3.125 LINK  

This example request would cost 3.125 LINK.

### Arbitrum example

Similarly to supported L1 networks, VRF gas costs are calculated based on the
amount of verification gas and callback gas used, multiplied by the gas price:


    (L2 gas price * (Verification gas + Callback gas)) = total gas cost

Set your `callbackGasLimit` to account for L2 gas costs only. As with VRF
requests on L1 chains, the request fails if your `callbackGasLimit` is too
low.

Although the total transaction costs for using Arbitrum involve both L2 gas
costs and L1 costs, the Chainlink node pays any L1 gas costs to post the
transaction. To understand how Arbitrum's total transaction fees are
calculated, including L1 costs, refer to this [Arbitrum gas estimation
tutorial](https://developer.arbitrum.io/devs-how-tos/how-to-estimate-gas#an-example-of-how-to-apply-this-formula-in-your-code).

VRF direct funding is not yet supported on Arbitrum.

This is an example calculation of a VRF request on the Arbitrum network.
Arbitrum is the only L2 network supported by Chainlink VRF. The values for
other supported networks are available on the [Supported
Networks](/vrf/v2/subscription/supported-networks) page.

#### Estimate minimum subscription balance

You must provide the [minimum subscription
balance](/vrf/v2/subscription#minimum-subscription-balance) of LINK for your
requests to be processed. This provides a buffer in case gas prices go higher
while processing a request. The actual cost of the request is usually lower
than the minimum subscription balance.

| Parameter            | Value      |
|:---------------------|:-----------|
| Gas lane             | 30 gwei    |
| Callback gas limit   | 100000     |
| Max verification gas | 200000     |
| LINK premium         | 0.005 LINK |
  1. Calculate the total gas cost using the maximum possible gas price for the selected gas lane, the estimated maximum verification gas, and the full callback gas limit:

Gas cost calculation| Total gas cost  
---|---  
Gas price x (Verification gas + Callback gas)|  
30 gwei x (200000 + 100000)| 9000000 gwei (0.009 ETH)  
  2. Convert the gas cost to LINK using the [LINK/ETH feed](https://data.chain.link/ethereum/mainnet/crypto-eth/link-eth). For this example, assume the feed returns a conversion value of Ξ0.004 ETH per 1 LINK.

ETH to LINK cost conversion| Total gas cost (LINK)  
---|---  
0.009 ETH / 0.004 ETH/LINK| 2.25 LINK  
  3. Add the LINK premium to get the total maximum cost of a request:

Adding LINK premium| Maximum request cost (LINK)  
---|---  
Total gas cost (LINK) + LINK premium|  
2.25 LINK + 0.005 LINK| 2.255 LINK  

This example request requires a minimum subscription balance of 2.255 LINK.
Check the **Max Cost** in the [Subscription Manager](https://vrf.chain.link/)
to view the minimum subscription balance for all your contracts. When your
request is processed, the actual cost of the request is deducted from your
subscription balance.

#### Estimate VRF request cost

This example is an estimate of how much a VRF request costs. Check
[Arbiscan](https://arbiscan.io/) for current gas prices.

| Parameter             | Value      |
|:----------------------|:-----------|
| Actual gas price      | 0.1 gwei   |
| Callback gas used     | 95000      |
| Verification gas used | 115000     |
| LINK premium          | 0.005 LINK |
  1. Calculate the total gas cost:

Gas cost calculation| Total gas cost  
---|---  
Gas price x (Verification gas + Callback gas)|  
0.1 gwei x (115000 + 95000)| 21000 gwei (0.000021 ETH)  
  2. Convert the gas cost to LINK using the [LINK/ETH feed](https://data.chain.link/ethereum/mainnet/crypto-eth/link-eth). For this example, assume the feed returns a conversion value of Ξ0.004 ETH per 1 LINK.

ETH to LINK cost conversion| Total gas cost (LINK)  
---|---  
0.000021 ETH / 0.004 ETH/LINK| 0.00525 LINK  
  3. Add the LINK premium to get the total cost of a request:

Adding LINK premium| Total request cost (LINK)  
---|---  
Total gas cost (LINK) + LINK premium|  
0.00525 LINK + 0.005 LINK| 0.1025 LINK  

This example request would cost 0.1025 LINK, which is deducted from your
subscription balance.

## What's next

  * [› Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/direct-funding/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/estimating-costs.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What could be causing the 'File not exist Solc' error when trying to import a data feed into a contract?,One possible cause of the 'File not exist Solc' error is if the yaml file is located in the tests folder instead of the top level directory. Moving the file to the top level directory may resolve the issue.,{'source': 'https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract'},"The 'File not exist Solc' error when trying to import a data feed into a contract could be caused by the file being outside of the allowed directories. Moving the file to the top-level directory may resolve the issue. Another possible solution is to import the AggregatorV3Interface into the contract and initialize the data feed in the constructor. It is not necessary to include the entire example PriceConsumer contract from the Chainlink docs in your own contract. 

","
- https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract
- https://stackoverflow.com/questions/69818347/how-to-call-getlatestprice-function-chainlink-price-feed","Question: (Asked on: 2022-03-15 07:39:01)
File not exist Solc error when trying to import data feed into my contract
URL: https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract

Question Body:


[](https://i.stack.imgur.com/fUE5J.png)

[](https://i.stack.imgur.com/lAkYb.png)

[](https://i.stack.imgur.com/b50Pt.png)

I have tried changing different versions of solc, solidity, and chainlink
contracts but it doesn't work.

Error:

    
    
    contracts/Lottery.sol:4:1: ParserError: Source ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    



Answers:
(Answered on: 2022-05-11 18:24:04)


Perhaps the yaml file being in the tests folder is the problem. I would move
that file to live in your top level directory.





:::NEXT DOC:::

Question: (Asked on: 2021-11-03 00:21:58)
How to Call getLatestPrice function Chainlink Price Feed
URL: https://stackoverflow.com/questions/69818347/how-to-call-getlatestprice-function-chainlink-price-feed

Question Body:


I'm trying to use the chainlink price feed. Are we supposed to type all of our
code in the [PriceconsumerV3 contract](https://docs.chain.link/docs/get-the-
latest-price/)? Can we use inheritance to access the value? I tried putting
the PriceconsumerV3 contract and my contract in the same file. What is the
conventional setup?



Answers:
(Answered on: 2022-11-16 17:03:16)


Note the Rinkeby and Kovan Testnets are phased out which isn't well documented
in Solidity and Chainlink tutorials. Goerli as of now is the predominat
Testnet with different contract addresses hope this helps:

Scroll down the page to find Goerli contract addresses

<https://docs.chain.link/docs/data-feeds/price-
feeds/addresses/#Goerli%20Testnet>


---
(Answered on: 2021-11-03 14:25:01)


To access chainlink data feeds you simply need to import the AggregatorV3
Interface into whatever contract you would like to have use them like this:

    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    

Then initialize the exact data feed your contract is pointing to in the
constructor like this:

    
    
        constructor() {
            priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
        }
    

Where `0x9326....331` is the address of the data feed we are pointing to.

You do not have to actually put the entire [example PriceConsumer
contract](https://docs.chain.link/docs/get-the-latest-price/) from the
Chainlink docs into your own contract. That is just an example to show you how
to structure a contract to use data feeds as I explained above.



"
What command is used to configure user management in Chainlink Node instance?,The admin `chainlink admin users` command is used to configure user management in Chainlink Node instance.,{'source': 'https://docs.chain.link/chainlink-nodes/v1/roles-and-access/'},"The command used to configure user management in a Chainlink Node instance is not mentioned in the provided content.
",,"Question: (Asked on: 2021-11-05 00:37:33)
Error Building and installing local chainlink node, when running make install - windows
URL: https://stackoverflow.com/questions/69847416/error-building-and-installing-local-chainlink-node-when-running-make-install

Question Body:


I am trying to create a local chainlink oracle node, for testing and learning
purposes. Using windows 10.

I followed the steps listed on the
<https://github.com/smartcontractkit/chainlink#install> to install a local
chainlink node.

Already installed Go, nodeJS, nvm, yarn, postgres (all latest version as of
21/11/04. All ruuning from root).

Downloaded the Chainlink executing: git clone
<https://github.com/smartcontractkit/chainlink> && cd chainlink

changed the directory to C:\chainlink

and ran make install command to build and install the node.

Got the error:

'make' is not recognized as an intern or extern command, operable program or a
batch file

What am I doing wrong? (Apparently, make install is a command that works for
mac command line, I am using windows instead)



Answers:
(Answered on: 2021-11-07 22:57:42)


Working on Windows, the easiest method of running a node would be to use
[docker](https://www.docker.com/) and download the docker image as described
in the [Chainlink docs](https://docs.chain.link/docs/running-a-chainlink-
node/).

Make is a UNIX based command and will require either using a virtual
UNIX/Linux environment, using a tool like Cgywin or WSL [as discussed in this
post.](https://stackoverflow.com/questions/32127524/how-to-install-and-use-
make-in-windows)





:::NEXT DOC:::

# Best Practices for Deploying Nodes on AWS

  * Overview
  * Created Resources
  * IAM Roles
  * Billable Services
  * Best Practices
  * Do not run as the root user
  * Protect your AWS account
  * Monitor your Chainlink node's health
  * Recovering or Upgrading your Chainlink Node Container
  * Generating the .env file
  * Generating the .password file
  * Generating the .api file
  * Stopping and removing the existing Chainlink node container
  * Starting the Chainlink node container in Docker
  * Backup and Restore
  * Database Backup
  * EC2 Instance Backup
  * Failover Capabilities and Disaster Recovery
  * Troubleshooting and Design Practices
  * AWS Certificate Manager
  * Amazon Devops Guru

AWS Quick Start and Chainlink node versions

The AWS Quick Start in this guide uses [version 1.12.0](/chainlink-nodes/node-versions#changes-in-v1120-nodes) and the [Legacy config](/chainlink-nodes/v1/configuration).

You can deploy a Chainlink node on the AWS Cloud using [AWS Quick
Start](https://aws.amazon.com/quickstart) to deploy a highly available and
secure Chainlink node on the AWS Cloud.

## Created Resources

The Quick Start creates the following public resources:

  * An Elastic Load Balancing (ELB) load balancer to access the Chainlink node web graphical user interface
  * A Linux bastion host in an Auto Scaling group to allow inbound Secure Shell (SSH) access to EC2 instances in public and private subnetworks
  * Managed network address translation (NAT) gateways to allow outbound internet access for the Chainlink node instances in the private subnets

Because these resources are public facing, you should review security and best
practices information on a regular basis against vulnerabilities that pose a
risk.

## IAM Roles

The Quick Start creates the following IAM roles:

  * **Administration Role:** Grants the provided administrator ID with administrator access
  * **Execution Role:** Grants cloudformation.amazonaws.com the administration role to extend the functionality of stacks by enabling create, update, or delete stacks across multiple accounts and regions with a single operation
  * **Chainlink Node Role:**
    * Enables instances to use Systems Manager core service functionality
    * Enables instances with logs and metrics functionality in CloudWatch
    * Enables instances to retrieve Chainlink node secrets created during the Quick Start

## Billable Services

The Quick Start has the following billable services. Click on each link to
learn about the pricing model for each service:

  * [**Amazon EC2**](https://aws.amazon.com/ec2/pricing/?nc2=type_a)
  * [**Amazon Virtual Private Cloud (VPC)**](https://aws.amazon.com/vpc/pricing/)
  * [**Amazon Aurora PostgreSQL-Compatible DB**](https://aws.amazon.com/rds/aurora/pricing/)
  * [**Parameter Store**](https://aws.amazon.com/systems-manager/pricing/?nc2=type_a)
  * [**AWS Secrets Manager**](https://aws.amazon.com/secrets-manager/pricing/?nc1=h_ls)
  * [**AWS Key Management Service**](https://aws.amazon.com/kms/pricing/?nc2=type_a)
  * [**Amazon CloudWatch**](https://aws.amazon.com/cloudwatch/pricing/?nc2=type_a)
  * ( _Optional_ if you are not using a public certificate with AWS Certificate Manager) [**Application Load Balancer**](https://aws.amazon.com/elasticloadbalancing/pricing/?nc=sn&loc=3)
  * ( _Optional_ ) [**Amazon Devops Guru**](https://aws.amazon.com/devops-guru/pricing/?nc=sn&loc=3&refid=0c5ce5de-7dc6-4ce5-95c9-29c9047095fc~ha_awssm-10495_event_prospect)

You are responsible for the cost of the AWS services and any third-party
licenses that you use while running this Quick Start. There is no additional
cost for using the Quick Start.

AWS maintains service limits for each account to help guarantee the
availability of AWS resources. You are responsible for monitoring and managing
the service limits of the resources that this Quick Start provisions.

For more information, visit [Manage Service
Limits](https://aws.amazon.com/premiumsupport/knowledge-center/manage-service-limits/).

## Best Practices

### Do not run as the root user

The operations on the Chainlink node do not require the root user so it is
recommended to use the default user or run as a non-root user.

### Protect your AWS account

As a best security practice, [rotate programmatic system
credentials](https://aws.amazon.com/blogs/security/how-to-rotate-access-keys-for-iam-users/) and [cryptographic
keys](https://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html).

If you enable Amazon Devops Guru, the Quick Start deploys an AWS managed
customer key (CMK) that is used for the Amazon SNS topic for DevOps Guru. The
default setting is automatically set to rotate this KMS key every year.

### Monitor your Chainlink node's health

Run regular health checks of your Chainlink node.

We recommend using a monitoring solution to track the health of your Chainlink
node, such as
[Prometheus](https://prometheus.io/docs/prometheus/latest/getting_started/) or
[Grafana](https://grafana.com/docs/grafana/latest/getting-started/getting-started-prometheus/). Chainlink exposes metrics on the `/metrics` endpoint of
the UI. By default, that's <http://localhost:6688/metrics>.


    # A scrape configuration containing exactly one endpoint to scrape:
    # Here it's Prometheus itself.
    scrape_configs:
      # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
      - job_name: 'chainlink_node'
        static_configs:
        - targets: ['127.0.0.1:6688']
        metrics_path: '/metrics'

Alternatively, you can run a health check on your node using `curl` and make
sure the checks are `passing`. You can replace `localhost:6688` with the load
balancer endpoint if you are using a domain.


    curl -XGET localhost:6688/health | jq '.'


    % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                     Dload  Upload   Total   Spent    Left  Speed
    100  1900  100  1900    0     0   927k      0 --:--:-- --:--:-- --:--:--  927k
    {
      ""data"": [
        {
          ""type"": ""checks"",
          ""id"": ""*offchainreporting.SingletonPeerWrapper"",
          ""attributes"": {
            ""name"": ""*offchainreporting.SingletonPeerWrapper"",
            ""status"": ""passing"",
            ""output"": """"
          }
        },
        {
          ""type"": ""checks"",
          ""id"": ""*job.spawner"",
          ""attributes"": {
            ""name"": ""*job.spawner"",
            ""status"": ""passing"",
            ""output"": """"
          }
        },
        {
          ""type"": ""checks"",
          ""id"": ""*fluxmonitor.concreteFluxMonitor"",
          ""attributes"": {
            ""name"": ""*fluxmonitor.concreteFluxMonitor"",
            ""status"": ""passing"",
            ""output"": """"
          }
        },
        ⋮
      ]
    }

To check the status of your Chainlink node container, use the `docker ps`
command.

## Recovering or Upgrading your Chainlink Node Container

Tag versions for Chainlink node releases are available in the [Chainlink
docker hub](https://hub.docker.com/r/smartcontract/chainlink/tags)

If the Chainlink node containers are stopped or if you need to start up a new
instance during an upgrade or recovery, you must create new `.env`,
`.password`, and `.api` files to start the Chainlink node.

### Generating the `.env` file


    cd /home/ec2-user/.chainlink/ && ./create-env.sh \
    ${chainNetwork} \
    ${blockchainNodeUrl} \
    ${psqlUser} \
    $(aws secretsmanager get-secret-value --secret-id DBSecret --query ""SecretString"" --output text) \
    ${psqlHostname} \
    ${psqlPort} \
    ${psqlDb}

### Generating the `.password` file


    cd /home/ec2-user/.chainlink/ && ./create-password.sh \
    $(aws secretsmanager get-secret-value --secret-id WalletSecret --query ""SecretString"" --output text)

### Generating the `.api` file


    cd /home/ec2-user/.chainlink/ && ./create-api.sh \
    ${apiUser} \
    $(aws secretsmanager get-secret-value --secret-id ApiSecret --query ""SecretString"" --output text)

### Stopping and removing the existing Chainlink node container

This process is required when you update the container to a newer release.


    docker stop chainlink && docker rm chainlink

### Starting the Chainlink node container in Docker


    latestimage=$(curl -s -S ""https://registry.hub.docker.com/v2/repositories/smartcontract/chainlink/tags/"" | jq -r '.""results""[][""name""]' | head -n 1)
    cd /home/ec2-user/.chainlink && docker run -d \
    --log-driver=awslogs \
    --log-opt awslogs-group=ChainlinkLogs \
    --restart unless-stopped \
    --name chainlink \
    -p 6688:6688 \
    -v /home/ec2-user/.chainlink:/chainlink \
    --env-file=/home/ec2-user/.chainlink/.env  smartcontract/chainlink:$latestimage local n \
    -p /chainlink/.password
    -a /chainlink/.api

You can find more details with maintenance and examples in the [Performing
System Maintenance](/chainlink-nodes/resources/performing-system-maintenance)
guide.

Additionally, follow the directions in the [User Guide for Linux
Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/install-updates.html) to keep your Amazon Linux instance software up to date.

## Backup and Restore

### Database Backup

The PostgreSQL database is critical because it stores most of the Chainlink
node data. Aurora automatically backs up your PostgreSQL cluster during the
backup window with a default backup retention of 7 days. You can change the
database cluster’s backup retention period to be as short as 1 day or up to 35
days. For more details, see the guide for [backing up and restoring an Aurora
cluster](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/Aurora.Managing.Backups.html).

If the primary instance in your PostgreSQL cluster fails during an instance or
service failure, Aurora will automatically fail over to an existing read
replica or create a new primary instance if there are no read replicas
available.

### EC2 Instance Backup

By default, the Chainlink node does not contain any critical data other than
the logs found in the Chainlink directory. If the primary Chainlink node
instance is marked as unhealthy during an instance or service failure, the
Auto Scaling group schedules a replacement instance and the standby Chainlink
node instance will automatically fail over.

You can backup the EBS volumes attached to the Chainlink node by following the
instructions in the [Amazon EBS
snapshots](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSSnapshots.html)
guide. The [Amazon Data Lifecycle
Manager](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/snapshot-lifecycle.html) can help to automate your EBS snapshots. To create a backup of
the entire EC2 instance, you must create an AMI from the instance.

To see how to restore resources from an Amazon EBS snapshot or an AMI, see the
[Restoring from an Amazon EBS snapshot or an
AMI](https://docs.aws.amazon.com/prescriptive-guidance/latest/backup-recovery/restore.html) guide.

## Failover Capabilities and Disaster Recovery

Chainlink node reputation depends on the uptime of the following itmes:

  * The Chainlink node
  * The database
  * The Ethereum client

To reduce downtime, failover capabilities are required on both the Chainlink
node and Ethereum clients so that the service is still online even in the
unlikely event of a virtual machine or network failure.

The [Amazon EC2 Auto Scaling](https://aws.amazon.com/ec2/autoscaling/) group
provisions both a primary Chainlink node and a standby Chainlink node. Each
node is placed in a separate Availability Zone.

If one Availability Zone becomes unhealthy or unavailable, the Amazon EC2 Auto
Scaling group launches a new instance of the Chainlink node or bastion host in
the unaffected Availability Zone. The failover happens automatically.

The data from both the Chainlink node and the Ethereum client is stored in the
PostgreSQL database. The Aurora database cluster is fault tolerant by design
and can handle an Availability Zone failure without any loss of data. There
might be only a brief interruption of service with an automatic failover,
which helps to reduce the Recovery Point Objective (RPO) and Recovery Time
Objective (RTO).

Management of AWS service limits are not required for proper disaster
recovery. The Quick Start deployment is configured with high availability in
mind.

## Troubleshooting and Design Practices

### AWS Certificate Manager

In the AWS console, if the **SSL certificate with AWS Certificate Manager** is
set to `false`, you can leave **arn:aws:acm:region:account-id:certificate** as
is. However, if your node is external facing and must be reached by the
internet, enable this feature and set it to `true`.



### Amazon Devops Guru

In the AWS console, if the **Amazon DevOps Guru** is set to `false`, you can
leave **AdministerAccountId** and **EmailAddress** as is.



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/resources/best-practices-aws.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the 'fulfill' function in this contract?,The 'fulfill' function is used to record the fulfillment of a Chainlink request and update the 'volume' state variable with the provided volume.,{'source': 'https://docs.chain.link/any-api/get-request/examples/single-word-response/'},"The purpose of the 'fulfill' function in this contract is to receive the response from the Chainlink oracle and store the temperature value in the 'temperature' variable. It is called as part of the fulfillment process when the oracle provides the requested data. The 'fulfill' function is defined as follows:

```solidity
function fulfill(bytes32 _requestId, uint256 _temperature) public recordChainlinkFulfillment(_requestId) {
    temperature = _temperature;
}
```

","- https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example
- https://stackoverflow.com/questions/69465001/what-are-the-functions-setpublicchainlinktoken-setchainlinktoken-in-chainlink","Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    





:::NEXT DOC:::

Question: (Asked on: 2021-10-06 11:38:05)
What are the functions setPublicChainlinkToken &amp; setChainlinkToken in Chainlink API call?
URL: https://stackoverflow.com/questions/69465001/what-are-the-functions-setpublicchainlinktoken-setchainlinktoken-in-chainlink

Question Body:


I was following the tutorial of Chainlink docs at
<https://docs.chain.link/docs/advanced-tutorial/> to make an API call from my
smart contract. However, I am still not able to understand the function
`setPublicChainlinkToken()` that is being called in the constructor of
APIConsumer. I am trying to fetch the temperature of a city through the API
call. But my contract gives an error in compilation saying:

`APIConsumer hit a require or revert statement somewhere in its constructor`

The above error is very generic and I am unable to understand what is the
issue. Below is my contract code and the script which I am using to deploy it.

What params do I need to pass in the deploy script?

APIConsumer contract

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.0;
    
    import ""@chainlink/contracts/src/v0.6/ChainlinkClient.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
     */
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public temperature;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        constructor () public {
            setPublicChainlinkToken(); // Do I need to pass any params for this?
            // if (_link == address(0)) {
            //     setPublicChainlinkToken();
            // } else {
            //     setChainlinkToken(_link);
            // }
            // setPublicChainlinkToken();
            oracle = <oracle id>; // Removed oracle id and jobid values for post
            jobId = <job id>;
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network and job)
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            // ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
            
            request.add(""get"", ""http://api.weatherstack.com/current?access_key=7940b0c1136901badcb304724132b234&query=Mumbai"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"": xxx.xxx,
            //     }
            //    }
            //   }
            //  }
            request.add(""path"", ""current.temperature"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
            // int timesAmount = 10**18;
            // request.addInt(""times"", timesAmount);
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, uint256 _temperature) public recordChainlinkFulfillment(_requestId)
        {
            temperature = _temperature;
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    

Javascript Script To Deploy:

    
    
    const APIConsumer = artifacts.require(""APIConsumer"");
    module.exports = async (deployer, network, [defaultAccount]) => {
      try {
        await deployer.deploy(APIConsumer);
      } catch (err) {
        console.error(err);
      }
    };
    



Answers:
(Answered on: 2021-10-11 19:45:39)


[`setChainlinkToken`](https://github.com/smartcontractkit/chainlink/blob/d8982d45739a2157c3c5d73d2462b8b449165308/contracts/src/v0.8/ChainlinkClient.sol#L219)
is a function that tells the oracle contract what it should use to accept LINK
payments. It points to an ERC677 token for the contracts to use.

You have to know what the LINK token address is to use this function.

The
[`setPublicChainlinkToken()`](https://github.com/smartcontractkit/chainlink/blob/d8982d45739a2157c3c5d73d2462b8b449165308/contracts/src/v0.8/ChainlinkClient.sol#L227)
is a way to set the LINK token address without knowing it's address. There is
an on-chain contract (on specific chains) that has a pointer to a ""link token
contract"" registry that points to the address of the LINK token on different
chains. So this function gets the address by looking at this lookup table,
then calls the `setChainlinkToken` function with this address.

* * *

You're then getting the error you specified, because the oracle contract
you're interacting with doesn't know what the address of the LINK token is.

    
    
            // if (_link == address(0)) {
            //     setPublicChainlinkToken();
            // } else {
            //     setChainlinkToken(_link);
            // }
            // setPublicChainlinkToken();
    



"
What can you expect to stay up to date on by subscribing to the Chainlink Developer mailing list?,"You can expect to stay up to date on releases, package updates, new features, breaking changes, events, and connecting with other developers.",{'source': 'https://docs.chain.link/resources/developer-communications?parent=anyApi/'},"By subscribing to the Chainlink Developer mailing list, you can expect to stay up to date on the following:

- Releases
- Package Updates
- New Features
- Breaking Changes
- Events
- Connecting with other developers

Source: https://docs.chain.link/resources/developer-communications?parent=anyApi/

",https://docs.chain.link/resources/developer-communications?parent=anyApi/,"# Developer Communications

  * Overview

The Chainlink Developer mailing list is the best place to stay up to date on

  * Releases
  * Package Updates
  * New Features
  * Breaking Changes
  * Events
  * Connecting with other developers

## Subscribe to the latest Chainlink Developer news

### 微信中文开发者社区

### (WeChat Chinese Developer Community)

[
https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE](https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/developer-communications.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Contributing to Chainlink

  * Overview
  * Contributing to Software and Tooling
  * Raising an Issue
  * Requesting a new Feature
  * Submitting a Pull Request
  * Contributing to the documentation
  * Creating Community Content
  * Becoming a Developer Expert
  * Joining the Chainlink Community Advocate program
  * Running a Chainlink Focused Developer Bootcamp
  * Running an In-Person Meetup or Watch Party
  * Participate in a Hackathon
  * Applying for a Grant

Chainlink is an open-source project licensed [under the MIT
license](https://github.com/smartcontractkit/chainlink/blob/master/LICENSE),
and we encourage contributions from all developers and community members.

# What It Means to Contribute

When you contribute to the Chainlink project, you as a developer or community
member contribute your time and effort to help improve and grow Chainlink.
Your contribution can be from various methods:

  * Building and maintaining the Chainlink software and tools
  * Improving and maintaining the documentation, including translations into other languages
  * Creating Chainlink focused content (blog posts, tutorials, videos etc)
  * Becoming a developer expert
  * Becoming a community advocate
  * Running a Chainlink focused developer Bootcamp (in person or online)
  * Running an in-person meetup or watch party
  * Participate in a hackathon
  * Applying for a grant

# Why Should You Contribute

[Open source software](https://en.wikipedia.org/wiki/Open-source_software) is
a model that brings multiple benefits for both the project and the
contributors. As a developer or community member, contributing to Chainlink
helps you to gain valuable skills and experience, improve the software that
you use, and grow your personal brand in the community which can lead to
future employment opportunities. On top of these awesome things, contributing
to open source is fun. It can give you a sense of community involvement, and
gives you a personal sense of satisfaction knowing that you're part of an
effort to build something that will enable a fairer, more transparent, and
efficient new world.

# Ways to Contribute

## Contributing to Software and Tooling

The most direct way you can contribute to Chainlink is to contribute to the
core code or the various tooling found in our [GitHub
repository](https://github.com/smartcontractkit/). Contributing to code or
code-based tools can generally be split into a few different categories:

  * Raising an issue
  * Requesting a new feature
  * Submitting a Pull Request (PR) for a fix, improvement, or new tool

### Raising an Issue

During the course of using Chainlink software or tools, you might encounter
errors or unexpected behavior that leads you to believe the software isn't
behaving correctly. You can bring this to the attention of the Chainlink Labs
team as well as the wider developer community by raising an issue in the
project’s GitHub repository. The 'Issues' tab lists all of the open issues for
the repository.

After an issue is raised and tagged, the Chainlink Labs team and the wider
community can address it. This gives the issue the visibility required for
someone to investigate it and resolve the issue.

When you first create an issue, you must also categorize it. This prefixes the
issue name to give viewers an indication of what category the issue relates
to:

  * [NODE]: The issue relates to the core node software
  * [DEVEL]: The issue is a result of working on code found in the current repository
  * [FEAT]: The issue relates to a new feature request
  * [SMRT]: The issue related to using Chainlink smart contracts
  * [EXPL]: The issue related to using the Chainlink Explorer
  * [FAUC]: The issue related to using the Chainlink Faucet



After you select a category, enter the details for the issue. Include as much
detail about the issue as possible. Provide a thorough description,
environment, and software version details. Also provide detailed steps that
describe how to reproduce the issue. The more thorough you make your
description, the better the chances are that someone will be able to pick up
the issue and resolve it.

Once a team member acknowledges that the issue has been received, they will
tag it with an appropriate label. You should then monitor the state of the
open issue for any questions or updates.

### Requesting a new Feature

Have you thought of an improvement or an awesome new feature that you think
should be implemented into Chainlink? Request a new feature to bring it to the
attention of the team and the wider community. You can request new features by
creating a new GitHub issue in the correct repository and tagging that issue
with the [FEAT] prefix (Feature request). The process for doing this is
covered in the Raising an Issue section. Provide as much detail as possible in
your feature request, including any benefits, risks, or considerations that
you can think of.

#### Voting on new features

Sometimes a new feature is put to a vote to decide if it's something that the
team and wider community should implement. When a feature is put to a vote,
the issue is tagged with the 'needs votes' label. You can contribute to the
voting process by reacting to the first post in the feature request with a
thumbs up or thumbs down emoji. This will help drive the decision. You can
also contribute your thoughts by replying directly to the feature request with
a new post in the thread.



### Submitting a Pull Request

The best way to contribute to Chainlink is to submit a [pull request
(PR)](https://docs.github.com/en/github/collaborating-with-pull-
requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests). PRs can be submitted for various reasons, such as fixing an
identified issue, adding a feature or improvement to the project, or even
adding an entirely new repository to the Chainlink source code for a new tool
or feature. If you're looking for something to pick up and create a PR for,
you can search through the Chainlink repositories to find open issues, and
approved feature requests.

If you're new to contributing to open-source software or Chainlink, we've
tagged some [good first
issues](https://github.com/smartcontractkit/chainlink/issues?q=is%3Aissue+label%3A%22good+first+issue%22)
against the main node software and smart contracts that you can tackle. Each
major repository in the Chainlink GitHub should also have some good first
issues tagged for developers to be able to take on.

All code changes must follow the [style guide]
(<https://github.com/smartcontractkit/chainlink/wiki/Code-Style-Guide>), All
PRs must be in an appropriately named branch with a format like 'feat/feature-
description' or 'devel/issue-description'. After you submit a PR, you should
get a response by a team member within a day or two acknowledging that the PR
has been received. After that, monitor the PR for any additional questions or
updates that come up while the team and the community review the changes.

## Contributing to the documentation

The [Chainlink documentation](https://docs.chain.link/) is the go-to place for
developers who want to learn how to build applications using Chainlink, and
node operators wanting useful information on running a Chainlink node. The
documentation is [open
source](https://github.com/smartcontractkit/documentation), allowing for other
developers and community members to contribute to adding or improving it. You
can contribute to the Chainlink documentation in various ways:

  * Improving the readability of pages
  * Fixing typos or grammar errors
  * Adding new guides or tutorials that you would find useful
  * Translating the documentation into other languages

The process for contributing to the documentation follows the process defined
earlier in the Submitting a Pull Request section. Each page also has a
'Suggest Edits' link on the top right, and will directly take you to the page
in the [documentation
repository](https://github.com/smartcontractkit/documentation), where you can
create a new PR with the suggested changes. Before you create a PR for the
documentation, read the [contributing
guidelines](https://github.com/smartcontractkit/documentation/blob/main/CONTRIBUTING.md).

If you want to translate the documentation into a new language that is not yet
supported, feel free to [reach out to the
team](mailto:devrel@smartcontract.com) beforehand, so we can make sure you get
the support you need.

## Creating Community Content

Chainlink has a strong and vibrant community of developers and community
advocates. Community members often create Chainlink-focused content in various
forms and publish it for the wider community on various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually hosted](https://blog.chain.link/smart-contract-developer-bootcamp-on-demand/) the first [Chainlink Developer
Bootcamp](http://chain.link/bootcamp). If you're passionate about educating
others about smart contracts and Chainlink, you can contribute by running your
own developer Bootcamp. You can also contribute by translating an existing
Bootcamp and running it in another language. Before you run your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the benefit of using Off-Chain Reporting (OCR) for Chainlink oracle networks?,"Submitting only one transaction per round reduces overall network congestion, individual node operators spend less on gas costs, node networks are more scalable, and data feeds can be updated in a more timely manner.",{'source': 'https://docs.chain.link/architecture-overview/off-chain-reporting/'},"The benefit of using Off-Chain Reporting (OCR) for Chainlink oracle networks is that it increases decentralization and scalability. With OCR, all nodes communicate using a peer-to-peer network and a lightweight consensus algorithm runs where each node reports its data observation and signs it. This allows for a single aggregate transaction to be transmitted, saving a significant amount of gas. OCR also reduces network congestion, lowers gas costs for node operators, allows for more scalability in node networks, and enables more timely updates for data feeds. 
",https://docs.chain.link/architecture-overview/off-chain-reporting/,"# Data Feeds Architecture

  * Overview
  * Basic Request Model
  * Decentralized Data Model
  * Off-Chain Reporting

## Basic Request Model

Chainlink connects smart contracts with external data using its decentralized
oracle network. Chainlink API requests are handled 1:1 by an oracle.

The [Basic Request Model](/architecture-overview/architecture-request-model)
describes the on-chain architecture of requesting data from a single oracle
source.

To learn how to make a GET request using a single oracle, see [Make a GET
Request](/any-api/get-request/introduction).

## Decentralized Data Model

For a more robust and trustworthy answer, you can aggregate data from many
oracles. With on-chain aggregation, data is aggregated from a decentralized
network of independent oracle nodes. This architecture is applied to Chainlink
Data Feeds, which can aggregate data such as asset price data.

The [Decentralized Data Model](/architecture-overview/architecture-decentralized-model) describes how data is aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Off-Chain Reporting

  * Overview
  * What is OCR?
  * How does OCR work?

Off-Chain Reporting (OCR) is a significant step towards increasing the
decentralization and scalability of Chainlink networks. See the [OCR Protocol
Paper](https://research.chain.link/ocr.pdf) for a technical deep dive.

For Off-Chain Reporting aggregators, all nodes communicate using a peer to
peer network. During the communication process, a lightweight consensus
algorithm runs where each node reports its data observation and signs it. A
single aggregate transaction is then transmitted, which saves a significant
amount of gas.

The report contained in the aggregate transaction is signed by a quorum of
oracles and contains all oracles' observations. By validating the report on-
chain and checking the quorum's signatures on-chain, we preserve the
trustlessness properties of Chainlink oracle networks.

## What is OCR?

A simple analogy

Imagine ordering 10 items from an online store. Each item is packaged
separately and posted separately, meaning postage and packaging costs must be
applied to each one, and the carrier has to transport 10 different boxes.

OCR, on the other hand, packages all of these items into a single box and
posts that. This saves postage and packaging fees and all effort the carrier
associates with transporting 9 fewer boxes.

The OCR protocol allows nodes to aggregate their observations into a single
report off-chain using a secure P2P network. A single node then submits a
transaction with the aggregated report to the chain. Each report consists of
many nodes' observations and has to be signed by a quorum of nodes. These
signatures are verified on-chain.

Submitting only one transaction per round achieves the following benefits:

  * Overall network congestion from Chainlink oracle networks is reduced dramatically
  * Individual node operators spend far less on gas costs
  * Node networks are more scalable because data feeds can accommodate more nodes
  * Data feeds can be updated in a more timely manner since each round needn't wait for multiple transactions to be confirmed before a price is confirmed on-chain.

## How does OCR work?

Protocol execution happens mostly off-chain over a peer to peer network
between Chainlink nodes. The nodes regularly elect a new leader node that
drives the rest of the protocol.

The leader regularly requests followers to provide freshly signed observations
and aggregates them into a report. It then sends this report back to the
followers and asks them to verify the report's validity. If a quorum of
followers approves the report by sending a signed copy back to the leader, the
leader assembles a final report with the quorum's signatures and broadcasts it
to all followers.

The nodes attempt to transmit the final report to the aggregator contract
according to a randomized schedule. The aggregator verifies that a quorum of
nodes signed the report and exposes the median value to consumers as an answer
with a block timestamp and a round ID.

All nodes watch the blockchain for the final report to remove any single point
of failure during transmission. If the designated node fails to get their
transmission confirmed within a determined period, a round-robin protocol
kicks in so other nodes can also transmit the final report until one of them
is confirmed.

## What's next

  * [› Using Data Feeds](/data-feeds/price-feeds/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/off-chain-reporting.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are external initiators and how do they enable blockchain agnostic cross-chain compatibility?,External initiators allow jobs in a node to be initiated depending on some external condition. The ability to create and add external initiators to Chainlink nodes enables blockchain agnostic cross-chain compatibility.,{'source': 'https://docs.chain.link/chainlink-nodes/external-initiators/external-initiators-introduction/'},"External initiators are a feature in Chainlink nodes that allow jobs to be initiated based on external conditions. They enable blockchain agnostic cross-chain compatibility. External initiators are disabled by default but can be enabled by setting the `FEATURE_EXTERNAL_INITIATORS=true` configuration variable. When creating an external initiator, two pairs of credentials are generated: Outgoing and Incoming. The Outgoing credentials are used to authenticate messages sent from the Core to the External Initiator, while the Incoming credentials are used to authenticate messages sent from the External Initiator to the Core. External initiators can trigger webhook jobs and are activated by making an API call to the Chainlink node with the appropriate access key headers. The API call includes the job's external UUID and the necessary headers for authentication. External initiators can be used to trigger multiple jobs simultaneously. They are implemented as a separate service that sends an HTTP POST message to the Chainlink node's runs API. The external initiator service can be run on the same machine as the Chainlink node. (""","[1] [2]"")","# Introduction

  * Overview

External initiators allow jobs in a node to be initiated depending on some
external condition. The ability to create and add external initiators to
Chainlink nodes enables blockchain agnostic cross-chain compatibility.

note

At this time of writing, external initiators do not show up in the bridges
tab. However, they act exactly the same as if they did.

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

Initiator Bridges handle the authentication to and from the External Initiator
and where to send the messages. When creating a Bridge two parameters are
required:

Only the [webhook](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) job
type can be initiated using an External Initiator.

The external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators to
nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes).

## What's next

  * [› Building External Initiators](/chainlink-nodes/external-initiators/building-external-initiators)
  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Building External Initiators

  * Overview
  * JSON jobs (REMOVED)

An external initiator can trigger a run for any webhook job that it has been
linked to.

The URL for triggering a run is such:


    curl -X POST -H ""Content-Type: application/json"" --data '{""myKey"": ""myVal""}' http://localhost:6688/v2/jobs/<job external UUID>/runs

You will need to specify two headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

## JSON jobs (REMOVED)

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

We will be using the [Chainlink external
initiator](https://github.com/smartcontractkit/external-initiator) repo for
reference. You can see some examples of existing initiators in the
[blockchain](https://github.com/smartcontractkit/external-initiator/tree/master/blockchain) folder.

External initiators are simple web initiators that can be activated by any job
instead of just one. To set one up, you need to have a service similar to an
external adapter that sends an `HTTPPost` message runs API call to your
chainlink node service. Here is a sample URL for a web job could look like:


    curl -b cookiefile -X POST -H ""Content-Type: application/json"" --data '{""myKey"":""myVal""}' http://localhost:6688/v2/jobs/%s/runs

Where `%s` is the jobId.

External initiators make the same API call, with 2 added headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

These are keys generated when you register your external initiator with your
node.

Triggering a run through an external initiator is as simple as making this API
call to your node. All jobs with this EI configured will then be kicked off in
this way. A simple external initiator in psedo code could look like this:


    while(True):
        send_api_call_with_external_initiator_access_key_headers()
        sleep(4)

And have this job run on the same machine as your node.

## What's next

  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/building-external-initiators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the GET>bool function in the given text?,"To perform an HTTP GET request to any public API, parse the response, and return a boolean value.",{'source': 'https://docs.chain.link/any-api/testnet-oracles/'},The purpose of the GET>bool function in the given text is to handle requests made through the LINK token and determine if the Distributor has violated or caused Google to violate any Anti-Bribery Laws. It is used to check if a violation has occurred or is likely to occur.,,"# Operator

  * Overview
  * Features
  * Multi-word Response
  * Factory deployment
  * Distributing funds to multiple addresses
  * Flexibility and security
  * API Reference
  * Methods
  * Events

Oracles must deploy an on-chain contract to handle requests made through the
LINK token (Read [Basic Request Model](/architecture-overview/architecture-request-model) to learn more).

When the _Basic Request_ model was introduced, node operators had to deploy
[Oracle
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol).
However, these come with some limitations, and soon, we introduced [operator
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).

note

In addition to replacing oracle contracts, operator contracts come with
additional features that add more security and flexibility for node operators.

## Features

### Multi-word Response

In the EVM architecture, a word is made up of 32 bytes. One limitation of the
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
contract is that it limits responses to requests to 32 bytes.

[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
doesn't have the same limitation as it supports a response made of multiple
EVM words.

### Factory deployment

To deploy an _Oracle_ contract, each node operator has to manually compile and
deploy
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol).
The vast number of Solidity versions and steps involved in verifying the
contract made it difficult for a client to verify that the deployed contract
had not been tampered with. To fix this, node operators can use a
[factory](/chainlink-nodes/contracts/operatorfactory) to deploy an instance of
the _operator_ contract. Moreover, the factory exposes a getter for clients to
check if it deployed a specific _operator_ contract address.

### Distributing funds to multiple addresses

A common pain point of node operators is keeping their addresses funded.
_Operator_ 's `distributeFunds` method allows node operators to fund multiple
addresses in a single transaction.

### Flexibility and security

By using multiple externally-owned accounts (EOAs) on Chainlink nodes and
[forwarder](/chainlink-nodes/contracts/forwarder) contracts, node operators
can set up different transaction-sending strategies.

note

As discussed in the [forwarder](/chainlink-nodes/contracts/forwarder)
contracts page:

  * Chainlink nodes' EOAs are hot wallets that fulfill requests.
  * These EOAs can be associated with one or multiple [forwarder](/chainlink-nodes/contracts/forwarder) contracts. The forwarder's owner must whitelist them to call the [forward](/chainlink-nodes/contracts/forwarder#forward) function. One operator contract owns one or multiple forwarder contracts.
  * Node operators manage their forwarder contracts through operator contracts. They use a secure wallet such as hardware or a multisig wallet as the operator's owner account.

## API Reference

The operator contract inherits
[AuthorizedReceiver](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/AuthorizedReceiver.sol)
and
[ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/edit/develop/contracts/src/v0.7/ConfirmedOwnerWithProposal.sol).
Read [AuthorizedReceiver](/chainlink-nodes/contracts/receiver) and
[ConfirmedOwnerWithProposal](/chainlink-nodes/contracts/ownership) API
references.

### Methods

#### oracleRequest

Legacy

Use `operatorRequest` function instead.


    function oracleRequest(address sender, uint256 payment, bytes32 specId, address callbackAddress, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. This is backwards compatible API with
[Oracle.sol
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol),
but the behavior changes because `callbackAddress` is assumed to be the same
as the request sender.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackAddress    | address | The consumer of the request                    |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### operatorRequest


    function operatorRequest(address sender, uint256 payment, bytes32 specId, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. Stores the hash of the params as the on-chain
commitment for the request. Emits OracleRequest event for the Chainlink node
to detect.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### fulfillOracleRequest

Legacy

Use `fulfillOracleRequest2` function instead.


    function fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data) external returns (bool)

Called by the Chainlink node to fulfill requests. Given params must hash back
to the commitment stored from `oracleRequest`. Will call the callback address'
callback function without bubbling up error checking in a `require` so that
the node can get paid. Emits OracleResponse event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes32 | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### fulfillOracleRequest2


    function fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data) external returns (bool)

Called by the Chainlink node to fulfill requests with multi-word support.
Given params must hash back to the commitment stored from `oracleRequest`.
Will call the callback address' callback function without bubbling up error
checking in a `require` so that the node can get paid. Emits OracleResponse
event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes   | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### transferOwnableContracts


    function transferOwnableContracts(address[] ownable, address newOwner) external

Transfer the ownership of ownable contracts. This is primarily intended for
authorized forwarders but could possibly be extended to work with future
contracts.

##### Parameters

| Name     | Type      | Description                      |
|:---------|:----------|:---------------------------------|
| ownable  | address[] | list of addresses to transfer    |
| newOwner | address   | address to transfer ownership to |
#### acceptOwnableContracts


    function acceptOwnableContracts(address[] ownable) public

Accept the ownership of an ownable contract. This is primarily intended for
authorized forwarders but could possibly be extended to work with future
contracts. Emits OwnableContractAccepted event.

_Must be the pending owner on the contract_

##### Parameters

| Name    | Type      | Description                                      |
|:--------|:----------|:-------------------------------------------------|
| ownable | address[] | list of addresses of Ownable contracts to accept |
#### setAuthorizedSendersOn


    function setAuthorizedSendersOn(address[] targets, address[] senders) public

Sets the fulfillment permission for `senders` on `targets`. Emits
TargetsUpdatedAuthorizedSenders event.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| targets | address[] | The addresses to set permissions on            |
| senders | address[] | The addresses that are allowed to send updates |
#### acceptAuthorizedReceivers


    function acceptAuthorizedReceivers(address[] targets, address[] senders) external

Accepts ownership of ownable contracts and then immediately sets the
authorized sender list on each of the newly owned contracts. This is primarily
intended for authorized forwarders but could possibly be extended to work with
future contracts.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| targets | address[] | The addresses to set permissions on            |
| senders | address[] | The addresses that are allowed to send updates |
#### withdraw


    function withdraw(address recipient, uint256 amount) external

Allows the node operator to withdraw earned LINK to a given address
`recipient`.

_The owner of the contract can be another wallet and does not have to be a
Chainlink node_

##### Parameters

| Name      | Type    | Description                           |
|:----------|:--------|:--------------------------------------|
| recipient | address | The address to send the LINK token to |
| amount    | uint256 | The amount to send (specified in wei) |
#### withdrawable


    function withdrawable() external view returns (uint256)

Displays the amount of LINK that is available for the node operator to
withdraw.

_We use`1` in place of 0 in storage_

##### Return values

|   Name | Type    | Description                                     |
|-------:|:--------|:------------------------------------------------|
|    nan | uint256 | The amount of withdrawable LINK on the contract |
#### ownerForward


    function ownerForward(address to, bytes data) external

Forward a call to another contract.

_Only callable by the owner_

##### Parameters

| Name   | Type    | Description   |
|:-------|:--------|:--------------|
| to     | address | address       |
| data   | bytes   | to forward    |
#### ownerTransferAndCall


    function ownerTransferAndCall(address to, uint256 value, bytes data) external returns (bool success)

Interact with other LinkTokenReceiver contracts by calling transferAndCall.

##### Parameters

| Name   | Type    | Description                                            |
|:-------|:--------|:-------------------------------------------------------|
| to     | address | The address to transfer to.                            |
| value  | uint256 | The amount to be transferred.                          |
| data   | bytes   | The extra data to be passed to the receiving contract. |
##### Return values

| Name    | Type   | Description   |
|:--------|:-------|:--------------|
| success | bool   | bool          |
#### distributeFunds


    function distributeFunds(address payable[] receivers, uint256[] amounts) external payable

Distribute funds to multiple addresses using ETH sent to this payable
function.

Array length must be equal, ETH sent must equal the sum of amounts. A
malicious receiver could cause the distribution to revert, in which case it is
expected that the address is removed from the list.

##### Parameters

| Name      | Type              | Description       |
|:----------|:------------------|:------------------|
| receivers | address payable[] | list of addresses |
| amounts   | uint256[]         | list of amounts   |
#### cancelOracleRequest


    function cancelOracleRequest(bytes32 requestId, uint256 payment, bytes4 callbackFunc, uint256 expiration) external

Allows recipient to cancel requests sent to this oracle contract. Will
transfer the LINK sent for the request back to the recipient address. Given
params must hash to a commitment stored on the contract in order for the
request to be valid. Emits CancelOracleRequest event.

##### Parameters

| Name         | Type    | Description                                          |
|:-------------|:--------|:-----------------------------------------------------|
| requestId    | bytes32 | The request ID                                       |
| payment      | uint256 | The amount of payment given (specified in wei)       |
| callbackFunc | bytes4  | The requester's specified callback function selector |
| expiration   | uint256 | The time of the expiration for the request           |
#### cancelOracleRequestByRequester


    function cancelOracleRequestByRequester(uint256 nonce, uint256 payment, bytes4 callbackFunc, uint256 expiration) external

Allows requester to cancel requests sent to this oracle contract. Will
transfer the LINK sent for the request back to the recipient address. Given
params must hash to a commitment stored on the contract in order for the
request to be valid. Emits CancelOracleRequest event.

##### Parameters

| Name         | Type    | Description                                          |
|:-------------|:--------|:-----------------------------------------------------|
| nonce        | uint256 | The nonce used to generate the request ID            |
| payment      | uint256 | The amount of payment given (specified in wei)       |
| callbackFunc | bytes4  | The requester's specified callback function selector |
| expiration   | uint256 | The time of the expiration for the request           |
#### getChainlinkToken


    function getChainlinkToken() public view returns (address)

Returns the address of the LINK token

This is the public implementation for chainlinkTokenAddress, which is an
internal method of the ChainlinkClient contract.

### Events

#### OracleRequest


    event OracleRequest(bytes32 specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)

#### CancelOracleRequest


    event CancelOracleRequest(bytes32 requestId)

#### OracleResponse


    event OracleResponse(bytes32 requestId)

#### OwnableContractAccepted


    event OwnableContractAccepted(address acceptedContract)

#### TargetsUpdatedAuthorizedSenders


    event TargetsUpdatedAuthorizedSenders(address[] targets, address[] senders, address changedBy)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/contracts/operator.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-04-05 00:56:37)
Chainlink- Issue when fetching an API in form of `bytes32`
URL: https://stackoverflow.com/questions/71745260/chainlink-issue-when-fetching-an-api-in-form-of-bytes32

Question Body:


I've been learning the chainlink API and trying to modify the
[example](https://docs.chain.link/docs/advanced-tutorial/) from the Chainlin's
documentation to get a `byets32` value from an API. The original code of the
example works well, but since the API I was hitting is returning a `byets32`
foem, the Chainlink job need to be configured to handle this type of return.
The node is given [here](https://docs.chain.link/docs/decentralized-oracles-
ethereum-mainnet/) with Kovan testnet. Here is my code

    
    
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
     */
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
         //Result of the api
         bytes32 public martket;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Get -> bytes32
         * Network: Kovan
         * Oracle: 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 (Chainlink Devrel   
         * Node)
         * Job ID: 7401f318127148a894c00c292e486ffd
         * Fee: 0.1 LINK
         */
        constructor() {
            setPublicChainlinkToken();
            // Get -> bytes32 node taken from documentation
            oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
            jobId = ""7401f318127148a894c00c292e486ffd"";
            fee = 0.1 * 10 ** 18; // (Varies by network and job)
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""MARKET"": ""CCCAGG"",
            //     }
            //    }
            //   }
            //  }
            
            //Get the MARKET field of API
            request.add(""path"", ""RAW,ETH,USD,MARKET""); // Chainlink nodes 1.0.0 and later support this format
            
           
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of bytes32
         */ 
        function fulfill(bytes32 _requestId, bytes32 _market) public recordChainlinkFulfillment(_requestId)
        {
            martket = _market;
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    

The value of `market` should be a `byets32` reprsenting ""CCCAGG"" as shown in
the API. But what I got was just `0x0...00` all the time, which means `market`
has not been modified yet. I've checked this various ways and found out that
the `fulfill` function never get rans. Then same thing happens when I changed
the `jobId` and `oracle` to handle `get-> int256`, `get -> bool` (of course I
did change the return type of the variable such that it's consistent with the
returning form of API). I also noticed that only the job `get -> uint256`
works well (the example from documentation also used this job). Does anyon
know why? Was my code wrong or the problem came from the node/job? Since I was
able the get the example right, I don't think the problem cam from my wallet.

Any help would be appreciated!



Answers:
(Answered on: 2022-08-10 09:12:51)


You can test with a GET>STRING JOB

  1. Go to this link: <https://docs.chain.link/docs/any-api-testnet-oracles/>
  2. Take the Oracle contract address relevant to your network. For instance: 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 for Goerli
  3. Use a Get>String job: 7d80a6386ef543a3abb52817f6707e3b

Make sure that your callback function expects to receive a string. (see a full
example here: <https://docs.chain.link/docs/api-array-response/>)



"
What is the purpose of this contract?,This is an example contract which uses hardcoded values for clarity. It uses un-audited code. Do not use this code in production.,{'source': 'https://docs.chain.link/getting-started/advanced-tutorial/'},"The purpose of this contract is to request Ethereum last market data from an API and store it in the contract. The `requestEthereumLastMarket` function is used to make the API request and specify the path to the desired data in the JSON response. The `req` variable is used to build the Chainlink request, and the `path` variable is used to specify the path to the desired data in the JSON response. The contract is designed to be used as a guide for creating custom Chainlink jobs and associated consumer contracts.
","
- https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example
- https://docs.chain.link/getting-started/conceptual-overview/","Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    





:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of OpenSSL in generating self-signed certificates for Chainlink node?,OpenSSL is needed to generate self-signed certificates for Chainlink node.,{'source': 'https://docs.chain.link/chainlink-nodes/resources/enabling-https-connections/'},"The purpose of OpenSSL in generating self-signed certificates for Chainlink node is to enable HTTPS connections. OpenSSL is used to generate the self-signed certificates that are necessary for securing the communication between the Chainlink node and other entities. These certificates are used to encrypt the data transmitted over the network and verify the identity of the parties involved in the communication. By generating self-signed certificates, the Chainlink node can establish secure connections and protect sensitive information.

",- https://docs.chain.link/chainlink-nodes/resources/enabling-https-connections/,"# Enabling HTTPS Connections

  * Overview

This guide will walk you through how to generate your own self-signed
certificates for use by the Chainlink node. You can also substitute self-
signed certificates with certificates of your own, like those created by
[Let's Encrypt](https://letsencrypt.org/).

TLS

You will need [OpenSSL](https://www.openssl.org) in order to generate your own
self-signed certificates.

Create a directory `tls/` within your local Chainlink directory:


    mkdir ~/.chainlink-sepolia/tls


    mkdir ~/.chainlink-goerli/tls


    mkdir ~/.chainlink/tls

Run this command to create a `server.crt` and `server.key` file in the
previously created directory:


    openssl req -x509 -out  ~/.chainlink-sepolia/tls/server.crt  -keyout ~/.chainlink-sepolia/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink-goerli/tls/server.crt  -keyout ~/.chainlink-goerli/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink/tls/server.crt  -keyout ~/.chainlink/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")

Next, add the `TLS_CERT_PATH` and `TLS_KEY_PATH` environment variables to your
`.env` file.


    echo ""TLS_CERT_PATH=/chainlink/tls/server.crt
    TLS_KEY_PATH=/chainlink/tls/server.key"" >> .env

If `CHAINLINK_TLS_PORT=0` is present in your `.env` file, remove it by
running:


    sed -i '/CHAINLINK_TLS_PORT=0/d' .env

Also remove the line that disables `SECURE_COOKIES` by running:


    code"": ""sed -i '/SECURE_COOKIES=false/d' .env

Finally, update your run command to forward port 6689 to the container instead
of 6688:


    cd ~/.chainlink-sepolia && docker run -p 6689:6689 -v ~/.chainlink-sepolia:/chainlink -it
    --env-file=.env smartcontract/chainlink local n


    cd ~/.chainlink-goerli && docker run -p 6689:6689 -v ~/.chainlink-goerli:/chainlink -it
    --env-file=.env smartcontract/chainlink local n


    cd ~/.chainlink && docker run -p 6689:6689 -v ~/.chainlink:/chainlink -it --env-file=.env
    smartcontract/chainlink local n

Now when running the node, you can access it by navigating to
<https://localhost:6689> if running on the same machine or with a ssh tunnel.

## What's next

  * [› Miscellaneous](/chainlink-nodes/resources/miscellaneous)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/resources/enabling-https-connections.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-10-26 03:26:08)
Error running hardhat node: error:0308010C:digital envelope routines::unsupported
URL: https://stackoverflow.com/questions/69717140/error-running-hardhat-node-error0308010cdigital-envelope-routinesunsupporte

Question Body:


tried running `npx hardhat node`

this is the error I got

    
    
    Error HH604: Error running JSON-RPC server: error:0308010C:digital envelope routines::unsupported
    
    For more info go to https://hardhat.org/HH604 or run Hardhat with --show-stack-traces
    

here is my config file.

    
    
    require('dotenv').config();
    require(""@nomiclabs/hardhat-ethers"");
    
    const KOVAN_RPC_URL = process.env.KOVAN_RPC_URL;
    const PRIVATE_KEY = process.env.PRIVATE_KEY;
    
    module.exports = {
      defaultNetwork: ""hardhat"",
      networks: {
        hardhat: {
        },
        kovan: {
          url: KOVAN_RPC_URL,
          accounts: [PRIVATE_KEY]
        }
      },
      solidity: {
        version: ""0.8.0"",
        settings: {
          optimizer: {
            enabled: true,
            runs: 200
          }
        }
      },
      paths: {
        sources: ""./contracts"",
        tests: ""./test"",
        cache: ""./cache"",
        artifacts: ""./artifacts""
      },
      mocha: {
        timeout: 20000
      }
    }



Answers:
(Answered on: 2021-10-28 03:59:53)


To solve this, you need to update your `package.json` with `export SET
NODE_OPTIONS=--openssl-legacy-provider`

    
    
      ""scripts"": {
        ""start"": ""export SET NODE_OPTIONS=--openssl-legacy-provider && npx hardhat node""
      },
    

Then, you can just run `yarn start` or `export SET NODE_OPTIONS=--openssl-
legacy-provider && npx hardhat node`

<https://github.com/webpack/webpack/issues/14532#issuecomment-951378874>



"
What are some improvements and changes introduced in Chainlink VRF v2?,"Chainlink VRF v2 includes improvements such as subscription management, variable callback gas limit, more configuration capability, multiple random outputs in a single request, and unified billing.",{'source': 'https://docs.chain.link/vrf/v2/subscription/migration-from-v1/'},"Some improvements and changes introduced in Chainlink VRF v2 include:

1. Subscription management: VRF v2 introduces a Subscription Manager application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces gas fees and eliminates the need to transfer LINK tokens for each individual request.

2. Variable Callback Gas Limit: VRF v2 allows adjusting the callback gas limit when receiving verifiable randomness, enabling more complex logic in the callback request function.

3. More configuration capability: VRF v2 allows defining the number of block confirmations required before generating and delivering verifiable randomness on-chain, providing flexibility and low latency.

4. Multiple Random Outputs in a Single Request: VRF v2 allows requesting multiple random numbers in a single on-chain transaction, reducing gas costs and response latency.

5. Unified Billing - Delegate Subscription Balance to Multiple Addresses: VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance.

","
- https://docs.chain.link/vrf/v2/subscription/migration-from-v1/
- https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/","# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  2. Import the new [`VRFConsumerBaseV2.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  3. Import the [`VRFCoordinatorV2Interface.sol` interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol). This interface includes the new `requestRandomWords` function.

  4. Add a `VRFConsumerBaseV2` constructor as shown in the [Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number) example.

  5. Change `requestRandomness` function calls to `requestRandomWords`. The `requestRandomWords` function requires several additional parameters.

  6. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparison between VRF v1 and VRF v2 (Direct funding method)
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparison between VRF v1 and VRF v2 (Direct funding method)

The main similarity between VRF v1 and VRF v2 Direct funding method is that
consuming contracts must be funded with LINK to pay for requests. However,
Chainlink VRF v2 includes several improvements.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper contracts](/vrf/v2/direct-funding/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

## Updating your applications to use VRF v2

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) guide for an example.

  1. Import and inherit the new [`VRFV2WrapperConsumerBase.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  2. Add a `VRFV2WrapperConsumerBase` constructor as shown in the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) example and use the correct VRF v2 Direct funding configuration.

  3. You can still call the `requestRandomness` function. However, the v2 `requestRandomness` function requires several different parameters (`callbackGasLimit` , `requestConfirmations` , `numWords`). See the [Supported networks](/vrf/v2/direct-funding/supported-networks) page to adjust them for your own needs.

  4. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are some improvements in Chainlink VRF v2 compared to VRF v1 Direct funding method?,"Chainlink VRF v2 includes improvements such as variable callback gas limit, more configuration capability, and multiple random outputs in a single request.",{'source': 'https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/'},"Some improvements in Chainlink VRF v2 compared to VRF v1 Direct funding method include:

1. Variable Callback Gas Limit: VRF v2 allows for adjusting the callback gas limit, allowing consuming contracts to execute more complex logic in the callback request function that receives the random values. The gas limits are higher than VRF v1 and vary depending on the underlying blockchain used.

2. More configuration capability: VRF v2 allows for defining how many block confirmations must pass before verifiable randomness is generated and delivered on-chain. The range is from 3 to 200 blocks, providing flexibility in balancing security and latency.

3. Multiple Random Outputs in a Single Request: VRF v2 allows for requesting multiple random numbers in a single on-chain transaction, reducing gas costs and response latency.

",https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/,"# Migrating from VRF v1

  * Overview
  * Comparison between VRF v1 and VRF v2 (Direct funding method)
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparison between VRF v1 and VRF v2 (Direct funding method)

The main similarity between VRF v1 and VRF v2 Direct funding method is that
consuming contracts must be funded with LINK to pay for requests. However,
Chainlink VRF v2 includes several improvements.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper contracts](/vrf/v2/direct-funding/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

## Updating your applications to use VRF v2

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) guide for an example.

  1. Import and inherit the new [`VRFV2WrapperConsumerBase.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  2. Add a `VRFV2WrapperConsumerBase` constructor as shown in the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) example and use the correct VRF v2 Direct funding configuration.

  3. You can still call the `requestRandomness` function. However, the v2 `requestRandomness` function requires several different parameters (`callbackGasLimit` , `requestConfirmations` , `numWords`). See the [Supported networks](/vrf/v2/direct-funding/supported-networks) page to adjust them for your own needs.

  4. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                                                                                                          | Suitable for infrequent one-off requests                                                                                                                                                                    |
| Supports multiple VRF consuming contracts connected to one subscription account                                                                                        | Each VRF consuming contract directly pays for its requests                                                                                                                                                  |
| VRF costs are calculated after requests are fulfilled and then deducted from the subscription balance. Learn how VRF costs are calculated for the subscription method. | VRF costs are estimated and charged at request time, which may make it easier to transfer the cost of VRF to the end user. Learn how VRF costs are calculated for the direct funding method.                |
| Reduced gas overhead and more control over the maximum gas price for requests                                                                                          | Higher gas overhead than the subscription method                                                                                                                                                            |
| More random values returned per single request. See the maximum random values per request for the Subscription supported networks.                                     | Fewer random values returned per single request than the subscription method, due to higher overhead. See the maximum random values per request and gas overhead for the Direct funding supported networks. |
| You don't have to estimate costs precisely for each request. Ensure that the subscription account has enough funds.                                                    | You must estimate transaction costs carefully for each request to ensure the consuming contract has enough funds to pay for the request.                                                                    |
| Requires a subscription account                                                                                                                                        | No subscription account required                                                                                                                                                                            |
| Supported on Arbitrum                                                                                                                                                  | Not yet supported on Arbitrum                                                                                                                                                                               |
| VRF costs are billed to your subscription account. Manage and monitor your balance                                                                                     | No refunds for overpayment after requests are completed                                                                                                                                                     |
| Flexible funding method first introduced in VRF v2. Compare the VRF v2 subscription method to VRF v1.                                                                  | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is Chainlink Functions and what are some use cases for it?,"Chainlink Functions is a platform that enables users to connect to public data sources, transform data, connect to password-protected data sources, connect to external decentralized databases, and fetch data from almost any Web2 system. Some use cases for it include connecting smart contracts to weather statistics for parametric insurance, calculating Twitter sentiment, and fetching data from AWS S3, Firebase, or Google Cloud Storage.",{'source': 'https://docs.chain.link/chainlink-functions/'},"Chainlink Functions is a feature provided by Chainlink that allows smart contracts to access a trust-minimized compute infrastructure. It enables smart contracts to send their code to a Decentralized Oracle Network (DON), where the code is executed by oracles in a serverless environment. The DON aggregates the results of the independent runs and returns the final result to the smart contract. Chainlink Functions can be used for various purposes, such as connecting to public data sources, transforming data, accessing password-protected data sources, interacting with decentralized databases, integrating with Web2 applications, and fetching data from Web2 systems. It provides off-chain computation without the need to run and configure a Chainlink Node. To use Chainlink Functions, a subscription account needs to be funded with LINK tokens to pay for the requests. The subscription is billed only when the DON fulfills the request. More information about Chainlink Functions can be found in the official Chainlink documentation [1].

Some use cases for Chainlink Functions include:
- Connecting smart contracts to public data sources, such as weather statistics or real-time sports results, for applications like parametric insurance or dynamic NFTs.
- Transforming public data before consumption, such as calculating Twitter sentiment or deriving asset prices from Chainlink Price Feeds.
- Accessing password-protected data sources, including IoT devices or enterprise resource planning systems.
- Interacting with external decentralized databases, like IPFS, for off-chain processes or low-cost governance voting systems.
- Integrating with Web2 applications and building complex hybrid smart contracts.
- Fetching data from various Web2 systems, such as AWS S3, Firebase, or Google Cloud Storage [2].

","[1] https://docs.chain.link/chainlink-functions/
[2] https://docs.chain.link/chainlink-functions/resources/add-functions-to-projects/","# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature improvements
along with interface and contract changes. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and add your EVM account address to the allow list.

## Supported networks

See the [Supported Networks](/chainlink-functions/supported-networks) page to
find a list of supported networks and contract addresses.

## What's next

  * [› Learn the basics in the Getting Started guide.](/chainlink-functions/getting-started)
  * [› Learn how to use more advanced capabilities in one of the Tutorials.](/chainlink-functions/tutorials)
  * [› Learn about core concepts, the Chainlink Functions architecture, and billing.](/chainlink-functions/resources)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Adding Chainlink Functions to an Existing Project

  * Overview
  * Before you begin
  * Configure Hardhat
  * Get the dependency contracts and scripts
  * Configure on-chain resources
  * Create a consumer contract
  * Deploy a consumer contract
  * Create and fund a subscription
  * Send requests
  * Create a request script

The [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) lets
you run several example requests, but extra steps are required to add
Chainlink Functions to your existing projects.

If you are new to Chainlink Functions, complete the steps in the [Getting
Started Guide](/chainlink-functions/getting-started) to learn the basics. If
you already have a project, you can skip to the Libraries and Dependencies
section.

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

Using Chainlink Functions to your existing projects requires the following
components:

  * **A consumer contract:** Use this contract to send requests to the Chainlink Functions decentralized oracle network (DON). The consumer contract imports the following dependencies: 
    * [FunctionsClient.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/dev/functions/FunctionsClient.sol): This includes several functions necessary to submit requests to the DON.
    * [ConfirmedOwner.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwner.sol) from the [@chainlink/contracts](https://www.npmjs.com/package/@chainlink/contracts) NPM package.
  * **A Chainlink Functions subscription:** The subscription is used to pay for Chainlink Functions requests when they are fulfilled. You can [create and fund](/chainlink-functions/resources/subscriptions) subscriptions using the starter kit tools, but this guide shows you how to manage subscriptions programmatically.

## Before you begin

This guide assumes you are using a [Hardhat](https://hardhat.org/) JavaScript
project with Node.js, but you can modify it to work with other frameworks. If
you already have a project, you can skip to the Libraries and Dependencies
section.

You must have a wallet with testnet LINK and native tokens to run this
example. This example uses Polygon Mumbai, but you can use any of the
[Supported Networks](/chainlink-functions/supported-networks). You can get
testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai) and
testnet MATIC at the [Polygon Faucet](https://faucet.polygon.technology/). To
learn how to get testnet funds for other networks, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

### Configure Hardhat

If you don't already have a Hardhat project, start one with the following
steps:

  1. Install [Node.js](https://nodejs.org/en/download/). **Note** : Node.js version 18 is required.

  2. Make a new project directory:
    
        mkdir new-functions-project && cd new-functions-project

  3. Create a new Node.js project:
    
        npm init

  4. Install Hardhat as a dev dependency:
    
        npm install --save-dev hardhat

  5. Install the dependency packages:
    
        npm install @chainlink/contracts @chainlink/env-enc @openzeppelin/contracts @openzeppelin/contracts-upgradeable eth-crypto dotenv axios vm2 is-http-url prompt-sync

  6. Create a new Hardhat project. For this example, create a JavaScript project and use the default configurations:
    
        npx hardhat

  7. Remove the `Lock.sol` contract that Hardhat creates by default. This contract is not necessary to compile it for this tutorial.
    
        rm ./contracts/Lock.sol

  8. Use `curl` to get the example hardhat config file `hardhat.config.js`:
    
        curl -o hardhat.config.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/hardhat.config.js

  9. Open `hardhat.config.js`. To use a different network, see the [Supported Networks](/chainlink-functions/supported-networks) page for a list of networks where Chainlink Functions DONs are available. This example uses Polygon Mumbai by default.

  10. For higher security, you should encrypt your environment variables at rest.

    1. Set an encryption password for your environment variables.
        
                npx env-enc set-pw

    2. Run `npx env-enc set` to configure a `.env.enc` file with the basic variables that you need to send your requests to the Polygon Mumbai network.

      * `POLYGON_MUMBAI_RPC_URL`: Set a URL for the Polygon Mumbai testnet. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.

      * `PRIVATE_KEY`: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to [Export a Private Key](https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key). Set this in the `.env` file. **Note** : The Chainlink Functions hardhat starter kit uses your private key to sign any transactions you make such as deploying your consumer contract, creating subscriptions, and making requests.
        
                npx env-enc set

Run the compile command for Hardhat or your framework of choice to make sure
everything is configured correctly. You will see several compile warnings, but
everything is correct if the Solidity files compile successfully. For this
example, run:


    npx hardhat compile

## Get the dependency contracts and scripts

Get the required libraries from the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You
can clone the repo and copy the folders into your existing project manually,
or use a single command to get a tarball through the GitHub API and extract
the folders you need to the correct location in your project.

  1. Open a terminal and change directories to the root of your project. Usually this is the folder with `package.json`.

  2. Run the `curl` command to download the latest tarball from the starter kit `main` branch and then run `tar -xf` with the `--strip` flag to extract only the files you need. The following command combines both steps:

MacOSLinux

    
        curl -L -o ../functions.tar.gz https://api.github.com/repos/smartcontractkit/functions-hardhat-starter-kit/tarball/main &&
    tar -xf ../functions.tar.gz --strip=1 --wildcards smartcontractkit-functions-hardhat-starter-kit-*/contracts/dev smartcontractkit-functions-hardhat-starter-kit-*/contracts/test smartcontractkit-functions-hardhat-starter-kit-*/FunctionsSandboxLibrary smartcontractkit-functions-hardhat-starter-kit-*/contracts/FunctionsConsumer.sol
    
        curl -L -o ../functions.tar.gz https://api.github.com/repos/smartcontractkit/functions-hardhat-starter-kit/tarball/main &&
    tar -xf ../functions.tar.gz --strip=1 -T <(echo -e ""smartcontractkit-functions-hardhat-starter-kit-*/contracts/dev\nsmartcontractkit-functions-hardhat-starter-kit-*/contracts/test\nsmartcontractkit-functions-hardhat-starter-kit-*/FunctionsSandboxLibrary\nsmartcontractkit-functions-hardhat-starter-kit-*/contracts/FunctionsConsumer.sol"")

When you are done, you should have the necessary dependencies in the following
directories:

  * `contracts/dev`
  * `contracts/test`
  * `FunctionsSandboxLibrary`

Run the compile command to make sure all the dependencies are satisfied. Add
missing dependencies or Hardhat configuration options as necessary. For
Hardhat, run `npx hardhat compile`.


    npx hardhat compile

## Configure on-chain resources

The on-chain resources are critical for Chainlink Functions to process your
requests.

  1. Create a consumer contract
  2. Deploy a consumer contract

### Create a consumer contract

Use the [FunctionsConsumer.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/FunctionsConsumer.sol), which is
already in your `./contracts` folder. You can modify it to fit your needs and
redeploy it later. Optionally, you can take an existing contract of your own
and enable it to handle Chainlink Functions requests. Just make sure that it
meets the requirements listed in this guide.

In general, a consumer contract requires several components:

  * To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol). You can read the API reference: [FunctionsClient](/chainlink-functions/api-reference/FunctionsClient).

This contract is not available in an NPM package, so you must download and
import it from within your project.

    
        import {Functions, FunctionsClient} from ""./dev/functions/FunctionsClient.sol"";

  * Use the [Functions.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/Functions.sol) library to get all the functions needed for building a Chainlink Functions request. You can read the API reference: [Functions](/chainlink-functions/api-reference/Functions).
    
        using Functions for Functions.Request;
    

  * The latest request id, latest received response, and latest received error (if any) are defined as state variables. Note `latestResponse` and `latestError` are encoded as dynamically sized byte array `bytes`, so you will still need to decode them to read the response or error:
    
        bytes32 public latestRequestId;
    bytes public latestResponse;
    bytes public latestError;

  * We define the `OCRResponse` event that your smart contract will emit during the callback
    
        event OCRResponse(bytes32 indexed requestId, bytes result, bytes err);

  * Pass the oracle address for your network when you deploy the contract:
    
        constructor(address oracle) FunctionsClient(oracle)

  * At any time, you can change the oracle address by calling the `updateOracleAddress` function.

  * The two remaining functions are:

    * `executeRequest` for sending a request. It receives the JavaScript source code, encrypted secrets, list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

      * It uses the `Functions`library to initialize the request and add any passed encrypted secrets or arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/Functions/#initializerequest), [adding secrets](/chainlink-functions/api-reference/Functions/#addinlinesecrets), and [adding arguments](/chainlink-functions/api-reference/Functions/#addargs).
            
                        Functions.Request memory req;
            req.initializeRequest(Functions.Location.Inline, Functions.CodeLanguage.JavaScript, source);
            if (secrets.length > 0) {
              req.addRemoteSecrets(secrets);
            }
            if (args.length > 0) req.addArgs(args);

      * It sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Finally, it stores the request id in `latestRequestId`.
            
                        bytes32 assignedReqID = sendRequest(req, subscriptionId, gasLimit);
            latestRequestId = assignedReqID;

    * `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `latestResponse` and `latestError` before emitting the `OCRResponse` event.
        
                latestResponse = response;
        latestError = err;
        emit OCRResponse(requestId, response, err);

Next, deploy the contract.

### Deploy a consumer contract

You can deploy consumer contracts using the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit), but
this example shows how to deploy the contract programmatically using a script.

  1. Use `curl` to get the example deployment script `deploy.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/deploy.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/deploy.js

  2. Open `deploy.js` in your editor of choice.

  3. Set the `oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  4. Set `const contractName` to the name of the contract that you want Hardhat to deploy. The `ethers.getContractFactory(contractName);` line creates a `ContractFactory` object using the contract that you define. For this example, use `FunctionsConsumer`.
    
        const contractName = ""FunctionsConsumer""
    
    ⋮
    
    const consumerContract = await ethers.getContractFactory(contractName);

  5. Save the file and run the script to deploy your contract. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run ./scripts/deploy.js --network your_network

Example:

    
        npx hardhat run ./scripts/deploy.js --network polygonMumbai

  6. If your contract deployed successfully, you will see the deployed consumer address. Record this address to use later:
    
        Deployed Functions Consumer address: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Next, create and fund your Chainlink Functions subscription.

### Create and fund a subscription

You can use the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to
create and manage your subscriptions. See [Managing Subscriptions](/chainlink-functions/resources/subscriptions) for instructions.

This example shows how to create and manage subscriptions programmatically.
You can create the subscription, fund the subscription, and authorize the
consumer all in one script. If you have not already signed up for limited Beta
access to Chainlink Functions, apply [here](http://functions.chain.link/) to
add your EVM account address to the Allow List.

  1. Ensure that the wallet address you are using to create the subscription has a sufficient LINK balance. You can get testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai). To get testnet funds for other networks, see the [LINK Token Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

  2. Use `curl` to get the example subscription script `functions-sub.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/functions-sub.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/functions-sub.js

  3. Open `functions-sub.js` in your editor of choice.

  4. Set `const linkAmount` with the amount of LINK you want to send to the subscription. You can retrieve extra funds later when you cancel the subscription.
    
        const linkAmount = ""1""

  5. Set `const consumer` to the address of the consumer contract that you deployed:
    
        const consumer = ""0x5484e266c2cD379800e6F27EaB097Bb806647CbF""

  6. Save the file and run the script. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run scripts/functions-sub.js --network your_network

Example:

    
        npx hardhat run scripts/functions-sub.js --network polygonMumbai

  7. If the script is successful, you the terminal prints your subscription ID. Record this ID to use for Chainlink Functions requests. You should see output similar to the following example:
    
        Subscription created with ID: 917
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Subscription 917 funded with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Adding consumer contract address 0x5484e266c2cD379800e6F27EaB097Bb806647CbF to subscription 917
    Authorized consumer contract: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Now that the consumer contract is deployed and the subscription is created and
funded with LINK, the on-chain resources are ready to handle your requests.
Next, create JavaScript code that you want to run on the DON, configure
arguments for the code, and create a script to send your request.

## Send requests

After your on-chain resources are configured, you can send Chainlink Functions
requests to the DON. This can be done from a Web3 application, script, another
on-chain smart contract, or any other location capable of submitting requests
to your consumer contract. This example shows you how to generate a request,
encrypt secrets, send your request, and read the fulfillment response.

Each request has the following components:

  * **Source code:** JavaScript code that will run on the DON.
  * **Arguments:** Optional arguments for the source code. The arguments that you need are defined in your source code. Depending on how you configured your source, you might not need any arguments at all.
  * **Secrets:** Optional secrets that your source code needs to access APIs or other interfaces. See the [Using Secrets in Requests](/chainlink-functions/tutorials/api-use-secrets) and [Using Off-chain Secrets](/chainlink-functions/tutorials/api-use-secrets-offchain) tutorials for examples.

### Create a request script

If you already have source code or want to write your own source code, put it
in a file in your project. Later, you can specify the path to this file before
you submit your request.

For this example, download some example source code and create a script to
assemble the required components. The script will read your source code,
define arguments, encrypt secrets, and send requests to your consumer
contract. This example script does not require Hardhat, so you can modify it
to run in a browser using Ethers or another framework.

  1. Use `curl` to get the example source code. This code runs on each node in the DON and returns a response to your consumer contract. For this example, use the source from the [Call an API](/chainlink-functions/tutorials/api-query-parameters) tutorial. The following `curl` request creates a file named `Functions-request-source.js` with the source code:
    
        curl -o Functions-request-source.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/Functions-request-source.js

  2. Get the example script and put it in the `./scripts` directory:
    
        curl -o ./scripts/request.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/request.js

  3. Edit the `request.js` script and set your deployed consumer address in `const consumerAddress`:
    
        const consumerAddress = 0x5484e266c2cd379800e6f27eab097bb806647cbf

  4. Set `const subscriptionId` to your Chainlink Functions subscription ID. This must be the same ID that your consumer contract is authorized to use. You can [add a consumer contract to a subscription](/chainlink-functions/resources/subscriptions#add-a-consumer-contract-to-a-subscription) later if you need to.
    
        const subscriptionId = 917

  5. Set `const consumerAbiPath` to the ABI file that you created when you ran `npx hardhat compile`. The ABI tells Ethers how to interact with your deployed contract. If you compiled and deployed `FunctionsConsumer.sol`, set a path like the following example:
    
        const consumerAbiPath = ""./artifacts/contracts/FunctionsConsumer.sol/FunctionsConsumer.json""

  6. Set `const source` with the path to the request source code that you downloaded earlier:
    
        const source = ./Functions-request-source.js

  7. Set `const args` with an array of arguments for the DON to use when it runs your source. If you look at the `Functions-request-source.js` file, you can see that it requires two arguments. The args define which assets to retrieve from the data source URL.
    
        const args = [""ETH"", ""USD""]

  8. Set `const oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  9. Set `const oracleAbiPath` to the ABI for the oracle contract. If you downloaded and compiled the dependencies for deploying your consumer contract, the oracle ABI is already generated in `./artifacts/contracts/dev/functions/`:
    
        const oracleAbiPath = ""./artifacts/contracts/dev/functions/FunctionsOracle.sol/FunctionsOracle.json""

  10. Secrets are not required for this example.

  11. Save and close the script.

  12. Run the script to send the request to the DON.
    
        npx hardhat run scripts/request.js --network your_network

Example:

    
        npx hardhat run scripts/request.js --network polygonMumbai

If the script runs successfully, the script reads your consumer contract and
prints the stored value that the DON returned.


    Waiting 2 blocks for transaction 0x949184e7b605f034ce1d1d954973dc7132efb815bfa4861c54774cee457566d8 to be confirmed...
    
    Request 0xb3a4f9f47caeb83c5125ee61e2db1ca41beaa8a6781fb3c4364b4d394c40bc6b initiated
    Waiting for fulfillment...
    
    
    Request 0xb3a4f9f47caeb83c5125ee61e2db1ca41beaa8a6781fb3c4364b4d394c40bc6b fulfilled!
    Response returned to client contract represented as a hex string: 180972

Now you have the tools you need to build your own applications that use
Chainlink Functions. Modify `Functions-request-source.js` and your input
arguments to try out different capabilities. For more examples, see the
[Tutorials](/chainlink-functions/tutorials) section.

## What's next

  * [› Try out the Chainlink Functions Tutorials](/chainlink-functions/tutorials)
  * [› Read the Concepts page to learn about the core concepts behind Chainlink Functions](/chainlink-functions/resources/concepts)
  * [› Read the Architecture to understand how Chainlink Functions operates](/chainlink-functions/resources/architecture)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/add-functions-to-projects.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the AggregatorV3Interface contract?,"The AggregatorV3Interface contract is used to get data from a specific round or the latest round of an aggregator, and to get the number of decimals and description of the aggregator.",{'source': 'https://docs.chain.link/data-feeds/api-reference/'},"The purpose of the AggregatorV3Interface contract is to provide an interface for accessing data feeds, such as asset pricing data, in smart contracts. It defines functions for retrieving the latest price data from a specific data feed address. The contract is used to connect smart contracts to real-world services or off-chain data. It is part of the Chainlink ecosystem and can be imported and used in Solidity smart contracts.",,"Question: (Asked on: 2023-01-06 09:55:44)
ParserError: Source &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot; not found: File outside of allowed directories
URL: https://stackoverflow.com/questions/75029401/parsererror-source-chainlink-contracts-src-v0-8-interfaces-aggregatorv3interf

Question Body:


I'm trying to compile a ""FundMe.sol"" contract: the issue is that when I try to
compile it I keep getting the following Compiler Error:

    
    
    Brownie v1.19.2 - Python development framework for Ethereum
    
    New compatible solc version available: 0.8.0
    Compiling contracts...
      Solc version: 0.8.0
      Optimizer: Enabled  Runs: 200
      EVM Version: Istanbul
    CompilerError: solc returned the following errors:
    
    ParserError: Source ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
      --> contracts/FundMe.sol:15:1:
       |
    15 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    

The contract is included inside of the ""contracts"" folder (initted by
brownie), moreover I have created the ""brownie-config.yaml"" file which should
remap @chainlink - I feel as it might have contain some kind of error aswell.

I'm including all the mentioned files down below:

**Project Folder** : [brownie_fund_me](https://i.stack.imgur.com/HEeeo.png)

**FundMe.sol** :

    
    
    //SPDX-License-Identifier: MIT
    //Last update: 25/12/2022
    
    /* ***** ABI = Application Binary Interface *****
     * Interfaces compile down to an ABI. 
     *
     * ABI tells Solidity and other coding languages
     * how it can interact with other contracts. 
     *
     * Anytime you want to interact with another
     * deployed contract, you will need that contracts' ABI.
     */
    
    pragma solidity >=0.6.0 <0.9.0;
    
    // ***** Imports *****
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";   //The following library is shown below
    /*
     *
     *      interface AggregatorV3Interface 
     *      {
     *       function decimals() external view returns (uint8);
     *
     *       function description() external view returns (string memory);
     *
     *       function version() external view returns (uint256);    <-------------- Version
     *
     *       function getRoundData(uint80 _roundId) external view returns 
     *       (
     *           uint80 roundId,
     *           int256 answer,          
     *           uint256 startedAt,
     *           uint256 updatedAt,
     *           uint80 answeredInRound
     *       );
     *
     *       function latestRoundData() external view returns 
     *       (
     *           uint80 roundId,
     *           int256 answer,             <---------- Value in USD
     *           uint256 startedAt,
     *           uint256 updatedAt,
     *           uint80 answeredInRound
     *       );
     *      }
     *
     */
    
    // ***** FundMe *****
    // The following contract allows the end users to send a minimum amount
    // of ETH without being able to retrive it.
    // This contract is a good example of crowd funding.
    contract FundMe{
        
        // ***** AddressToAmountFunded *****
        // The following mapping allows the user to access the amount funded
        // by somebody, provided the address.
        mapping (address => uint256) public AddressToAmountFunded;
    
        // Array of addresses where the address of each funder will be stored in a temporary way
        // Every time the owner calls the withdraw function, the array is being reset
        address[] public funders;
    
        // Owners' address: this will be the only address being able to withdraw
        address public owner;
    
        // Constructor is called automatically and istantly when the contract is being deployed
        // Such thing allows the deployer of the contract to be the owner
        constructor() public
        {
            owner = msg.sender;     // msg.sender is who calls a function, in the constructor case, who deploys the contract
        }
    
        // ***** onlyOwner *****
        // The following modifier is used in the declaration of functions, such as withdraw, 
        // in order to allow the function, to be called only by the owner.
        modifier onlyOwner
        {
            require(msg.sender == owner);      // Whoever calls the function (msg.sender) must be the owner
            _;                                 // The ""_;"" means that we call the instruction after we check that the address of the caller is equal to owner
        }
    
        // ***** fund *****
        // The following function allows the users to fund the contract with a minimum amount of money ""minimumUSD""
        // to this date (25/12/2022) 50$ = 0,041ETH = 41000000000000000Wei = (41 * 10^15)Wei - to update the value, check the USD/ETH change and convert to Wei here https://eth-converter.com/
        // If the amount funded is <= minimumUSD the transaction will not go through and will lead to an inversion of the
        // transaction
        // ! ! ! ! ! Please notice that the amount funded cannot be retrived in any way ! ! ! ! !
        function fund() public payable
        {
            uint256 minimumUSD = 41 * 10 ** 15;                                                                                        // Minimum amount transferable
            require(msg.value >= minimumUSD, ""The amount of ETH you sent is less then 50$ - Transaction is being inverted"");           // ""msg.value"" is a keyword that stays for the amount of Wei sent
    
            AddressToAmountFunded[msg.sender] += msg.value;             // Given an address, the mapping will return the amount funded by such account - Note that these values will be reset every time withdraw is called
            funders.push(msg.sender);                                   // The funders' address will be added to the funders array - Note that these values will be reset every time withdraw is called
        }
    
        // ***** getVersion *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current version of the contract/library AggregatorV3Interface
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getVersion() public view returns(uint256)
        {      
            return AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e).version();     // .version method is contained inside of AggregatorV3Interface, the address can be find here
            //                                                                                                                                                                                 |
            // The function works also if written like this:                                                                                                                                   |
            // AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);  <--- Address                                                              |
            // return priceFeed.version();                                                                           <--- ABI                                                                 /
            // You can find the Addresses for AggregatorV3Interface here ---> https://docs.chain.link/data-feeds/price-feeds/addresses/ <----------------------------------------------------
        }
    
        // ***** getPrice *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current value of 1ETH in USD, please note that you will get an apporximate value 
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getPrice() public view returns(uint256)
        {
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);    // .latestRoundData method is contained inside of AggregatorV3Interface, the address can be found above
            (,int256 answer,,,) = priceFeed.latestRoundData();                                                      // The method returns 5 different values, we exclude all of them but answer, for further understanding check at AggregatorV3Interface under imports
            return uint256(answer / 10 ** 8);                                                                       // Answer is divided by 10^8 so that the value in USD has no decimals and is easier to read
            
            // Historical:
            // 23/12/2022 - 1,226.67395017
            // 25/12/2022 - 1,220.00000000
        }
    
        // ***** getConvertionRate *****
        // The following function could be considered an extension of getPrice : given
        // the amount of ETH, the function will return the current value of such amount of ETH
        // in USD
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getConvertionRate(uint256 ETH_Amount) public view returns(uint256)
        {
            uint256 ETH_Price = getPrice();                         // Calls getPrice function
            uint256 ETH_AmountInUSD = ETH_Price * ETH_Amount;       // Current ETH pirce * ETH amount
            return ETH_AmountInUSD;                                 // Returns the value of amount ETH in USD
        }
    
        // ***** withdraw *****
        // The following function allows the deployer of the contract (owner) to withdraw
        // the amount of ETH funded to the contract, moreover when the function is called,
        // the funders array will be reset
        function withdraw() payable onlyOwner public                // Check for onlyOwner modifier description at line 77
        {
            payable(msg.sender).transfer(address(this).balance);    // This line of code allows the withdrawal, this refers to the contract
    
            for(uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++)   // The following cycle allows the reset of the money
            {                                                                           // value sent by the funders, accessible through mapping
                address funder = funders[funderIndex];
                AddressToAmountFunded[funder] = 0;
            }
    
            funders = new address[] (0);                            // funders array gets reset, so that it's able to store new values starting from 0
        }
    }
    
    

**brownie-config.yaml** :

    
    
    dependencies:
      # - <organization/repo@version>
      - smartcontractkit/chainlink-brownie-contracts@0.5.1
      
    compiler:
      solc:
        remappings:
          - '@chainlink = smartcontractkit/chainlink-brownie-contracts@0.5.1' 
    

I'm quiet new to ""python-solidity"" coding, but so far I had managed to
overcome all the issues that were popping up. I have spent over 2 days tring
to find a solution to this problem - it's becoming really frustrating. I'm
really thankful to whoever - at least - tries helping me!

**Solutions I tried:**

  * Changing versions of pragma solidity, imports and repo;
  * Adding a .vscode folder --> setting.json containing a path to solidity remappings
  * Updating solc and brownie



Answers:
(Answered on: 2023-01-07 09:23:18)


Can you try `npm install @chainlink/contracts` or `pip3 install
@chainlink/contracts` again and compile it?





:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the HTTPGet adapter?,The HTTPGet adapter is used to make a GET request to a specified URL and return the response body.,{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/'},"The purpose of the HTTPGet adapter is to perform a GET request to a specified URL and report the body of a successful response or return an error if the response status code is greater than or equal to 400.
",https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/,"# Core Adapters [v1]

  * Overview
  * Adapters
  * Compare
  * Copy
  * EthBool
  * EthBytes32
  * EthInt256
  * EthTx
  * EthUint256
  * HttpGet
  * HttpPost
  * JsonParse
  * Multiply
  * NoOp
  * NoOpPend
  * Quotient
  * Sleep

# REMOVED

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

## Adapters

Core adapters are the built-in functionality that every Chainlink node
supports. Strung together, they act as tasks that need to be performed to
complete a Job.

Adapters that are prefixed with ""Eth"" refer to tasks that post data onto the
chain. Here are some examples of the data types that adapters convert data to.

| Name              | Core Adapter   | Ethereum Data Type   |
|:------------------|:---------------|:---------------------|
| Signed Integers   | EthInt256      | int256               |
| Unsigned Integers | EthUint256     | uint256              |
| Bytes             | EthBytes32     | bytes32              |
| Boolean           | EthBool        | bool                 |
You can learn more about Solidity data types
[here](https://docs.soliditylang.org/en/latest/types.html).

## Compare

This core adapter compares a user-specified value with the value from the
previous adapter's result.

#### Parameters

  * `operator`: the operator used to compare values. You may use one of the following: 
    * `eq`: Equals
    * `neq`: Not equals
    * `gt`: Greater than
    * `gte`: Greater than or equals to
    * `lt`: Less than
    * `lte`: Less than or equals to
  * `value`: the value to check against the previous adapter's result. May be a string or a number, but if the value is a string, only `eq` and `neq` may be used.

#### Solidity Example


    req.addInt(""value"", 10000);
    req.add(""operator"", ""gte"");

## Copy

The core adapter walks the `copyPath` specified and returns the value found at
that result. If returning JSON data from an [external adapter](/chainlink-nodes/external-adapters/external-adapters), you will need to use this adapter
to parse the response.

#### Parameters

  * `copyPath`: takes an array of strings, each string being the next key to parse out in the JSON object or a single dot-delimited string.

#### Solidity Example

For the JSON object:


    { ""RAW"": { ""ETH"": { ""USD"": { ""LASTMARKET"": ""_someValue"" } } } }

You would use the following for an array of strings:


    string[] memory path = new string(4);
    path[0] = ""RAW"";
    path[1] = ""ETH"";
    path[2] = ""USD"";
    path[3] = ""LASTMARKET"";
    req.addStringArray(""copyPath"", path);

Or the following for a single comma-delimited string:


    req.add(""copyPath"", ""RAW,ETH,USD,LASTMARKET"");

note

#### Job Specification Example


    {
      ""type"": ""Copy"",
      ""params"": {
        ""copyPath"": [""RAW"", ""ETH"", ""USD"", ""LASTMARKET""]
      }
    }

For arrays, you can access the path of an array by using the index. If this is
your JSON:


    { ""endpoint"": [{ ""path"": ""value"" }] }

You could get the `""value""` by:


    req.add(""copyPath"", ""endpoint.0.path"");

## EthBool

The core adapter reads the given Boolean value and then converts it into
Solidity's `bool` format.

#### Parameters

_None taken._

## EthBytes32

The core adapter formats its input into a string and then converts it into
Solidity's `bytes32` format.

#### Parameters

_None taken._

## EthInt256

The core adapter formats its input into an integer and then converts it into
Solidity's `int256` format.

#### Parameters

_None taken._

## EthTx

The core adapter takes the input given and places it into the data field of
the transaction. It then signs an Ethereum transaction and broadcasts it to
the network. The task is only completed once the transaction's confirmations
equal the
[`MIN_OUTGOING_CONFIRMATIONS`](https://github.com/smartcontractkit/chainlink/wiki/Configuration-Variables#min_outgoing_confirmations) amount.

If the transaction does not confirm by the time
[`ETH_GAS_BUMP_THRESHOLD`](https://github.com/smartcontractkit/chainlink/wiki/Configuration-Variables#eth_gas_bump_threshold) number of blocks have passed since initially
broadcasting, then it bumps the gas price of the transaction by
[`ETH_GAS_BUMP_WEI`](https://github.com/smartcontractkit/chainlink/wiki/Configuration-Variables#eth_gas_bump_wei).

#### Parameters

  * `address`: the address of the Ethereum account which the transaction will be sent to.
  * `functionSelector`: **(optional)** the [function selector](https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#function-selector) of the contract which the transaction will invoke. `functionSelector` is placed before `dataPrefix` and the adapter's input in the data field of the transaction.
  * `dataPrefix`: **(optional)** data which will be prepended before the adapter's input, but after the `functionSelector` in the transaction's data field.
  * `value`: **(optional)** data to send to the function, will append after the `dataPrefix` payload if it's included. Will automatically come from the previous task.

## EthUint256

The core adapter formats its input into an integer and then converts it into
Solidity's `uint256` format.

#### Parameters

_None taken._

## HttpGet

The core adapter will report the body of a successful `GET` request to the
specified `get`, or return an error if the response status code is greater
than or equal to 400.

#### Parameters

  * `get`: takes a string containing the URL to make a `GET` request to.
  * `queryParams`: takes a string or array of strings for the URL's query parameters.
  * `extPath`: takes a slash-delimited string or array of strings to be appended to the job's URL.
  * `headers`: takes a object containing keys as strings and values as arrays of strings.

Headers

Currently not available on-chain. Available for job specs only.

#### Solidity Example


    req.add(""get"", ""http://example.com"");
    req.add(""queryParams"", ""firstKey=firstVal&secondKey=secondVal"");
    req.add(""extPath"", ""price/BTC/USD"");

#### Job Specification Example


    {
      ""type"": ""HttpGet"",
      ""params"": {
        ""get"": ""https://example.com/some-endpoint"",
        ""headers"": {
          ""X-API-Key"": [""abc123abc123abc123abc123""]
        }
      }
    }

Local network and multicast IPs are disallowed by default

For security, because the URL can come from an untrusted source, HTTPGet
imposes some restrictions on which IPs may be fetched. Local network and
multicast IPs are disallowed by default and attempting to connect will result
in an error.

If you really must access one of these IPs, you can use the
`HTTPGetWithUnrestrictedNetworkAccess` adapter instead.

## HttpPost

The core adapter will report the body of a successful `POST` request to the
specified `post`, or return an error if the response status code is greater
than or equal to 400.

#### Parameters

  * `post`: takes a string containing the URL to make a `POST` request to.
  * `headers`: takes a object containing keys as strings and values as arrays of strings.
  * `queryParams`: takes a string or array of strings for the URL's query parameters.
  * `extPath`: takes a slash-delimited string or array of strings to be appended to the job's URL.
  * `body`: the JSON body (as a string) that will be used as the data in the request.

note

#### Solidity Example


    req.add(""post"", ""http://post.example.com"");
    req.add(""queryParams"", ""firstKey=firstVal&secondKey=secondVal"");
    req.add(""extPath"", ""price/BTC/USD"");

#### Job Specification Example


    {
        ""type"": ""HttpPost"",
        ""params"": {
            ""post"": ""https://example.com/some-endpoint"",
            ""headers"": {
                ""X-API-Key"": [
                    ""abc123abc123abc123abc123""
                ]
            }
        }
    }

Local network and multicast IPs are disallowed by default

For security, because the URL can come from an untrusted source, HTTPGet
imposes some restrictions on which IPs may be fetched. Local network and
multicast IPs are disallowed by default and attempting to connect will result
in an error.

If you really must access one of these IPs, you can use the
`HTTPPostWithUnrestrictedNetworkAccess` adapter instead.

## JsonParse

The core adapter walks the `path` specified and returns the value found at
that result. If returning JSON data from the [HttpGet](/chainlink-nodes/oracle-jobs/v1/adapters/#httpget) or [HttpPost](/chainlink-nodes/oracle-jobs/v1/adapters/#httppost) adapters, you must use this adapter to parse the
response.

#### Parameters

  * `path`: takes an array of strings, each string being the next key to parse out in the stringified JSON result or a single dot-delimited string.

#### Solidity Example

For the stringified JSON:


    { ""RAW"": { ""ETH"": { ""USD"": { ""LASTMARKET"": ""_someValue"" } } } }

You would use the following for an array of strings:


    string[] memory path = new string[](4);
    path[0] = ""RAW"";
    path[1] = ""ETH"";
    path[2] = ""USD"";
    path[3] = ""LASTMARKET"";
    req.addStringArray(""path"", path);

Or the following for a single comma-delimited string:


    req.add(""path"", ""RAW,ETH,USD,LASTMARKET"");

note

Chainlink nodes prior to 1.0.0 support dot-delimited strings instead of comma-
delimited strings.

#### Job Specification Example


    {
      ""type"": ""JsonParse"",
      ""params"": {
        ""path"": [""RAW"", ""ETH"", ""USD"", ""LASTMARKET""]
      }
    }

#### Parsing Arrays


    req.add(""path"", ""3,standardId"");

The above example parses the 4th object of the following JSON response and
returns 677 as a result:


    ;[
      {
        standardId: 20,
        name: ""ERC-20"",
      },
      {
        standardId: 721,
        name: ""ERC-721"",
      },
      {
        standardId: 1155,
        name: ""ERC-1155"",
      },
      {
        standardId: 677,
        name: ""ERC-677"",
      },
    ]

## Multiply

The core adapter parses the input into a float and then multiplies it by the
`times` field.

#### Parameters

  * `times`: the number to multiply the input by.

#### Solidity Example


    run.addInt(""times"", 100);

## NoOp

The core adapter performs no operations, simply passing the input on as
output. Commonly used for testing.

#### Parameters

_None taken._

## NoOpPend

The core adapter performs no operations, and marks its task run pending.
Commonly used for testing.

#### Parameters

_None taken._

## Quotient

Quotient

The core adapter gives the result of x / y where x is a specified value
(dividend) and y is the input value (result).

This can be useful for inverting outputs, e.g. if your API only offers a
USD/ETH conversion rate and you want ETH/USD instead you can use this adapter
with a dividend of 1 to get the inverse (i.e. 1 / result).

#### Parameters

  * `dividend`: the number which is divided by the result

## Sleep

The core adapter will pause the current task pipeline for the given duration.

ENABLE_EXPERIMENTAL_ADAPTERS

You must set `ENABLE_EXPERIMENTAL_ADAPTERS=true` in order to use the sleep
adapter.

#### Parameters

  * `until`: the UNIX timestamp of when the job should stop sleeping and resume at the next task in the pipeline.

#### Solidity Example


    req.addUint(""until"", now + 1 hours);

#### Job Specification example


    {
      ""initiators"": [
        {
          ""type"": ""web"",
          ""params"": {
          }
        }
      ],
      ""tasks"": [
        {
          ""type"": ""sleep"",
          ""params"": {
            ""until"": ""1605651000""
          }
        }
      ]
    }

## What's next

  * [› Introduction to External Adapters](/chainlink-nodes/external-adapters/external-adapters)
  * [› Initiators](/chainlink-nodes/oracle-jobs/v1/initiators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/adapters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Job Specifications [v1]

  * Overview
  * What is a job?

# REMOVED

v1 Jobs are removed

The v1 job spec or JSON spec removed for Chainlink nodes running version 1.0.0
and later. If you are still running this type of job, migrate them to v2
specs.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

## What is a job?

Job specifications, or specs, contain the sequential tasks that the node must
perform to produce a final result. Chainlink jobs are divided into 2 segments.

  * [Initiators](/chainlink-nodes/oracle-jobs/v1/initiators)
  * [Adapters](/chainlink-nodes/oracle-jobs/v1/adapters) (also known as tasks)

A job must contain at least one of each.

**Initiators** define _when_ a job will run. **Adapters** define _how_ a job
will run.

Specs are defined using standard JSON so that they are human-readable and can
be easily parsed by the Chainlink node.

Here is an example of a spec:


    {
      ""initiators"": [
        {
          ""type"": ""RunLog"",
          ""params"": { ""address"": ""0x51DE85B0cD5B3684865ECfEedfBAF12777cd0Ff8"" }
        }
      ],
      ""tasks"": [
        {
          ""type"": ""HTTPGet"",
          ""confirmations"": 0,
          ""params"": { ""get"": ""https://bitstamp.net/api/ticker/"" }
        },
        {
          ""type"": ""JSONParse"",
          ""params"": { ""path"": [""last""] }
        },
        {
          ""type"": ""Multiply"",
          ""params"": { ""times"": 100 }
        },
        { ""type"": ""EthUint256"" },
        { ""type"": ""EthTx"" }
      ],
      ""startAt"": ""2020-02-09T15:13:03Z"",
      ""endAt"": null,
      ""minPayment"": ""1000000000000000000""
    }

This example shows the two main components of a spec: initiators and tasks.
[Initiators](/resources/glossary/#initiator) determine how the spec will
start. [Tasks](/resources/glossary/#task-spec) are the individual steps that
the Chainlink node follows to process data in order to produce a result.

In the example above, we see that the only initiator is a RunLog. This means
that the spec can only be started when a specific event log is emitted from a
specified address. The specified address will be the address of the oracle
contract on Ropsten, which manages requests from contracts and responses from
Chainlink nodes.

The five tasks (referred to as [core adapters](/chainlink-nodes/oracle-jobs/v1/adapters)) in the example above follow a common pattern for requesting
data from the Chainlink network, and returning a single result. Each task
takes three fields: `type`, `confirmations`, and `params`. The `type` is the
adapter or [bridge](/resources/glossary/#bridge) name and is required.
`confirmations` is optional, and will default to 0. `params` is also optional,
and will default to an empty object if not specified. See the [core
adapters](/chainlink-nodes/oracle-jobs/v1/adapters) page for a complete list
of `params` for each adapter.

  1. The **HTTPGet** adapter uses the value in the `get` field to perform a standard HTTP GET request at the value specified. The body of that result is passed on to the next task, JSONParse.
  2. The **JSONParse** adapter takes a dot-delimited string or an array of strings, and will walk the given path to store the value at the end. In this case, there is only one field to save, ""last"". JSONParse will then pass the value stored in the ""last"" field to the Multiply adapter.
  3. The **Multiply** adapter will, as its name describes, multiply the given value by the value of the `times` field, in this case, 100.
  4. The multiplied value will be passed to the **EthUint256** adapter, which will format it specifically for the `uint256` data type on Ethereum. Notice there are no parameters supplied to the EthUint256 adapter, as it does not accept any.
  5. Finally, that formatted value is written to the blockchain with the **EthTx** adapter. The parameters for the EthTx adapter are given by the oracle contract when the run is initiated through the RunLog initiator.

Note: If specifying multiple adapters of the same type, the parameters can be
specified in the job spec itself if the key values need to be different. The
requester can also use run parameters for these requests, but shared keys will
be the same for any adapter that uses them.

Additional parameters may be specified on the job as well. These include:

  * **startAt** : The beginning date at which the job can be executed, specified in ISO 8601 standard. Jobs can not be ran before this date. Defaults to null if unspecified.
  * **endAt** : The ending date at which the job can be executed, specified in ISO 8601 standard. Jobs can not be ran after this date. Defaults to null if unspecified.
  * **minPayment** : The payment amount for this job, specified in LINK to the 18th decimal. If supplied, this will override the global `MIN_CONTRACT_PAYMENT` configuration set on the node, regardless if the value is lower or higher.

## What's next

  * [› Core Adapters](/chainlink-nodes/oracle-jobs/v1/adapters)
  * [› Initiators](/chainlink-nodes/oracle-jobs/v1/initiators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/job-specifications.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the `oracleRequest` function in the `AuthorizedReceiver` contract?,The `oracleRequest` function creates a Chainlink request and assumes that the `callbackAddress` is the same as the request sender.,{'source': 'https://docs.chain.link/chainlink-nodes/contracts/operator/'},"The `oracleRequest` function in the `AuthorizedReceiver` contract is used to create a Chainlink request. It takes several parameters such as the sender of the request, the payment amount, the Job Specification ID, the callback address, the callback function ID, the nonce, the data version, and additional request parameters. This function is used to initiate a request to the Chainlink node for data retrieval and processing.

",https://docs.chain.link/chainlink-nodes/contracts/operator/,"# Operator

  * Overview
  * Features
  * Multi-word Response
  * Factory deployment
  * Distributing funds to multiple addresses
  * Flexibility and security
  * API Reference
  * Methods
  * Events

Oracles must deploy an on-chain contract to handle requests made through the
LINK token (Read [Basic Request Model](/architecture-overview/architecture-request-model) to learn more).

When the _Basic Request_ model was introduced, node operators had to deploy
[Oracle
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol).
However, these come with some limitations, and soon, we introduced [operator
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).

note

In addition to replacing oracle contracts, operator contracts come with
additional features that add more security and flexibility for node operators.

## Features

### Multi-word Response

In the EVM architecture, a word is made up of 32 bytes. One limitation of the
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
contract is that it limits responses to requests to 32 bytes.

[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
doesn't have the same limitation as it supports a response made of multiple
EVM words.

### Factory deployment

To deploy an _Oracle_ contract, each node operator has to manually compile and
deploy
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol).
The vast number of Solidity versions and steps involved in verifying the
contract made it difficult for a client to verify that the deployed contract
had not been tampered with. To fix this, node operators can use a
[factory](/chainlink-nodes/contracts/operatorfactory) to deploy an instance of
the _operator_ contract. Moreover, the factory exposes a getter for clients to
check if it deployed a specific _operator_ contract address.

### Distributing funds to multiple addresses

A common pain point of node operators is keeping their addresses funded.
_Operator_ 's `distributeFunds` method allows node operators to fund multiple
addresses in a single transaction.

### Flexibility and security

By using multiple externally-owned accounts (EOAs) on Chainlink nodes and
[forwarder](/chainlink-nodes/contracts/forwarder) contracts, node operators
can set up different transaction-sending strategies.

note

As discussed in the [forwarder](/chainlink-nodes/contracts/forwarder)
contracts page:

  * Chainlink nodes' EOAs are hot wallets that fulfill requests.
  * These EOAs can be associated with one or multiple [forwarder](/chainlink-nodes/contracts/forwarder) contracts. The forwarder's owner must whitelist them to call the [forward](/chainlink-nodes/contracts/forwarder#forward) function. One operator contract owns one or multiple forwarder contracts.
  * Node operators manage their forwarder contracts through operator contracts. They use a secure wallet such as hardware or a multisig wallet as the operator's owner account.

## API Reference

The operator contract inherits
[AuthorizedReceiver](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/AuthorizedReceiver.sol)
and
[ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/edit/develop/contracts/src/v0.7/ConfirmedOwnerWithProposal.sol).
Read [AuthorizedReceiver](/chainlink-nodes/contracts/receiver) and
[ConfirmedOwnerWithProposal](/chainlink-nodes/contracts/ownership) API
references.

### Methods

#### oracleRequest

Legacy

Use `operatorRequest` function instead.


    function oracleRequest(address sender, uint256 payment, bytes32 specId, address callbackAddress, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. This is backwards compatible API with
[Oracle.sol
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol),
but the behavior changes because `callbackAddress` is assumed to be the same
as the request sender.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackAddress    | address | The consumer of the request                    |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### operatorRequest


    function operatorRequest(address sender, uint256 payment, bytes32 specId, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. Stores the hash of the params as the on-chain
commitment for the request. Emits OracleRequest event for the Chainlink node
to detect.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### fulfillOracleRequest

Legacy

Use `fulfillOracleRequest2` function instead.


    function fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data) external returns (bool)

Called by the Chainlink node to fulfill requests. Given params must hash back
to the commitment stored from `oracleRequest`. Will call the callback address'
callback function without bubbling up error checking in a `require` so that
the node can get paid. Emits OracleResponse event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes32 | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### fulfillOracleRequest2


    function fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data) external returns (bool)

Called by the Chainlink node to fulfill requests with multi-word support.
Given params must hash back to the commitment stored from `oracleRequest`.
Will call the callback address' callback function without bubbling up error
checking in a `require` so that the node can get paid. Emits OracleResponse
event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes   | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### transferOwnableContracts


    function transferOwnableContracts(address[] ownable, address newOwner) external

Transfer the ownership of ownable contracts. This is primarily intended for
authorized forwarders but could possibly be extended to work with future
contracts.

##### Parameters

| Name     | Type      | Description                      |
|:---------|:----------|:---------------------------------|
| ownable  | address[] | list of addresses to transfer    |
| newOwner | address   | address to transfer ownership to |
#### acceptOwnableContracts


    function acceptOwnableContracts(address[] ownable) public

Accept the ownership of an ownable contract. This is primarily intended for
authorized forwarders but could possibly be extended to work with future
contracts. Emits OwnableContractAccepted event.

_Must be the pending owner on the contract_

##### Parameters

| Name    | Type      | Description                                      |
|:--------|:----------|:-------------------------------------------------|
| ownable | address[] | list of addresses of Ownable contracts to accept |
#### setAuthorizedSendersOn


    function setAuthorizedSendersOn(address[] targets, address[] senders) public

Sets the fulfillment permission for `senders` on `targets`. Emits
TargetsUpdatedAuthorizedSenders event.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| targets | address[] | The addresses to set permissions on            |
| senders | address[] | The addresses that are allowed to send updates |
#### acceptAuthorizedReceivers


    function acceptAuthorizedReceivers(address[] targets, address[] senders) external

Accepts ownership of ownable contracts and then immediately sets the
authorized sender list on each of the newly owned contracts. This is primarily
intended for authorized forwarders but could possibly be extended to work with
future contracts.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| targets | address[] | The addresses to set permissions on            |
| senders | address[] | The addresses that are allowed to send updates |
#### withdraw


    function withdraw(address recipient, uint256 amount) external

Allows the node operator to withdraw earned LINK to a given address
`recipient`.

_The owner of the contract can be another wallet and does not have to be a
Chainlink node_

##### Parameters

| Name      | Type    | Description                           |
|:----------|:--------|:--------------------------------------|
| recipient | address | The address to send the LINK token to |
| amount    | uint256 | The amount to send (specified in wei) |
#### withdrawable


    function withdrawable() external view returns (uint256)

Displays the amount of LINK that is available for the node operator to
withdraw.

_We use`1` in place of 0 in storage_

##### Return values

|   Name | Type    | Description                                     |
|-------:|:--------|:------------------------------------------------|
|    nan | uint256 | The amount of withdrawable LINK on the contract |
#### ownerForward


    function ownerForward(address to, bytes data) external

Forward a call to another contract.

_Only callable by the owner_

##### Parameters

| Name   | Type    | Description   |
|:-------|:--------|:--------------|
| to     | address | address       |
| data   | bytes   | to forward    |
#### ownerTransferAndCall


    function ownerTransferAndCall(address to, uint256 value, bytes data) external returns (bool success)

Interact with other LinkTokenReceiver contracts by calling transferAndCall.

##### Parameters

| Name   | Type    | Description                                            |
|:-------|:--------|:-------------------------------------------------------|
| to     | address | The address to transfer to.                            |
| value  | uint256 | The amount to be transferred.                          |
| data   | bytes   | The extra data to be passed to the receiving contract. |
##### Return values

| Name    | Type   | Description   |
|:--------|:-------|:--------------|
| success | bool   | bool          |
#### distributeFunds


    function distributeFunds(address payable[] receivers, uint256[] amounts) external payable

Distribute funds to multiple addresses using ETH sent to this payable
function.

Array length must be equal, ETH sent must equal the sum of amounts. A
malicious receiver could cause the distribution to revert, in which case it is
expected that the address is removed from the list.

##### Parameters

| Name      | Type              | Description       |
|:----------|:------------------|:------------------|
| receivers | address payable[] | list of addresses |
| amounts   | uint256[]         | list of amounts   |
#### cancelOracleRequest


    function cancelOracleRequest(bytes32 requestId, uint256 payment, bytes4 callbackFunc, uint256 expiration) external

Allows recipient to cancel requests sent to this oracle contract. Will
transfer the LINK sent for the request back to the recipient address. Given
params must hash to a commitment stored on the contract in order for the
request to be valid. Emits CancelOracleRequest event.

##### Parameters

| Name         | Type    | Description                                          |
|:-------------|:--------|:-----------------------------------------------------|
| requestId    | bytes32 | The request ID                                       |
| payment      | uint256 | The amount of payment given (specified in wei)       |
| callbackFunc | bytes4  | The requester's specified callback function selector |
| expiration   | uint256 | The time of the expiration for the request           |
#### cancelOracleRequestByRequester


    function cancelOracleRequestByRequester(uint256 nonce, uint256 payment, bytes4 callbackFunc, uint256 expiration) external

Allows requester to cancel requests sent to this oracle contract. Will
transfer the LINK sent for the request back to the recipient address. Given
params must hash to a commitment stored on the contract in order for the
request to be valid. Emits CancelOracleRequest event.

##### Parameters

| Name         | Type    | Description                                          |
|:-------------|:--------|:-----------------------------------------------------|
| nonce        | uint256 | The nonce used to generate the request ID            |
| payment      | uint256 | The amount of payment given (specified in wei)       |
| callbackFunc | bytes4  | The requester's specified callback function selector |
| expiration   | uint256 | The time of the expiration for the request           |
#### getChainlinkToken


    function getChainlinkToken() public view returns (address)

Returns the address of the LINK token

This is the public implementation for chainlinkTokenAddress, which is an
internal method of the ChainlinkClient contract.

### Events

#### OracleRequest


    event OracleRequest(bytes32 specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)

#### CancelOracleRequest


    event CancelOracleRequest(bytes32 requestId)

#### OracleResponse


    event OracleResponse(bytes32 requestId)

#### OwnableContractAccepted


    event OwnableContractAccepted(address acceptedContract)

#### TargetsUpdatedAuthorizedSenders


    event TargetsUpdatedAuthorizedSenders(address[] targets, address[] senders, address changedBy)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/contracts/operator.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Fulfilling Requests

  * Overview
  * Requirements
  * Address Types
  * Setup your Operator contract
  * Deploy your own Operator contract
  * Whitelist your node address in the Operator contract
  * Add a job to the node
  * Create a request to your node
  * Withdrawing LINK

Run a Chainlink node

This guide assumes you have a running Chainlink node. To learn how to run a
node, see the [Running a Chainlink Node locally](/chainlink-nodes/v1/running-a-chainlink-node) guide.

You can use your Chainlink nodes to fulfill requests. This guide shows you how
to deploy your own operator contract and add jobs to your node so that it can
provide data to smart contracts.

Chainlink nodes can fulfill requests from open or unauthenticated APIs without
the need for [External Adapters](/chainlink-nodes/external-adapters/external-adapters) as long as you've added the jobs to the node. For these requests,
requesters supply the URL to the open API that they want each node to
retrieve. The Chainlink node will use [tasks](/chainlink-nodes/oracle-jobs/tasks) to fulfill the request.

Some APIs require authentication by providing request headers for the
operator's API key, which the Chainlink node supports. If you would like to
provide access to an API that requires authentication, you must create a job
that is specific for that API either using an [external adapter](/chainlink-nodes/external-adapters/external-adapters) or by using the parameters of the
[HTTP task](/chainlink-nodes/oracle-jobs/all-tasks/#http-task).

## Requirements

Before you begin this guide, complete the following tasks to make sure you
have all of the tools that you need:

  * [Set up MetaMask](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) and [obtain testnet LINK](/resources/acquire-link).

  * [Run a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node).

  * Fund the Ethereum address that your Chainlink node uses. You can find the address in the node Operator GUI under the **Key Management** configuration. The address of the node is the `Regular` type. You can obtain test ETH from several [faucets](/resources/link-token-contracts). For this tutorial to work, you will have to fund the node's Ethereum address with Sepolia ETH. Here is an example:

## Address Types

Your node works with several different types of addresses. Each address type
has a specific function:

  * **Node address:** This is the address for your Chainlink node wallet. The node requires native blockchain tokens at all times to respond to requests. For this example, the node uses Sepolia ETH. When you start a Chainlink node, it automatically generates this address. You can find this address on the Node Operator GUI under **Key Management > EVM Chain Accounts**.
  * **Oracle contract address:** This is the address for contracts like `Operator.sol` or `Oracle.sol` that are deployed to a blockchain. Do not fund these addresses with native blockchain tokens such as ETH. When you make API call requests, the funds pass through this contract to interact with your Chainlink node. This will be the address that smart contract developers point to when they choose a node for an API call.
  * **Admin wallet address:** This is the address that owns your `Operator.sol` or `Oracle.sol` contract addresses. If you're on OCR, this is the wallet address that receives LINK tokens.

## Setup your Operator contract

### Deploy your own Operator contract

  1. Go to Remix and open the [`Operator.sol` smart contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkNodes/Operator.sol).

  2. On the **Compile** tab, click the **Compile** button for `Operator.sol`. Remix automatically selects the compiler version and language from the `pragma` line unless you select a specific version manually.

  3. On the **Deploy and Run** tab, configure the following settings:

    * Select ""Injected Provider"" as your **Environment**. The Javascript VM environment cannot access your oracle node. Make sure your Metamask is connected to Sepolia testnet.

    * Select the ""Operator"" contract from the **Contract** menu.

    * Copy the [LINK token contract address](/resources/link-token-contracts) for the network you are using and paste it into the `LINK` field next to the **Deploy** button. For Sepolia, you can use this address:
        
                0x779877A7B0D9E8603169DdbD7836e478b4624789

    * Copy the _Admin wallet address_ into the `OWNER` field.

  4. Click **transact**. MetaMask prompts you to confirm the transaction.

MetaMask doesn't pop up?

If MetaMask does not prompt you and instead displays the error below, disable
""Privacy Mode"" in MetaMask. You can do this by clicking on your unique account
icon at the top-right, then go to the Settings. Privacy Mode will be a switch
near the bottom.

  

Error: **Send transaction failed: Invalid address. If you use an injected
provider, please check it is properly unlocked.**

  5. If the transaction is successful, a new address displays in the **Deployed Contracts** section.

  6. Keep note of the Operator contract address. You need it later for your consuming contract.

### Whitelist your node address in the Operator contract

  1. In the Chainlink node GUI, find and copy the address of your chainlink node. see Requirements.

  2. In Remix, call the `setAuthorizedSenders` function with the address of your node. Note the function expects an array.

  3. Click the `transact` function to run it. Approve the transaction in MetaMask and wait for it to confirm on the blockchain.

  4. Call `isAuthorizedSender` function with the address of your node to verify that your chainlink node address can call the operator contract. The function must return `true`.

## Add a job to the node

You will create a job that calls an OpenAPI , parses the response and then
return a `uint256`.

  1. In the Chainlink Operator UI on the **Jobs** tab, click **New Job**.

  2. Paste the job specification from above into the text field.
    
        # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    name = ""Get > Uint256 - (TOML)""
    schemaVersion = 1
    type = ""directrequest""
    # Optional External Job ID: Automatically generated if unspecified
    # externalJobID = ""b1d42cd5-4a3a-4200-b1f7-25a68e48aad8""
    contractAddress = ""YOUR_OPERATOR_CONTRACT_ADDRESS""
    maxTaskDuration = ""0s""
    minIncomingConfirmations = 0
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=""cborparse"" data=""$(decode_log.data)""]
        fetch        [type=""http"" method=GET url=""$(decode_cbor.get)"" allowUnrestrictedNetworkAccess=""true""]
        parse        [type=""jsonparse"" path=""$(decode_cbor.path)"" data=""$(fetch)""]
    
        multiply     [type=""multiply"" input=""$(parse)"" times=""$(decode_cbor.times)""]
    
        encode_data  [type=""ethabiencode"" abi=""(bytes32 requestId, uint256 value)"" data=""{ \\""requestId\\"": $(decode_log.requestId), \\""value\\"": $(multiply) }""]
        encode_tx    [type=""ethabiencode""
                      abi=""fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes calldata data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"":   $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                      ]
        submit_tx    [type=""ethtx"" to=""YOUR_OPERATOR_CONTRACT_ADDRESS"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> multiply -> encode_data -> encode_tx -> submit_tx
    """"""
    

  3. Replace `YOUR_OPERATOR_CONTRACT_ADDRESS` with the address of your deployed operator contract address from the previous steps.

  4. Click **Create Job**. If the node creates the job successfully, a notice with the job number appears.

  5. Click the job number to view the job details. You can also find the job listed on the **Jobs** tab in the Node Operators UI. Save the `externalJobID` value because you will need it later to tell your consumer contract what job ID to request from your node.

## Create a request to your node

After you add jobs to your node, you can use the node to fulfill requests.
This section shows what a requester does when they send requests to your node.
It is also a way to test and make sure that your node is functioning
correctly.

  1. Open [ATestnetConsumer.sol in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol).

  2. Note that `setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789)` is configured for _Sepolia_.

  3. On the **Compiler** tab, click the **Compile** button for `ATestnetConsumer.sol`.

  4. On the **Deploy and Run** tab, configure the following settings:

    * Select _Injected Provider_ as your environment. Make sure your metamask is connected to Sepolia.
    * Select _ATestnetConsumer_ from the **Contract** menu.
  5. Click **Deploy**. MetaMask prompts you to confirm the transaction.

  6. Fund the contract by sending LINK to the contract's address. See the [Fund your contract](/resources/fund-your-contract) page for instructions. The address for the `ATestnetConsumer` contract is on the list of your deployed contracts in Remix. You can fund your contract with 1 LINK.

  7. After you fund the contract, create a request. Input your operator contract address and the job ID for the `Get > Uint256` job into the `requestEthereumPrice` request method **without dashes**. The job ID is the `externalJobID` parameter, which you can find on your job's definition page in the Node Operators UI.

  8. Click the **transact** button for the `requestEthereumPrice` function and approve the transaction in Metamask. The `requestEthereumPrice` function asks the node to retrieve `uint256` data specifically from [https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD](https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD).

  9. After the transaction processes, you can see the details for the complete the job run the **Runs** page in the Node Operators UI.

  10. In Remix, click the `currentPrice` variable to see the current price updated on your consumer contract.

## Withdrawing LINK

You can withdraw LINK from the operator contract. In Remix under the list of
deployed contracts, click on your Operator contract and find the `withdraw`
function in the function list. Note that only the admin (see Admin wallet
address) can withdraw LINK.



Paste the address you want to withdraw to, and specify the amount of LINK that
you want to withdraw. Then, click `withdraw`. Confirm the transaction in
MetaMask when the popup appears.

## What's next

  * [› Performing System Maintenance](/chainlink-nodes/resources/performing-system-maintenance)
  * [› v2 Jobs](/chainlink-nodes/oracle-jobs/jobs)
  * [› Security and Operation Best Practices](/chainlink-nodes/resources/best-security-practices)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/fulfilling-requests.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the Chainlink Solana Crate and how can it be used?,The Chainlink Solana Crate is a library that can be imported into an existing project to read Chainlink Data Feed data on-chain. It can be used to query price data by specifying the feed account and the Chainlink Data Feeds OCR2 Program for the network.,{'source': 'https://docs.chain.link/data-feeds/solana/using-data-feeds-solana/'},"The Chainlink Solana Crate is a program that allows users to access data feeds on the Solana network. It employs Off-Chain Reporting (OCR) to aggregate data from data providers, both centralized and decentralized. The program is separate from external blockchain networks like Ethereum, and it stores the logic of the smart contract separately from the data. To use Chainlink products on Solana, users must deploy their contract on-chain to one of the supported Solana clusters. The Chainlink Solana Crate can be used to retrieve market prices for real-world assets and can be integrated into off-chain projects or used with the Solana Starter Kit. The Solana Starter Kit provides example code and instructions for reading Chainlink Data Feeds off-chain using the Chainlink Solana NPM library. Users can install the necessary tools, such as the Solana CLI and Node.js, and run the example program to retrieve and print price feed data. The Solana Wallets are required when using Chainlink on Solana, and users can create temporary wallets for testing or use existing wallets for production applications. It is important to select quality data feeds and make responsible data quality decisions. For more information and detailed instructions, refer to the provided sources.

","- https://docs.chain.link/data-feeds/solana/
- https://docs.chain.link/data-feeds/solana/using-data-feeds-off-chain/","# Data Feeds on Solana

  * Overview
  * Chainlink products and Solana clusters
  * Languages, tools, and frameworks
  * Solana Wallets

Chainlink provides data feeds on the [Solana](https://solana.com/) network.
Chainlink data feeds on Solana employ [Off-Chain Reporting
(OCR)](/architecture-overview/off-chain-reporting?parent=dataFeeds) to
aggregate data from data providers who pull from both centralized and
decentralized exchanges. Chainlink’s Solana deployment has no dependencies on
external blockchain networks such as Ethereum. In Solana, storage and smart
contract logic are separate. Programs store all the logic similar to an EVM
(Ethereum) smart contract. The accounts store all the data. Compared to
Solidity, the combination of an account and a program is equivalent to a smart
contract on an EVM chain. State and logic are separate in Solana.

Solana programs are stateless, so you don't always need to deploy your program
to the network to test it. You can deploy and test your programs on a [Solana
Test Validator](https://docs.solana.com/developing/test-validator). However,
to use Chainlink products on Solana, you must deploy your contract on-chain to
one of the supported Solana clusters.

Note

Please note that Price Feeds performance relies on the chains they are
deployed on. Periods of high network congestion may impact the frequency of
Chainlink Price Feeds. Subscribe to [Solana
status](https://status.solana.com/) notifications to stay updated on system
performance.

To learn how to mitigate risk to your applications, read the [Selecting
Quality Data Feeds](/data-feeds/selecting-data-feeds) page.

## Chainlink products and Solana clusters

[Price Feeds](/data-feeds/price-feeds/addresses?network=solana) are available
on the following Solana clusters:

  * [Solana Mainnet](https://solscan.io/)
  * [Solana Devnet](https://solscan.io/?cluster=devnet)

Solana provides a [Testnet cluster](https://docs.solana.com/clusters#testnet)
that runs newer [Solana releases](https://github.com/solana-labs/solana/releases), but Chainlink Data Feeds are not available on this
cluster.

See the [Solana Data Feeds](/data-feeds/price-feeds/addresses?network=solana)
page for a full list of Chainlink data feeds that are available on Solana.

To learn when more Chainlink services become available, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=dataFeeds).

## Languages, tools, and frameworks

The examples in the Chainlink documentation use the following languages,
tools, and frameworks:

  * [Node.js 14 or higher](https://nodejs.org/en/download/): Used to run client code
  * [Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust): A general-purpose programming language designed for performance and memory safety
  * [Anchor](https://project-serum.github.io/anchor/getting-started/introduction.html): A framework for the [Solana Sealevel runtime](https://github.com/solana-labs/sealevel) that provides several developer tools
  * [Chainlink Solana Starter Kit](https://github.com/smartcontractkit/solana-starter-kit): An Anchor based program and client that shows developers how to use and interact with Chainlink Data Feeds on Solana
  * [Solana CLI](https://docs.solana.com/cli): The Solana command line interface
  * [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git): Used to clone the example code repository

When developing applications to use Chainlink products on Solana, always use a
[Mainnet release](https://github.com/solana-labs/solana/releases) version of
the Solana CLI that is equal to or greater than the version currently running
on your target cluster. Use `solana --version` and `solana cluster-version` to
check CLI and cluster versions:


    solana --version
    solana-cli 1.9.28 (src:b576e9cc; feat:320703611)
    
    solana cluster-version --url devnet
    1.9.25
    
    solana cluster-version --url mainnet-beta
    1.9.28

The examples in this documentation use Solana programs in
[Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust),
but you can also write Solana programs in
[C](https://docs.solana.com/developing/on-chain-programs/developing-c). To
learn more about the Solana programming model, see the [Solana
Documentation](https://docs.solana.com/developing/programming-model/overview).

## Solana Wallets

When you use Chainlink on Solana, you need a [Solana
wallet](https://docs.solana.com/wallet-guide/). The Chainlink documentation
uses [file system wallets](https://docs.solana.com/wallet-guide/file-system-wallet) and free Devnet SOL tokens to demonstrate examples. When you deploy
your programs to the Solana Mainnet, you must use wallets with mainnet
lamports.

If you have existing wallets that you want to use for the guides in the
Chainlink documentation, find your wallet keypair and make it available in
your development environment as a file. You can point
[Anchor](https://project-serum.github.io/anchor/getting-started/introduction.html) and the [Solana CLI](https://docs.solana.com/cli)
to a specific keypair when you deploy or manage your Solana programs.


    anchor build
    ⋮
    
    anchor deploy --provider.wallet ~/.config/solana/id.json --provider.cluster devnet
    ⋮
    
    solana program show --programs --keypair ~/.config/solana/id.json --url devnet
    
    Program Id                                   | Slot      | Authority                                    | Balance
    6U4suTp55kiJRKqV7HGAQvFgcLaStLnUA4myg5DRqsKw | 109609728 | E6gKKToCJPgf4zEL1GRLL6T99g2WcfAzJAMvtma1KijT | 2.57751768 SOL

When you build your production applications and deploy Solana programs to the
Mainnet cluster, always follow the security best practices in the [Solana
Wallet Guide](https://docs.solana.com/wallet-guide) for managing your wallets
and keypairs.

## What's next

  * [› Use data feeds off-chain](/data-feeds/solana/using-data-feeds-off-chain)
  * [› Use data feeds on-chain](/data-feeds/solana/using-data-feeds-solana)
  * [› See the available data feeds on Solana](/data-feeds/price-feeds/addresses?network=solana)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/solana/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds Off-Chain (Solana)

  * Overview
  * The Chainlink Data Feeds Store Program
  * Adding Data Feeds to an existing off-chain project
  * Using the Solana Starter Kit
  * Install the required tools
  * Run the example program

Chainlink Data Feeds are the quickest way to access market prices for real-
world assets. This guide demonstrates how to read Chainlink Data Feeds on the
Solana Devnet using off-chain examples in the [Chainlink Solana Starter
Kit](https://github.com/smartcontractkit/solana-starter-kit). To learn how to
use Data Feeds in your on-chain Solana programs, see the [Using Data Feeds On-
Chain](/data-feeds/solana/using-data-feeds-solana) guide.

To get the full list of Chainlink Data Feeds on Solana, see the [Solana
Feeds](/data-feeds/price-feeds/addresses?network=solana) page.

Select quality data feeds

Be aware of the quality of the data that you use. [Learn more about making
responsible data quality decisions](/data-feeds/selecting-data-feeds).

## The Chainlink Data Feeds Store Program

The program that contains the logic required for the storing and retrieval of
Chainlink Data Feeds data on both Devnet and Mainnet is
[cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ](https://solscan.io/account/cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ?cluster=devnet).
This is the program ID that you use to read price data from off-chain. You can
find the source code for this program in the [smartcontractkit/chainlink-
solana](https://github.com/smartcontractkit/chainlink-solana/tree/develop/contracts/programs/store/src) on GitHub.

You can add data feeds to an existing off-chain project or use the Solana
Starter Kit.

## Adding Data Feeds to an existing off-chain project

You can read Chainlink Data Feeds off-chain in your existing project by using
the [Chainlink Solana NPM
library](https://www.npmjs.com/package/@chainlink/solana-sdk).

Reading feed data

Although you can directly query the data feed accounts, you should not rely on
the memory layout always being the same as it currently is. Based on this, the
recommendation is to always use the consumer library.

Install the necessary components and include the example code in your project.
Optionally, you can run the example code by itself to learn how it works
before you integrate it with your project.

  1. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  2. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  3. Change to your project directory or create a new directory.
    
        mkdir off-chain-project && cd off-chain-project

  4. Optionally [install Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to use as a package manager and initialize yarn if your project does not already have a `package.json` file:
    
        npm install -g yarn && yarn init

  5. Add the [Anchor library](https://www.npmjs.com/package/@project-serum/anchor) to your project:

npmyarn

    
        npm i @project-serum/anchor
    
        yarn add @project-serum/anchor

  6. Add the [Chainlink Solana NPM library](https://www.npmjs.com/package/@chainlink/solana-sdk) to your project:

npmyarn

    
        npm i -g @chainlink/solana-sdk
    
        yarn add @chainlink/solana-sdk

  7. Create a temporary Solana wallet to use for this example. Alternatively, if you have an existing wallet that you want to use, locate the path to your [keypair](https://docs.solana.com/terminology#keypair) file and use it as the keypair for the rest of this guide.
    
        solana-keygen new --outfile ./id.json

  8. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and how to get a connection to a Solana cluster. Because this example does not generate or sign any transactions, no lamports are required. The wallet is required only by the Anchor library. For a list of available networks and endpoints, see the [Solana Cluster RPC Endpoints](https://docs.solana.com/cluster/rpc-endpoints) documentation.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  9. Copy the sample code into your project. This example queries price data off-chain. By default, the script reads the SOL/USD feed, but you can change the `CHAINLINK_FEED_ADDRESS` variable to point to the [feed account addresses](/data-feeds/price-feeds/addresses?network=solana) that you want to query. You can take the components of these code samples and integrate them with your existing project. Because these examples read data feeds without making any on-chain changes, no lamports are required to run them.
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const anchor = require(""@project-serum/anchor"")
    const chainlink = require(""@chainlink/solana-sdk"")
    const provider = anchor.AnchorProvider.env()
    
    async function main() {
      anchor.setProvider(provider)
    
      const CHAINLINK_FEED_ADDRESS = ""99B2bTijsU6f1GCT73HmdR7HCFFjGMBcPZY6jZ96ynrR""
      const CHAINLINK_PROGRAM_ID = new anchor.web3.PublicKey(""cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ"")
      const feedAddress = new anchor.web3.PublicKey(CHAINLINK_FEED_ADDRESS) //SOL-USD Devnet Feed
    
      //load the data feed account
      let dataFeed = await chainlink.OCR2Feed.load(CHAINLINK_PROGRAM_ID, provider)
      let listener = null
    
      //listen for events agains the price feed, and grab the latest rounds price data
      listener = dataFeed.onRound(feedAddress, (event) => {
        console.log(event.answer.toNumber())
      })
    
      //block execution and keep waiting for events to be emitted with price data
      await new Promise(function () {})
    }
    
    main().then(
      () => process.exit(),
      (err) => {
        console.error(err)
        process.exit(-1)
      }
    )
    
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    import * as anchor from ""@project-serum/anchor""
    import { OCR2Feed } from ""@chainlink/solana-sdk""
    
    async function main() {
      const provider = anchor.AnchorProvider.env()
      anchor.setProvider(provider)
    
      const CHAINLINK_FEED_ADDRESS = ""99B2bTijsU6f1GCT73HmdR7HCFFjGMBcPZY6jZ96ynrR""
      const CHAINLINK_PROGRAM_ID = new anchor.web3.PublicKey(""cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ"")
      const feedAddress = new anchor.web3.PublicKey(CHAINLINK_FEED_ADDRESS) //SOL-USD Devnet Feed
    
      //load the data feed account
      let dataFeed = await OCR2Feed.load(CHAINLINK_PROGRAM_ID, provider)
      let listener = null
    
      //listen for events agains the price feed, and grab the latest rounds price data
      listener = dataFeed.onRound(feedAddress, (event) => {
        console.log(event.answer.toNumber())
      })
    
      //block execution and keep waiting for events to be emitted with price data
      await new Promise(function () {})
    }
    
    main().then(
      () => process.exit(),
      (err) => {
        console.error(err)
        process.exit(-1)
      }
    )
    

You can run these examples using the following commands:

JavascriptTypescript

    
        node javascript-example.js
    
        yarn add ts-node typescript && yarn ts-node typescript-example.ts

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://book.anchor-lang.com/).

## Using the Solana Starter Kit

This example reads price data from an off-chain client using the [Solana
Starter Kit](https://github.com/smartcontractkit/solana-starter-kit).

### Install the required tools

Before you begin, set up your environment for development on Solana:

  1. Install [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if it is not already configured on your system.

  2. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  3. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  4. [Install Anchor](https://book.anchor-lang.com/getting_started/installation.html). On some operating systems, you might need to build and install Anchor locally. See the [Anchor documentation](https://book.anchor-lang.com/getting_started/installation.html#build-from-source-for-other-operating-systems-without-avm) for instructions.

  5. Install [Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to simplify package management and run code samples in the Starter Kit.
    
        npm install -g yarn

### Run the example program

After you install the required tools, clone the example code from the [solana-
starter-kit](https://github.com/smartcontractkit/solana-starter-kit)
repository.

  1. In a terminal, clone the [solana-starter-kit](https://github.com/smartcontractkit/solana-starter-kit) repository and change to the `solana-starter-kit` directory:
    
        git clone https://github.com/smartcontractkit/solana-starter-kit &&
    cd ./solana-starter-kit

You can see the complete code for the example on
[GitHub](https://github.com/smartcontractkit/solana-starter-kit/).

  2. In the `./solana-starter-kit` directory, install Node.js dependencies defined in the `package.json` file:
    
        yarn install

  3. Create a temporary Solana wallet file to use for this example. Because your application runs off-chain and does not run any functions or alter data on-chain, the wallet does not require any SOL tokens to function.
    
        solana-keygen new --outfile ./id.json

  4. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and Solana cluster to use. Take note that because we are not generating or signing any transactions, the wallet isn't used, it's just required by the Anchor library. For a list of available networks and endpoints, see the [Solana Cluster RPC Endpoints](https://docs.solana.com/cluster/rpc-endpoints) documentation.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  5. Run the example:

JavascriptTypescript

    
        node read-data.js
    
        yarn run read-data

The example code retrieves and prints the current price feed data until you
close the application:

    
        4027000000
    4026439929
    4026476542
    4023000000

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://book.anchor-lang.com/).

## What's next

  * [› Use data feeds on-chain](/data-feeds/solana/using-data-feeds-solana)
  * [› See the available data feeds on Solana](/data-feeds/price-feeds/addresses?network=solana)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/solana/using-data-feeds-off-chain.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Why is it important to assess the liquidity and reliability of a specific exchange when obtaining pricing data for a smart contract?,Assessing the liquidity and reliability of a specific exchange is important to avoid price manipulation and ensure that prices are accurately reported throughout a liquidity migration.,{'source': 'https://docs.chain.link/data-feeds/selecting-data-feeds/'},"It is important to assess the liquidity and reliability of a specific exchange when obtaining pricing data for a smart contract because assets with low liquidity can be volatile and susceptible to price manipulation. Additionally, using data feeds from single source data providers increases the risk of errors or omissions in the data. Assessing the liquidity and reliability of an exchange helps ensure the accuracy and quality of the pricing data used in the smart contract.

","
- https://docs.chain.link/data-feeds/selecting-data-feeds/
- https://docs.chain.link/data-feeds/using-data-feeds/","# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside off-chain.
  * **LP Token Feeds:** These feeds use a decentralized feed for the underlying asset as well as calculations to value the LP tokens.
  * **Wrapped Calculated Feeds:** These feeds are typically pegged 1:1 to the underlying token or asset. Under normal market conditions, these feeds track their underlying value accurately. However, the price is a derivative formed from a calculated method and might not always track value precisely.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⭕ Deprecating

These feeds are being deprecated. To find the deprecation dates for specific
feeds, see the [Feeds Scheduled For Deprecation](/data-feeds/deprecating-feeds) page.

## Risk Mitigation

As a development best practice, design your systems and smart contracts to be
resilient and mitigate risk to your protocol and your users. Ensure that your
systems can tolerate known and unknown exceptions that might occur. Some
examples include but are not limited to volatile market conditions, the
degraded performance of infrastructure, chains, or networks, and any other
upstream outage related to data providers or node operators. You bear
responsibility for any manner in which you use the Chainlink Network, its
software, and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel: <https://discord.gg/Dqy5N9UbsR>

## Chainlink Community Deployments

Chainlink technology is used by many within the blockchain community to
support their use cases. Deployments built and run by community members are
not tracked in the Chainlink documentation. Chainlink's community is
continuously growing, and we believe they play a vital role in developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Fast Gas Reliability

### Liquidity and its Distribution

If your smart contract relies on pricing data for a specific asset, make sure
that the asset has sufficient liquidity in the market to avoid price
manipulation. Assets with low liquidity can be volatile, which might
negatively impact your application and its users. Malicious actors might try
to exploit volatility to take advantage of the logic in a smart contract and
cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather
than from aggregated price tracking services that gather their data from
multiple exchanges. These are marked as such in the docs page for that feed.
Assess the liquidity and reliability of that specific exchange.

_Liquidity migrations_ occur when a project moves its tokens from one
liquidity provider (such as a DEX, a CEX, or a new DeFi application) to
another. When liquidity migrations occur, it can result in low liquidity in
the original pool, making the asset susceptible to market manipulation. If
your project is considering a liquidity migration, you should coordinate with
relevant stakeholders, including liquidity providers, exchanges, oracle node
operators, and users, to ensure prices are accurately reported throughout the
migration.

Feeds for assets with low market liquidity where data providers exhibit an
abnormal price spread may, on occasion, see a price oscillate between two or
more price points within regular intervals. To mitigate risk associated with
such price oscillation, users must regularly monitor & assess the quality of
an asset’s liquidity. Similarly, assets with low market liquidity may
experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk
management measures to protect your assets. For example, create mock tests
that return various oracle responses.

### Single Source Data Providers

Some data providers use a single data source, which might be necessary if only
one source exists off-chain for a specific type of data. Evaluate data
providers to make sure they provide high-quality data that your smart
contracts can rely on. Any error or omission in the provider's data might
negatively impact your application and its users.

### Crypto and Blockchain Actions

Price data quality is subject to crypto actions by the crypto and blockchain
project teams. Crypto actions are similar to [corporate
actions](https://en.wikipedia.org/wiki/Corporate_action) but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on. Periods of
high network congestion might impact the frequency of Chainlink Price Feeds.
It is advised that you configure your applications to detect such chain
performance issues and to respond appropriately.

### Unknown and Known Users

Routine maintenance is carried out on Chainlink Data Feeds, including
decommissioning, on an ad-hoc basis. These maintenance periods might require
users to take action in order to maintain business continuity.

Notifications are sent to inform known users regarding such occurrences, and
it is strongly encouraged for all users, including those users utilizing data
feeds for off-chain purposes, [to provide their contact
information](https://chain.link/contact?ref_id=DataFeed) before utilizing data
feeds. Without providing contact information, users will be unable to receive
notifications regarding important price feed updates.

If you are using Price Feeds but have not provided your contact information,
you can do so [here](https://chain.link/contact?ref_id=DataFeed). Users that
fail to provide notification information do so at their own risk.

## Evaluating Wrapped or Bridged Assets

### Assessing how to Price Wrapped or Bridged Assets

When assessing a Chainlink Price Feed for a wrapped or bridged asset such as
WBTC, users should evaluate the tradeoffs between using a price feed
specifically built for the wrapped or bridged asset or a price feed built for
the underlying asset.

Decisions should be made on a case-by-case basis considering the liquidity,
depth, and trading volatility of the underlying asset compared to its
derivative. In addition, users must consider the security mechanism that is
designed to keep the wrapped or bridged asset coupled to its underlying asset.
Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets

Chainlink Price Feeds are designed to provide the market-wide price of various
assets, as determined by a volume-weighted average across a wide range of
exchanges. On blockchain networks where assets are wrapped and/or bridged from
another environment using a cross-chain token bridge, Chainlink Price Feeds
built for the underlying asset will continue to report the market-wide price
of the underlying asset as opposed to the price of the wrapped/bridged asset.
This methodology reduces risks around market manipulation because
wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price
deviations between the wrapped/bridged asset and its underlying counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible for reviewing the quality of the data that you integrate into your
smart contracts.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/selecting-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the VRFv2SubscriptionManager contract?,The VRFv2SubscriptionManager contract is an example contract that uses hardcoded values for clarity and uses un-audited code. It should not be used in production.,{'source': 'https://docs.chain.link/vrf/v2/subscription/examples/programmatic-subscription/'},"The purpose of the VRFv2SubscriptionManager contract is to manage subscriptions and interact with the Chainlink VRF (Verifiable Random Function) system. It allows the contract owner to create and fund subscriptions, request random numbers, add and remove consumer contracts, and perform other functions related to the VRF system. The contract is designed to work with the Chainlink VRF v2 and includes functions for interacting with the VRFCoordinatorV2Interface and LinkTokenInterface contracts. It also includes storage variables for storing random words and subscription information. The contract is deployed on the Rinkeby testnet and uses the Rinkeby coordinator and LINK token contract addresses. The contract is written in Solidity and uses the Brownie framework for deployment and testing. To fund the contract with LINK tokens, the contract owner can use the topUpSubscription function, which transfers the specified amount of LINK tokens to the subscription account. The contract also includes functions for adding and removing consumer contracts from the subscription, canceling the subscription, and withdrawing funds from the contract. The contract is owned by the account that deployed it and requires the onlyOwner modifier for certain functions. The purpose of the VRFv2SubscriptionManager contract is to provide a convenient and scalable way to interact with the Chainlink VRF system and generate random numbers in a secure and verifiable manner.

",- https://stackoverflow.com/questions/72168793/how-to-fund-your-contract-with-links-for-vrf-v2-subscription,"Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    





:::NEXT DOC:::

Question: (Asked on: 2022-05-09 08:07:14)
How to fund your contract with LINKs for VRF v2 subscription?
URL: https://stackoverflow.com/questions/72168793/how-to-fund-your-contract-with-links-for-vrf-v2-subscription

Question Body:


I've been learning solidity with brownie framework and python. I'm trying to
write a very simple contract which will generate a random number using
**ChainLink VRF v2**.

Here's the link of their sample **Subscription Manager Contract** :
<https://docs.chain.link/docs/chainlink-vrf/example-contracts/>

I've copied this exact same code in my **VRFv2SubscriptionManager.sol** file :

    
    
    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that also owns and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Rinkeby coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
    
        // Rinkeby LINK token contract. For other networks, see
        // https://docs.chain.link/docs/vrf-contracts/#configurations
        address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 keyHash =
            0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
    
        // A reasonable default is 100000, but this value could be different
        // on other networks.
        uint32 callbackGasLimit = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 requestConfirmations = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
        uint32 numWords = 2;
    
        // Storage parameters
        uint256[] public s_randomWords;
        uint256 public s_requestId;
        uint64 public s_subscriptionId;
        address public s_owner;
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            LINKTOKEN = LinkTokenInterface(link_token_contract);
            s_owner = msg.sender;
            //Create a new subscription when you deploy the contract.
            createNewSubscription();
        }
    
        // Assumes the subscription is funded sufficiently.
        function requestRandomWords() external onlyOwner {
            // Will revert if subscription is not set and funded.
            s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
        }
    
        function fulfillRandomWords(
            uint256, /* requestId */
            uint256[] memory randomWords
        ) internal override {
            s_randomWords = randomWords;
        }
    
        // Create a new subscription when the contract is initially deployed.
        function createNewSubscription() private onlyOwner {
            // Create a subscription with a new subscription ID.
            address[] memory consumers = new address[](1);
            consumers[0] = address(this);
            s_subscriptionId = COORDINATOR.createSubscription();
            // Add this contract as a consumer of its own subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumers[0]);
        }
    
        // Assumes this contract owns link.
        // 1000000000000000000 = 1 LINK
        function topUpSubscription(uint256 amount) external onlyOwner {
            LINKTOKEN.transferAndCall(
                address(COORDINATOR),
                amount,
                abi.encode(s_subscriptionId)
            );
        }
    
        function addConsumer(address consumerAddress) external onlyOwner {
            // Add a consumer contract to the subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
        }
    
        function removeConsumer(address consumerAddress) external onlyOwner {
            // Remove a consumer contract from the subscription.
            COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
        }
    
        function cancelSubscription(address receivingWallet) external onlyOwner {
            // Cancel the subscription and send the remaining LINK to a wallet address.
            COORDINATOR.cancelSubscription(s_subscriptionId, receivingWallet);
            s_subscriptionId = 0;
        }
    
        // Transfer this contract's funds to an address.
        // 1000000000000000000 = 1 LINK
        function withdraw(uint256 amount, address to) external onlyOwner {
            LINKTOKEN.transfer(to, amount);
        }
    
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }
    

This is my **deploy_first.py** :

    
    
    from brownie import VRFv2SubscriptionManager
    from scripts.helpful_scripts import get_account
    import time
    
    
    def deploy_random_number():
        account = get_account()
        random_number = VRFv2SubscriptionManager.deploy({""from"": account})
    
        print(""Deployed Random Number!!!"")
    
        owner = random_number.s_owner()
        print(""owner : "", owner)
    
        sub_id = random_number.s_subscriptionId()
        print(""sub_id : "", sub_id)
    
        random_number.topUpSubscription(9000000000000000000)
        print(""after the top up"")
        random_number.requestRandomWords()
        # time.sleep(60)
        print(""array : "", random_number.s_randomWords())
    
        return random_number
    
    
    def main():
        deploy_random_number()
    

I'm running this contract on Rinkeby TestNet and the account through which I'm
running this contract, has enough ETHER and LINK because I've tried
chainlink's official guide to generate the random number on **REMIX** and I
was able to generate it.

Here's the link of remix implementation of code :
<https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol>

**The Process on Remix :**

The new release of chainlink VRF v2 works this way from what I've understood
by implementing on **REMIX** :

  1. Inject web3, connect your Metamask (Rinkeby testnet) account to deploy the contract

  2. You deploy the contract and the contract creates a subscription for you in the constructor using **COORDINATOR.createSubscription();** where COOORDINATOR is **VRFCoordinatorV2Interface**

  3. Your Metamask account -- owns --> deployed contract

  4. Your deployed contract -- owns --> created subscription

  5. Consumers under a subscription account are allowed to use LINKs of that account and we are assigning our contract as the first consumer in the constructor

  6. To make calls to oracle our subscription account pays in LINKs, to send my subscription account LINKs I transferred LINKs from my metamask account to the address of the deployed contract, then used the function :
    
         // Assumes this contract owns link.
     // 1000000000000000000 = 1 LINK
     function topUpSubscription(uint256 amount) external onlyOwner {
         LINKTOKEN.transferAndCall(
             address(COORDINATOR),
             amount,
             abi.encode(s_subscriptionId)
         );
     }
    

to send LINKs from my contract to the subscription account.

  7. This worked completely fine in **REMIX** and I was able to generate the random number

**The Problem :**

Funding subscription and contracts is easy with Metamask wallet and Remix but
not scalable so I've got 2 main problems :

  1. How do I transfer LINKs from my Metamask (Rinkeby testnet) account (basically the **first msg.sender** i.e. **owner of the contract** ) to the contract that has been in deployed using my **VRFv2SubscriptionManager.sol** and **python_first.py**? Is there a way to do this using **web3.py**? (basically automate the process of funding the subscription account with LINKs while deploying the contract and creating subscription in the code only)

  2. In this example the **deployed contract** \-- owns --> **subscription account** after deploying the contract and creating a subscription using following functions :
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        LINKTOKEN = LinkTokenInterface(link_token_contract);
        s_owner = msg.sender;
        //Create a new subscription when you deploy the contract.
        createNewSubscription();
    }
    
    
        // Create a new subscription when the contract is initially deployed.
    function createNewSubscription() private onlyOwner {
        // Create a subscription with a new subscription ID.
        address[] memory consumers = new address[](1);
        consumers[0] = address(this);
        s_subscriptionId = COORDINATOR.createSubscription();
        // Add this contract as a consumer of its own subscription.
        COORDINATOR.addConsumer(s_subscriptionId, consumers[0]);
    }
    

Is there any way to create subscription, programatically, so that
**msg.sender** i.e. my Metamask (Rinkeby Testnet) account is the owner of
subscription account so that I don't have to transfer the LINKs to contract
first and can directly send it to the subscription account? On browser you can
do it easily here : <https://vrf.chain.link/>

  1. Link you Metamask wallet to the website
  2. Create a subscription account using you Metamask (Rinkeby Testnet) account
  3. Fund it with LINKs directly and in consumers you can add your deployed previously contracts using their addresses for them to use the LINKs to interact with VRF

I've tried changing the Gas Limit pre set in the contract, doublechecked my
values that I'm sending but I'm getting following error when python compiler
reaches the line : `random_number.topUpSubscription(9000000000000000000)` in
my **python_first.py**

**error :**

    
    
    Deployed Random Number!!!
    owner :  0xD8154fBD7cf816CdFde8cBC397b7cF5C604d7154
    sub_id :  4091
      File ""brownie/_cli/run.py"", line 51, in main
        return_value, frame = run(
      File ""brownie/project/scripts.py"", line 103, in run
        return_value = f_locals[method_name](*args, **kwargs)
      File ""./scripts/deploy_first.py"", line 28, in main
        deploy_random_number()
      File ""./scripts/deploy_first.py"", line 18, in deploy_random_number
        random_number.topUpSubscription(9000000000000000000)
      File ""brownie/network/contract.py"", line 1710, in __call__
        return self.transact(*args)
      File ""brownie/network/contract.py"", line 1583, in transact
        return tx[""from""].transfer(
      File ""brownie/network/account.py"", line 644, in transfer
        receipt, exc = self._make_transaction(
      File ""brownie/network/account.py"", line 727, in _make_transaction
        raise VirtualMachineError(e) from None
      File ""brownie/exceptions.py"", line 93, in __init__
        raise ValueError(str(exc)) from None
    ValueError: Gas estimation failed: 'execution reverted'. This transaction will likely revert. If you wish to broadcast, you must set the gas limit manually.
    

I assume this is because my contract doesn't have any LINK or ETHER i don't
know, I need more clarity on this error too.

I've been stuck on this problem for a day now. Please help. Thanks in advance.



Answers:
(Answered on: 2022-05-09 20:10:29)


As you said, the easiest way is to go to the
[vrf.chain.link](https://vrf.chain.link/), connect your wallet, and manage
your subscription(s). The initial flow is:

  * connect your wallet and select the proper network
  * create a new subscription, save your subscription id
  * fund your subscription
  * deploy VRF consumer smart contract
  * add it as a subscription consumer

[The Subscription Manager page](https://vrf.chain.link/) allows us to easily
manage subscription funds, add/remove multiple consumer contracts to/from one
subscription, and so much more.

Since you want to automate this process from the brownie CLI in a way that
your smart contract is not the owner of a subscription (and doesn't need to
worry about the funds), I suggest you move ""subscription logic"" from the smart
contract to python scripts, as described [in Chainlink Brownie Starter
Kit](https://github.com/smartcontractkit/chainlink-
mix/tree/main/scripts/vrf_scripts).

  1. To transfer LINKs from your Metamask (Rinkeby testnet) account to the contract that has been deployed, just perform the regular ERC20 transfer, but add your contract's address as the receiver/destination address. More examples [here](https://stackoverflow.com/questions/50764686/send-erc20-token-with-web3-py-using-a-local-private-key) and [here](https://web3py.readthedocs.io/en/stable/examples.html#sending-tokens).
  2. Probably because of that, try to set gas manually, as described in previous URLs, to some high value to confirm



"
What are the two methods offered by Chainlink VRF v2 for requesting randomness?,Chainlink VRF v2 offers two methods for requesting randomness: Subscription and Direct funding.,{'source': 'https://docs.chain.link/vrf/'},"The two methods offered by Chainlink VRF v2 for requesting randomness are the Subscription method and the Direct funding method.
",https://docs.chain.link/vrf/v2/subscription/migration-from-v1/ and https://docs.chain.link/vrf/v2/introduction.mdx,"# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  2. Import the new [`VRFConsumerBaseV2.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  3. Import the [`VRFCoordinatorV2Interface.sol` interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol). This interface includes the new `requestRandomWords` function.

  4. Add a `VRFConsumerBaseV2` constructor as shown in the [Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number) example.

  5. Change `requestRandomness` function calls to `requestRandomWords`. The `requestRandomWords` function requires several additional parameters.

  6. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                                                                                                          | Suitable for infrequent one-off requests                                                                                                                                                                    |
| Supports multiple VRF consuming contracts connected to one subscription account                                                                                        | Each VRF consuming contract directly pays for its requests                                                                                                                                                  |
| VRF costs are calculated after requests are fulfilled and then deducted from the subscription balance. Learn how VRF costs are calculated for the subscription method. | VRF costs are estimated and charged at request time, which may make it easier to transfer the cost of VRF to the end user. Learn how VRF costs are calculated for the direct funding method.                |
| Reduced gas overhead and more control over the maximum gas price for requests                                                                                          | Higher gas overhead than the subscription method                                                                                                                                                            |
| More random values returned per single request. See the maximum random values per request for the Subscription supported networks.                                     | Fewer random values returned per single request than the subscription method, due to higher overhead. See the maximum random values per request and gas overhead for the Direct funding supported networks. |
| You don't have to estimate costs precisely for each request. Ensure that the subscription account has enough funds.                                                    | You must estimate transaction costs carefully for each request to ensure the consuming contract has enough funds to pay for the request.                                                                    |
| Requires a subscription account                                                                                                                                        | No subscription account required                                                                                                                                                                            |
| Supported on Arbitrum                                                                                                                                                  | Not yet supported on Arbitrum                                                                                                                                                                               |
| VRF costs are billed to your subscription account. Manage and monitor your balance                                                                                     | No refunds for overpayment after requests are completed                                                                                                                                                     |
| Flexible funding method first introduced in VRF v2. Compare the VRF v2 subscription method to VRF v1.                                                                  | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the `functions-simulate` command in the Chainlink Functions hardhat starter kit?,"The `functions-simulate` command executes your code in a local runtime environment and simulates an end-to-end fulfillment, helping you fix any issues before submitting your functions to a Decentralized Oracle Network.",{'source': 'https://docs.chain.link/chainlink-functions/tutorials/simple-computation/'},"The purpose of the `functions-simulate` command in the Chainlink Functions hardhat starter kit is to simulate a Chainlink Functions request. It runs on a local Hardhat network and executes a request defined in the default `Functions-request-config.js` file. This allows developers to quickly test their code before sending it to the Chainlink Functions Decentralized Oracle Network (DON).

",https://docs.chain.link/chainlink-functions/getting-started/,"# Getting Started

  * Overview
  * Set up your environment
  * Configure your on-chain resources
  * Run the example request

Use the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) with
[Hardhat](https://hardhat.org/) to set up your on-chain contracts, test your
requests, and send your requests to be fulfilled by the Chainlink Functions
Decentralized Oracle Network (DON). Chainlink Functions is available on
Sepolia and Polygon Mumbai, but this guide uses Polygon Mumbai to simplify
access to testnet funds. Complete the following tasks to get started with
Chainlink Functions:

  * Set up your Web3 wallet and find your private key
  * Install the required frameworks
  * Configure the starter kit with your environment variables
  * Simulate a Chainlink Functions request
  * Set up a subscription for Chainlink Functions
  * Send a Chainlink Functions request to the DON

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

## Set up your environment

You must provide the private key from a testnet wallet to run the examples in
this documentation. Install a Web3 wallet, configure
[Node.js](https://nodejs.org/en/download/), clone the [Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit.git),
and configure a `.env` file with the required variables.

Install and configure your Web3 wallet for Polygon Mumbai:

  1. [Install the MetaMask wallet](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) or other Ethereum Web3 wallet.

  2. Set the network for your wallet to the Polygon Mumbai testnet. If you need to add Mumbai to your wallet, you can find the chain ID and the LINK token contract address on the [LINK Token Contracts](/resources/link-token-contracts#mumbai-testnet) page.

    * [Polygon Mumbai testnet

](/resources/link-token-contracts#mumbai-testnet)

  3. Request testnet MATIC from the [Polygon Faucet](https://faucet.polygon.technology/).

  4. Request testnet LINK from [faucets.chain.link/mumbai](https://faucets.chain.link/mumbai).

Install the required frameworks and dependencies:

  1. [Install Node.js 18](https://nodejs.org/en/download/). Optionally, you can use the [nvm package](https://www.npmjs.com/package/nvm) to switch between Node.js versions with `nvm use 18`.

**Note** : The starter kit only supports node versions at 18 or higher. To
ensure you are running the correct version in a terminal, type `node -v`.

    
        node -v
    
        $ node -v
    v18.7.0

  2. In a terminal, clone the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit.git) repository and change directories.
    
        git clone https://github.com/smartcontractkit/functions-hardhat-starter-kit.git && \
    cd functions-hardhat-starter-kit/

  3. Run `npm install` to install the dependencies.
    
        npm install

  4. For higher security, the starter kit encrypts your environment variables at rest.

    1. Set an encryption password for your environment variables.
        
                npx env-enc set-pw

    2. Run `npx env-enc set` to configure a `.env.enc` file with the basic variables that you need to send your requests to the Polygon Mumbai network.

      * `POLYGON_MUMBAI_RPC_URL`: Set a URL for the Polygon Mumbai testnet. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.

      * `PRIVATE_KEY`: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to [Export a Private Key](https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key). Set this in the `.env` file. **Note** : The Chainlink Functions hardhat starter kit uses your private key to sign any transactions you make such as deploying your consumer contract, creating subscriptions, and making requests.
        
                npx env-enc set

  5. Compile the contracts in the repository. You will see several compile warnings, but no errors.
    
        npx hardhat compile

Simulate a request to test your environment and make sure everything is
configured correctly. Run the `npx hardhat functions-simulate` command. The
simulation runs on a local Hardhat network (a local Ethereum network node
designed for development) and executes a request defined in the default
[Functions-request-config.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/Functions-request-config.js) file. The starter
kit includes the capability to simulate transactions so you can quickly test
your code before you send it to the DON.


    npx hardhat functions-simulate

If the simulation is successful, the output includes the simulated on-chain
response:


    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000000f50ed
    Decoded as a uint256: 1003757
    
    Gas used by sendRequest: 360602
    Gas used by client callback function: 75029

## Configure your on-chain resources

After you configure your local environment, configure some on-chain resources
to process your requests, receive the responses, and pay for the work done by
the DON.

Deploy an on-chain
[FunctionsConsumer.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/FunctionsConsumer.sol) contract, create a
[subscription](/chainlink-functions/resources/subscriptions), and fund the
subscription with LINK to pay for requests after they are fulfilled.

  1. Deploy the consumer contract and record the contract address. For now, you can skip on-chain contract verification with the `--verify false` flag. If you do need to [verify](https://blog.chain.link/how-to-verify-a-smart-contract-on-etherscan) your contract on-chain, sign up for a [free Polygonscan API key](https://polygonscan.com/login) and include the key in your `.env.enc` file by running `npx env-enc set` and set `POLYGONSCAN_API_KEY`.
    
        npx hardhat functions-deploy-client --network polygonMumbai --verify false

Find the contract address in the output:

    
        FunctionsConsumer contract deployed to 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea on mumbai

  2. Create a Chainlink Functions subscription and add your contract as an approved consumer contract. You can do this with a single transaction if you include your contract address with the `--contract` flag. For this example, 1 LINK is more than enough on the Mumbai testnet. You can always get more LINK from [faucets.chain.link](https://faucets.chain.link/mumbai) and later add it to the subscription. See the [Subscriptions Management](/chainlink-functions/resources/subscriptions#fund-a-subscription) page for details.
    
        npx hardhat functions-sub-create --network polygonMumbai --amount 1 --contract YOUR_CONSUMER_CONTRACT_ADDRESS

Record the subscription ID from the output.

    
        Created subscription with ID: 443
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 1.0 LINK
    1 authorized consumer contract:
    [ '0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea' ]

## Run the example request

After your environment and on-chain resources are configured, you can send
your request to the DON to execute the request defined in the [Functions-
request-config.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/Functions-request-config.js) file. Run `npx hardhat
functions-request`. Specify your subscription ID with the `--subid` flag and
specify your consumer contract address with the `--contract` flag.


    npx hardhat functions-request --subid YOUR_SUBSCRIPTION_ID --contract YOUR_CONSUMER_CONTRACT_ADDRESS --network polygonMumbai

The on-chain transaction and request will take longer to complete than the
simulation. The output includes a decoded response:


    Actual amount billed to subscription #443:
    ┌──────────────────────┬─────────────────────────────┐
    │         Type         │           Amount            │
    ├──────────────────────┼─────────────────────────────┤
    │  Transmission cost:  │  0.000074413446128386 LINK  │
    │      Base fee:       │          0.2 LINK           │
    │                      │                             │
    │     Total cost:      │  0.200074413446128386 LINK  │
    └──────────────────────┴─────────────────────────────┘
    
    
    ✔ Request 0x4b97078053700c816e6ba1cd54fa5a5b4c279f36c6e4a4be690a71ba84d26819 fulfilled! Data has been written on-chain.
    
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000000f50ed
    Decoded as a uint256: 1003757

If your request is successful, you have all the tools that you need to make
your own custom requests. Edit the [Functions-request-
config.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/Functions-request-config.js) file and the [calculation-
example.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/calculation-example.js) source file with your own code. Then,
run the `npx hardhat functions-request` command again to test your changes.
You can re-use the same consumer contract and subscription for different
requests.

Chainlink Functions is capable of much more than just computation. Try one of
the [Tutorials](/chainlink-functions/tutorials) to see examples that can GET
and POST to public APIs, securely handle API secrets, handle custom responses,
and query multiple APIs.

## What's next

  * [› Try out the Chainlink Functions Tutorials](/chainlink-functions/tutorials)
  * [› Read the Concepts page to learn about the core concepts behind Chainlink Functions](/chainlink-functions/resources/concepts)
  * [› Read the Architecture to understand how Chainlink Functions operates](/chainlink-functions/resources/architecture)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/getting-started.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Adding Chainlink Functions to an Existing Project

  * Overview
  * Before you begin
  * Configure Hardhat
  * Get the dependency contracts and scripts
  * Configure on-chain resources
  * Create a consumer contract
  * Deploy a consumer contract
  * Create and fund a subscription
  * Send requests
  * Create a request script

The [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) lets
you run several example requests, but extra steps are required to add
Chainlink Functions to your existing projects.

If you are new to Chainlink Functions, complete the steps in the [Getting
Started Guide](/chainlink-functions/getting-started) to learn the basics. If
you already have a project, you can skip to the Libraries and Dependencies
section.

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

Using Chainlink Functions to your existing projects requires the following
components:

  * **A consumer contract:** Use this contract to send requests to the Chainlink Functions decentralized oracle network (DON). The consumer contract imports the following dependencies: 
    * [FunctionsClient.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/dev/functions/FunctionsClient.sol): This includes several functions necessary to submit requests to the DON.
    * [ConfirmedOwner.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwner.sol) from the [@chainlink/contracts](https://www.npmjs.com/package/@chainlink/contracts) NPM package.
  * **A Chainlink Functions subscription:** The subscription is used to pay for Chainlink Functions requests when they are fulfilled. You can [create and fund](/chainlink-functions/resources/subscriptions) subscriptions using the starter kit tools, but this guide shows you how to manage subscriptions programmatically.

## Before you begin

This guide assumes you are using a [Hardhat](https://hardhat.org/) JavaScript
project with Node.js, but you can modify it to work with other frameworks. If
you already have a project, you can skip to the Libraries and Dependencies
section.

You must have a wallet with testnet LINK and native tokens to run this
example. This example uses Polygon Mumbai, but you can use any of the
[Supported Networks](/chainlink-functions/supported-networks). You can get
testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai) and
testnet MATIC at the [Polygon Faucet](https://faucet.polygon.technology/). To
learn how to get testnet funds for other networks, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

### Configure Hardhat

If you don't already have a Hardhat project, start one with the following
steps:

  1. Install [Node.js](https://nodejs.org/en/download/). **Note** : Node.js version 18 is required.

  2. Make a new project directory:
    
        mkdir new-functions-project && cd new-functions-project

  3. Create a new Node.js project:
    
        npm init

  4. Install Hardhat as a dev dependency:
    
        npm install --save-dev hardhat

  5. Install the dependency packages:
    
        npm install @chainlink/contracts @chainlink/env-enc @openzeppelin/contracts @openzeppelin/contracts-upgradeable eth-crypto dotenv axios vm2 is-http-url prompt-sync

  6. Create a new Hardhat project. For this example, create a JavaScript project and use the default configurations:
    
        npx hardhat

  7. Remove the `Lock.sol` contract that Hardhat creates by default. This contract is not necessary to compile it for this tutorial.
    
        rm ./contracts/Lock.sol

  8. Use `curl` to get the example hardhat config file `hardhat.config.js`:
    
        curl -o hardhat.config.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/hardhat.config.js

  9. Open `hardhat.config.js`. To use a different network, see the [Supported Networks](/chainlink-functions/supported-networks) page for a list of networks where Chainlink Functions DONs are available. This example uses Polygon Mumbai by default.

  10. For higher security, you should encrypt your environment variables at rest.

    1. Set an encryption password for your environment variables.
        
                npx env-enc set-pw

    2. Run `npx env-enc set` to configure a `.env.enc` file with the basic variables that you need to send your requests to the Polygon Mumbai network.

      * `POLYGON_MUMBAI_RPC_URL`: Set a URL for the Polygon Mumbai testnet. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.

      * `PRIVATE_KEY`: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to [Export a Private Key](https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key). Set this in the `.env` file. **Note** : The Chainlink Functions hardhat starter kit uses your private key to sign any transactions you make such as deploying your consumer contract, creating subscriptions, and making requests.
        
                npx env-enc set

Run the compile command for Hardhat or your framework of choice to make sure
everything is configured correctly. You will see several compile warnings, but
everything is correct if the Solidity files compile successfully. For this
example, run:


    npx hardhat compile

## Get the dependency contracts and scripts

Get the required libraries from the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You
can clone the repo and copy the folders into your existing project manually,
or use a single command to get a tarball through the GitHub API and extract
the folders you need to the correct location in your project.

  1. Open a terminal and change directories to the root of your project. Usually this is the folder with `package.json`.

  2. Run the `curl` command to download the latest tarball from the starter kit `main` branch and then run `tar -xf` with the `--strip` flag to extract only the files you need. The following command combines both steps:

MacOSLinux

    
        curl -L -o ../functions.tar.gz https://api.github.com/repos/smartcontractkit/functions-hardhat-starter-kit/tarball/main &&
    tar -xf ../functions.tar.gz --strip=1 --wildcards smartcontractkit-functions-hardhat-starter-kit-*/contracts/dev smartcontractkit-functions-hardhat-starter-kit-*/contracts/test smartcontractkit-functions-hardhat-starter-kit-*/FunctionsSandboxLibrary smartcontractkit-functions-hardhat-starter-kit-*/contracts/FunctionsConsumer.sol
    
        curl -L -o ../functions.tar.gz https://api.github.com/repos/smartcontractkit/functions-hardhat-starter-kit/tarball/main &&
    tar -xf ../functions.tar.gz --strip=1 -T <(echo -e ""smartcontractkit-functions-hardhat-starter-kit-*/contracts/dev\nsmartcontractkit-functions-hardhat-starter-kit-*/contracts/test\nsmartcontractkit-functions-hardhat-starter-kit-*/FunctionsSandboxLibrary\nsmartcontractkit-functions-hardhat-starter-kit-*/contracts/FunctionsConsumer.sol"")

When you are done, you should have the necessary dependencies in the following
directories:

  * `contracts/dev`
  * `contracts/test`
  * `FunctionsSandboxLibrary`

Run the compile command to make sure all the dependencies are satisfied. Add
missing dependencies or Hardhat configuration options as necessary. For
Hardhat, run `npx hardhat compile`.


    npx hardhat compile

## Configure on-chain resources

The on-chain resources are critical for Chainlink Functions to process your
requests.

  1. Create a consumer contract
  2. Deploy a consumer contract

### Create a consumer contract

Use the [FunctionsConsumer.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/FunctionsConsumer.sol), which is
already in your `./contracts` folder. You can modify it to fit your needs and
redeploy it later. Optionally, you can take an existing contract of your own
and enable it to handle Chainlink Functions requests. Just make sure that it
meets the requirements listed in this guide.

In general, a consumer contract requires several components:

  * To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol). You can read the API reference: [FunctionsClient](/chainlink-functions/api-reference/FunctionsClient).

This contract is not available in an NPM package, so you must download and
import it from within your project.

    
        import {Functions, FunctionsClient} from ""./dev/functions/FunctionsClient.sol"";

  * Use the [Functions.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/Functions.sol) library to get all the functions needed for building a Chainlink Functions request. You can read the API reference: [Functions](/chainlink-functions/api-reference/Functions).
    
        using Functions for Functions.Request;
    

  * The latest request id, latest received response, and latest received error (if any) are defined as state variables. Note `latestResponse` and `latestError` are encoded as dynamically sized byte array `bytes`, so you will still need to decode them to read the response or error:
    
        bytes32 public latestRequestId;
    bytes public latestResponse;
    bytes public latestError;

  * We define the `OCRResponse` event that your smart contract will emit during the callback
    
        event OCRResponse(bytes32 indexed requestId, bytes result, bytes err);

  * Pass the oracle address for your network when you deploy the contract:
    
        constructor(address oracle) FunctionsClient(oracle)

  * At any time, you can change the oracle address by calling the `updateOracleAddress` function.

  * The two remaining functions are:

    * `executeRequest` for sending a request. It receives the JavaScript source code, encrypted secrets, list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

      * It uses the `Functions`library to initialize the request and add any passed encrypted secrets or arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/Functions/#initializerequest), [adding secrets](/chainlink-functions/api-reference/Functions/#addinlinesecrets), and [adding arguments](/chainlink-functions/api-reference/Functions/#addargs).
            
                        Functions.Request memory req;
            req.initializeRequest(Functions.Location.Inline, Functions.CodeLanguage.JavaScript, source);
            if (secrets.length > 0) {
              req.addRemoteSecrets(secrets);
            }
            if (args.length > 0) req.addArgs(args);

      * It sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Finally, it stores the request id in `latestRequestId`.
            
                        bytes32 assignedReqID = sendRequest(req, subscriptionId, gasLimit);
            latestRequestId = assignedReqID;

    * `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `latestResponse` and `latestError` before emitting the `OCRResponse` event.
        
                latestResponse = response;
        latestError = err;
        emit OCRResponse(requestId, response, err);

Next, deploy the contract.

### Deploy a consumer contract

You can deploy consumer contracts using the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit), but
this example shows how to deploy the contract programmatically using a script.

  1. Use `curl` to get the example deployment script `deploy.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/deploy.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/deploy.js

  2. Open `deploy.js` in your editor of choice.

  3. Set the `oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  4. Set `const contractName` to the name of the contract that you want Hardhat to deploy. The `ethers.getContractFactory(contractName);` line creates a `ContractFactory` object using the contract that you define. For this example, use `FunctionsConsumer`.
    
        const contractName = ""FunctionsConsumer""
    
    ⋮
    
    const consumerContract = await ethers.getContractFactory(contractName);

  5. Save the file and run the script to deploy your contract. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run ./scripts/deploy.js --network your_network

Example:

    
        npx hardhat run ./scripts/deploy.js --network polygonMumbai

  6. If your contract deployed successfully, you will see the deployed consumer address. Record this address to use later:
    
        Deployed Functions Consumer address: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Next, create and fund your Chainlink Functions subscription.

### Create and fund a subscription

You can use the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to
create and manage your subscriptions. See [Managing Subscriptions](/chainlink-functions/resources/subscriptions) for instructions.

This example shows how to create and manage subscriptions programmatically.
You can create the subscription, fund the subscription, and authorize the
consumer all in one script. If you have not already signed up for limited Beta
access to Chainlink Functions, apply [here](http://functions.chain.link/) to
add your EVM account address to the Allow List.

  1. Ensure that the wallet address you are using to create the subscription has a sufficient LINK balance. You can get testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai). To get testnet funds for other networks, see the [LINK Token Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

  2. Use `curl` to get the example subscription script `functions-sub.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/functions-sub.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/functions-sub.js

  3. Open `functions-sub.js` in your editor of choice.

  4. Set `const linkAmount` with the amount of LINK you want to send to the subscription. You can retrieve extra funds later when you cancel the subscription.
    
        const linkAmount = ""1""

  5. Set `const consumer` to the address of the consumer contract that you deployed:
    
        const consumer = ""0x5484e266c2cD379800e6F27EaB097Bb806647CbF""

  6. Save the file and run the script. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run scripts/functions-sub.js --network your_network

Example:

    
        npx hardhat run scripts/functions-sub.js --network polygonMumbai

  7. If the script is successful, you the terminal prints your subscription ID. Record this ID to use for Chainlink Functions requests. You should see output similar to the following example:
    
        Subscription created with ID: 917
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Subscription 917 funded with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Adding consumer contract address 0x5484e266c2cD379800e6F27EaB097Bb806647CbF to subscription 917
    Authorized consumer contract: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Now that the consumer contract is deployed and the subscription is created and
funded with LINK, the on-chain resources are ready to handle your requests.
Next, create JavaScript code that you want to run on the DON, configure
arguments for the code, and create a script to send your request.

## Send requests

After your on-chain resources are configured, you can send Chainlink Functions
requests to the DON. This can be done from a Web3 application, script, another
on-chain smart contract, or any other location capable of submitting requests
to your consumer contract. This example shows you how to generate a request,
encrypt secrets, send your request, and read the fulfillment response.

Each request has the following components:

  * **Source code:** JavaScript code that will run on the DON.
  * **Arguments:** Optional arguments for the source code. The arguments that you need are defined in your source code. Depending on how you configured your source, you might not need any arguments at all.
  * **Secrets:** Optional secrets that your source code needs to access APIs or other interfaces. See the [Using Secrets in Requests](/chainlink-functions/tutorials/api-use-secrets) and [Using Off-chain Secrets](/chainlink-functions/tutorials/api-use-secrets-offchain) tutorials for examples.

### Create a request script

If you already have source code or want to write your own source code, put it
in a file in your project. Later, you can specify the path to this file before
you submit your request.

For this example, download some example source code and create a script to
assemble the required components. The script will read your source code,
define arguments, encrypt secrets, and send requests to your consumer
contract. This example script does not require Hardhat, so you can modify it
to run in a browser using Ethers or another framework.

  1. Use `curl` to get the example source code. This code runs on each node in the DON and returns a response to your consumer contract. For this example, use the source from the [Call an API](/chainlink-functions/tutorials/api-query-parameters) tutorial. The following `curl` request creates a file named `Functions-request-source.js` with the source code:
    
        curl -o Functions-request-source.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/Functions-request-source.js

  2. Get the example script and put it in the `./scripts` directory:
    
        curl -o ./scripts/request.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/request.js

  3. Edit the `request.js` script and set your deployed consumer address in `const consumerAddress`:
    
        const consumerAddress = 0x5484e266c2cd379800e6f27eab097bb806647cbf

  4. Set `const subscriptionId` to your Chainlink Functions subscription ID. This must be the same ID that your consumer contract is authorized to use. You can [add a consumer contract to a subscription](/chainlink-functions/resources/subscriptions#add-a-consumer-contract-to-a-subscription) later if you need to.
    
        const subscriptionId = 917

  5. Set `const consumerAbiPath` to the ABI file that you created when you ran `npx hardhat compile`. The ABI tells Ethers how to interact with your deployed contract. If you compiled and deployed `FunctionsConsumer.sol`, set a path like the following example:
    
        const consumerAbiPath = ""./artifacts/contracts/FunctionsConsumer.sol/FunctionsConsumer.json""

  6. Set `const source` with the path to the request source code that you downloaded earlier:
    
        const source = ./Functions-request-source.js

  7. Set `const args` with an array of arguments for the DON to use when it runs your source. If you look at the `Functions-request-source.js` file, you can see that it requires two arguments. The args define which assets to retrieve from the data source URL.
    
        const args = [""ETH"", ""USD""]

  8. Set `const oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  9. Set `const oracleAbiPath` to the ABI for the oracle contract. If you downloaded and compiled the dependencies for deploying your consumer contract, the oracle ABI is already generated in `./artifacts/contracts/dev/functions/`:
    
        const oracleAbiPath = ""./artifacts/contracts/dev/functions/FunctionsOracle.sol/FunctionsOracle.json""

  10. Secrets are not required for this example.

  11. Save and close the script.

  12. Run the script to send the request to the DON.
    
        npx hardhat run scripts/request.js --network your_network

Example:

    
        npx hardhat run scripts/request.js --network polygonMumbai

If the script runs successfully, the script reads your consumer contract and
prints the stored value that the DON returned.


    Waiting 2 blocks for transaction 0x949184e7b605f034ce1d1d954973dc7132efb815bfa4861c54774cee457566d8 to be confirmed...
    
    Request 0xb3a4f9f47caeb83c5125ee61e2db1ca41beaa8a6781fb3c4364b4d394c40bc6b initiated
    Waiting for fulfillment...
    
    
    Request 0xb3a4f9f47caeb83c5125ee61e2db1ca41beaa8a6781fb3c4364b4d394c40bc6b fulfilled!
    Response returned to client contract represented as a hex string: 180972

Now you have the tools you need to build your own applications that use
Chainlink Functions. Modify `Functions-request-source.js` and your input
arguments to try out different capabilities. For more examples, see the
[Tutorials](/chainlink-functions/tutorials) section.

## What's next

  * [› Try out the Chainlink Functions Tutorials](/chainlink-functions/tutorials)
  * [› Read the Concepts page to learn about the core concepts behind Chainlink Functions](/chainlink-functions/resources/concepts)
  * [› Read the Architecture to understand how Chainlink Functions operates](/chainlink-functions/resources/architecture)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/add-functions-to-projects.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of disallowing local network and multicast IPs by default in HTTPGet?,"For security, because the URL can come from an untrusted source, HTTPGet imposes some restrictions on which IPs may be fetched. Local network and multicast IPs are disallowed by default and attempting to connect will result in an error.",{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/'},"Disallowing local network and multicast IPs by default in HTTPGet is a security measure to prevent unauthorized access to potentially sensitive information. However, it is possible to enable local/private connections by modifying the configuration. According to the Chainlink documentation, you can use the `allowUnrestrictedNetworkAccess` parameter in the HTTP task to permit access to URLs at localhost. This parameter can be set to `true` to enable local/private connections. Additionally, Bridge tasks allow unrestricted network access by default. It is important to note that enabling unrestricted network access can present security risks, so it should be done cautiously and with proper security measures in place.

","- https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/
- https://stackoverflow.com/questions/70022029/how-to-enable-local-bridge-httpget-task-api-connection-to-chainlink-node","# Core Adapters [v1]

  * Overview
  * Adapters
  * Compare
  * Copy
  * EthBool
  * EthBytes32
  * EthInt256
  * EthTx
  * EthUint256
  * HttpGet
  * HttpPost
  * JsonParse
  * Multiply
  * NoOp
  * NoOpPend
  * Quotient
  * Sleep

# REMOVED

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

## Adapters

Core adapters are the built-in functionality that every Chainlink node
supports. Strung together, they act as tasks that need to be performed to
complete a Job.

Adapters that are prefixed with ""Eth"" refer to tasks that post data onto the
chain. Here are some examples of the data types that adapters convert data to.

| Name              | Core Adapter   | Ethereum Data Type   |
|:------------------|:---------------|:---------------------|
| Signed Integers   | EthInt256      | int256               |
| Unsigned Integers | EthUint256     | uint256              |
| Bytes             | EthBytes32     | bytes32              |
| Boolean           | EthBool        | bool                 |
You can learn more about Solidity data types
[here](https://docs.soliditylang.org/en/latest/types.html).

## Compare

This core adapter compares a user-specified value with the value from the
previous adapter's result.

#### Parameters

  * `operator`: the operator used to compare values. You may use one of the following: 
    * `eq`: Equals
    * `neq`: Not equals
    * `gt`: Greater than
    * `gte`: Greater than or equals to
    * `lt`: Less than
    * `lte`: Less than or equals to
  * `value`: the value to check against the previous adapter's result. May be a string or a number, but if the value is a string, only `eq` and `neq` may be used.

#### Solidity Example


    req.addInt(""value"", 10000);
    req.add(""operator"", ""gte"");

## Copy

The core adapter walks the `copyPath` specified and returns the value found at
that result. If returning JSON data from an [external adapter](/chainlink-nodes/external-adapters/external-adapters), you will need to use this adapter
to parse the response.

#### Parameters

  * `copyPath`: takes an array of strings, each string being the next key to parse out in the JSON object or a single dot-delimited string.

#### Solidity Example

For the JSON object:


    { ""RAW"": { ""ETH"": { ""USD"": { ""LASTMARKET"": ""_someValue"" } } } }

You would use the following for an array of strings:


    string[] memory path = new string(4);
    path[0] = ""RAW"";
    path[1] = ""ETH"";
    path[2] = ""USD"";
    path[3] = ""LASTMARKET"";
    req.addStringArray(""copyPath"", path);

Or the following for a single comma-delimited string:


    req.add(""copyPath"", ""RAW,ETH,USD,LASTMARKET"");

note

#### Job Specification Example


    {
      ""type"": ""Copy"",
      ""params"": {
        ""copyPath"": [""RAW"", ""ETH"", ""USD"", ""LASTMARKET""]
      }
    }

For arrays, you can access the path of an array by using the index. If this is
your JSON:


    { ""endpoint"": [{ ""path"": ""value"" }] }

You could get the `""value""` by:


    req.add(""copyPath"", ""endpoint.0.path"");

## EthBool

The core adapter reads the given Boolean value and then converts it into
Solidity's `bool` format.

#### Parameters

_None taken._

## EthBytes32

The core adapter formats its input into a string and then converts it into
Solidity's `bytes32` format.

#### Parameters

_None taken._

## EthInt256

The core adapter formats its input into an integer and then converts it into
Solidity's `int256` format.

#### Parameters

_None taken._

## EthTx

The core adapter takes the input given and places it into the data field of
the transaction. It then signs an Ethereum transaction and broadcasts it to
the network. The task is only completed once the transaction's confirmations
equal the
[`MIN_OUTGOING_CONFIRMATIONS`](https://github.com/smartcontractkit/chainlink/wiki/Configuration-Variables#min_outgoing_confirmations) amount.

If the transaction does not confirm by the time
[`ETH_GAS_BUMP_THRESHOLD`](https://github.com/smartcontractkit/chainlink/wiki/Configuration-Variables#eth_gas_bump_threshold) number of blocks have passed since initially
broadcasting, then it bumps the gas price of the transaction by
[`ETH_GAS_BUMP_WEI`](https://github.com/smartcontractkit/chainlink/wiki/Configuration-Variables#eth_gas_bump_wei).

#### Parameters

  * `address`: the address of the Ethereum account which the transaction will be sent to.
  * `functionSelector`: **(optional)** the [function selector](https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI#function-selector) of the contract which the transaction will invoke. `functionSelector` is placed before `dataPrefix` and the adapter's input in the data field of the transaction.
  * `dataPrefix`: **(optional)** data which will be prepended before the adapter's input, but after the `functionSelector` in the transaction's data field.
  * `value`: **(optional)** data to send to the function, will append after the `dataPrefix` payload if it's included. Will automatically come from the previous task.

## EthUint256

The core adapter formats its input into an integer and then converts it into
Solidity's `uint256` format.

#### Parameters

_None taken._

## HttpGet

The core adapter will report the body of a successful `GET` request to the
specified `get`, or return an error if the response status code is greater
than or equal to 400.

#### Parameters

  * `get`: takes a string containing the URL to make a `GET` request to.
  * `queryParams`: takes a string or array of strings for the URL's query parameters.
  * `extPath`: takes a slash-delimited string or array of strings to be appended to the job's URL.
  * `headers`: takes a object containing keys as strings and values as arrays of strings.

Headers

Currently not available on-chain. Available for job specs only.

#### Solidity Example


    req.add(""get"", ""http://example.com"");
    req.add(""queryParams"", ""firstKey=firstVal&secondKey=secondVal"");
    req.add(""extPath"", ""price/BTC/USD"");

#### Job Specification Example


    {
      ""type"": ""HttpGet"",
      ""params"": {
        ""get"": ""https://example.com/some-endpoint"",
        ""headers"": {
          ""X-API-Key"": [""abc123abc123abc123abc123""]
        }
      }
    }

Local network and multicast IPs are disallowed by default

For security, because the URL can come from an untrusted source, HTTPGet
imposes some restrictions on which IPs may be fetched. Local network and
multicast IPs are disallowed by default and attempting to connect will result
in an error.

If you really must access one of these IPs, you can use the
`HTTPGetWithUnrestrictedNetworkAccess` adapter instead.

## HttpPost

The core adapter will report the body of a successful `POST` request to the
specified `post`, or return an error if the response status code is greater
than or equal to 400.

#### Parameters

  * `post`: takes a string containing the URL to make a `POST` request to.
  * `headers`: takes a object containing keys as strings and values as arrays of strings.
  * `queryParams`: takes a string or array of strings for the URL's query parameters.
  * `extPath`: takes a slash-delimited string or array of strings to be appended to the job's URL.
  * `body`: the JSON body (as a string) that will be used as the data in the request.

note

#### Solidity Example


    req.add(""post"", ""http://post.example.com"");
    req.add(""queryParams"", ""firstKey=firstVal&secondKey=secondVal"");
    req.add(""extPath"", ""price/BTC/USD"");

#### Job Specification Example


    {
        ""type"": ""HttpPost"",
        ""params"": {
            ""post"": ""https://example.com/some-endpoint"",
            ""headers"": {
                ""X-API-Key"": [
                    ""abc123abc123abc123abc123""
                ]
            }
        }
    }

Local network and multicast IPs are disallowed by default

For security, because the URL can come from an untrusted source, HTTPGet
imposes some restrictions on which IPs may be fetched. Local network and
multicast IPs are disallowed by default and attempting to connect will result
in an error.

If you really must access one of these IPs, you can use the
`HTTPPostWithUnrestrictedNetworkAccess` adapter instead.

## JsonParse

The core adapter walks the `path` specified and returns the value found at
that result. If returning JSON data from the [HttpGet](/chainlink-nodes/oracle-jobs/v1/adapters/#httpget) or [HttpPost](/chainlink-nodes/oracle-jobs/v1/adapters/#httppost) adapters, you must use this adapter to parse the
response.

#### Parameters

  * `path`: takes an array of strings, each string being the next key to parse out in the stringified JSON result or a single dot-delimited string.

#### Solidity Example

For the stringified JSON:


    { ""RAW"": { ""ETH"": { ""USD"": { ""LASTMARKET"": ""_someValue"" } } } }

You would use the following for an array of strings:


    string[] memory path = new string[](4);
    path[0] = ""RAW"";
    path[1] = ""ETH"";
    path[2] = ""USD"";
    path[3] = ""LASTMARKET"";
    req.addStringArray(""path"", path);

Or the following for a single comma-delimited string:


    req.add(""path"", ""RAW,ETH,USD,LASTMARKET"");

note

Chainlink nodes prior to 1.0.0 support dot-delimited strings instead of comma-
delimited strings.

#### Job Specification Example


    {
      ""type"": ""JsonParse"",
      ""params"": {
        ""path"": [""RAW"", ""ETH"", ""USD"", ""LASTMARKET""]
      }
    }

#### Parsing Arrays


    req.add(""path"", ""3,standardId"");

The above example parses the 4th object of the following JSON response and
returns 677 as a result:


    ;[
      {
        standardId: 20,
        name: ""ERC-20"",
      },
      {
        standardId: 721,
        name: ""ERC-721"",
      },
      {
        standardId: 1155,
        name: ""ERC-1155"",
      },
      {
        standardId: 677,
        name: ""ERC-677"",
      },
    ]

## Multiply

The core adapter parses the input into a float and then multiplies it by the
`times` field.

#### Parameters

  * `times`: the number to multiply the input by.

#### Solidity Example


    run.addInt(""times"", 100);

## NoOp

The core adapter performs no operations, simply passing the input on as
output. Commonly used for testing.

#### Parameters

_None taken._

## NoOpPend

The core adapter performs no operations, and marks its task run pending.
Commonly used for testing.

#### Parameters

_None taken._

## Quotient

Quotient

The core adapter gives the result of x / y where x is a specified value
(dividend) and y is the input value (result).

This can be useful for inverting outputs, e.g. if your API only offers a
USD/ETH conversion rate and you want ETH/USD instead you can use this adapter
with a dividend of 1 to get the inverse (i.e. 1 / result).

#### Parameters

  * `dividend`: the number which is divided by the result

## Sleep

The core adapter will pause the current task pipeline for the given duration.

ENABLE_EXPERIMENTAL_ADAPTERS

You must set `ENABLE_EXPERIMENTAL_ADAPTERS=true` in order to use the sleep
adapter.

#### Parameters

  * `until`: the UNIX timestamp of when the job should stop sleeping and resume at the next task in the pipeline.

#### Solidity Example


    req.addUint(""until"", now + 1 hours);

#### Job Specification example


    {
      ""initiators"": [
        {
          ""type"": ""web"",
          ""params"": {
          }
        }
      ],
      ""tasks"": [
        {
          ""type"": ""sleep"",
          ""params"": {
            ""until"": ""1605651000""
          }
        }
      ]
    }

## What's next

  * [› Introduction to External Adapters](/chainlink-nodes/external-adapters/external-adapters)
  * [› Initiators](/chainlink-nodes/oracle-jobs/v1/initiators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/adapters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-11-18 14:56:42)
how to enable local bridge/httpget/task api connection to chainlink node?
URL: https://stackoverflow.com/questions/70022029/how-to-enable-local-bridge-httpget-task-api-connection-to-chainlink-node

Question Body:


I have a custom API running on <http://127.0.0.1:8080> and I have my own
chainlink node running on <http://127.0.0.1:6688>. I get the error saying
""Connections to local/private and multicast networks are disabled by default
for security reasons: disallowed IP"" when sending requests.

I guess maybe we can enable it by modifying the env file, but I don't know
which configuration should I change. Does anyone know if we can enable these
local/private connections? and how to do that?



Answers:
(Answered on: 2021-11-20 17:32:25)


Per the [chainlink docs on the http
task](https://docs.chain.link/docs/jobs/task-types/http/):

> allowUnrestrictedNetworkAccess (optional): permits the task to access a URL
> at localhost, which could present a security risk. Note that Bridge tasks
> allow this by default.

ie:

    
    
    my_http_task [type=""http""
                  method=PUT
                  url=""http://chain.link""
                  requestData=""{\\""foo\\"": $(foo), \\""bar\\"": $(bar), \\""jobID\\"": 123}""
                  allowUnrestrictedNetworkAccess=true
                  ]
    

You can also use this flag in JSON



"
What is the purpose of the Proof of Reserve feeds mentioned in the text?,"The Proof of Reserve feeds are used to attest to the reserves held by various assets, including US Dollar, Gold, Staked ETH, Bitcoin, and Wrapped Filecoin, among others.",{'source': 'https://docs.chain.link/data-feeds/proof-of-reserve/addresses/'},"The purpose of the Proof of Reserve feeds mentioned in the text is to provide the status of reserves for several assets. These feeds can be used to verify the reserves of both off-chain assets and cross-chain assets. The feeds provide data attestation variations and help highlight the inherent market risks surrounding the data quality of these feeds. The Proof of Reserve feeds can be read in the same way as other Data Feeds, by specifying the Proof of Reserve Feed Address. The feeds can be used to drive breakthroughs in various areas such as cancer, Alzheimer's, and diabetes. It is important to carefully review the quality of the data and assume full responsibility for any loss caused by the use of these feeds.

",https://docs.chain.link/data-feeds/proof-of-reserve/,"# Proof of Reserve Feeds

  * Overview
  * Types of Proof of Reserve Feeds
  * Off-chain reserves
  * Cross-chain reserves
  * Using Proof of Reserve Feeds

Chainlink Proof of Reserve Feeds provide the status of the reserves for
several assets. You can read these feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

To find a list of available Proof of Reserve Feeds, see the [Proof of Reserve
Feed Addresses](/data-feeds/proof-of-reserve/addresses) page.

## Types of Proof of Reserve Feeds

Reserves are available for both cross-chain assets and off-chain assets. This
categorization describes the data attestation variations of Proof of Reserve
feeds and helps highlight some of the inherent market risks surrounding the
data quality of these feeds.

Reserves are available for both off-chain assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
  * ⚠️ Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

### Cross-chain reserves

Cross-chain reserves are sourced from the network where the reserves are held.
Chainlink node operators can report cross-chain reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of funding smart contracts with LINK or ETH?,Some smart contracts require funding at their addresses so they can operate without you having to call functions manually and pay for the transactions through MetaMask.,{'source': 'https://docs.chain.link/resources/fund-your-contract/'},"The purpose of the `path` variable in the `ATestnetConsumer.sol` example is to specify the path to the desired data in the JSON response. It allows the chainlink node to navigate through the JSON structure and extract the specific value needed. Each element in the `path` array represents a key in the JSON object hierarchy. The chainlink node will follow the path specified in the `path` array to retrieve the desired value.

For example, if the JSON response looks like this:

```
{
  ""RAW"": {
    ""ETH"": {
      ""USD"": {
        ""LASTMARKET"": value
      }
    }
  }
}
```

The `path` array would be:

```
string[] memory path = new string[](4);
path[0] = ""RAW"";
path[1] = ""ETH"";
path[2] = ""USD"";
path[3] = ""LASTMARKET"";
```

This specifies the path to the `LASTMARKET` value in the JSON response.

",- https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example,"# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    



"
What is the purpose of the `fulfillOracleRequest` function in the Oracle contract?,The `fulfillOracleRequest` function is used by the node to fulfill a request once it has the result of the job. This function returns the result to the `ChainlinkClient` using the callback function defined in the original request.,{'source': 'https://docs.chain.link/architecture-overview/architecture-request-model/'},"The purpose of the `fulfillOracleRequest` function in the Oracle contract is to fulfill a request made by an off-chain oracle node. Once the off-chain oracle node has the result of the job, it can use the `fulfillOracleRequest` function to return the result to the `ChainlinkClient` contract using the callback function defined in the original request. This function is responsible for completing the cycle of the request and providing the result back to the smart contract.

",https://docs.chain.link/architecture-overview/architecture-request-model/,"# Basic Request Model

  * Overview
  * Contracts Overview
  * ChainlinkClient
  * LINK Token
  * Oracle Contract
  * Off-Chain Oracle Node
  * Consumer UML

## Contracts Overview

All source code is open source and available in the [Chainlink Github
repository](https://github.com/smartcontractkit/chainlink).

### ChainlinkClient

[`ChainlinkClient`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol)
is a parent contract that enables smart contracts to consume data from
oracles. It's available in the Chainlink smart contract library which can be
[installed using the latest package managers](/resources/create-a-chainlinked-project).

The client constructs and makes a request to a known Chainlink oracle through
the `transferAndCall` function, implemented by the LINK token. This request
contains encoded information that is required for the cycle to succeed. In the
`ChainlinkClient` contract, this call is initiated with a call to
`sendChainlinkRequestTo`.

To build your own client contract using `ChainlinkClient`, see [Introduction
to Using Any API](/any-api/introduction), or view the [ChainlinkClient API
Reference](/any-api/api-reference) for the `ChainlinkClient` contract.

### LINK Token

LINK is an [ERC-677](https://github.com/ethereum/EIPs/issues/677) compliant
token which implements `transferAndCall`, a function that allows tokens to be
transferred whilst also triggering logic in the receiving contract within a
single transaction.

Learn more about [ERC-677 and the LINK token](/resources/link-token-contracts).

### Oracle Contract

[`Oracle`
contracts](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/Oracle.sol)
are owned by oracle node operators, which run alongside off-chain oracle
nodes.

#### Request

The client contract that initiates this cycle must create a request with the
following items:

  * The oracle address.
  * The job ID, so the oracle knows which tasks to perform.
  * The callback function, which the oracle sends the response to.

To learn about how to find oracles to suit your needs, see [Find Existing
Jobs](/any-api/find-oracle).

Oracle contracts are responsible for handling on-chain requests made through
the LINK token, by implementing `onTokenTransfer` as a
[`LinkTokenReceiver`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/LinkTokenReceiver.sol).
Upon execution of this function, the oracle contract **emits an`OracleRequest`
event** containing information about the request. This event is crucial, as it
is monitored by the off-chain oracle node which acts upon it.

#### Fulfillment

For fulfillment, the oracle contract has a `fulfillOracleRequest` function
which is used by the node to fulfill a request once it has the result of the
job. This function returns the result to the `ChainlinkClient` using the
callback function defined in the original request.

### Off-Chain Oracle Node

The off-chain oracle node is responsible for listening for events emitted by
its corresponding on-chain smart contract. Once it detects an `OracleRequest`
event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API,
retrieve some data from it, parse the response, convert the result into
blockchain compatible data, then submit it in a transaction back to the oracle
contract, using the `fulfillOracleRequest` function.

For more information on how to become a node operator, learn how to [run a
Chainlink node](/chainlink-nodes/v1/running-a-chainlink-node).

## Consumer UML

Below is a UML diagram describing the contract structure of
`ATestnetConsumer`, a deployed example contract implementing
`ChainlinkClient`.

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-request-model.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# ChainlinkClient API Reference

  * Overview
  * Index
  * Methods
  * Events
  * Modifiers
  * Constants
  * Structs
  * Methods
  * setChainlinkOracle
  * setChainlinkToken
  * buildChainlinkRequest
  * buildOperatorRequest
  * sendChainlinkRequest
  * sendChainlinkRequestTo
  * sendOperatorRequest
  * sendOperatorRequestTo
  * validateChainlinkCallback
  * addChainlinkExternalRequest
  * cancelChainlinkRequest
  * useChainlinkWithENS
  * updateChainlinkOracleWithENS
  * chainlinkTokenAddress
  * chainlinkOracleAddress
  * Events
  * ChainlinkRequested
  * ChainlinkFulfilled
  * ChainlinkCancelled
  * Constants
  * LINK_DIVISIBILITY
  * Modifiers
  * recordChainlinkFulfillment
  * Chainlink.Request
  * Attributes
  * Methods

API reference for ChainlinkClient

`ChainlinkClient`
[contracts](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol)
can communicate with legacy `Oracle`
[contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or `Operator`
[contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).

## Index

### Methods

| Name                         | Description                                                                                                                    |
|:-----------------------------|:-------------------------------------------------------------------------------------------------------------------------------|
| setChainlinkOracle           | Sets the stored address for the oracle contract                                                                                |
| setChainlinkToken            | Sets the stored address for the LINK token                                                                                     |
| buildChainlinkRequest        | Instantiates a Request object with the required parameters                                                                     |
| buildOperatorRequest         | Instantiates a Request object with the required parameters. Note the oracle must be an Operator contract                       |
| sendChainlinkRequest         | Sends the request payload to the stored address stored as chainlinkOracleAddress                                               |
| sendChainlinkRequestTo       | Sends a request to the oracle address specified                                                                                |
| sendOperatorRequest          | Sends the request payload to the stored address stored as chainlinkOracleAddress. Note the oracle must be an Operator contract |
| sendOperatorRequestTo        | Sends a request to the oracle address specified. Note the oracle must be an Operator contract                                  |
| validateChainlinkCallback    | Secures the fulfillment callback to make sure it is only called by permissioned senders                                        |
| addChainlinkExternalRequest  | Allows a Chainlinked contract to track unfulfilled requests that it hasn't created itself                                      |
| cancelChainlinkRequest       | Cancels Chainlink requests attempting to contact an unresponsive node                                                          |
| useChainlinkWithENS          | Looks up the addresses of the LINK token and Oracle contract through ENS                                                       |
| updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS                                                 |
| chainlinkTokenAddress        | Returns the stored address of the LINK token                                                                                   |
| chainlinkOracleAddress       | Returns the stored address of the oracle contract                                                                              |
### Events

| Name               | Description                                                                  |
|:-------------------|:-----------------------------------------------------------------------------|
| ChainlinkRequested | Emitted from a Chainlinked contract when a request is sent to an oracle      |
| ChainlinkFulfilled | Emitted from a Chainlinked contract when a request is fulfilled by an oracle |
| ChainlinkCancelled | Emitted from a Chainlinked contract when a request is cancelled              |
### Modifiers

| Name                       | Description                                                                                                                                              |
|:---------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------|
| recordChainlinkFulfillment | Used on fulfillment callbacks to ensure that the caller and requestId are valid. This is the modifier equivalent of the method validateChainlinkCallback |
### Constants

| Name              | Description                                                                       |
|:------------------|:----------------------------------------------------------------------------------|
| LINK_DIVISIBILITY | Helper uint256 to represent the divisibility of a LINK token. Equivalent to 10^18 |
### Structs

| Name              | Description                                                          |
|:------------------|:---------------------------------------------------------------------|
| Chainlink.Request | All of the parameters that can be passed over in a Chainlink request |
## Methods

Below you'll find each helper explained in greater detail alongside respective
implementation examples to help you leverage these methods once you start
building your own Chainlinked contract.

After the function signature and a short description, two code examples are
provided, one focusing on the exact usage of the method and one where the
helper is presented in the context of a full contract.

### setChainlinkOracle


    function setChainlinkOracle(
      address _oracle
    )

Sets a private storage variable provided for convenience if your contract only
needs to talk to one oracle and you do not want to specify it on every
request. Once an oracle is set with `setChainlinkOracle` that is the address
used with sendChainlinkRequest.

Retrieve the oracle address using chainlinkOracleAddress. These getters and
setters are provided to enforce that changes to the oracle are explicitly made
in the code.


    constructor(address _oracle)
    {
      setChainlinkOracle(_oracle);
    }

### setChainlinkToken


    setChainlinkToken(
      address _link
    )

Sets the stored address for the LINK token which is used to send requests to
Oracles. There are different token addresses on different network. See [LINK
Token Contracts](/resources/link-token-contracts) for the address of the LINK
token on the network you're deploying to.


    constructor(address _link)
      public
    {
      setChainlinkToken(_link);
    }

### buildChainlinkRequest

Use `buildOperatorRequest` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function buildChainlinkRequest(
        bytes32 _jobId,
        address _callbackAddress,
        bytes4 _callbackFunctionSignature
    ) returns (Chainlink.Request memory request)

Instantiates a Request from the Chainlink contract. A Request is a struct
which contains the necessary parameters to be sent to the oracle contract. The
`buildChainlinkRequest` function takes an ID, which can be a [Job
ID](/chainlink-nodes/oracle-jobs/jobs), a callback address to receive the
resulting data, and a callback function signature to call on the callback
address.


    function requestPrice()
      public
    {
      bytes32 jobId = ""493610cff14346f786f88ed791ab7704"";
      bytes4 selector = this.myCallback.selector;
      // build a request that calls the myCallback function defined
      //   below by specifying the address of this contract and the function
      //   selector of the myCallback
      Chainlink.Request memory request = buildChainlinkRequest(
        jobId,
        address(this),
        selector);
    }

### buildOperatorRequest

This function is similar to `buildChainlinkRequest`function. One major
difference is that `buildOperatorRequest` does not allow setting up the
address of the callback. The callback address is set to the address of the
calling contract.

It is recommended to use `buildOperatorRequest` but make sure the oracle you
are contacting is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function buildOperatorRequest(
        bytes32 _jobId,
        bytes4 _callbackFunctionSignature
    ) returns (Chainlink.Request memory request)

Instantiates a _Request_ from the Chainlink contract. A Request is a struct
that contains the necessary parameters to be sent to the oracle contract. The
`buildOperatorRequest` function takes an ID, which can be a [Job
ID](/chainlink-nodes/oracle-jobs/jobs), and a callback function signature to
call on the calling contract address.


    function requestPrice()
      public
    {
      bytes32 jobId = ""493610cff14346f786f88ed791ab7704"";
      bytes4 selector = this.myCallback.selector;
      // build a request that calls the myCallback function defined
      //   below by specifying the function selector of myCallback
      Chainlink.Request memory request = buildOperatorRequest(
        jobId,
        selector);
    }

### sendChainlinkRequest

Use `sendOperatorRequest` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequest(
        Chainlink.Request memory _req,
        uint256 _payment
    ) returns (bytes32 requestId)

Sends the request payload to the stored oracle address. It takes a
Chainlink.Request and the amount of LINK to send amount as parameters. The
request is serialized and calls `oracleRequest` on the address stored in
`chainlinkOracleAddress` via the LINK token's `transferAndCall` method.

`sendChainlinkRequest` returns the ID of the request. If your application
needs to, your contract can store that ID, but you don't need to. The
ChainlinkClient helpers will store the ID under the hood, along with the
oracle address, and use them when you call `recordChainlinkFulfillment` in
your callback function to make sure only that the address you want can call
your Chainlink callback function.

`sendChainlinkRequest` emits a ChainlinkRequested event containing the request
ID, if you would like to use it in your Web3 application.


    function requestPrice()
      public
    {
      Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.callback.selector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK
    
      // send the request that you just built
      sendChainlinkRequest(request, paymentAmount);
    }

### sendChainlinkRequestTo

Use `sendOperatorRequestTo` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequestTo(
      address _oracle,
      Chainlink.Request memory _req,
      uint256 _payment
    ) returns (bytes32 requestId)

Similar to sendChainlinkRequest, `sendChainlinkRequestTo` sends a Request but
allows the target oracle to be specified. It requires an address, a Request,
and an amount, and returns the `requestId`. This allows a requesting contract
to create and track requests sent to multiple oracle contract addresses.

`sendChainlinkRequestTo` emits a ChainlinkRequested event containing the
request ID, if you would like to use it in your Web3 application.


    function requestPriceFrom(address _oracle)
      public
    {
      Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.callback.callbackSelector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK
    
      // send the request that you just built to a specified oracle
      sendChainlinkRequestTo(_oracle, request, paymentAmount);
    }

### sendOperatorRequest

This function is similar to `sendChainlinkRequest`function. It is recommended
to use `sendOperatorRequest` but make sure the oracle you are contacting is an
`Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendOperatorRequest(
        Chainlink.Request memory _req,
        uint256 _payment
    ) returns (bytes32 requestId)

The `sendOperatorRequest` function sends the request payload to the stored
oracle address. It takes a Chainlink.Request and the amount of LINK to send
amount as parameters. The request is serialized and calls `operatorRequest` on
the address stored in `chainlinkOracleAddress` using the LINK token's
`transferAndCall` method.

`sendOperatorRequest` returns the ID of the request. Optionally, your contract
can store the ID if your application needs it. The `ChainlinkClient` helpers
store the ID and the oracle address and use them when you call
`recordChainlinkFulfillment` in your callback function. This ensures that only
the specified address can call your Chainlink callback function.

`sendOperatorRequest` emits a ChainlinkRequested event containing the request
ID that you can use in your Web3 application.


    function requestPrice()
      public
    {
      Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.selector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK
    
      // send the request that you just built
      sendOperatorRequest(request, paymentAmount);
    }

### sendOperatorRequestTo

This function is similar to `sendChainlinkRequestTo`function. It is
recommended to use `sendOperatorRequestTo`, but make sure the oracle you are
contacting is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequestTo(
      address _oracle,
      Chainlink.Request memory _req,
      uint256 _payment
    ) returns (bytes32 requestId)

Similar to sendOperatorRequest, `sendOperatorRequestTo` sends a Request but
allows the target oracle to be specified. It requires an address, a Request,
and an amount, and returns the `requestId`. This allows a requesting contract
to create and track requests sent to multiple oracle contract addresses.

`sendOperatorRequestTo` emits a ChainlinkRequested event containing a request
ID that you can use in your Web3 application.


    function requestPriceFrom(address _oracle)
      public
    {
      Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.callbackSelector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK
    
      // send the request that you just built to a specified oracle
      sendOperatorRequestTo(_oracle, request, paymentAmount);
    }

### validateChainlinkCallback


    function validateChainlinkCallback(
        bytes32 _requestId
    )

Used on fulfillment callbacks to ensure that the caller and `requestId` are
valid. They protect ChainlinkClient callbacks from being called by malicious
callers. `validateChainlinkCallback` allows for a request to be called

This is the method equivalent of the modifier `recordChainlinkFulfillment`.
Either `validateChainlinkCallback` or `recordChainlinkFulfillment` should be
used on all fulfillment functions to ensure that the caller and `requestId`
are valid. Use the modifier or the method, not both.

`validateChainlinkCallback` emits a ChainlinkFulfilled event.


    function myCallback(bytes32 _requestId, uint256 _price)
      public
    {
      validateChainlinkCallback(_requestId);
      currentPrice = _price;
    }

Do not call multiple times

Do not call `validateChainlinkCallback` multiple times. The nature of
validating the callback is to ensure the response is only received once and
not replayed. Calling a second time with the same method ID will trigger a
revert. Similarly, your callback should validate using either
`validateChainlinkCallback` or `recordChainlinkFulfillment`, not both.

### addChainlinkExternalRequest


    function addChainlinkExternalRequest(
      address _oracle,
      bytes32 _requestId
    )

`addChainlinkExternalRequest` allows a Chainlink contract to track unfulfilled
requests that it hasn't created itself. For example, contract A creates a
request and sets the callback for contract B. Contract B needs to know about
the request created by contract A so that it can validate the callback when it
is executed.


    function expectResponseFor(bytes32 _requestId)
      public
    {
      addChainlinkExternalRequest(chainlinkOracleAddress(), _requestId);
    }

Be careful adding external requests

Being able to change a request means that you can change the data fed into a
contract. Permissioning someone to make external requests can allow them to
change the outcome of your contract. You should be sure to make sure that they
are a trusted to do so. If they are not trusted to do so, you should put the
request making logic on-chain where it is auditable and tamperproof.

### cancelChainlinkRequest


    function cancelChainlinkRequest(bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    )

In case an oracle node does not respond, it may be necessary to retrieve the
LINK used to pay for the unfulfilled request. The `cancelChainlinkRequest`
will send the cancel request to the address used for the request, which
transfers the amount of LINK back to the requesting contract, and delete it
from the tracked requests.

The default expiration for a request is five minutes, after which it can be
cancelled. The cancellation must be sent by the address which was specified as
the callback location of the contract.

For the sake of efficient gas usage, only a hash of the request's parameters
are stored on-chain. In order to validate the terms of the request and that it
can be calculated, the request parameters must be provided. Additionally,
cancellation must be called by the address which the callback would otherwise
have been called on.

`cancelChainlinkRequest` emits a ChainlinkCancelled event.


    function cancelRequest(
        bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    ) public {
      cancelChainlinkRequest(_requestId, _payment, _callbackFunc, _expiration);
    }

### useChainlinkWithENS


    function useChainlinkWithENS(
      address _ens,
      bytes32 _node
    )

Allows a Chainlink contract to store the addresses of the LINK token and
oracle contract addresses without supplying the addresses themselves. We use
ENS where available to resolve these addresses. It requires the address of the
ENS contract and the node (which is a hash) for the domain.

If your Oracle provider supports using ENS for rolling upgrades to their
oracle contract, once you've pointed your Chainlinked contract to the ENS
records then you can update the records using updateChainlinkOracleWithENS.


    address constant ROPSTEN_ENS = 0x112234455C3a32FD11230C42E7Bccd4A84e02010;
    bytes32 constant ROPSTEN_CHAINLINK_ENS = 0xead9c0180f6d685e43522fcfe277c2f0465fe930fb32b5b415826eacf9803727;
    
    constructor(){
      useChainlinkWithENS(ROPSTEN_ENS, ROPSTEN_CHAINLINK_ENS);
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Oracle.sol)
or trust whoever can update the records.

### updateChainlinkOracleWithENS


    function updateChainlinkOracleWithENS()

Updates the stored oracle contract address with the latest address resolved
through the ENS contract. This requires the oracle provider to support listing
their address on ENS.

This method only works after useChainlinkWithENS has been called on the
contract.


    function updateOracleAddressToLatest() public {
      updateChainlinkOracleWithENS();
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or trust whoever can update the records.

### chainlinkTokenAddress


    function chainlinkTokenAddress() returns (address)

The `chainlinkTokenAddress` function is a helper used to return the stored
address of the Chainlink token. This variable is protected and so only made
available through getters and setters.


    function withdrawLink() public {
      LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
    
      require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
    }

### chainlinkOracleAddress

The `chainlinkOracleAddress` function is a helper used to return the stored
address of the oracle contract.


    function getOracle() public view returns (address) {
      return chainlinkOracleAddress();
    }
    

## Events

### ChainlinkRequested


    event ChainlinkRequested(
      bytes32 indexed id
    )

Emitted when sendChainlinkRequest and sendChainlinkRequestTo are called.
Includes the request ID as an event topic.

### ChainlinkFulfilled


    event ChainlinkFulfilled(
      bytes32 indexed id
    )

Emitted when validateChainlinkCallback or recordChainlinkFulfillment are
called. Includes the request ID as an event topic.

### ChainlinkCancelled


    event ChainlinkCancelled(
      bytes32 indexed id
    )

Emitted when cancelChainlinkRequest is called. Includes the request ID as an
event topic.

## Constants

### LINK_DIVISIBILITY

`LINK_DIVISIBILITY` is a uint256 constant to represent one whole unit of the
LINK token (1000000000000000000). It can be used with another value to specify
payment in an easy-to-read format, instead of hardcoding magic numbers.


    uint256 constant private ORACLE_PAYMENT = 100 * LINK_DIVISIBILITY; // = 100 LINK

## Modifiers

### recordChainlinkFulfillment

`recordChainlinkFulfillment` is used on fulfillment callbacks to ensure that
the caller and `requestId` are valid. This is the method equivalent of the
method `validateChainlinkCallback`.

Either `validateChainlinkCallback` or `recordChainlinkFulfillment` should be
used on all Chainlink callback functions to ensure that the sender and
`requestId` are valid. They protect ChainlinkClient callbacks from being
called by malicious callers. Do not call both of them, or your callback may
revert before you can record the reported response.


    function myCallback(bytes32 _requestId, uint256 _price)
      public
      recordChainlinkFulfillment(_requestId) // always validate callbacks
    {
      currentPrice = _price;
    }

## Chainlink.Request


    library Chainlink {
      struct Request {
        bytes32 id;
        address callbackAddress;
        bytes4 callbackFunctionId;
        uint256 nonce;
        Buffer.buffer buf;
      }
    }

The Chainlink Request struct encapsulates all of the fields needed for a
Chainlink request and its corresponding response callback.

The Chainlink protocol aims to be flexible and not restrict application
developers. The Solidity Chainlink Request model is a great example of that.
It is exceptionally flexible, given the limitations of Solidity. The request
can contain an arbitrary amount of keys and values to be passed off-chain to
the oracles for each request. It does so by converting the parameters into
CBOR, and then storing them in a buffer. This allows for any number of
parameters all of different types to be encoded on-chain.

The request's ID is generated by hashing the sender's address and the
request's nonce. This scheme ensures that only the requester can generate
their request ID, and no other contract can trigger a response from an oracle
with that ID. New requests whose IDs match an unfulfilled request ID will not
be accepted by the oracle.

Intended for memory

The Request object was intended to be stored in memory. If you have a reason
to persist the struct in storage, it is recommended that you do so by copying
each attribute over and explicitly copying the bytes in the buffer.

### Attributes

| Name               | Description                                                                                             |
|:-------------------|:--------------------------------------------------------------------------------------------------------|
| id                 | Identifier for the request                                                                              |
| callbackAddress    | Address that the response will be sent to upon fulfillment                                              |
| callbackFunctionId | Selector of the function on the callbackAddress that will be invoked with the response upon fulfillment |
| nonce              | Used to generate the request ID                                                                         |
| buf                | Buffer that stores additional user defined parameters as CBOR                                           |
### Methods

| Name           | Description                                                      |
|:---------------|:-----------------------------------------------------------------|
| add            | Add a string value to the run request parameters                 |
| addBytes       | Add a bytes value to the run request parameters                  |
| addInt         | Add an integer value to the run request parameters               |
| addUint        | Add an unsigned integer to the run request parameters            |
| addStringArray | Add an array of strings as a value in the run request parameters |
| setBuffer      | Directly set the CBOR of the run request parameters              |
#### add


    function add(
      Request memory self,
      string _key,
      string _value
    )

Add a string value to the run request parameters. Commonly used for `get` with
jobs using `httpGet` tasks.


    function requestEthereumPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.add(""get"", ""https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY"");
    
      sendChainlinkRequest(req, 1 * LINK_DIVISIBILITY); // =1 LINK
    }

#### addBytes


    function addBytes(
      Request memory self,
      string _key,
      bytes _value
    )

Add a CBOR bytes type value to the run request parameters.


    function requestEmojiPopularity(bytes _unicode)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addBytes(""emojiUnicode"", _unicode);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

Note that this can also be used as a workaround to pass other data types like
arrays or addresses. For instance, to add an _address_ , one would first
encode it using `abi.encode` then pass the result to `addBytes`:


    Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
    req.addBytes(""address"", abi.encode(msg.sender)); // msg.sender used in this example. Replace it with your address
    

#### addInt


    function addInt(
      Request memory self,
      string _key,
      int256 _value
    )

Add a CBOR signed integer type value to the run request parameters. Commonly
used with the `times` parameter of any job using a `multiply` task.


    function requestPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addInt(""times"", 100);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

#### addUint


    function addUint(
      Request memory self,
      string _key,
      uint256 _value
    )

Add a CBOR unsigned integer type value to the run request parameters. Commonly
used with the `times` parameter of any job using a `multiply` task.


    function requestPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addUint(""times"", 100);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

#### addStringArray


    function addStringArray(
      Request memory self,
      string _key,
      string[] memory _values
    )

Add a CBOR array of strings to the run request parameters. Commonly used with
the `path` parameter for any job including a `jsonParse` task.


    function requestPrice(string _currency)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
      string[] memory path = new string[](2);
      path[0] = _currency;
      path[1] = ""recent"";
    
      // specify templated fields in a job specification
      req.addStringArray(""path"", path);
    
      sendChainlinkRequest(req, PAYMENT);
    }

#### setBuffer


    function setBuffer(
      Request memory self,
      bytes _data
    )

Set the CBOR payload directly on the request object, avoiding the cost of
encoding the parameters in CBOR. This can be helpful when reading the bytes
from storage or having them passed in from off-chain where they were pre-
encoded.


    function requestPrice(bytes _cbor)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
    
      req.setBuffer(_cbor);
    
      sendChainlinkRequest(req, PAYMENT);
    }

Be careful setting the request buffer directly

Moving the CBOR encoding logic off-chain can save some gas, but it also opens
up the opportunity for people to encode parameters that not all parties agreed
to. Be sure that whoever is permissioned to call `setBuffer` is trusted or
auditable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/api-reference.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the 'proposedFeed' function?,The 'proposedFeed' function is used to propose a new price feed for a given base and quote currency pair.,{'source': 'https://docs.chain.link/data-feeds/feed-registry/'},"The purpose of the 'proposedFeed' function is to request the last market price of Ethereum in USD from an external API and store it in the contract. The function uses the Chainlink oracle to make the API request and retrieve the data. The 'req' variable is used to build the Chainlink request, including the API endpoint and the path to the desired data in the JSON response. The 'path' variable is an array of strings that specifies the path to the 'LASTMARKET' value in the JSON response. The function then sends the Chainlink request to the specified oracle and includes the payment for the oracle service. 
",30-pl,"Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    





:::NEXT DOC:::

Question: (Asked on: 2023-01-06 09:55:44)
ParserError: Source &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot; not found: File outside of allowed directories
URL: https://stackoverflow.com/questions/75029401/parsererror-source-chainlink-contracts-src-v0-8-interfaces-aggregatorv3interf

Question Body:


I'm trying to compile a ""FundMe.sol"" contract: the issue is that when I try to
compile it I keep getting the following Compiler Error:

    
    
    Brownie v1.19.2 - Python development framework for Ethereum
    
    New compatible solc version available: 0.8.0
    Compiling contracts...
      Solc version: 0.8.0
      Optimizer: Enabled  Runs: 200
      EVM Version: Istanbul
    CompilerError: solc returned the following errors:
    
    ParserError: Source ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
      --> contracts/FundMe.sol:15:1:
       |
    15 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    

The contract is included inside of the ""contracts"" folder (initted by
brownie), moreover I have created the ""brownie-config.yaml"" file which should
remap @chainlink - I feel as it might have contain some kind of error aswell.

I'm including all the mentioned files down below:

**Project Folder** : [brownie_fund_me](https://i.stack.imgur.com/HEeeo.png)

**FundMe.sol** :

    
    
    //SPDX-License-Identifier: MIT
    //Last update: 25/12/2022
    
    /* ***** ABI = Application Binary Interface *****
     * Interfaces compile down to an ABI. 
     *
     * ABI tells Solidity and other coding languages
     * how it can interact with other contracts. 
     *
     * Anytime you want to interact with another
     * deployed contract, you will need that contracts' ABI.
     */
    
    pragma solidity >=0.6.0 <0.9.0;
    
    // ***** Imports *****
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";   //The following library is shown below
    /*
     *
     *      interface AggregatorV3Interface 
     *      {
     *       function decimals() external view returns (uint8);
     *
     *       function description() external view returns (string memory);
     *
     *       function version() external view returns (uint256);    <-------------- Version
     *
     *       function getRoundData(uint80 _roundId) external view returns 
     *       (
     *           uint80 roundId,
     *           int256 answer,          
     *           uint256 startedAt,
     *           uint256 updatedAt,
     *           uint80 answeredInRound
     *       );
     *
     *       function latestRoundData() external view returns 
     *       (
     *           uint80 roundId,
     *           int256 answer,             <---------- Value in USD
     *           uint256 startedAt,
     *           uint256 updatedAt,
     *           uint80 answeredInRound
     *       );
     *      }
     *
     */
    
    // ***** FundMe *****
    // The following contract allows the end users to send a minimum amount
    // of ETH without being able to retrive it.
    // This contract is a good example of crowd funding.
    contract FundMe{
        
        // ***** AddressToAmountFunded *****
        // The following mapping allows the user to access the amount funded
        // by somebody, provided the address.
        mapping (address => uint256) public AddressToAmountFunded;
    
        // Array of addresses where the address of each funder will be stored in a temporary way
        // Every time the owner calls the withdraw function, the array is being reset
        address[] public funders;
    
        // Owners' address: this will be the only address being able to withdraw
        address public owner;
    
        // Constructor is called automatically and istantly when the contract is being deployed
        // Such thing allows the deployer of the contract to be the owner
        constructor() public
        {
            owner = msg.sender;     // msg.sender is who calls a function, in the constructor case, who deploys the contract
        }
    
        // ***** onlyOwner *****
        // The following modifier is used in the declaration of functions, such as withdraw, 
        // in order to allow the function, to be called only by the owner.
        modifier onlyOwner
        {
            require(msg.sender == owner);      // Whoever calls the function (msg.sender) must be the owner
            _;                                 // The ""_;"" means that we call the instruction after we check that the address of the caller is equal to owner
        }
    
        // ***** fund *****
        // The following function allows the users to fund the contract with a minimum amount of money ""minimumUSD""
        // to this date (25/12/2022) 50$ = 0,041ETH = 41000000000000000Wei = (41 * 10^15)Wei - to update the value, check the USD/ETH change and convert to Wei here https://eth-converter.com/
        // If the amount funded is <= minimumUSD the transaction will not go through and will lead to an inversion of the
        // transaction
        // ! ! ! ! ! Please notice that the amount funded cannot be retrived in any way ! ! ! ! !
        function fund() public payable
        {
            uint256 minimumUSD = 41 * 10 ** 15;                                                                                        // Minimum amount transferable
            require(msg.value >= minimumUSD, ""The amount of ETH you sent is less then 50$ - Transaction is being inverted"");           // ""msg.value"" is a keyword that stays for the amount of Wei sent
    
            AddressToAmountFunded[msg.sender] += msg.value;             // Given an address, the mapping will return the amount funded by such account - Note that these values will be reset every time withdraw is called
            funders.push(msg.sender);                                   // The funders' address will be added to the funders array - Note that these values will be reset every time withdraw is called
        }
    
        // ***** getVersion *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current version of the contract/library AggregatorV3Interface
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getVersion() public view returns(uint256)
        {      
            return AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e).version();     // .version method is contained inside of AggregatorV3Interface, the address can be find here
            //                                                                                                                                                                                 |
            // The function works also if written like this:                                                                                                                                   |
            // AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);  <--- Address                                                              |
            // return priceFeed.version();                                                                           <--- ABI                                                                 /
            // You can find the Addresses for AggregatorV3Interface here ---> https://docs.chain.link/data-feeds/price-feeds/addresses/ <----------------------------------------------------
        }
    
        // ***** getPrice *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current value of 1ETH in USD, please note that you will get an apporximate value 
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getPrice() public view returns(uint256)
        {
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);    // .latestRoundData method is contained inside of AggregatorV3Interface, the address can be found above
            (,int256 answer,,,) = priceFeed.latestRoundData();                                                      // The method returns 5 different values, we exclude all of them but answer, for further understanding check at AggregatorV3Interface under imports
            return uint256(answer / 10 ** 8);                                                                       // Answer is divided by 10^8 so that the value in USD has no decimals and is easier to read
            
            // Historical:
            // 23/12/2022 - 1,226.67395017
            // 25/12/2022 - 1,220.00000000
        }
    
        // ***** getConvertionRate *****
        // The following function could be considered an extension of getPrice : given
        // the amount of ETH, the function will return the current value of such amount of ETH
        // in USD
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getConvertionRate(uint256 ETH_Amount) public view returns(uint256)
        {
            uint256 ETH_Price = getPrice();                         // Calls getPrice function
            uint256 ETH_AmountInUSD = ETH_Price * ETH_Amount;       // Current ETH pirce * ETH amount
            return ETH_AmountInUSD;                                 // Returns the value of amount ETH in USD
        }
    
        // ***** withdraw *****
        // The following function allows the deployer of the contract (owner) to withdraw
        // the amount of ETH funded to the contract, moreover when the function is called,
        // the funders array will be reset
        function withdraw() payable onlyOwner public                // Check for onlyOwner modifier description at line 77
        {
            payable(msg.sender).transfer(address(this).balance);    // This line of code allows the withdrawal, this refers to the contract
    
            for(uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++)   // The following cycle allows the reset of the money
            {                                                                           // value sent by the funders, accessible through mapping
                address funder = funders[funderIndex];
                AddressToAmountFunded[funder] = 0;
            }
    
            funders = new address[] (0);                            // funders array gets reset, so that it's able to store new values starting from 0
        }
    }
    
    

**brownie-config.yaml** :

    
    
    dependencies:
      # - <organization/repo@version>
      - smartcontractkit/chainlink-brownie-contracts@0.5.1
      
    compiler:
      solc:
        remappings:
          - '@chainlink = smartcontractkit/chainlink-brownie-contracts@0.5.1' 
    

I'm quiet new to ""python-solidity"" coding, but so far I had managed to
overcome all the issues that were popping up. I have spent over 2 days tring
to find a solution to this problem - it's becoming really frustrating. I'm
really thankful to whoever - at least - tries helping me!

**Solutions I tried:**

  * Changing versions of pragma solidity, imports and repo;
  * Adding a .vscode folder --> setting.json containing a path to solidity remappings
  * Updating solc and brownie



Answers:
(Answered on: 2023-01-07 09:23:18)


Can you try `npm install @chainlink/contracts` or `pip3 install
@chainlink/contracts` again and compile it?



"
What is Chainlink VRF and how can it be used in smart contracts?,Chainlink VRF is a provably-fair and verifiable source of randomness designed for smart contracts. Smart contract developers can use Chainlink VRF as a tamper-proof random number generator (RNG) to build reliable smart contracts for any applications which rely on unpredictable outcomes.,{'source': 'https://docs.chain.link/vrf/v1/introduction/'},"Chainlink VRF (Verifiable Random Function) is a provably-fair and verifiable source of randomness designed for smart contracts. It allows smart contract developers to use it as a tamper-proof random number generator (RNG) for applications that rely on unpredictable outcomes. Chainlink VRF generates a random number and cryptographic proof of how that number was determined, which is published and verified on-chain. This ensures that the results cannot be tampered with by anyone, including oracle operators, miners, users, and smart contract developers. It can be used in various applications such as blockchain games, random assignment of duties and resources, and choosing representative samples for consensus mechanisms. More information can be found in the Chainlink VRF documentation. 
",https://docs.chain.link/vrf/v1/introduction/,"# Introduction to Chainlink VRF [v1]

  * Overview
  * Generate Random Numbers in your Smart Contracts
  * On-chain Verification of Randomness

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

## Generate Random Numbers in your Smart Contracts

Chainlink VRF (Verifiable Random Function) is a provably-fair and verifiable
source of randomness designed for smart contracts. Smart contract developers
can use Chainlink VRF as a tamper-proof random number generator (RNG) to build
reliable smart contracts for any applications which rely on unpredictable
outcomes:

  * Blockchain games and NFTs
  * Random assignment of duties and resources (e.g. randomly assigning judges to cases)
  * Choosing a representative sample for consensus mechanisms

Learn how to write smart contracts that consume random numbers: [Get a Random
Number](/vrf/v1/examples/get-a-random-number).

## On-chain Verification of Randomness

Chainlink VRF enables smart contracts to access randomness without
compromising on security or usability. With every new request for randomness,
Chainlink VRF generates a random number and cryptographic proof of how that
number was determined. The proof is published and verified on-chain before it
can be used by any consuming applications. This process ensures that the
results cannot be tampered with nor manipulated by anyone, including oracle
operators, miners, users and even smart contract developers.

Read more about Chainlink VRF in [our announcement
post](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/).

## What's next

  * [› Get a Random Number](/vrf/v1/examples/get-a-random-number)
  * [› API Reference](/vrf/v1/api-reference)
  * [› Supported Networks](/vrf/v1/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the useChainlinkWithENS function?,"The useChainlinkWithENS function allows a Chainlink contract to store the addresses of the LINK token and oracle contract addresses without supplying the addresses themselves, using ENS where available to resolve these addresses.",{'source': 'https://docs.chain.link/any-api/api-reference/'},"The purpose of the useChainlinkWithENS function is to allow a Chainlink contract to store the addresses of the LINK token and oracle contract addresses without specifying the addresses themselves. It uses the Ethereum Name Service (ENS) to resolve these addresses. This function requires the address of the ENS contract and the node (hash) for the domain. It is typically used for updating the stored oracle address with the latest address resolved through ENS.

Source: https://docs.chain.link/any-api/api-reference/",,"Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    





:::NEXT DOC:::

# ChainlinkClient API Reference

  * Overview
  * Index
  * Methods
  * Events
  * Modifiers
  * Constants
  * Structs
  * Methods
  * setChainlinkOracle
  * setChainlinkToken
  * buildChainlinkRequest
  * buildOperatorRequest
  * sendChainlinkRequest
  * sendChainlinkRequestTo
  * sendOperatorRequest
  * sendOperatorRequestTo
  * validateChainlinkCallback
  * addChainlinkExternalRequest
  * cancelChainlinkRequest
  * useChainlinkWithENS
  * updateChainlinkOracleWithENS
  * chainlinkTokenAddress
  * chainlinkOracleAddress
  * Events
  * ChainlinkRequested
  * ChainlinkFulfilled
  * ChainlinkCancelled
  * Constants
  * LINK_DIVISIBILITY
  * Modifiers
  * recordChainlinkFulfillment
  * Chainlink.Request
  * Attributes
  * Methods

API reference for ChainlinkClient

`ChainlinkClient`
[contracts](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol)
can communicate with legacy `Oracle`
[contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or `Operator`
[contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).

## Index

### Methods

| Name                         | Description                                                                                                                    |
|:-----------------------------|:-------------------------------------------------------------------------------------------------------------------------------|
| setChainlinkOracle           | Sets the stored address for the oracle contract                                                                                |
| setChainlinkToken            | Sets the stored address for the LINK token                                                                                     |
| buildChainlinkRequest        | Instantiates a Request object with the required parameters                                                                     |
| buildOperatorRequest         | Instantiates a Request object with the required parameters. Note the oracle must be an Operator contract                       |
| sendChainlinkRequest         | Sends the request payload to the stored address stored as chainlinkOracleAddress                                               |
| sendChainlinkRequestTo       | Sends a request to the oracle address specified                                                                                |
| sendOperatorRequest          | Sends the request payload to the stored address stored as chainlinkOracleAddress. Note the oracle must be an Operator contract |
| sendOperatorRequestTo        | Sends a request to the oracle address specified. Note the oracle must be an Operator contract                                  |
| validateChainlinkCallback    | Secures the fulfillment callback to make sure it is only called by permissioned senders                                        |
| addChainlinkExternalRequest  | Allows a Chainlinked contract to track unfulfilled requests that it hasn't created itself                                      |
| cancelChainlinkRequest       | Cancels Chainlink requests attempting to contact an unresponsive node                                                          |
| useChainlinkWithENS          | Looks up the addresses of the LINK token and Oracle contract through ENS                                                       |
| updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS                                                 |
| chainlinkTokenAddress        | Returns the stored address of the LINK token                                                                                   |
| chainlinkOracleAddress       | Returns the stored address of the oracle contract                                                                              |
### Events

| Name               | Description                                                                  |
|:-------------------|:-----------------------------------------------------------------------------|
| ChainlinkRequested | Emitted from a Chainlinked contract when a request is sent to an oracle      |
| ChainlinkFulfilled | Emitted from a Chainlinked contract when a request is fulfilled by an oracle |
| ChainlinkCancelled | Emitted from a Chainlinked contract when a request is cancelled              |
### Modifiers

| Name                       | Description                                                                                                                                              |
|:---------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------|
| recordChainlinkFulfillment | Used on fulfillment callbacks to ensure that the caller and requestId are valid. This is the modifier equivalent of the method validateChainlinkCallback |
### Constants

| Name              | Description                                                                       |
|:------------------|:----------------------------------------------------------------------------------|
| LINK_DIVISIBILITY | Helper uint256 to represent the divisibility of a LINK token. Equivalent to 10^18 |
### Structs

| Name              | Description                                                          |
|:------------------|:---------------------------------------------------------------------|
| Chainlink.Request | All of the parameters that can be passed over in a Chainlink request |
## Methods

Below you'll find each helper explained in greater detail alongside respective
implementation examples to help you leverage these methods once you start
building your own Chainlinked contract.

After the function signature and a short description, two code examples are
provided, one focusing on the exact usage of the method and one where the
helper is presented in the context of a full contract.

### setChainlinkOracle


    function setChainlinkOracle(
      address _oracle
    )

Sets a private storage variable provided for convenience if your contract only
needs to talk to one oracle and you do not want to specify it on every
request. Once an oracle is set with `setChainlinkOracle` that is the address
used with sendChainlinkRequest.

Retrieve the oracle address using chainlinkOracleAddress. These getters and
setters are provided to enforce that changes to the oracle are explicitly made
in the code.


    constructor(address _oracle)
    {
      setChainlinkOracle(_oracle);
    }

### setChainlinkToken


    setChainlinkToken(
      address _link
    )

Sets the stored address for the LINK token which is used to send requests to
Oracles. There are different token addresses on different network. See [LINK
Token Contracts](/resources/link-token-contracts) for the address of the LINK
token on the network you're deploying to.


    constructor(address _link)
      public
    {
      setChainlinkToken(_link);
    }

### buildChainlinkRequest

Use `buildOperatorRequest` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function buildChainlinkRequest(
        bytes32 _jobId,
        address _callbackAddress,
        bytes4 _callbackFunctionSignature
    ) returns (Chainlink.Request memory request)

Instantiates a Request from the Chainlink contract. A Request is a struct
which contains the necessary parameters to be sent to the oracle contract. The
`buildChainlinkRequest` function takes an ID, which can be a [Job
ID](/chainlink-nodes/oracle-jobs/jobs), a callback address to receive the
resulting data, and a callback function signature to call on the callback
address.


    function requestPrice()
      public
    {
      bytes32 jobId = ""493610cff14346f786f88ed791ab7704"";
      bytes4 selector = this.myCallback.selector;
      // build a request that calls the myCallback function defined
      //   below by specifying the address of this contract and the function
      //   selector of the myCallback
      Chainlink.Request memory request = buildChainlinkRequest(
        jobId,
        address(this),
        selector);
    }

### buildOperatorRequest

This function is similar to `buildChainlinkRequest`function. One major
difference is that `buildOperatorRequest` does not allow setting up the
address of the callback. The callback address is set to the address of the
calling contract.

It is recommended to use `buildOperatorRequest` but make sure the oracle you
are contacting is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function buildOperatorRequest(
        bytes32 _jobId,
        bytes4 _callbackFunctionSignature
    ) returns (Chainlink.Request memory request)

Instantiates a _Request_ from the Chainlink contract. A Request is a struct
that contains the necessary parameters to be sent to the oracle contract. The
`buildOperatorRequest` function takes an ID, which can be a [Job
ID](/chainlink-nodes/oracle-jobs/jobs), and a callback function signature to
call on the calling contract address.


    function requestPrice()
      public
    {
      bytes32 jobId = ""493610cff14346f786f88ed791ab7704"";
      bytes4 selector = this.myCallback.selector;
      // build a request that calls the myCallback function defined
      //   below by specifying the function selector of myCallback
      Chainlink.Request memory request = buildOperatorRequest(
        jobId,
        selector);
    }

### sendChainlinkRequest

Use `sendOperatorRequest` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequest(
        Chainlink.Request memory _req,
        uint256 _payment
    ) returns (bytes32 requestId)

Sends the request payload to the stored oracle address. It takes a
Chainlink.Request and the amount of LINK to send amount as parameters. The
request is serialized and calls `oracleRequest` on the address stored in
`chainlinkOracleAddress` via the LINK token's `transferAndCall` method.

`sendChainlinkRequest` returns the ID of the request. If your application
needs to, your contract can store that ID, but you don't need to. The
ChainlinkClient helpers will store the ID under the hood, along with the
oracle address, and use them when you call `recordChainlinkFulfillment` in
your callback function to make sure only that the address you want can call
your Chainlink callback function.

`sendChainlinkRequest` emits a ChainlinkRequested event containing the request
ID, if you would like to use it in your Web3 application.


    function requestPrice()
      public
    {
      Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.callback.selector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK
    
      // send the request that you just built
      sendChainlinkRequest(request, paymentAmount);
    }

### sendChainlinkRequestTo

Use `sendOperatorRequestTo` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequestTo(
      address _oracle,
      Chainlink.Request memory _req,
      uint256 _payment
    ) returns (bytes32 requestId)

Similar to sendChainlinkRequest, `sendChainlinkRequestTo` sends a Request but
allows the target oracle to be specified. It requires an address, a Request,
and an amount, and returns the `requestId`. This allows a requesting contract
to create and track requests sent to multiple oracle contract addresses.

`sendChainlinkRequestTo` emits a ChainlinkRequested event containing the
request ID, if you would like to use it in your Web3 application.


    function requestPriceFrom(address _oracle)
      public
    {
      Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.callback.callbackSelector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK
    
      // send the request that you just built to a specified oracle
      sendChainlinkRequestTo(_oracle, request, paymentAmount);
    }

### sendOperatorRequest

This function is similar to `sendChainlinkRequest`function. It is recommended
to use `sendOperatorRequest` but make sure the oracle you are contacting is an
`Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendOperatorRequest(
        Chainlink.Request memory _req,
        uint256 _payment
    ) returns (bytes32 requestId)

The `sendOperatorRequest` function sends the request payload to the stored
oracle address. It takes a Chainlink.Request and the amount of LINK to send
amount as parameters. The request is serialized and calls `operatorRequest` on
the address stored in `chainlinkOracleAddress` using the LINK token's
`transferAndCall` method.

`sendOperatorRequest` returns the ID of the request. Optionally, your contract
can store the ID if your application needs it. The `ChainlinkClient` helpers
store the ID and the oracle address and use them when you call
`recordChainlinkFulfillment` in your callback function. This ensures that only
the specified address can call your Chainlink callback function.

`sendOperatorRequest` emits a ChainlinkRequested event containing the request
ID that you can use in your Web3 application.


    function requestPrice()
      public
    {
      Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.selector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK
    
      // send the request that you just built
      sendOperatorRequest(request, paymentAmount);
    }

### sendOperatorRequestTo

This function is similar to `sendChainlinkRequestTo`function. It is
recommended to use `sendOperatorRequestTo`, but make sure the oracle you are
contacting is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequestTo(
      address _oracle,
      Chainlink.Request memory _req,
      uint256 _payment
    ) returns (bytes32 requestId)

Similar to sendOperatorRequest, `sendOperatorRequestTo` sends a Request but
allows the target oracle to be specified. It requires an address, a Request,
and an amount, and returns the `requestId`. This allows a requesting contract
to create and track requests sent to multiple oracle contract addresses.

`sendOperatorRequestTo` emits a ChainlinkRequested event containing a request
ID that you can use in your Web3 application.


    function requestPriceFrom(address _oracle)
      public
    {
      Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.callbackSelector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK
    
      // send the request that you just built to a specified oracle
      sendOperatorRequestTo(_oracle, request, paymentAmount);
    }

### validateChainlinkCallback


    function validateChainlinkCallback(
        bytes32 _requestId
    )

Used on fulfillment callbacks to ensure that the caller and `requestId` are
valid. They protect ChainlinkClient callbacks from being called by malicious
callers. `validateChainlinkCallback` allows for a request to be called

This is the method equivalent of the modifier `recordChainlinkFulfillment`.
Either `validateChainlinkCallback` or `recordChainlinkFulfillment` should be
used on all fulfillment functions to ensure that the caller and `requestId`
are valid. Use the modifier or the method, not both.

`validateChainlinkCallback` emits a ChainlinkFulfilled event.


    function myCallback(bytes32 _requestId, uint256 _price)
      public
    {
      validateChainlinkCallback(_requestId);
      currentPrice = _price;
    }

Do not call multiple times

Do not call `validateChainlinkCallback` multiple times. The nature of
validating the callback is to ensure the response is only received once and
not replayed. Calling a second time with the same method ID will trigger a
revert. Similarly, your callback should validate using either
`validateChainlinkCallback` or `recordChainlinkFulfillment`, not both.

### addChainlinkExternalRequest


    function addChainlinkExternalRequest(
      address _oracle,
      bytes32 _requestId
    )

`addChainlinkExternalRequest` allows a Chainlink contract to track unfulfilled
requests that it hasn't created itself. For example, contract A creates a
request and sets the callback for contract B. Contract B needs to know about
the request created by contract A so that it can validate the callback when it
is executed.


    function expectResponseFor(bytes32 _requestId)
      public
    {
      addChainlinkExternalRequest(chainlinkOracleAddress(), _requestId);
    }

Be careful adding external requests

Being able to change a request means that you can change the data fed into a
contract. Permissioning someone to make external requests can allow them to
change the outcome of your contract. You should be sure to make sure that they
are a trusted to do so. If they are not trusted to do so, you should put the
request making logic on-chain where it is auditable and tamperproof.

### cancelChainlinkRequest


    function cancelChainlinkRequest(bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    )

In case an oracle node does not respond, it may be necessary to retrieve the
LINK used to pay for the unfulfilled request. The `cancelChainlinkRequest`
will send the cancel request to the address used for the request, which
transfers the amount of LINK back to the requesting contract, and delete it
from the tracked requests.

The default expiration for a request is five minutes, after which it can be
cancelled. The cancellation must be sent by the address which was specified as
the callback location of the contract.

For the sake of efficient gas usage, only a hash of the request's parameters
are stored on-chain. In order to validate the terms of the request and that it
can be calculated, the request parameters must be provided. Additionally,
cancellation must be called by the address which the callback would otherwise
have been called on.

`cancelChainlinkRequest` emits a ChainlinkCancelled event.


    function cancelRequest(
        bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    ) public {
      cancelChainlinkRequest(_requestId, _payment, _callbackFunc, _expiration);
    }

### useChainlinkWithENS


    function useChainlinkWithENS(
      address _ens,
      bytes32 _node
    )

Allows a Chainlink contract to store the addresses of the LINK token and
oracle contract addresses without supplying the addresses themselves. We use
ENS where available to resolve these addresses. It requires the address of the
ENS contract and the node (which is a hash) for the domain.

If your Oracle provider supports using ENS for rolling upgrades to their
oracle contract, once you've pointed your Chainlinked contract to the ENS
records then you can update the records using updateChainlinkOracleWithENS.


    address constant ROPSTEN_ENS = 0x112234455C3a32FD11230C42E7Bccd4A84e02010;
    bytes32 constant ROPSTEN_CHAINLINK_ENS = 0xead9c0180f6d685e43522fcfe277c2f0465fe930fb32b5b415826eacf9803727;
    
    constructor(){
      useChainlinkWithENS(ROPSTEN_ENS, ROPSTEN_CHAINLINK_ENS);
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Oracle.sol)
or trust whoever can update the records.

### updateChainlinkOracleWithENS


    function updateChainlinkOracleWithENS()

Updates the stored oracle contract address with the latest address resolved
through the ENS contract. This requires the oracle provider to support listing
their address on ENS.

This method only works after useChainlinkWithENS has been called on the
contract.


    function updateOracleAddressToLatest() public {
      updateChainlinkOracleWithENS();
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or trust whoever can update the records.

### chainlinkTokenAddress


    function chainlinkTokenAddress() returns (address)

The `chainlinkTokenAddress` function is a helper used to return the stored
address of the Chainlink token. This variable is protected and so only made
available through getters and setters.


    function withdrawLink() public {
      LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
    
      require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
    }

### chainlinkOracleAddress

The `chainlinkOracleAddress` function is a helper used to return the stored
address of the oracle contract.


    function getOracle() public view returns (address) {
      return chainlinkOracleAddress();
    }
    

## Events

### ChainlinkRequested


    event ChainlinkRequested(
      bytes32 indexed id
    )

Emitted when sendChainlinkRequest and sendChainlinkRequestTo are called.
Includes the request ID as an event topic.

### ChainlinkFulfilled


    event ChainlinkFulfilled(
      bytes32 indexed id
    )

Emitted when validateChainlinkCallback or recordChainlinkFulfillment are
called. Includes the request ID as an event topic.

### ChainlinkCancelled


    event ChainlinkCancelled(
      bytes32 indexed id
    )

Emitted when cancelChainlinkRequest is called. Includes the request ID as an
event topic.

## Constants

### LINK_DIVISIBILITY

`LINK_DIVISIBILITY` is a uint256 constant to represent one whole unit of the
LINK token (1000000000000000000). It can be used with another value to specify
payment in an easy-to-read format, instead of hardcoding magic numbers.


    uint256 constant private ORACLE_PAYMENT = 100 * LINK_DIVISIBILITY; // = 100 LINK

## Modifiers

### recordChainlinkFulfillment

`recordChainlinkFulfillment` is used on fulfillment callbacks to ensure that
the caller and `requestId` are valid. This is the method equivalent of the
method `validateChainlinkCallback`.

Either `validateChainlinkCallback` or `recordChainlinkFulfillment` should be
used on all Chainlink callback functions to ensure that the sender and
`requestId` are valid. They protect ChainlinkClient callbacks from being
called by malicious callers. Do not call both of them, or your callback may
revert before you can record the reported response.


    function myCallback(bytes32 _requestId, uint256 _price)
      public
      recordChainlinkFulfillment(_requestId) // always validate callbacks
    {
      currentPrice = _price;
    }

## Chainlink.Request


    library Chainlink {
      struct Request {
        bytes32 id;
        address callbackAddress;
        bytes4 callbackFunctionId;
        uint256 nonce;
        Buffer.buffer buf;
      }
    }

The Chainlink Request struct encapsulates all of the fields needed for a
Chainlink request and its corresponding response callback.

The Chainlink protocol aims to be flexible and not restrict application
developers. The Solidity Chainlink Request model is a great example of that.
It is exceptionally flexible, given the limitations of Solidity. The request
can contain an arbitrary amount of keys and values to be passed off-chain to
the oracles for each request. It does so by converting the parameters into
CBOR, and then storing them in a buffer. This allows for any number of
parameters all of different types to be encoded on-chain.

The request's ID is generated by hashing the sender's address and the
request's nonce. This scheme ensures that only the requester can generate
their request ID, and no other contract can trigger a response from an oracle
with that ID. New requests whose IDs match an unfulfilled request ID will not
be accepted by the oracle.

Intended for memory

The Request object was intended to be stored in memory. If you have a reason
to persist the struct in storage, it is recommended that you do so by copying
each attribute over and explicitly copying the bytes in the buffer.

### Attributes

| Name               | Description                                                                                             |
|:-------------------|:--------------------------------------------------------------------------------------------------------|
| id                 | Identifier for the request                                                                              |
| callbackAddress    | Address that the response will be sent to upon fulfillment                                              |
| callbackFunctionId | Selector of the function on the callbackAddress that will be invoked with the response upon fulfillment |
| nonce              | Used to generate the request ID                                                                         |
| buf                | Buffer that stores additional user defined parameters as CBOR                                           |
### Methods

| Name           | Description                                                      |
|:---------------|:-----------------------------------------------------------------|
| add            | Add a string value to the run request parameters                 |
| addBytes       | Add a bytes value to the run request parameters                  |
| addInt         | Add an integer value to the run request parameters               |
| addUint        | Add an unsigned integer to the run request parameters            |
| addStringArray | Add an array of strings as a value in the run request parameters |
| setBuffer      | Directly set the CBOR of the run request parameters              |
#### add


    function add(
      Request memory self,
      string _key,
      string _value
    )

Add a string value to the run request parameters. Commonly used for `get` with
jobs using `httpGet` tasks.


    function requestEthereumPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.add(""get"", ""https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY"");
    
      sendChainlinkRequest(req, 1 * LINK_DIVISIBILITY); // =1 LINK
    }

#### addBytes


    function addBytes(
      Request memory self,
      string _key,
      bytes _value
    )

Add a CBOR bytes type value to the run request parameters.


    function requestEmojiPopularity(bytes _unicode)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addBytes(""emojiUnicode"", _unicode);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

Note that this can also be used as a workaround to pass other data types like
arrays or addresses. For instance, to add an _address_ , one would first
encode it using `abi.encode` then pass the result to `addBytes`:


    Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
    req.addBytes(""address"", abi.encode(msg.sender)); // msg.sender used in this example. Replace it with your address
    

#### addInt


    function addInt(
      Request memory self,
      string _key,
      int256 _value
    )

Add a CBOR signed integer type value to the run request parameters. Commonly
used with the `times` parameter of any job using a `multiply` task.


    function requestPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addInt(""times"", 100);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

#### addUint


    function addUint(
      Request memory self,
      string _key,
      uint256 _value
    )

Add a CBOR unsigned integer type value to the run request parameters. Commonly
used with the `times` parameter of any job using a `multiply` task.


    function requestPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addUint(""times"", 100);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

#### addStringArray


    function addStringArray(
      Request memory self,
      string _key,
      string[] memory _values
    )

Add a CBOR array of strings to the run request parameters. Commonly used with
the `path` parameter for any job including a `jsonParse` task.


    function requestPrice(string _currency)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
      string[] memory path = new string[](2);
      path[0] = _currency;
      path[1] = ""recent"";
    
      // specify templated fields in a job specification
      req.addStringArray(""path"", path);
    
      sendChainlinkRequest(req, PAYMENT);
    }

#### setBuffer


    function setBuffer(
      Request memory self,
      bytes _data
    )

Set the CBOR payload directly on the request object, avoiding the cost of
encoding the parameters in CBOR. This can be helpful when reading the bytes
from storage or having them passed in from off-chain where they were pre-
encoded.


    function requestPrice(bytes _cbor)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
    
      req.setBuffer(_cbor);
    
      sendChainlinkRequest(req, PAYMENT);
    }

Be careful setting the request buffer directly

Moving the CBOR encoding logic off-chain can save some gas, but it also opens
up the opportunity for people to encode parameters that not all parties agreed
to. Be sure that whoever is permissioned to call `setBuffer` is trusted or
auditable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/api-reference.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the minimum spend requirement for each registered upkeep in the Keepers Registry v1.2?,"Each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam.",{'source': 'https://docs.chain.link/chainlink-automation/automation-release-notes/'},The minimum spend requirement for each registered upkeep in the Keepers Registry v1.2 is 0.1 LINK.,,"# Chainlink Automation Release Notes

  * Overview
  * 2023-05-15 - Automation on Optimism
  * Chainlink Keepers is now Chainlink Automation
  * 2022-09-23 - v1.3 Release
  * 2022-08-04 - v1.2 Release
  * Manually migrating upkeeps from v1.1 to v1.2
  * 2022-07-21 - Underfunded upkeep notifications
  * 2022-06-29 - Keepers on Fantom
  * 2022-06-09 - Keepers on Avalanche
  * 2022-03-01 - Keepers on Ethereum Rinkeby
  * 2021-11-18 - Keepers on Binance Smart Chain and Polygon
  * 2021-08-05 - Keepers v1.1 launch on Ethereum
  * Questions

**Chainlink Automation release notes:**

  * Automation on Optimism
  * Chainlink Keepers is now Chainlink Automation
  * v1.3 release
  * v1.2 release
    * Manually migrating upkeeps from v1.1 to v1.2
  * Underfunded upkeep email notifications
  * Keepers on Fantom
  * Keepers on Avalanche
  * Keepers on Ethereum Rinkeby
  * Keepers on Binance Smart Chain and Polygon
  * Keepers v1.1 launch on Ethereum
  * Questions

## 2023-05-15 - Automation on Optimism

Chainlink Automation is live on [Optimism](/chainlink-automation/supported-networks#optimism).

## Chainlink Keepers is now Chainlink Automation

Chainlink Keepers has been renamed to **Chainlink Automation**. The table
below describes what terms under the former Keepers naming system translate to
under the current Automation naming system:

| Keepers Term                  | Automation Term                   |
|:------------------------------|:----------------------------------|
| Chainlink Keepers Network     | Chainlink Automation Network      |
| Keeper/Keeper Node            | Automation/Automation Node        |
| Keepers Job                   | Automation Job                    |
| Keepers Registry/Registrar    | Automation Registry/Registrar     |
| KeeperCompatible.sol          | AutomationCompatible.sol          |
| KeeperBase.sol                | AutomationBase.sol                |
| KeeperCompatibleInterface.sol | AutomationCompatibleInterface.sol |
## 2022-09-23 - v1.3 Release

Keepers Registry v1.3 [launched on Arbitrum Mainnet](/chainlink-automation/supported-networks/#arbitrum).

## 2022-08-04 - v1.2 Release

Keepers Registry v1.2 launched on Ethereum, Binance Smart Chain, Polygon,
Avalanche, and Fantom

  * **Automatic upkeep registration approval** : All upkeeps on supported mainnets are now automatically approved.

  * **Programmatic control** : With automatic approval, you can now dynamically create, manage, and fund upkeeps from within your dApps and even have an upkeep fund itself. Learn more [here](/chainlink-automation/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract).

  * **Advanced turn-taking algorithm** : Our turn taking algorithm now supports upkeeps that require high-frequency execution.

  * **Durable ID and user-triggered migration** : All upkeeps created in versions v1.2 and later will have durable IDs. v1.2 also supports user-triggered migration to future registry versions to make it easier to migrate to a new Keepers Registry and benefit from new features. Future migrations can still retain the existing ID. The ID is now a hash in format of a 77 digit integer.

  * **Configurable upkeeps** : You can now edit the gas limit of your upkeep to easily customize your upkeep to fit your needs without having to create a new upkeep.

  * **Off-chain compute improvements** : The off-chain compute sequence is improved for higher-fidelity representation of the gas and logic before transactions are submitted on-chain. This helps to reduce reverts and reduce fees.

  * **Minimum spend requirement** : As part of the mission to continuously enhance the security of the Chainlink Network for all participants, each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam. Note that an _upkeep_ is the automation job itself. It is not a transaction. Each upkeep can have thousands of transactions. If an upkeep has not spent more than 0.1 LINK across all transactions at the time of cancellation, then 0.1 LINK will be retained for the network. If more than 0.1 LINK has been spent by an upkeep, the full remaining balance of the upkeep will be withdrawable when the upkeep is canceled.

### Manually migrating upkeeps from v1.1 to v1.2

If your upkeep ID has 77 digits, it is already migrated to v1.2 and no further
action is required. If your upkeep ID has less than 4 digits, your upkeep is
on the v1.1 registry. To migrate your upkeep from Keepers v1.1 to Keepers
v1.2, you can cancel it in the Keepers App, and register an exact copy of the
upkeep in the Keepers App. While you can see upkeeps from both v1.1 and v1.2
in the [Keepers App](https://automation.chain.link), all new upkeeps in the
Keepers App will be automatically created on Keepers v1.2.

## 2022-07-21 - Underfunded upkeep notifications

You will now receive notifications to the email address you register in your
upkeep when your upkeep is underfunded. We are limiting notifications on the
same upkeep to once per week.

## 2022-06-29 - Keepers on Fantom

Chainlink Keepers is live on the Fantom Network,
[Mainnet](https://automation.chain.link/fantom) and
[Testnet](https://automation.chain.link/fantom-testnet).

## 2022-06-09 - Keepers on Avalanche

Chainlink Keepers is live on the Avalanche Network,
[Mainnet](https://automation.chain.link/avalanche) and
[Testnet](https://automation.chain.link/fuji).

## 2022-03-01 - Keepers on Ethereum Rinkeby

Chainlink Keepers is live on [Ethereum
Rinkeby](https://automation.chain.link/rinkeby).

## 2021-11-18 - Keepers on Binance Smart Chain and Polygon

Chainlink Keepers is live on the both Binance Smart Chain
[Mainnet](https://automation.chain.link/bsc) and
[Testnet](https://automation.chain.link/chapel), and Polygon
[Mainnet](https://automation.chain.link/polygon) and
[Testnet](https://automation.chain.link/mumbai).

## 2021-08-05 - Keepers v1.1 launch on Ethereum

Chainlink Keepers officially launched on [Ethereum
Mainnet](https://keepers.chain.link/mainnet).

## Questions

If you have questions, read the [Chainlink Automation Frequently Asked
Questions](/chainlink-automation/faqs) page. You can also ask questions in the
[#automation
channel](https://discord.com/channels/592041321326182401/821350860302581771)
in our [Discord server](https://discord.gg/qj9qarT), or [contact
us](https://forms.gle/WadxnzzjHPtta5Zd9) for assistance with registration.

## What's next

  * [› Register a time-based upkeep](/chainlink-automation/job-scheduler/)
  * [› Register a Custom Logic Upkeep](/chainlink-automation/register-upkeep/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/automation-release-notes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-08-12 14:00:57)
Chainlink&#39;s dynamic upkeep registration example failing: UpkeepIDConsumerExample.registerAndPredictID errored: execution reverted
URL: https://stackoverflow.com/questions/73335353/chainlinks-dynamic-upkeep-registration-example-failing-upkeepidconsumerexample

Question Body:


I'm playing around with Chainlink's ""Register an Upkeep using your own
deployed contract"" example: <https://docs.chain.link/docs/chainlink-
keepers/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract>

However, once the UpkeepIDConsumerExample is deployed with the Link Token
Contact, Registry and Registrar parameters for the respective chain, I am
unable to use the UpkeepIDConsumerExample.registerAndPredictID function as it
fails.

_(Gas estimation errored with the following message (see below). The
transaction execution will likely fail. Do you want to force sending? Internal
JSON-RPC error. { ""code"": -32000, ""message"": ""execution reverted"" })_

I've tried on Rinkeby, Mumbai and Polygon Mainnet, incase testnets weren't
live yet. And I've used the parameters suggested by the docs for calling the
function. And I have sufficient Link in my metamask.

Is it correct to use these: <https://docs.chain.link/docs/link-token-
contracts/> as the Link Token Interfrace parameter?

Thanks!



Answers:
(Answered on: 2022-08-18 02:47:27)


I was able to make this work (though I tried only on Goerli)using the code
from the [offical docs](https://docs.chain.link/docs/chainlink-
keepers/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract)
that you linked to.

For the benefit of others that read this post, I will break it down into
detailed steps - perhaps more than you needed for an answer!

**Prerequisites**

  1. [Get some LINK tokens](https://faucets.chain.link/goerli) in your browser wallet
  2. Deploy a Chainlink Keepers-compatible contract -- this is your Upkeep contract; the one that will be automated. [Here is the example Upkeep smart contract](https://docs.chain.link/docs/chainlink-keepers/compatible-contracts/#example-contract) that you can copy and deploy right away. You can use `10` as the `interval` \-- that's 10 seconds. This way you can see the upkeep happen fast. **Note this Upkeep's address**
  3. Next, deploy the `UpkeepIDConsumerExample` from the [example in the docs](https://docs.chain.link/docs/chainlink-keepers/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract), which is the smart contract that programmatically registers your Upkeep Contract. This contract handles registering the Upkeep Contract you deployed in Step #2 with Chainlink's Keepers network, so that the Keepers Network can automate the running of functions in your Upkeep contract. **Note this Contracts Address**

**Making it work**

  1. From your wallet, which should now have LINK in it, send 5 LINK to the deployed `UpkeepIDConsumerExample` address. This is funding it will need to send onwards to your Upkeep (Upkeeps need funding so they can pay the Keepers Network for the compute work they do in performing the automations).

  2. Using Remix, connect to the right network and then connect to your deployed `UpkeepIDConsumerExample` contract by using its address.

  3. When Remix shows your contract and its interactions in the DEPLOYED CONTRACTS section of the UI, fill in the parameters for the `registerAndPredictID()` function using [this table in the docs](https://docs.chain.link/docs/chainlink-keepers/register-upkeep/#registerandpredictid-parameters).

While following the table referred to above, please note:

    * upkeepContract is the Upkeep Contracts address - the one you deployed in Step 2 in **Prerequisites**
    * gasLimit - I used `3000000`
    * adminAddress - this can just be your wallet address. The one that you're deployed from, sending LINK from etc.
    * Amount - 5 LINK expressed in Juels (LINK's equivalent of Wei), so `5000000000000000000`
    * Sender - this is the `UpkeepIDConsumerExample`'s address. In this example it's the calling contract itself.
  4. run `registerAndPredictID()` with the params as per the previous step. It should run successfully.

  5. Verify by going to the [Keepers App](https://keepers.chain.link/goerli) and checking under ""My Upkeeps"" for a new Upkeep that you just programmatically created.

**Cleanup**

  1. In the [Keepers App](https://keepers.chain.link/goerli) note the LINK balance of the Upkeep you just created and funded with the 5 LINK -- it may be a bit less than the 5 LINK you sent it because the keepers network may have already run your Upkeep - we had set the interval for 10 seconds in Step 2 of Prerequisites.
  2. And on Etherscan check whether `UpkeepIDConsumerExample` has any LINK in it (it shouldn't because the 5 LINK you sent from your wallet to this contract, was transferred when you ran `registerAndPredictID()` and sent an amount of 5 LINK

Hope this helps!



"
What is the purpose of setting the `const consumerAddress` in the `request.js` script?,To set the deployed consumer address,{'source': 'https://docs.chain.link/chainlink-functions/resources/add-functions-to-projects/'},"The purpose of setting the `const consumerAddress` in the `request.js` script is to import the consumer contract address that was deployed in the `deploy.js` script. This allows the `request.js` script to interact with the deployed consumer contract and send requests to the Chainlink Functions decentralized oracle network (DON). The `consumerAddress` is used to instantiate the consumer contract and make function calls to it.

","
- https://docs.chain.link/chainlink-functions/resources/add-functions-to-projects/
- https://stackoverflow.com/questions/76231362/chainlink-functions-error-thrown-in-sandboxed-source-code-cannot-find-module","# Adding Chainlink Functions to an Existing Project

  * Overview
  * Before you begin
  * Configure Hardhat
  * Get the dependency contracts and scripts
  * Configure on-chain resources
  * Create a consumer contract
  * Deploy a consumer contract
  * Create and fund a subscription
  * Send requests
  * Create a request script

The [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) lets
you run several example requests, but extra steps are required to add
Chainlink Functions to your existing projects.

If you are new to Chainlink Functions, complete the steps in the [Getting
Started Guide](/chainlink-functions/getting-started) to learn the basics. If
you already have a project, you can skip to the Libraries and Dependencies
section.

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

Using Chainlink Functions to your existing projects requires the following
components:

  * **A consumer contract:** Use this contract to send requests to the Chainlink Functions decentralized oracle network (DON). The consumer contract imports the following dependencies: 
    * [FunctionsClient.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/dev/functions/FunctionsClient.sol): This includes several functions necessary to submit requests to the DON.
    * [ConfirmedOwner.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwner.sol) from the [@chainlink/contracts](https://www.npmjs.com/package/@chainlink/contracts) NPM package.
  * **A Chainlink Functions subscription:** The subscription is used to pay for Chainlink Functions requests when they are fulfilled. You can [create and fund](/chainlink-functions/resources/subscriptions) subscriptions using the starter kit tools, but this guide shows you how to manage subscriptions programmatically.

## Before you begin

This guide assumes you are using a [Hardhat](https://hardhat.org/) JavaScript
project with Node.js, but you can modify it to work with other frameworks. If
you already have a project, you can skip to the Libraries and Dependencies
section.

You must have a wallet with testnet LINK and native tokens to run this
example. This example uses Polygon Mumbai, but you can use any of the
[Supported Networks](/chainlink-functions/supported-networks). You can get
testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai) and
testnet MATIC at the [Polygon Faucet](https://faucet.polygon.technology/). To
learn how to get testnet funds for other networks, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

### Configure Hardhat

If you don't already have a Hardhat project, start one with the following
steps:

  1. Install [Node.js](https://nodejs.org/en/download/). **Note** : Node.js version 18 is required.

  2. Make a new project directory:
    
        mkdir new-functions-project && cd new-functions-project

  3. Create a new Node.js project:
    
        npm init

  4. Install Hardhat as a dev dependency:
    
        npm install --save-dev hardhat

  5. Install the dependency packages:
    
        npm install @chainlink/contracts @chainlink/env-enc @openzeppelin/contracts @openzeppelin/contracts-upgradeable eth-crypto dotenv axios vm2 is-http-url prompt-sync

  6. Create a new Hardhat project. For this example, create a JavaScript project and use the default configurations:
    
        npx hardhat

  7. Remove the `Lock.sol` contract that Hardhat creates by default. This contract is not necessary to compile it for this tutorial.
    
        rm ./contracts/Lock.sol

  8. Use `curl` to get the example hardhat config file `hardhat.config.js`:
    
        curl -o hardhat.config.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/hardhat.config.js

  9. Open `hardhat.config.js`. To use a different network, see the [Supported Networks](/chainlink-functions/supported-networks) page for a list of networks where Chainlink Functions DONs are available. This example uses Polygon Mumbai by default.

  10. For higher security, you should encrypt your environment variables at rest.

    1. Set an encryption password for your environment variables.
        
                npx env-enc set-pw

    2. Run `npx env-enc set` to configure a `.env.enc` file with the basic variables that you need to send your requests to the Polygon Mumbai network.

      * `POLYGON_MUMBAI_RPC_URL`: Set a URL for the Polygon Mumbai testnet. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.

      * `PRIVATE_KEY`: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to [Export a Private Key](https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key). Set this in the `.env` file. **Note** : The Chainlink Functions hardhat starter kit uses your private key to sign any transactions you make such as deploying your consumer contract, creating subscriptions, and making requests.
        
                npx env-enc set

Run the compile command for Hardhat or your framework of choice to make sure
everything is configured correctly. You will see several compile warnings, but
everything is correct if the Solidity files compile successfully. For this
example, run:


    npx hardhat compile

## Get the dependency contracts and scripts

Get the required libraries from the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You
can clone the repo and copy the folders into your existing project manually,
or use a single command to get a tarball through the GitHub API and extract
the folders you need to the correct location in your project.

  1. Open a terminal and change directories to the root of your project. Usually this is the folder with `package.json`.

  2. Run the `curl` command to download the latest tarball from the starter kit `main` branch and then run `tar -xf` with the `--strip` flag to extract only the files you need. The following command combines both steps:

MacOSLinux

    
        curl -L -o ../functions.tar.gz https://api.github.com/repos/smartcontractkit/functions-hardhat-starter-kit/tarball/main &&
    tar -xf ../functions.tar.gz --strip=1 --wildcards smartcontractkit-functions-hardhat-starter-kit-*/contracts/dev smartcontractkit-functions-hardhat-starter-kit-*/contracts/test smartcontractkit-functions-hardhat-starter-kit-*/FunctionsSandboxLibrary smartcontractkit-functions-hardhat-starter-kit-*/contracts/FunctionsConsumer.sol
    
        curl -L -o ../functions.tar.gz https://api.github.com/repos/smartcontractkit/functions-hardhat-starter-kit/tarball/main &&
    tar -xf ../functions.tar.gz --strip=1 -T <(echo -e ""smartcontractkit-functions-hardhat-starter-kit-*/contracts/dev\nsmartcontractkit-functions-hardhat-starter-kit-*/contracts/test\nsmartcontractkit-functions-hardhat-starter-kit-*/FunctionsSandboxLibrary\nsmartcontractkit-functions-hardhat-starter-kit-*/contracts/FunctionsConsumer.sol"")

When you are done, you should have the necessary dependencies in the following
directories:

  * `contracts/dev`
  * `contracts/test`
  * `FunctionsSandboxLibrary`

Run the compile command to make sure all the dependencies are satisfied. Add
missing dependencies or Hardhat configuration options as necessary. For
Hardhat, run `npx hardhat compile`.


    npx hardhat compile

## Configure on-chain resources

The on-chain resources are critical for Chainlink Functions to process your
requests.

  1. Create a consumer contract
  2. Deploy a consumer contract

### Create a consumer contract

Use the [FunctionsConsumer.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/FunctionsConsumer.sol), which is
already in your `./contracts` folder. You can modify it to fit your needs and
redeploy it later. Optionally, you can take an existing contract of your own
and enable it to handle Chainlink Functions requests. Just make sure that it
meets the requirements listed in this guide.

In general, a consumer contract requires several components:

  * To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol). You can read the API reference: [FunctionsClient](/chainlink-functions/api-reference/FunctionsClient).

This contract is not available in an NPM package, so you must download and
import it from within your project.

    
        import {Functions, FunctionsClient} from ""./dev/functions/FunctionsClient.sol"";

  * Use the [Functions.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/Functions.sol) library to get all the functions needed for building a Chainlink Functions request. You can read the API reference: [Functions](/chainlink-functions/api-reference/Functions).
    
        using Functions for Functions.Request;
    

  * The latest request id, latest received response, and latest received error (if any) are defined as state variables. Note `latestResponse` and `latestError` are encoded as dynamically sized byte array `bytes`, so you will still need to decode them to read the response or error:
    
        bytes32 public latestRequestId;
    bytes public latestResponse;
    bytes public latestError;

  * We define the `OCRResponse` event that your smart contract will emit during the callback
    
        event OCRResponse(bytes32 indexed requestId, bytes result, bytes err);

  * Pass the oracle address for your network when you deploy the contract:
    
        constructor(address oracle) FunctionsClient(oracle)

  * At any time, you can change the oracle address by calling the `updateOracleAddress` function.

  * The two remaining functions are:

    * `executeRequest` for sending a request. It receives the JavaScript source code, encrypted secrets, list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

      * It uses the `Functions`library to initialize the request and add any passed encrypted secrets or arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/Functions/#initializerequest), [adding secrets](/chainlink-functions/api-reference/Functions/#addinlinesecrets), and [adding arguments](/chainlink-functions/api-reference/Functions/#addargs).
            
                        Functions.Request memory req;
            req.initializeRequest(Functions.Location.Inline, Functions.CodeLanguage.JavaScript, source);
            if (secrets.length > 0) {
              req.addRemoteSecrets(secrets);
            }
            if (args.length > 0) req.addArgs(args);

      * It sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Finally, it stores the request id in `latestRequestId`.
            
                        bytes32 assignedReqID = sendRequest(req, subscriptionId, gasLimit);
            latestRequestId = assignedReqID;

    * `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `latestResponse` and `latestError` before emitting the `OCRResponse` event.
        
                latestResponse = response;
        latestError = err;
        emit OCRResponse(requestId, response, err);

Next, deploy the contract.

### Deploy a consumer contract

You can deploy consumer contracts using the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit), but
this example shows how to deploy the contract programmatically using a script.

  1. Use `curl` to get the example deployment script `deploy.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/deploy.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/deploy.js

  2. Open `deploy.js` in your editor of choice.

  3. Set the `oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  4. Set `const contractName` to the name of the contract that you want Hardhat to deploy. The `ethers.getContractFactory(contractName);` line creates a `ContractFactory` object using the contract that you define. For this example, use `FunctionsConsumer`.
    
        const contractName = ""FunctionsConsumer""
    
    ⋮
    
    const consumerContract = await ethers.getContractFactory(contractName);

  5. Save the file and run the script to deploy your contract. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run ./scripts/deploy.js --network your_network

Example:

    
        npx hardhat run ./scripts/deploy.js --network polygonMumbai

  6. If your contract deployed successfully, you will see the deployed consumer address. Record this address to use later:
    
        Deployed Functions Consumer address: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Next, create and fund your Chainlink Functions subscription.

### Create and fund a subscription

You can use the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to
create and manage your subscriptions. See [Managing Subscriptions](/chainlink-functions/resources/subscriptions) for instructions.

This example shows how to create and manage subscriptions programmatically.
You can create the subscription, fund the subscription, and authorize the
consumer all in one script. If you have not already signed up for limited Beta
access to Chainlink Functions, apply [here](http://functions.chain.link/) to
add your EVM account address to the Allow List.

  1. Ensure that the wallet address you are using to create the subscription has a sufficient LINK balance. You can get testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai). To get testnet funds for other networks, see the [LINK Token Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

  2. Use `curl` to get the example subscription script `functions-sub.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/functions-sub.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/functions-sub.js

  3. Open `functions-sub.js` in your editor of choice.

  4. Set `const linkAmount` with the amount of LINK you want to send to the subscription. You can retrieve extra funds later when you cancel the subscription.
    
        const linkAmount = ""1""

  5. Set `const consumer` to the address of the consumer contract that you deployed:
    
        const consumer = ""0x5484e266c2cD379800e6F27EaB097Bb806647CbF""

  6. Save the file and run the script. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run scripts/functions-sub.js --network your_network

Example:

    
        npx hardhat run scripts/functions-sub.js --network polygonMumbai

  7. If the script is successful, you the terminal prints your subscription ID. Record this ID to use for Chainlink Functions requests. You should see output similar to the following example:
    
        Subscription created with ID: 917
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Subscription 917 funded with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Adding consumer contract address 0x5484e266c2cD379800e6F27EaB097Bb806647CbF to subscription 917
    Authorized consumer contract: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Now that the consumer contract is deployed and the subscription is created and
funded with LINK, the on-chain resources are ready to handle your requests.
Next, create JavaScript code that you want to run on the DON, configure
arguments for the code, and create a script to send your request.

## Send requests

After your on-chain resources are configured, you can send Chainlink Functions
requests to the DON. This can be done from a Web3 application, script, another
on-chain smart contract, or any other location capable of submitting requests
to your consumer contract. This example shows you how to generate a request,
encrypt secrets, send your request, and read the fulfillment response.

Each request has the following components:

  * **Source code:** JavaScript code that will run on the DON.
  * **Arguments:** Optional arguments for the source code. The arguments that you need are defined in your source code. Depending on how you configured your source, you might not need any arguments at all.
  * **Secrets:** Optional secrets that your source code needs to access APIs or other interfaces. See the [Using Secrets in Requests](/chainlink-functions/tutorials/api-use-secrets) and [Using Off-chain Secrets](/chainlink-functions/tutorials/api-use-secrets-offchain) tutorials for examples.

### Create a request script

If you already have source code or want to write your own source code, put it
in a file in your project. Later, you can specify the path to this file before
you submit your request.

For this example, download some example source code and create a script to
assemble the required components. The script will read your source code,
define arguments, encrypt secrets, and send requests to your consumer
contract. This example script does not require Hardhat, so you can modify it
to run in a browser using Ethers or another framework.

  1. Use `curl` to get the example source code. This code runs on each node in the DON and returns a response to your consumer contract. For this example, use the source from the [Call an API](/chainlink-functions/tutorials/api-query-parameters) tutorial. The following `curl` request creates a file named `Functions-request-source.js` with the source code:
    
        curl -o Functions-request-source.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/Functions-request-source.js

  2. Get the example script and put it in the `./scripts` directory:
    
        curl -o ./scripts/request.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/request.js

  3. Edit the `request.js` script and set your deployed consumer address in `const consumerAddress`:
    
        const consumerAddress = 0x5484e266c2cd379800e6f27eab097bb806647cbf

  4. Set `const subscriptionId` to your Chainlink Functions subscription ID. This must be the same ID that your consumer contract is authorized to use. You can [add a consumer contract to a subscription](/chainlink-functions/resources/subscriptions#add-a-consumer-contract-to-a-subscription) later if you need to.
    
        const subscriptionId = 917

  5. Set `const consumerAbiPath` to the ABI file that you created when you ran `npx hardhat compile`. The ABI tells Ethers how to interact with your deployed contract. If you compiled and deployed `FunctionsConsumer.sol`, set a path like the following example:
    
        const consumerAbiPath = ""./artifacts/contracts/FunctionsConsumer.sol/FunctionsConsumer.json""

  6. Set `const source` with the path to the request source code that you downloaded earlier:
    
        const source = ./Functions-request-source.js

  7. Set `const args` with an array of arguments for the DON to use when it runs your source. If you look at the `Functions-request-source.js` file, you can see that it requires two arguments. The args define which assets to retrieve from the data source URL.
    
        const args = [""ETH"", ""USD""]

  8. Set `const oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  9. Set `const oracleAbiPath` to the ABI for the oracle contract. If you downloaded and compiled the dependencies for deploying your consumer contract, the oracle ABI is already generated in `./artifacts/contracts/dev/functions/`:
    
        const oracleAbiPath = ""./artifacts/contracts/dev/functions/FunctionsOracle.sol/FunctionsOracle.json""

  10. Secrets are not required for this example.

  11. Save and close the script.

  12. Run the script to send the request to the DON.
    
        npx hardhat run scripts/request.js --network your_network

Example:

    
        npx hardhat run scripts/request.js --network polygonMumbai

If the script runs successfully, the script reads your consumer contract and
prints the stored value that the DON returned.


    Waiting 2 blocks for transaction 0x949184e7b605f034ce1d1d954973dc7132efb815bfa4861c54774cee457566d8 to be confirmed...
    
    Request 0xb3a4f9f47caeb83c5125ee61e2db1ca41beaa8a6781fb3c4364b4d394c40bc6b initiated
    Waiting for fulfillment...
    
    
    Request 0xb3a4f9f47caeb83c5125ee61e2db1ca41beaa8a6781fb3c4364b4d394c40bc6b fulfilled!
    Response returned to client contract represented as a hex string: 180972

Now you have the tools you need to build your own applications that use
Chainlink Functions. Modify `Functions-request-source.js` and your input
arguments to try out different capabilities. For more examples, see the
[Tutorials](/chainlink-functions/tutorials) section.

## What's next

  * [› Try out the Chainlink Functions Tutorials](/chainlink-functions/tutorials)
  * [› Read the Concepts page to learn about the core concepts behind Chainlink Functions](/chainlink-functions/resources/concepts)
  * [› Read the Architecture to understand how Chainlink Functions operates](/chainlink-functions/resources/architecture)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/add-functions-to-projects.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2023-05-11 20:21:54)
Chainlink Functions: _Error thrown in sandboxed source code__ Cannot find module &#39;./server.js&#39;
URL: https://stackoverflow.com/questions/76231362/chainlink-functions-error-thrown-in-sandboxed-source-code-cannot-find-module

Question Body:


Building on the Functions-ChatGPT integration workshop, I wrote `server.js`
code in which the idea is to get a ChatGPT prompt from the user from another
client. The steps my server takes are:

  1. listens for a client request on a `/chatgpt` endpoint,
  2. strips the body message (prompt) from the request, and
  3. loads the message to a global object and exports it via module export to another source file (call it `Functions-request-source.js` like in the workshop).
  4. Executes a child process to run `npx hardhat functions-simulate` under assumption that the exported prompt is being used as an input parameter to the `Functions-request-source.js` which will be called by the `npx hardhat functions-simulate` command. My `Functions-request-source.js` is the file I've used in my `Functions-request-config` file.

I think this should be a straight forward enough process (especially exporting
my prompt as a global object) but when I run the program, I receive the
message `__Error thrown in sandboxed source code__ Cannot find module
./server.js`. I believe my issue is that `Functions-request-source.js` doesn't
seem to be reading my module.export from `server.js`, but I'm not sure why. I
provided my code for `server.js` and `Functions-request-source.js` below.

`server.js`

    
    
    const express = require(""express"")
    const app = express()
    const bodyParser = require(""body-parser"")
    const { exec } = require(""child_process"")
    const port = 3667
    
    app.use(bodyParser.json())
    
    let telegramInputObj = {
      telegramInput: null,
      setTelegramInput: function (input) {
        this.telegramInput = input
      },
      getTelegramInput: function () {
        return this.telegramInput
      },
    }
    
    app.post(""/chatgpt"", (req, res) => {
      const message = req.body.message
      console.log(`received message from client: ${message}`)
    
      //Set global object variable
      telegramInputObj.setTelegramInput(message)
      console.log(""global telegram input: "" + telegramInputObj.getTelegramInput())
    
      //Command for child process
      const command = ""npx hardhat functions-simulate""
    
      //Execute child process
      exec(command, (error, stdout, stderr) => {
        if (error) {
          console.error(`exec error: ${error}`)
          res.status(500).send(`Error: ${error}`)
          return
        }
    
        console.log(`stdout: ${stdout}`)
        console.error(`stderr: ${stderr}`)
        res.send(stdout)
      })
    })
    
    app.listen(port, () => {
      console.log(`Server listening at http://localhost:${port}`)
    })
    
    module.exports = telegramInputObj
    

`Functions-request-source.js`

    
    
    const telegramInputObj = require(""./server.js"")
    
    console.log(""Imported telegram input is: "" + telegramInputObj.getTelegramInput())
    
    const prompt = telegramInputObj.getTelegramInput()
    
    if (!secrets.openaiKey) {
      throw Error(""Need to set OPENAI_KEY environment variable"")
    }
    
    // example request:
    // curl https://api.openai.com/v1/completions -H ""Content-Type: application/json"" -H ""Authorization: Bearer YOUR_API_KEY"" -d '{""model"": ""text-davinci-003"", ""prompt"": ""Say this is a test"", ""temperature"": 0, ""max_tokens"": 7}
    
    // example response:
    // {""id"":""cmpl-6jFdLbY08kJobPRfCZL4SVzQ6eidJ"",""object"":""text_completion"",""created"":1676242875,""model"":""text-davinci-003"",""choices"":[{""text"":""\n\nThis is indeed a test"",""index"":0,""logprobs"":null,""finish_reason"":""length""}],""usage"":{""prompt_tokens"":5,""completion_tokens"":7,""total_tokens"":12}}
    const openAIRequest = Functions.makeHttpRequest({
      url: ""https://api.openai.com/v1/completions"",
      method: ""POST"",
      headers: {
        Authorization: `Bearer ${secrets.openaiKey}`,
      },
      data: { model: ""text-davinci-003"", prompt: prompt, temperature: 1, max_tokens: 7 },
    })
    
    const [openAiResponse] = await Promise.all([openAIRequest])
    console.log(""raw response"", openAiResponse)
    
    const result = openAiResponse.data.choices[0].text
    
    return Functions.encodeString(result)
    
    

I have tried pointing my user prompt from `server.js` directly to the
`Functions-request-config.js` file using the `args` parameter of the
`requestConfig` object. I've also tried exporting the prompt as a variable
instead of an object. Both didn't help. I've double checked that my require()
statements at the top of my `Functions-request-source.js` file are also using
the correct file path (they're in the same directory).

Hoping someone might be able to help out, as I'm pretty junior to the dev
space. Thanks!



Answers:
(Answered on: 2023-05-12 01:05:21)


junior and senior people struggle with learning new things, so i wouldnt worry
about that :)

Ok so whats happening is that you're trying to import code into your custom
source.js file

""const telegramInputObj = require(""./server.js"")"" <\---- this

Thats not allowed for security reasons -- the Functions-request-source.js file
cannot contain imports other than specific node js libraries that are
allowlisted by Functions. This is essential to maintain code security so that
arbitrary and malicious code doesnt get imported.

See more here:

<https://github.com/smartcontractkit/functions-hardhat-starter-kit#javascript-
code>

since you're trying to access ""telegramInputObj"" inside your custom code, why
dont you just send that in request config as an ""args"" item? parse the JSON
into a String (JSON.stringify()) and then send the arg as one long string, and
then inside your custom JS do JSON.parse(telegramInputObj) to get it converted
back into a JS object?

Try that and see if it works!



"
What is the purpose of the Subscription Manager in Chainlink VRF?,"The Subscription Manager lets you create an account and pre-pay for VRF requests, so that funding of all your application requests are managed in a single location.",{'source': 'https://docs.chain.link/getting-started/intermediates-tutorial/'},"The purpose of the Subscription Manager in Chainlink VRF is to allow smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. The Subscription Manager also provides the capability to adjust the callback gas limit, define block confirmations, request multiple random outputs in a single request, and delegate subscription balance to multiple addresses. It allows for more efficient and flexible management of VRF subscriptions.
",https://docs.chain.link/vrf/v2/subscription/migration-from-v1/,"# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  2. Import the new [`VRFConsumerBaseV2.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  3. Import the [`VRFCoordinatorV2Interface.sol` interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol). This interface includes the new `requestRandomWords` function.

  4. Add a `VRFConsumerBaseV2` constructor as shown in the [Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number) example.

  5. Change `requestRandomness` function calls to `requestRandomWords`. The `requestRandomWords` function requires several additional parameters.

  6. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Programmatic Subscription

  * Overview
  * Modifying subscriptions and configurations
  * Subscription manager contract
  * Funding and requesting simultaneously

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

How you manage the subscription depends on your randomness needs. You can
configure your subscriptions using the [Subscription
Manager](/vrf/v2/subscription/ui), but these examples demonstrate how to
create your subscription and add your consumer contracts programmatically. For
these examples, the contract owns and manages the subscription. Any wallet can
provide funding to those subscriptions.

You can view and monitor your subscriptions in the [Subscription
Manager](/vrf/v2/subscription/ui) even if you create them programmatically. Go
to [vrf.chain.link](https://vrf.chain.link) to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    * `acceptSubscriptionOwnerTransfer(uint64 subId)`.
  * View the subscription with `getSubscription(uint64 subId)`.
  * Cancel the subscription with `cancelSubscription(uint64 subId)`.

To send LINK to the subscription balance, use the LINK token interface with
`LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(subId))`.
Any wallet can fund a subscription.

See the example in the Subscription manager contract section to learn how to
create a contract that can change your subscription configuration.

## Subscription manager contract

In this example, the contract operates as a subscription owner and can run
functions to add consuming contracts to the subscription. The consuming
contracts must include the `requestRandomWords()` function with the correct
coordinator parameters and the correct subscription ID to request random
values and use the subscription balance. The consuming contracts must also
include the `fulfillRandomWords()` function to receive the random values.

Subscription owners and consumers do not have to be separate. This contract
not only allows adding consumers with `addConsumer(address consumerAddress)`
but can also act as a consumer by running its own `requestRandomWords()`
function. This example contract includes a `createNewSubscription()` function
in the `constructor()` that creates the subscription and adds itself as a
consumer automatically when you deploy it.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that also owns and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Sepolia coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    
        // Sepolia LINK token contract. For other networks, see
        // https://docs.chain.link/docs/vrf-contracts/#configurations
        address link_token_contract = 0x779877A7B0D9E8603169DdbD7836e478b4624789;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 keyHash =
            0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;
    
        // A reasonable default is 100000, but this value could be different
        // on other networks.
        uint32 callbackGasLimit = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 requestConfirmations = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
        uint32 numWords = 2;
    
        // Storage parameters
        uint256[] public s_randomWords;
        uint256 public s_requestId;
        uint64 public s_subscriptionId;
        address s_owner;
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            LINKTOKEN = LinkTokenInterface(link_token_contract);
            s_owner = msg.sender;
            //Create a new subscription when you deploy the contract.
            createNewSubscription();
        }
    
        // Assumes the subscription is funded sufficiently.
        function requestRandomWords() external onlyOwner {
            // Will revert if subscription is not set and funded.
            s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
        }
    
        function fulfillRandomWords(
            uint256 /* requestId */,
            uint256[] memory randomWords
        ) internal override {
            s_randomWords = randomWords;
        }
    
        // Create a new subscription when the contract is initially deployed.
        function createNewSubscription() private onlyOwner {
            s_subscriptionId = COORDINATOR.createSubscription();
            // Add this contract as a consumer of its own subscription.
            COORDINATOR.addConsumer(s_subscriptionId, address(this));
        }
    
        // Assumes this contract owns link.
        // 1000000000000000000 = 1 LINK
        function topUpSubscription(uint256 amount) external onlyOwner {
            LINKTOKEN.transferAndCall(
                address(COORDINATOR),
                amount,
                abi.encode(s_subscriptionId)
            );
        }
    
        function addConsumer(address consumerAddress) external onlyOwner {
            // Add a consumer contract to the subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
        }
    
        function removeConsumer(address consumerAddress) external onlyOwner {
            // Remove a consumer contract from the subscription.
            COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
        }
    
        function cancelSubscription(address receivingWallet) external onlyOwner {
            // Cancel the subscription and send the remaining LINK to a wallet address.
            COORDINATOR.cancelSubscription(s_subscriptionId, receivingWallet);
            s_subscriptionId = 0;
        }
    
        // Transfer this contract's funds to an address.
        // 1000000000000000000 = 1 LINK
        function withdraw(uint256 amount, address to) external onlyOwner {
            LINKTOKEN.transfer(to, amount);
        }
    
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }
    

To use this contract, compile and deploy it in Remix.

  1. Open the contract in [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol).

  2. Compile and deploy the contract using the Injected Provider environment. The contract includes all of the configuration variables that you need, but you can edit them if necessary. For a full list of available configuration variables, see the [Supported Networks](/vrf/v2/subscription/supported-networks) page.

This contract automatically creates a new subscription when you deploy it.
Read the `s_subscriptionId` variable to find your subscription ID. You can use
this value to find the subscription at
[vrf.chain.link](https://vrf.chain.link).

  3. In this example, the `topUpSubscription()` function sends LINK from your contract to the subscription. Fund your contract with at least three testnet LINK. Alternatively, you can send LINK directly to the subscription at [vrf.chain.link](https://vrf.chain.link). Any address can provide funding to a subscription balance. If you need testnet LINK, you can get it from [faucets.chain.link](https://faucets.chain.link/sepolia/).

  4. Run the `topUpSubscription()` function to send LINK from your contract to your subscription balance. For this example, specify a value of `3000000000000000000`, which is equivalent to three LINK.

  5. Run the `requestRandomWords()` function. The request might take several minutes to process. Track the pending request status at [vrf.chain.link](https://vrf.chain.link).

  6. You can also add and test consumer contracts using the same programmatic subscription process:

    1. Create and deploy a consumer contract that includes the following components:

      * The `requestRandomWords()` function and the required variables and your subscription ID.
      * The `fulfillRandomWords()` callback function.

You can use the example from the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number/#analyzing-the-contract) guide.

    2. After you deploy the consumer contract, add it to the subscription as an approved consumer using the `addConsumer()` function on your subscription manager contract. Specify the address of your consumer contract.

    3. On the consumer contract, run the `requestRandomWords()` function to request and receive random values. The request might take several minutes to process. Track the pending request status at [vrf.chain.link](https://vrf.chain.link).

The consumer contract can continue to make requests until your subscription
balance runs out. The subscription manager contract must maintain sufficient
balance in the subscription so that the consumers can continue to operate.

    4. If you need to remove consumer contracts from the subscription, use the `removeConsumer()` function. Specify the address of the consumer contract to be removed.

  7. When you are done with your contracts and the subscription, run the `cancelSubscription()` function to close the subscription and send the remaining LINK to your wallet address. Specify the address of the receiving wallet.

## Funding and requesting simultaneously

You can fund a subscription and request randomness in a single transaction.
You must estimate how much the transaction might cost and determine the amount
of funding to send to the subscription yourself. See the [Subscription
billing](/vrf/v2/subscription/#subscription-limits) page to learn how to
estimate request costs.


    // Assumes this contract owns link
    // You must estimate LINK cost yourself based on the gas lane and limits.
    // 1_000_000_000_000_000_000 = 1 LINK
    function fundAndRequestRandomWords(uint256 amount) external onlyOwner {
        LINKTOKEN.transferAndCall(
            address(COORDINATOR),
            amount,
            abi.encode(s_subscriptionId)
        );
        // Will revert if subscription is not set and funded.
        s_requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
    }
    

Add this function to your contracts if you need to provide funding
simultaneously with your requests. The `transferAndCall()` function sends LINK
from your contract to the subscription, and the `requestRandomWords()`
function requests the random words. Your contract still needs the
`fulfillRandomWords()` callback function to receive the random values.

## What's next

  * [› Subscription Manager UI](/vrf/v2/subscription/ui)
  * [› Security Considerations](/vrf/v2/security)
  * [› Best Practices](/vrf/v2/best-practices)
  * [› Migrating from VRF v1 to v2](/vrf/v2/subscription/migration-from-v1)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/examples/programmatic-subscription.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of operating a Chainlink node?,"Operating a Chainlink node allows you to be part of the Chainlink Network, helping developers build hybrid smart contracts, giving them access to real-world data and services.",{'source': 'https://docs.chain.link/chainlink-nodes/'},"The purpose of operating a Chainlink node is to be part of the Chainlink Network and help developers build hybrid smart contracts by providing them access to real-world data and services. Chainlink nodes allow for the integration of external data and APIs into smart contracts. They play a crucial role in fetching and delivering data to smart contracts, ensuring the accuracy and reliability of the data used in the contract's execution. By operating a Chainlink node, individuals can contribute to the decentralized oracle network and support the development of secure and reliable smart contracts.

","- https://docs.chain.link/chainlink-nodes/
- https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example","# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req, ORACLE_PAYMENT);
      }
    

Edit: I did figure out what the path variable is for, it controls how you want
the jsonparse function to run. For example the path listed above will parse
down like this:

    
    
    {""RAW"": {""ETH"" : {""USD"" : { ""LASTMARKET"" : value
    



Answers:
(Answered on: 2021-11-29 17:18:45)


The `string[] memory path` is the `path` for the chainlink node to walk to get
data from the JSON responose.

For example, if your json looks like this:

    
    
    {
      cat: {
        tabby: 7,
        cool: 2
      }
    }
    

And you wanted the `cool` value of `2`, your `path` would be:

    
    
    string[] memory path = new string[](2);
    path[0] = ""cat"";
    path[1] = ""cool"";
    req.addStringArray(""path"", path);
    



"
Why is randomness important in many types of applications?,Randomness is important in many types of applications because it is an essential component of a majority of games.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-1/course.md'},"Randomness is important in many types of applications because it adds an element of unpredictability and fairness. In games, randomness is often used to determine outcomes and create a more engaging and dynamic experience. It prevents players from predicting or manipulating the results. In the context of blockchain and smart contracts, randomness is crucial for applications such as raffles, lotteries, and games that are built on the blockchain. It ensures that the selection process is unbiased and cannot be manipulated by any party. Randomness also adds a layer of security by making it difficult for malicious actors to exploit the system. Overall, randomness enhances the integrity and trustworthiness of various applications.

","- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-1/course.md
- https://docs.chain.link/vrf/v2/security/","#####Chapter 1:

# Randomness

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      With your newfound power, understanding of what smart contracts are you want to develop a smart contract to raffle an NFT to your friends. But how will you get randomness into your raffle smart contract?
    </div>
  </div>
</ContentWrapp>

Randomness is essential for many types of applications. Think about how many games have randomness built-in. Rolling dice in dungeons and dragons, a random starting hand of poker, or a random next block in Tetris, randomness is an essential component of a majority of games. As we learned in Chainlink 101, smart contracts are a powerful tool for decentralized applications (dapps). But what if you want to build a game, raffle or any other type of application that utilizes randomness on the blockchain? Let's learn about randomness on the blockchain in the next lesson!


:::NEXT DOC:::

# VRF Security Considerations

  * Overview
  * Use requestId to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * fulfillRandomWords must not revert
  * Use VRFConsumerBaseV2 in your contract, to interact with the VRF service
  * Use VRFv2WrapperConsumer.sol in your contract, to interact with the VRF service

Gaining access to high quality randomness on-chain requires a solution like
Chainlink's VRF, but it also requires you to understand some of the ways that
miners or validators can potentially manipulate randomness generation. Here
are some of the top security considerations you should review in your project.

  * Use `requestId` to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * The `fulfillRandomWords` function must not revert
  * Use `VRFConsumerBaseV2` in your contract to interact with the VRF service

## Use `requestId` to match randomness requests with their fulfillment in
order

If your contract could have multiple VRF requests in flight simultaneously,
you must ensure that the order in which the VRF fulfillments arrive cannot be
used to manipulate your contract's user-significant behavior.

Blockchain miners/validators can control the order in which your requests
appear on-chain, and hence the order in which your contract responds to them.

For example, if you made randomness requests `A`, `B`, `C` in short
succession, there is no guarantee that the associated randomness fulfillments
will also be in order `A`, `B`, `C`. The randomness fulfillments might just as
well arrive at your contract in order `C`, `A`, `B` or any other order.

We recommend using the `requestID` to match randomness requests with their
corresponding fulfillments.

## Choose a safe block confirmation time, which will vary between blockchains

In principle, miners/validators of your underlying blockchain could rewrite
the chain's history to put a randomness request from your contract into a
different block, which would result in a different VRF output. Note that this
does not enable a miner to determine the random value in advance. It only
enables them to get a fresh random value that might or might not be to their
advantage. By way of analogy, they can only re-roll the dice, not predetermine
or predict which side it will land on.

You must choose an appropriate confirmation time for the randomness requests
you make. Confirmation time is how many blocks the VRF service waits before
writing a fulfillment to the chain to make potential rewrite attacks
unprofitable in the context of your application and its value-at-risk.

## Do not re-request randomness

Any re-request of randomness is an incorrect use of VRFv2. Doing so would give
the VRF service provider the option to withhold a VRF fulfillment if the
outcome is not favorable to them and wait for the re-request in the hopes that
they get a better outcome, similar to the considerations with block
confirmation time.

Re-requesting randomness is easily detectable on-chain and should be avoided
for use cases that want to be considered as using VRFv2 correctly.

## Don't accept bids/bets/inputs after you have made a randomness request

Consider the example of a contract that mints a random NFT in response to a
user's actions.

The contract should:

  1. Record whatever actions of the user may affect the generated NFT.
  2. **Stop accepting further user actions that might affect the generated NFT** and issue a randomness request.
  3. On randomness fulfillment, mint the NFT.

Generally speaking, whenever an outcome in your contract depends on some user-
supplied inputs and randomness, the contract should not accept any additional
user-supplied inputs after it submits the randomness request.

Otherwise, the cryptoeconomic security properties may be violated by an
attacker that can rewrite the chain.

## `fulfillRandomWords` must not revert

If your `fulfillRandomWords()` implementation reverts, the VRF service will
not attempt to call it a second time. Make sure your contract logic does not
revert. Consider simply storing the randomness and taking more complex follow-
on actions in separate contract calls made by you, your users, or an
[Automation Node](/chainlink-automation/introduction).

## Use `VRFConsumerBaseV2` in your contract, to interact with the VRF service

If you implement the [subscription method](/vrf/v2/subscription), use
`VRFConsumerBaseV2`. It includes a check to ensure the randomness is fulfilled
by `VRFCoordinatorV2`. For this reason, it is a best practice to inherit from
`VRFConsumerBaseV2`. Similarly, don't override `rawFulfillRandomness`.

## Use `VRFv2WrapperConsumer.sol` in your contract, to interact with the VRF
service

If you implement the [direct funding method](/vrf/v2/direct-funding), use
`VRFv2WrapperConsumer`. It includes a check to ensure the randomness is
fulfilled by the `VRFV2Wrapper`. For this reason, it is a best practice to
inherit from `VRFv2WrapperConsumer`. Similarly, don't override
`rawFulfillRandomWords`.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/security.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the Monte Carlo fallacy?,The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md'},"The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. It is a fallacy because the occurrence of an event is random and independent of past events. An example of the Monte Carlo fallacy is believing that if red has appeared ten times in a row in a game of roulette, the next color is more likely to be black. However, statistically, there is no reason to assume that the next color is more likely to be black. The occurrence of the color is random.
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md,"#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let’s take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.


:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What does VRF stand for in Chainlink VRF?,VRF stands for Verifiable Randomness Function.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-3/course.md'},"VRF stands for Verifiable Random Function in Chainlink VRF.
",https://docs.chain.link/vrf/v2/direct-funding/,"# Direct Funding Method

  * Overview
  * VRF direct funding
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to generate random numbers using the _direct funding_
method. This method doesn't require a subscription and is optimal for one-off
requests for randomness. This method also works best for applications where
your end-users must pay the fees for VRF because the cost of the request is
determined at request time.

## VRF direct funding

Unlike the [subscription method](/vrf/v2/subscription), the direct funding
method does not require you to create subscriptions and pre-fund them.
Instead, you must directly fund consuming contracts with LINK tokens before
they request randomness. Because the consuming contract directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Wrapper (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol).

  2. Your contract must implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling the `requestRandomness` function in the [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) contract. Include the following parameters in your request:

    * `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2/direct-funding/supported-networks/#configurations).
    * `callbackGasLimit`: The maximum amount of gas to pay for completing the callback VRF function.
    * `numWords`: The number of random numbers to request. You can find the maximum number of random values per request for your network in the [Supported networks](/vrf/v2/direct-funding/supported-networks/#configurations) page.

### How VRF processes your request

After you submit your request, it is processed using the Request & Receive
Data cycle:

  1. The consuming contract calls the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `calculateRequestPrice` function to estimate the total transaction cost to fulfill randomness. Learn [how to estimate transaction costs](/vrf/v2/estimating-costs).

  2. The consuming contract calls the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/LinkToken.sol) `transferAndCall` function to pay the wrapper with the calculated request price. This method sends LINK tokens and executes the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `onTokenTransfer` logic.

  3. The VRFV2Wrapper's `onTokenTransfer` logic triggers the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) `requestRandomWords` function to request randomness.

  4. The VRF coordinator emits an event.

  5. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

  6. The VRF coordinator verifies the proof on-chain, then it calls back the wrapper contract's `fulfillRandomWords` function.

  7. Finally, the VRF Wrapper calls back your consuming contract.

## Limits

You can see the configuration for each network on the [Supported
networks](/vrf/v2/direct-funding/supported-networks) page. You can also view
the full configuration for each VRF v2 Wrapper contract directly in Etherscan.
As an example, view the [Ethereum Mainnet VRF v2 Wrapper
contract](https://etherscan.io/address/0x5A861794B927983406fCE1D062e00b9368d97Df6#readContract)
configuration by calling `getConfig` function.

  * Each wrapper has a `maxNumWords` parameter that limits the maximum number of random values you can receive in each request.
  * The maximum allowed `callbackGasLimit` value for your requests is defined in the [Coordinator contract supported networks](/vrf/v2/subscription/supported-networks) page. Because the VRF v2 Wrapper adds an overhead, your `callbackGasLimit` must not exceed `maxGasLimit - wrapperGasOverhead`. Learn more about [estimating costs](/vrf/v2/estimating-costs).

## What's next

  * [› Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/direct-funding/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink VRF API Reference [v1]

  * Overview
  * Index
  * Constructors
  * Functions
  * Constructor
  * Functions
  * requestRandomness
  * fulfillRandomness
  * Reference
  * Maximizing security

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

API reference for
[`VRFConsumerBase`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/VRFConsumerBase.sol).

## Index

### Constructors

| Name        | Description                         |
|:------------|:------------------------------------|
| constructor | Initialize your consuming contract. |
### Functions

| Name              | Description                                                  |
|:------------------|:-------------------------------------------------------------|
| requestRandomness | Make a request to the VRFCoordinator.                        |
| fulfillRandomness | Called by VRFCoordinator when it receives a valid VRF proof. |
## Constructor

Initialize your consuming contract.


    constructor(address _vrfCoordinator, address _link)

  * `_vrfCoordinator`: Address of the Chainlink VRF Coordinator. See [Chainlink VRF Addresses](/vrf/v1/supported-networks) for details.
  * `_link`: Address of the LINK token. See [LINK Token Addresses](/resources/link-token-contracts) for details.

Note: `_seed` has recently been deprecated.

## Functions

### requestRandomness

Make a request to the VRF coordinator.


    function requestRandomness(bytes32 _keyHash, uint256 _fee)
        public returns (bytes32 requestId)

  * `_keyHash`: The public key against which randomness is generated. See [Chainlink VRF supported networks](/vrf/v1/supported-networks) for details.
  * `_fee`: The fee, in LINK, for the request. Specified by the oracle.
  * `RETURN`: The ID unique to a single request.

### fulfillRandomness

Called by VRFCoordinator when it receives a valid VRF proof. Override this
function to act upon the random number generated by Chainlink VRF.


    function fulfillRandomness(bytes32 requestId, uint256 randomness)
        internal virtual;

  * `requestId`: The ID initially returned by `requestRandomness`.
  * `randomness`: The random number generated by Chainlink VRF.

## Reference

### Maximizing security

Chainlink VRF provides powerful security guarantees and is easy to integrate.
However, smart contract security is a nuanced topic. You can read about the
[top security considerations for VRF](/vrf/v1/security).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/api-reference.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is Solidity?,"Solidity is a smart contract programming language created by Ethereum developers to work with Ethereum, the first major smart contract blockchain.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-1/course.md'},"Solidity is a programming language used for writing smart contracts on Ethereum and EVM Chains. It is the most popular language for smart contract development and is specifically designed for that purpose. Solidity is constantly being updated and is the language used for Chainlink smart contracts. It is similar to object-oriented scripting languages like Javascript and Java. Smart contracts written in Solidity can be deployed to the blockchain and executed without intervention from third parties. They can store and manage on-chain assets and connect to real-world market prices using oracles. Solidity contracts are written in .sol files and must include the Solidity version definition at the beginning of the file. The Solidity version used can vary, but the most recent version is 0.8.7. Solidity contracts consist of variables, constructors, functions, and interfaces. Oracles provide a bridge between smart contracts and real-world data, allowing smart contracts to rely on and act upon external data. Chainlink is a popular oracle network that provides data feeds and other capabilities for smart contracts. Remix is a web IDE for creating, running, and debugging smart contracts in the browser, and MetaMask is a browser extension that allows users to create addresses, store funds, and interact with Ethereum-compatible blockchains. 

","
- https://docs.chain.link/getting-started/conceptual-overview/
- https://stackoverflow.com/questions/71709599/chain-link-aggregatorv2v3interface-interface-error","# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-04-01 15:45:32)
Chain link AggregatorV2V3Interface Interface error?
URL: https://stackoverflow.com/questions/71709599/chain-link-aggregatorv2v3interface-interface-error

Question Body:


I'm following a Solidity tutorial that implements Chain Link's
AggregatorV2V3Interface. An error is popping on VSCode 2 while compiling the
code with the `brownie compile` command

Here is the error : [](https://i.stack.imgur.com/18N0C.png)

I'm very new to Solidity and still trying to figure out how that works.



Answers:
(Answered on: 2022-04-04 15:59:58)


Changing the VSCode compiler to `v0.6.6+` and setting FundMe.sol solidity
version to `pragma solidity ^0.6.6;` is what worked for me



"
What are the four types of variable access modifiers in Solidity?,"The four types of variable access modifiers in Solidity are Public, Private, Internal, and External.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-7/course.md'},"The four types of variable access modifiers in Solidity are: Public, Private, Internal, and External.
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-7/course.md,"#####Chapter 7:

# Access Modifiers

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

We can actually give more information to the Solidity compiler on how we want to use our variables (and later functions). We can tell the compiler how we want our variables to be accessed. Many blockchains, such as Ethereum, act as one monolithic computer. While Ethereum is a network of computers distributed around the world, when you deploy code to a blockchain like Ethereum, that code can access any other code anyone has deployed to that blockchain. This is like how programs downloaded to your computer can access other programs on your computer. This allows smart contracts to interact in many unique and interesting ways that regular web application back ends may not be able to do so easily. However, this can also open risks of other code using our code in unintended ways.

To help prevent this we can declare “access modifiers” when declaring our variables, which limit what code on the blockchain can access and change those variables. The four types of variable access modifiers are:


* Public 
    * The variable/function can be accessed or changed by any other code or wallet on the blockchain.
* Private
    * The variable/function can only be accessed or changed within the current contract
* Internal
    * The variable/function can only be accessed or changed within the current contract or any other contract that inherits the current contract (we’ll discuss inheritance in another lesson)
* External
    * The variable/function can only be accessed/changed from outside code or blockchain wallets

To declare the access modifier of a variable we put it inbetween the function type and name like this:

<Highlight class=""language-javascript"">
uint public myFavNum;
</Highlight>

If no access modifier is declared then the variable is automatically assigned the private modifier. For example

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>
 
Is equivalent to 

<Highlight class=""language-javascript"">
uint private myFavNum;
</Highlight>


:::NEXT DOC:::

#####Chapter 11:

# Functions

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

Thus far, we’ve mainly been concerned with storing data in variables and accessing that stored data. But what if we want to manipulate data? That is the realm of **functions**. You can write the logic in a function and have it manipulate data in an infinite number of ways. Solidity and the EVM are called [Turing Complete](https://stackoverflow.com/questions/7284/what-is-turing-complete ""Turing Complete""), which essentially means they can solve any computational problem (although there’s no guarantee that it will complete within a reasonable amount of time). 

You can think of functions as little machines that take in data, run some logic and produce an output. The values that are input into functions are called **arguments**. The logic is put in the **body** of the function. If the function directly returns a value as an output of the function that output is called the **return** value. Finally, just like variables have access modifiers, functions also have **modifiers** (including access modifiers too). Some functions don’t take in any arguments. Some functions just run calculations to change some state variables or make a request to run other code (or to a Chainlink node!) Some functions don’t return a direct value and just run calculations based on storage variables, or make a request to run other code (or send a request to a Chainlink node!) Basically, functions can be customized to do anything.

To define a function, we first type the “function” keyword, define a name for the function and add a pair of parentheses beside the name as such:

<Highlight class=""language-javascript"">
function addNumbers()
</Highlight>

After this is complete you can define **parameters** for the function. Parameters are the name and types of the arguments we can input into the function. They are variables that only that function can access. For this example, we will define two parameters: 

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2)
</Highlight>

Now we can add any modifiers to the function. In this case we’ll simply add public for now:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public
</Highlight>

Now we’ll define what the function returns. Remember a function doesn’t **have** to return anything. In this example we will add the parameters and return the result. Since we are adding two uints, the return value will also have to be a uint:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public returns (uint)
</Highlight>

Finally we’ll create the function body by typing a pair of curly braces and typing our function logic within them:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public returns (uint) {
 answer = num1 + num2;
 return answer;
}
</Highlight>

As you can see the function takes the two parameters, num1 and num2, sums them, stores the sum in a variable called answer, and then returns the value inside the variable answer.

So if we were to call the function, we could store the result in another variable:

<Highlight class=""language-javascript"">
storedAnswer = addNumbers(1,2)
</Highlight>

The variable storedAnswer would then contain the uint 3.

"
What are some important data types in Solidity?,"Some important data types in Solidity are int, uint, string, bool, and address.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-5/course.md'},"Some important data types in Solidity are:
- int: Integers
- uint: Unsigned Integers
- string: Strings
- bool: Booleans
- address: An Account Address
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-5/course.md,"# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 5:

# Contract State, Variables and Data Types

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now you want to connect your artwork to the physical (off-chain) world. Tell your artwork how to behave. 
    </div>
  </div>
</ContentWrapp> -->

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing **variables** and change data by defining logic in **functions**. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time. When defining a variable, you must give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
    * These are phrases that meant to be read. You can store numbers in a string but you can’t do math on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>

This creates a variable called “myFavNum” and assigns it the type uint, or unsigned integer. Now we can use myFavoriteNumber to store numbers like 0,1,2,3,4…etc. in our contract. 
"
Why do customers tend not to read digital agreements?,"Customers tend not to read digital agreements due to lengthy, complex legalese and the fact that these agreements give consumers very little recourse.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-3/course.md'},"Customers tend not to read digital agreements due to their lengthy and complex legalese, as well as the limited recourse they provide for consumers. These agreements are often skewed in favor of the institutions that create them, rather than being fair and equitable for both parties. The power of digital agreements lies heavily with the institutions, and individual consumers may not find it worth the cost to enforce these agreements in court. This lack of understanding and imbalance in power contributes to customers' tendency to not read digital agreements.",,"#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>
"
What do you need to do after completing the contract in order to use the VRFCoordinator?,You need to subscribe your contract to the VRFCoordinator.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-12/course.md'},"After calling the `getRandomNumber()` function, you will need to wait until the `fulfillRandomness()` function is called by the coordinator. You don't need to do anything else, just check the storage variable where you store the number after a minute or two.
","
- https://stackoverflow.com/questions/71765980/how-to-use-chainlink-vrf-v1-in-my-smart-contract
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-9/course.md","Question: (Asked on: 2022-04-06 11:31:30)
How to use chainlink VRF v1 in my smart contract?
URL: https://stackoverflow.com/questions/71765980/how-to-use-chainlink-vrf-v1-in-my-smart-contract

Question Body:


I am trying to use getRandomNumber() function from my VRFConsumer smart
contract to get random numbers. Will I get the random number immediately after
I call this or do I also have to call the fulfillRandomness() function? If
yes, how to do that?



Answers:
(Answered on: 2022-04-06 14:40:50)


After you call the `getRandomNumber()` function you will need to wait until
the `fulfillRandomness()` is called by the coordinator. You don't need to do
anything, just check the storage variable where you store the number (if you
used a storage variable) after a minute or two.





:::NEXT DOC:::

#####Chapter 9: Building a Basic Contract

# The Constructor

Constructors are logic that is run whenever a smart contract is first deployed to a blockchain. We will set the constructor to the following values:

<Highlight class=""language-javascript"">
constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
    LINKTOKEN = LinkTokenInterface(link);
    s_owner = msg.sender;
    s_subscriptionId = subscriptionId;
  }
</Highlight>

Let's break down this constructor. It takes one parameter, subscriptionId, which is the ID of the subscription we will set up in a later chapter. It then passes in the address stored in the vrfCoordinator to the VRFConsumerBaseV2 contract's constructor to set it up. 

The COORDINATOR variable is set to the VRFCoordinatorV2Interface also initialized to the address stored in the vrfCoordinator.

The LINKTOKEN variable is set to LinkTokenInterface that we imported and the interface is initialized with the link token address we specificied earlier.

The s\_owner variable is set to msg.sender which is the address of the wallet account which will deploy the contract.

The s\_subscriptionId is set to subscriptionId which we fed into the constructor as a parameter."
What are the three different ways to throw an error in Solidity?,"The three different ways to throw an error in Solidity are require, revert, and assert.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-6/course.md'},"The three different ways to throw an error in Solidity are **require**, **revert**, and **assert**.
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-6/course.md,"#####Chapter 6:

# Errors

In the previous chapter, we learned about function modifiers. We already used the keyword **require** to check for conditions. If a condition is not met, an error is raised. An error will revert all changes made to the state during a transaction. There are three different ways to throw an error: **require**, **revert** and **assert**.

We use require if we want to validate user input and return values from calls to other functions. The syntax asks for a condition and a custom error message as the second argument. If the condition is not met, an error is raised. Otherwise, the next line will be executed.

<Highlight class=""language-javascript"">
require(x <= 42, ""x must be smaller or equal to 42."");
</Highlight>

**Revert** is used in a similar fashion but directly throws an error without checking a condition. It is useful when the condition check is more complex and you do not want to do it in a single line to improve readability or if several conditions have to be met that you want to check one by one. It will return all remaining gas to the caller. You can call it like this:

<Highlight class=""language-javascript"">
if (x <= 42 && x > 0) {
  revert(""x must be greater than 0 and smaller or equal to 42"");
}
</Highlight>

**Assert** is used for internal logic and checks code that should never be false. If an assertion fails, it’s likely that there is a bug in the contract. We can use asserts to ensure that even if there is a bug, we can simply catch it here and make it more difficult to abuse the bug. For example, it is often used to check for overflow/underflow. The following code shows how can ensure that a is always bigger or equal to b so that we do not run into a situation causing an underflow.

<Highlight class=""language-javascript"">
uint c = a - b 
assert(a >= b);
</Highlight>


:::NEXT DOC:::

Question: (Asked on: 2022-02-03 21:36:48)
Chainlink Quick Start problems connecting to the database?
URL: https://stackoverflow.com/questions/70978628/chainlink-quick-start-problems-connecting-to-the-database

Question Body:


I have gone through the AWS Chainlink quickstart successfully. I disabled the
ssl certificate and decided to use TCP enabled. The Chainlink node did not
launch on intial deployment. I used the .sh files to create .api, .password,
.env

I run the run script but get this error

opening db: failed to open db: failed to connect to `host=/tmp user=
database=`: dial error (dial unix /tmp/.s.PGSQL.5432: connect: no such file or
directory)

I have also gone through the step on the Chainlink docs to enable https
connections, and have configured the tls ports in the .env file.

I thought for sure it was the tls blocking me from the database. But still I
get this error

Here is my
DATABASE_URL=postgresql://user:password@writerendpointofcluster:5432/databasename

I used the writer endpoint of the cluster.

I don't know what to try next. Any help would be much appreciated.



Answers:
(Answered on: 2022-03-26 19:56:05)


In addition to !, * and _ can be used as the symbol requirement for the
database password.

The following characters also lead to an error: <, >, @, =. This is due to
some special characters requiring percent encoding, as discussed on this AWS
Chainlink QuickStart [GitHub issue](https://github.com/aws-
quickstart/quickstart-chainlinklabs-chainlink-
node/issues/23#issuecomment-970486800).


---
(Answered on: 2022-03-18 13:16:31)


The problem was the password for the database. There are certain characters
that throw an error.

The instructions on the AWS Chainlink quickstart on the database password
characters that are prohibited is not an exhaustive list.

In regards to AWS Chainlink quickstart, you can use the ""!"" as the symbol
requirement for the database password.

We are putting together a list of characters that throw an error, so far we
have #, ^, %, $ symbols that prevents you from connecting to the database.

*please comment which symbol gave you an error and I can add it to the list



"
What is the difference between an agreement and a contract?,"Contracts are agreements that are enforceable in a court of law, while agreements are oftentimes informal and not legally binding.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md'},"The difference between an agreement and a contract is that an agreement is a general understanding or arrangement between parties, which can be oral or written, and may not be legally enforceable. On the other hand, a contract is a legally binding agreement between parties that is enforceable in a court of law. Contracts typically have specific terms and conditions, and any breach of those terms can be disputed and discussed within a court. Agreements, on the other hand, may not have the same level of enforceability. 

","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-3/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md","#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>
"
What is Chainlink and what does it allow developers to do?,"Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. It allows developers to create and customize any type of Decentralized Oracle Network (DON) that a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-5/course.md'},"Chainlink is a platform that allows developers to connect smart contracts with real-world data and external APIs. It provides oracles, which are sources of data that smart contracts can rely on and act upon. By using Chainlink, developers can access data feeds, generate verifiable random numbers, call external APIs, and automate smart contract functions. The Chainlink VRF Coordinator is a specific contract that checks the randomness of random numbers returned from a random node. Developers can interact with the VRF Coordinator by putting its address in an interface, allowing them to programmatically call its functions from their smart contracts. 
","
- https://stackoverflow.com/questions/72618842/what-does-vrfcoordinatorv2interfacevrfcoordinator-mean-in-chain-link-documenta
- https://docs.chain.link/getting-started/conceptual-overview/","Question: (Asked on: 2022-06-14 14:35:22)
what does VRFCoordinatorV2Interface(vrfCoordinator) mean in chain link documentation
URL: https://stackoverflow.com/questions/72618842/what-does-vrfcoordinatorv2interfacevrfcoordinator-mean-in-chain-link-documenta

Question Body:


I know that VRFCoordinatorV2Interface is an interface and we put the
respective chain coordinator address in it. what does it signifies and how to
visualise it. OR What will be the outcome when we put an address in a
interface.



Answers:
(Answered on: 2022-06-15 21:30:54)


The Chainlink VRF Coordinator is a contract that is deployed to a blockchain
that will check the randomness of each random number returned from a random
node.

By putting ""its address in an interface"" you can programmatically interact
with it from your smart contract. In other words, the function of your smart
contract can call some other function from the VRF Coordinator function, like
for example `createSubscription()`.





:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are the three contracts being imported in the code?,"LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBaseV2",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-6/course.md'},"The three contracts being imported in the code are:
1. MockV3Aggregator.sol
2. AggregatorV2V3Interface.sol
3. AggregatorInterface.sol
",https://stackoverflow.com/questions/75576539/getting-typeerror-when-trying-to-compile-the-mock-file-imported-from-the-chianl,"Question: (Asked on: 2023-02-27 03:27:06)
Getting TypeError when trying to compile the mock file imported from the @chianlink/contracts
URL: https://stackoverflow.com/questions/75576539/getting-typeerror-when-trying-to-compile-the-mock-file-imported-from-the-chianl

Question Body:


I am getting the type error when I try to compile my mock file

Here's my mock file content

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.0;
    import ""@chainlink/contracts/src/v0.6/tests/MockV3Aggregator.sol"";
    

and this is the error I am getting when I try to compile it

> @chainlink/contracts/src/v0.6/interfaces/AggregatorV2V3Interface.sol:7:38:  
>  TypeError: Interfaces cannot inherit. interface AggregatorV2V3Interface is
> AggregatorInterface, AggregatorV3Interface

My chainlink version `""@chainlink/contracts"": ""^0.3.1""` Version I defined in
the hardhat config

    
    
      solidity: {
        compilers: [
          {version: ""0.8.9""},
          {version: ""0.6.0""},
        ]
      },
    

I think the error is coming from the @chainlink/contracts. Therefore I tried
to reinstall the package but the error remains the same.

I also tried to change the version of the @chainlink/contracts.

Can anyone please tell me what I am doing wrong?



Answers:
(Answered on: 2023-02-27 04:42:52)


The problem is solved. I installed the latest version of @chainlink and also
updated my compiler version. And instead of importing from v6.0. I am
importing from v8.0





:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are functions in Solidity and what do they do?,"Functions in Solidity are little machines that take in data, run some logic and produce an output. They manipulate data and can be customized to do anything.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-11/course.md'},"Functions in Solidity are a key component of smart contract development. They allow the contract to define and execute specific actions or operations. Functions can access and modify the state of the contract, interact with other contracts, and perform computations. They can also have visibility modifiers to define the level of access to the function. Solidity is the most popular language for writing smart contracts, and it is specifically designed for smart contract development. Functions in Solidity are written in Solidity language and are an essential part of the contract's code.

","
- https://docs.soliditylang.org/en/v0.8.7/
- https://docs.chain.link/getting-started/conceptual-overview/","# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature improvements
along with interface and contract changes. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and add your EVM account address to the allow list.

## Supported networks

See the [Supported Networks](/chainlink-functions/supported-networks) page to
find a list of supported networks and contract addresses.

## What's next

  * [› Learn the basics in the Getting Started guide.](/chainlink-functions/getting-started)
  * [› Learn how to use more advanced capabilities in one of the Tutorials.](/chainlink-functions/tutorials)
  * [› Learn about core concepts, the Chainlink Functions architecture, and billing.](/chainlink-functions/resources)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are the two main smart contracts of Chainlink VRF?,The two main smart contracts of Chainlink VRF are the Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2).,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-4/course.md'},"The two main smart contracts of Chainlink VRF are the VRF v2 Wrapper and the VRF v2 Coordinator.
",https://docs.chain.link/vrf/v2/direct-funding/,"# Direct Funding Method

  * Overview
  * VRF direct funding
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to generate random numbers using the _direct funding_
method. This method doesn't require a subscription and is optimal for one-off
requests for randomness. This method also works best for applications where
your end-users must pay the fees for VRF because the cost of the request is
determined at request time.

## VRF direct funding

Unlike the [subscription method](/vrf/v2/subscription), the direct funding
method does not require you to create subscriptions and pre-fund them.
Instead, you must directly fund consuming contracts with LINK tokens before
they request randomness. Because the consuming contract directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Wrapper (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol).

  2. Your contract must implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling the `requestRandomness` function in the [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) contract. Include the following parameters in your request:

    * `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2/direct-funding/supported-networks/#configurations).
    * `callbackGasLimit`: The maximum amount of gas to pay for completing the callback VRF function.
    * `numWords`: The number of random numbers to request. You can find the maximum number of random values per request for your network in the [Supported networks](/vrf/v2/direct-funding/supported-networks/#configurations) page.

### How VRF processes your request

After you submit your request, it is processed using the Request & Receive
Data cycle:

  1. The consuming contract calls the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `calculateRequestPrice` function to estimate the total transaction cost to fulfill randomness. Learn [how to estimate transaction costs](/vrf/v2/estimating-costs).

  2. The consuming contract calls the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/LinkToken.sol) `transferAndCall` function to pay the wrapper with the calculated request price. This method sends LINK tokens and executes the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `onTokenTransfer` logic.

  3. The VRFV2Wrapper's `onTokenTransfer` logic triggers the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) `requestRandomWords` function to request randomness.

  4. The VRF coordinator emits an event.

  5. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

  6. The VRF coordinator verifies the proof on-chain, then it calls back the wrapper contract's `fulfillRandomWords` function.

  7. Finally, the VRF Wrapper calls back your consuming contract.

## Limits

You can see the configuration for each network on the [Supported
networks](/vrf/v2/direct-funding/supported-networks) page. You can also view
the full configuration for each VRF v2 Wrapper contract directly in Etherscan.
As an example, view the [Ethereum Mainnet VRF v2 Wrapper
contract](https://etherscan.io/address/0x5A861794B927983406fCE1D062e00b9368d97Df6#readContract)
configuration by calling `getConfig` function.

  * Each wrapper has a `maxNumWords` parameter that limits the maximum number of random values you can receive in each request.
  * The maximum allowed `callbackGasLimit` value for your requests is defined in the [Coordinator contract supported networks](/vrf/v2/subscription/supported-networks) page. Because the VRF v2 Wrapper adds an overhead, your `callbackGasLimit` must not exceed `maxGasLimit - wrapperGasOverhead`. Learn more about [estimating costs](/vrf/v2/estimating-costs).

## What's next

  * [› Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/direct-funding/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Introduction to Chainlink VRF [v1]

  * Overview
  * Generate Random Numbers in your Smart Contracts
  * On-chain Verification of Randomness

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

## Generate Random Numbers in your Smart Contracts

Chainlink VRF (Verifiable Random Function) is a provably-fair and verifiable
source of randomness designed for smart contracts. Smart contract developers
can use Chainlink VRF as a tamper-proof random number generator (RNG) to build
reliable smart contracts for any applications which rely on unpredictable
outcomes:

  * Blockchain games and NFTs
  * Random assignment of duties and resources (e.g. randomly assigning judges to cases)
  * Choosing a representative sample for consensus mechanisms

Learn how to write smart contracts that consume random numbers: [Get a Random
Number](/vrf/v1/examples/get-a-random-number).

## On-chain Verification of Randomness

Chainlink VRF enables smart contracts to access randomness without
compromising on security or usability. With every new request for randomness,
Chainlink VRF generates a random number and cryptographic proof of how that
number was determined. The proof is published and verified on-chain before it
can be used by any consuming applications. This process ensures that the
results cannot be tampered with nor manipulated by anyone, including oracle
operators, miners, users and even smart contract developers.

Read more about Chainlink VRF in [our announcement
post](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/).

## What's next

  * [› Get a Random Number](/vrf/v1/examples/get-a-random-number)
  * [› API Reference](/vrf/v1/api-reference)
  * [› Supported Networks](/vrf/v1/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the 'keyHash' parameter in Chainlink VRF?,The 'keyHash' parameter in Chainlink VRF functions as an ID of the off-chain VRF job that runs in response to requests.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-7/course.md'},"The 'keyHash' parameter in Chainlink VRF is used to identify the specific key used for generating random numbers. It is a unique identifier that ensures the integrity and security of the random number generation process. Each keyHash corresponds to a specific key that is used by the VRF service to generate random numbers. By including the keyHash in the request, the smart contract can specify which key should be used for generating the random number.

",https://docs.chain.link/vrf/v2/direct-funding/,"# Direct Funding Method

  * Overview
  * VRF direct funding
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to generate random numbers using the _direct funding_
method. This method doesn't require a subscription and is optimal for one-off
requests for randomness. This method also works best for applications where
your end-users must pay the fees for VRF because the cost of the request is
determined at request time.

## VRF direct funding

Unlike the [subscription method](/vrf/v2/subscription), the direct funding
method does not require you to create subscriptions and pre-fund them.
Instead, you must directly fund consuming contracts with LINK tokens before
they request randomness. Because the consuming contract directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Wrapper (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol).

  2. Your contract must implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling the `requestRandomness` function in the [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) contract. Include the following parameters in your request:

    * `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2/direct-funding/supported-networks/#configurations).
    * `callbackGasLimit`: The maximum amount of gas to pay for completing the callback VRF function.
    * `numWords`: The number of random numbers to request. You can find the maximum number of random values per request for your network in the [Supported networks](/vrf/v2/direct-funding/supported-networks/#configurations) page.

### How VRF processes your request

After you submit your request, it is processed using the Request & Receive
Data cycle:

  1. The consuming contract calls the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `calculateRequestPrice` function to estimate the total transaction cost to fulfill randomness. Learn [how to estimate transaction costs](/vrf/v2/estimating-costs).

  2. The consuming contract calls the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/LinkToken.sol) `transferAndCall` function to pay the wrapper with the calculated request price. This method sends LINK tokens and executes the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `onTokenTransfer` logic.

  3. The VRFV2Wrapper's `onTokenTransfer` logic triggers the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) `requestRandomWords` function to request randomness.

  4. The VRF coordinator emits an event.

  5. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

  6. The VRF coordinator verifies the proof on-chain, then it calls back the wrapper contract's `fulfillRandomWords` function.

  7. Finally, the VRF Wrapper calls back your consuming contract.

## Limits

You can see the configuration for each network on the [Supported
networks](/vrf/v2/direct-funding/supported-networks) page. You can also view
the full configuration for each VRF v2 Wrapper contract directly in Etherscan.
As an example, view the [Ethereum Mainnet VRF v2 Wrapper
contract](https://etherscan.io/address/0x5A861794B927983406fCE1D062e00b9368d97Df6#readContract)
configuration by calling `getConfig` function.

  * Each wrapper has a `maxNumWords` parameter that limits the maximum number of random values you can receive in each request.
  * The maximum allowed `callbackGasLimit` value for your requests is defined in the [Coordinator contract supported networks](/vrf/v2/subscription/supported-networks) page. Because the VRF v2 Wrapper adds an overhead, your `callbackGasLimit` must not exceed `maxGasLimit - wrapperGasOverhead`. Learn more about [estimating costs](/vrf/v2/estimating-costs).

## What's next

  * [› Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/direct-funding/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  2. Import the new [`VRFConsumerBaseV2.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  3. Import the [`VRFCoordinatorV2Interface.sol` interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol). This interface includes the new `requestRandomWords` function.

  4. Add a `VRFConsumerBaseV2` constructor as shown in the [Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number) example.

  5. Change `requestRandomness` function calls to `requestRandomWords`. The `requestRandomWords` function requires several additional parameters.

  6. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
give me a sample solidity contract to use Chainlink price feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"The sample Solidity contract to use Chainlink price feeds is provided in the context information under the section ""Examine the sample contract"". The contract is named `PriceConsumerV3` and obtains the latest price answer from the BTC/USD feed on the Sepolia testnet. It uses the `AggregatorV3Interface` interface to define the function `latestRoundData()` for all v3 Aggregators. The contract can be modified to read any of the different types of data feeds.",,"# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
give me a sample solidity contract to use Chainlink VRF?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFD20 is VRFConsumerBaseV2 {

}
uint64 s_subscriptionId;
address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
uint32 callbackGasLimit = 40000;
uint16 requestConfirmations = 3;
uint32 numWords =  1;
)
(
give me a sample solidity contract to request data from a public API in a smart contract using chainlink?,
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req.add(
            ""get"",
            ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {""RAW"":
        //   {""ETH"":
        //    {""USD"":
        //     {
        //      ""VOLUME24HOUR"": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR""); // Chainlink nodes prior to 1.0.0 support this format
        req.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR""); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req.addInt(""times"", timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            ""Unable to transfer""
        );
    }
}",,Two sample Solidity contracts are provided in the context information for using Chainlink VRF: `VRFv2Consumer.sol` and `VRFv2DirectFundingConsumer.sol`.,,"`VRFv2Consumer.sol` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Provider** environment, select the `VRFv2Consumer` contract from the contract list, and specify your `subscriptionId` so the constructor can set it.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must add this address as an approved consuming contract on your subscription account.

  6. Open the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/) and click the ID of your new subscription under the **My Subscriptions** list. The subscription details page opens.

  7. Under the **Consumers** section, click **Add consumer**.

  8. Enter the address of your consuming contract that you just deployed and click **Add consumer**. MetaMask opens and asks you to confirm the transaction.

Your example contract is deployed and approved to use your subscription
balance to pay for VRF v2 requests. Next, request random values from Chainlink
VRF.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF processes your request. Chainlink VRF fulfills the request and returns the random values to your contract in a callback to the `fulfillRandomWords()` function. At this point, a new key `requestId` is added to the mapping `s_requests`.

Depending on current testnet conditions, it might take a few minutes for the
callback to return the requested random values to your contract. You can see a
list of pending requests for your subscription ID at
[vrf.chain.link](https://vrf.chain.link/).

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated: The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` specifying the `requestId` to display the random words.

You deployed a simple contract that can request and receive random values from
Chainlink VRF. To see more advanced examples where the contract can complete
the entire process including subscription setup and management, see the
[Programmatic Subscription](/vrf/v2/subscription/examples/programmatic-subscription) page.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, your MetaMask wallet is the subscription owner and you
created a consuming contract to use that subscription. The consuming contract
uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that relies on a subscription for funding.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    import

:::NEXT DOC:::

in Remix, compile the `VRFv2DirectFundingConsumer` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Web3 Environment** and select the `VRFv2DirectFundingConsumer` contract from the contract list.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must fund your consuming contract with enough LINK tokens in order to request for randomness. Next, fund your contract.

## Fund Your Contract

Requests for randomness will fail unless your consuming contract has enough
LINK.

  1. [Acquire testnet LINK](/resources/acquire-link).
  2. [Fund your contract with testnet LINK](/resources/fund-your-contract). For this example, funding your contract with 2 LINK should be sufficient.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them, and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _400,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _400000_ and select **Save**.
Finally, confirm the transaction.

After you approve the transaction, Chainlink VRF processes your request.
Chainlink VRF fulfills the request and returns the random values to your
contract in a callback to the `fulfillRandomWords()` function. At this point,
a new key `requestId` is added to the mapping `s_requests`. Depending on
current testnet conditions, it might take a few minutes for the callback to
return the requested random values to your contract.

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated. The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` and specify the `requestId` to display the random words.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, the consuming contract uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import"
give me a sample solidity contract to use NFT Floor Price Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}",,"Here is a sample Solidity contract to use NFT Floor Price Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}
```",,"# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) =

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
give me a sample solidity contract to use Proof of Reserve Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}",,"Here is a sample Solidity contract to use Proof of Reserve Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}
```",,"the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page

:::NEXT DOC:::

the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Give sample code for an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"Here is an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet:

```
import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    constructor() {
        priceFeed = AggregatorV3Interface(0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43);
    }

    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```",,"the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    from web3 import Web3
    
    # Change this to use your own RPC URL
    web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
    # AggregatorV3Interface ABI
    abi = '[{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""description"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint80"",""name"":""_roundId"",""type"":""uint80""}],""name"":""getRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""latestRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""version"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""}]'
    # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0 <0.8.0`, use
[OpenZeppelin's SafeMath

:::NEXT DOC:::

/*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct"
Give code examples to demonstrate how to deploy a consumer contract on-chain that reads a data feed and stores the value?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"The code examples for deploying a consumer contract on-chain that reads a data feed and stores the value are provided in the ""Reading data feeds on-chain"" section of the documentation. The examples are given in Solidity and Vyper languages. The Solidity example code imports the `AggregatorV3Interface` interface from the Chainlink contracts and defines a constructor that sets the address of the data feed to be read. The `getLatestPrice()` function is defined to return the latest price from the data feed.",,"# Code Examples

  * Overview
  * Reading data feeds on-chain
  * Solidity
  * Vyper
  * Reading data feeds off-chain
  * Javascript
  * Python
  * Golang
  * Getting a different price denomination
  * More Aggregator Functions

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same. To read a
feed, specify the following variables:

  * **RPC endpoint URL:** This determines which network that your smart contracts will run on. You can use a [node provider service](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) or point to your own [client](https://ethereum.org/en/developers/docs/nodes-and-clients/). If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the [Remix IDE](https://remix-project.org/) will automatically detect them for you.
  * **LINK token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
    

:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete"
Write code to show how to use web3.js to retrieve feed data from a price feed?,"/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
    name: ""getRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""latestRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""version"",
    outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
]
const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log(""Latest Round Data"", roundData)
  })",,"```
/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only

const web3 = new Web3(new Web3.providers.HttpProvider(""https://sepolia.infura.io/v3/YOUR-PROJECT-ID""))

const priceFeedABI = [{""inputs"":[],""name"":""latestAnswer"",""outputs"":[{""internalType"":""int256"",""name"":"""",""type"":""int256""}],""stateMutability"":""view"",""type"":""function""}]
const priceFeedAddress = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""

const priceFeedContract = new web3.eth.Contract(priceFeedABI, priceFeedAddress)

priceFeedContract.methods.latestAnswer().call((error, result) => {
  console.log(result)
})
```",,"On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
   "
What is the LINK token contract on ethereum mainnet?,0x514910771AF9Ca656af840dff83E8264EcF986CA,,"The LINK token contract on Ethereum mainnet has the address 0x514910771AF9Ca656af840dff83E8264EcF986CA, a name of Chainlink Token, a symbol of LINK, and 18 decimals.",,"# LINK Token Contracts

  * Overview
  * Ethereum
  * Ethereum Mainnet
  * Sepolia testnet
  * Goerli testnet
  * BNB Chain
  * BNB Chain mainnet
  * BNB Chain testnet
  * Polygon (Matic)
  * Polygon mainnet
  * Mumbai testnet
  * RSK
  * RSK mainnet
  * Gnosis Chain (xDai)
  * Gnosis Chain mainnet
  * Avalanche
  * Avalanche mainnet
  * Fuji testnet
  * Fantom
  * Fantom mainnet
  * Fantom testnet
  * Arbitrum
  * Arbitrum mainnet
  * Arbitrum Goerli testnet
  * Optimism
  * Optimism mainnet
  * Optimism Goerli testnet
  * Harmony
  * Harmony mainnet
  * Moonriver
  * Moonriver mainnet
  * Moonbeam
  * Moonbeam mainnet
  * Metis
  * Andromeda mainnet
  * BASE
  * BASE Goerli testnet

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=Contracts) to talk to an expert
about the networks that support the LINK token.

LINK tokens are used to pay node operators for retrieving data for smart
contracts and also for deposits placed by node operators as required by
contract creators. The smallest denomination of LINK is called a Juel, and
1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to
Wei, which is the [smallest denomination of
ETH](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations).

The LINK token is an ERC677 token that inherits functionality from the ERC20
token standard and allows token transfers to contain a data payload. Read more
about the [ERC677 transferAndCall token
standard](https://github.com/ethereum/EIPs/issues/677).

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

## Ethereum

### Ethereum Mainnet

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1                                          |
| Address        | 0x514910771AF9Ca656af840dff83E8264EcF986CA |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | ethstats.dev                               |
### Sepolia testnet

Testnet LINK and ETH are available at
[faucets.chain.link](https://faucets.chain.link/sepolia). Testnet ETH is also
available from several public

:::NEXT DOC:::

and
LINK from Ethereum Mainnet to Metis mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1088                                       |
| Address        | 0x79892E8A3Aea66C8F6893fa49eC6208ef07EC046 |
| Name           | Chainlink Token on Metis Mainnet           |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | andromeda-explorer.metis.io                |
## BASE

### BASE Goerli testnet

Testnet ETH is used to pay for transactions on BASE. Testnet ETH is available
from one of the [BASE Network Faucets](https://docs.base.org/tools/network-faucets). Alternatively, you can get testnet ETH from the faucets listed at
[faucetlink.to/goerli](https://faucetlink.to/goerli) and use the [BASE
Bridge](https://bridge.base.org/deposit) to transfer testnet ETH from Ethereum
Goerli to BASE Goerli.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 84531                                      |
| Address        | 0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3 |
| Name           | Chainlink Token on the BASE Goerli testnet |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | goerli.basescan.org                        |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/link-token-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the chainlink price feed address for 1INCH / ETH?,0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8,,The chainlink price feed address for 1INCH / ETH is 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8.,,"        |
|:---------------------------------------|:---------------------------------------------------------|:---------------|:------------|:------------|------:|:-------------------------------------------|
| 🟢1INCH / ETH                          | 1inch                                                    | Crypto         | 2%          | 86400s      |    18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8 |
| 🟢1INCH / USD                          | 1inch                                                    | Crypto         | 1%          | 86400s      |     8 | 0xc929ad75B72593967DE83E7F7Cda0493458261D9 |
| 🟢AAPL / USD                           | Apple                                                    | Equities       | 0.5%        | 86400s      |     8 | 0x139C8512Cde1778e9b9a8e721ce1aEbd4dD43587 |
| 🟢AAVE / ETH                           | Aave                                                     | Crypto         | 2%          | 86400s      |    18 | 0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012 |
| 🟢AAVE / USD                           | Aave                                                     | Crypto         | 1%          | 3600s       |     8 | 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 |
| 🟢ADA / USD                            | Cardano                                                  | Crypto         | 1%          | 86400s      |     8 | 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55 |
| 🟢ADX / USD                

:::NEXT DOC:::

                              | Crypto         | 1%          | 86400s      |     8 | 0x10a43289895eAff840E8d45995BBa89f9115ECEe |
| 🟢ERN / USD                            | Ethernity Chain                                          | Crypto         | 2%          | 86400s      |     8 | 0x0a87e12689374A4EF49729582B474a1013cceBf8 |
| 🟢ETH / BTC                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0xAc559F25B1619171CbC396a50854A3240b6A4e99 |
| 🟢ETH / USD                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 |
| 🟢EUR / USD                            | Euro                                                     | Forex          | 0.15%       | 86400s      |     8 | 0xb49f677943BC038e9857d61E7d053CaA2C1734C1 |
| 🟢EURT / USD                           | Tether Euro                                              | Crypto         | 2%          | 86400s      |     8 | 0x01D391A48f4F7339aC64CA2c83a07C22F95F587a |
| 🟢FARM / ETH                           | Harvest Finance                                          | Crypto         | 2%          | 86400s      |    18 |"
What is the proof of reserve address for CacheGold PoR USD on Goerli Testnet?,Not provided in the context,,There is no information provided about the proof of reserve address for CacheGold PoR USD on Goerli Testnet.,,"                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES        

:::NEXT DOC:::

Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                        "
What is the rate and Volatility Feed Address for 30-Day ETH APR?,0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29,,The rate and volatility feed address for 30-Day ETH APR is 0x8e604308BD61d975bc6aE7903747785Db7dE97e2.,,"# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is

:::NEXT DOC:::

nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2 |
| ETH-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 | 0xd599cEF88Bbd27F1392A544bD0F343ec8893124C |
| LINK-USD 7-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x03121C1a9e6b88f56b27aF5cc065ee1FaF3CB4A9 |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net?,0x352f2Bc3039429fC2fe62004a1575aE74001CfcE,,The NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net is 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE.,,"  |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
|

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |"
