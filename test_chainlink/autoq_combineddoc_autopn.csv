question,answer,metadata,result,retrieved_docs
What is the purpose of hosting encrypted secrets on AWS S3 in this tutorial?,To replace the default off-chain option and securely store the secrets.,{'source': 'https://docs.chain.link/chainlink-functions/tutorials/api-use-secrets-offchain/'},"The purpose of hosting encrypted secrets on AWS S3 in this tutorial is to share the secrets off-chain with a Decentralized Oracle Network (DON) using another storage platform such as AWS S3, Google Drive, IPFS, or any other service where the DON can fetch secrets via HTTP.","# Using Off-chain Secrets in Requests

  * Overview
  * Before you begin
  * Tutorial
  * Build Off-chain Secrets
  * Simulation
  * Request
  * Explanation
  * FunctionsConsumer.sol
  * config.js
  * source.js

As explained in the [Using Secrets in Requests guide](/chainlink-functions/tutorials/api-use-secrets), the Chainlink Functions starter kit
shares encrypted secrets off-chain with a Decentralized Oracle Network (DON)
using [gists](https://docs.github.com/en/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists). This tutorial
shows you how to share encrypted secrets off-chain with a Decentralized Oracle
Network (DON) using another storage platform such as AWS S3, Google Drive,
IPFS, or any other service where the DON can fetch secrets via HTTP.

Read the [API multiple calls](/chainlink-functions/tutorials/api-multiple-calls) tutorial before you follow the steps in this example. This tutorial
uses the same example, but with a slightly different process:

  1. Instead of relying on the default off-chain option(gists), you will host your encrypted secrets on AWS S3.
  2. Include the encrypted secrets in an `offchain-secrets.json` file.
  3. Host the secrets file off-chain (AWS S3).
  4. Include the HTTP URL to the file in your Chainlink Functions request.

The `functions-build-offchain-secrets` task encrypts the secrets and creates
the secrets file for you. For reference, you can find the public key for the
DON by running the `getDONPublicKey` function on the [Functions Oracle Proxy
contract](https://mumbai.polygonscan.com/address/0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4#readProxyContract#F5).
See the [Supported Networks](https://docs.chain.link/chainlink-functions/supported-networks#contract-addresses) page to find the Functions
Oracle Proxy contract for each supported network.

caution

Chainlink Functions is still in BETA. Please utilize credentials that are
assigned for your testing purposes only and that do not secure sensitive data
or real value. The use of secrets in your requests is an experimental feature
that may not operate as expected and is subject to change. Use of this feature
is at your own risk and may result in unexpected errors, possible revealing of
the secret as new versions are released, or other issues.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure to understand the [API multiple calls](/chainlink-functions/tutorials/api-multiple-calls) guide.

  3. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  4. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/7-offchain-secrets_

:::NEXT DOC:::

2. Make sure to understand the [API multiple calls](/chainlink-functions/tutorials/api-multiple-calls) guide.

  3. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  4. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/7-offchain-secrets_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/7-offchain-secrets).
    
        git checkout tutorials

  5. Get a free API key from [CoinMarketCap](https://coinmarketcap.com/api/).

  6. Run `npx env-enc set` to add an encrypted `COINMARKETCAP_API_KEY` to your `.env.enc` file.
    
        npx env-enc set

  7. Prepare the store for your encrypted secrets file.

    1. Create a [AWS free tier account](https://aws.amazon.com/free/).
    2. Follow [these steps](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html) to create a AWS S3 bucket. Choose a name for your bucket, set _ACLs enabled_ , and turn off _Block all public access_.

## Tutorial

Set up your environment variables

This tutorial has some unique `.env.enc` setup steps. Make sure that you
configured your `.env.enc` file with the necessary variables in the Before you
begin section.

This tutorial is configured to get the median `BTC/USD` price from multiple
data sources. For a detailed explanation of the code example, read the
Explanation section.

  * Open `config.js`. Note the `args` value is `[""1"", ""bitcoin"", ""btc-bitcoin""]`. These arguments are BTC IDs at CoinMarketCap, CoinGecko, and Coinpaprika. You can adapt `args` to fetch other asset prices. See the API docs for [CoinMarketCap](https://coinmarketcap.com/api/documentation/v1/), [CoinGecko](https://www.coingecko.com/en/api/documentation), and [CoinPaprika](https://api.coinpaprika.com/) for details. For more information about the request, read the request config section.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation of the request source file.

### Build Off-chain Secrets

Before you make a request, prepare the secrets file and host it off-chain:

  1. Encrypt the secrets with the public key of the DON and store them in the `offchain-secrets.json` file. The `--network` flag is required because each network has a unique DON with a different public key.
    
        npx hardhat functions-build-offchain-secrets --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:

    
        $ npx hardhat functions-build-offchain-secrets --network polygonMumbai --configpath tutorials/7-offchain-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    Using public keys from FunctionsOracle contract 0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4 on network mumbai
 "
What was the error message received when running the run script?,opening db: failed to open db: failed to connect to `host=/tmp user=database=`: dial error (dial unix /tmp/.s.PGSQL.5432: connect: no such file or directory),{'source': 'https://stackoverflow.com/questions/70978628/chainlink-quick-start-problems-connecting-to-the-database'},"For the first context, the error message received when running the run script was ""invalid BigNumber value (argument=""value"", value=[""ETH"",""USD""], code=INVALID_ARGUMENT, version=bignumber/5.7.0)"". 

For the second context, the error message received when running the run script was ""IndexError: list index out of range"".","       at resolveAddresses (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\contracts\lib\index.js:119:12)
        at C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\contracts\src.ts\index.ts:150:20    at Array.map (<anonymous>)
    PS C:\Users\Coding\vscode\x-functions-hardhat> npx hardhat run scripts/request.js --network polygonMumbai     
    secp256k1 unavailable, reverting to browser version
    

I can bypass this error by placing 420 into an array `[420]` but I then
receive this error:

    
    
    PS C:\Users\Coding\vscode\x-functions-hardhat> npx hardhat run scripts/request.js --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    
    C:\Users\Coding\vscode\donateassist-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:269
            const error: any = new Error(message);
                               ^
    Error: invalid BigNumber value (argument=""value"", value=[""ETH"",""USD""], code=INVALID_ARGUMENT, version=bignumber/5.7.0)
        at Logger.makeError (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:269:28)
        at Logger.throwError (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:281:20)
        at Logger.throwArgumentError (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:285:21)
        at Function.BigNumber.from (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\bignumber\src.ts\bignumber.ts:289:23)
        at NumberCoder.encode (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\abi\src.ts\coders\number.ts:25:27)
        at C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\abi\src.ts\coders\array.ts:71:19
        at Array.forEach (<anonymous>)
        at pack (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\abi\src.ts\coders\array.ts:54:12)     
        at TupleCoder.encode (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\abi\src.ts\coders\tuple.ts:54:20)
        at AbiCoder.encode (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\abi\src.ts\abi-coder.ts:111:15)
  

:::NEXT DOC:::

Question: (Asked on: 2022-04-27 06:50:03)
brownie local testing with ganache fails
URL: https://stackoverflow.com/questions/72024436/brownie-local-testing-with-ganache-fails

Question Body:


Following the steps taken in the bootcamp day2 video on testing solidity
contracts with brownie, I stumbled upon an error when testing the chainlink-
mix scripts locally.

Here are the steps are taken to introduce the error:

  1. execute brownie compile
  2. execute genache-cli in separate terminal
  3. execute brownie run scripts/price_feed_scripts/01_deploy_price_consumer_v3.py
  4. brownie run scripts/price_feed_scripts/02_read_price_feed.py

ganache is selected as the default network and the server is listening on the
ip/port 127.0.0.1:8545.

    
    
    brownie run scripts/price_feed_scripts/02_read_price_feed.py
    Brownie v1.18.1 - Python development framework for Ethereum
    
    ChainlinkMixProject is the active project.
    /usr/local/lib/python3.9/site-packages/brownie/network/main.py:44: BrownieEnvironmentWarning: Development network has a block height of 14
      warnings.warn(
    Attached to local RPC client listening at '127.0.0.1:8545'...
    
    Running 'scripts/price_feed_scripts/02_read_price_feed.py::main'...
    <brownie.network.contract.ContractContainer object at 0x10e410dc0>
      File ""brownie/_cli/run.py"", line 51, in main
        return_value, frame = run(
      File ""brownie/project/scripts.py"", line 103, in run
    return_value = f_locals[method_name](*args, **kwargs)
      File ""./scripts/price_feed_scripts/02_read_price_feed.py"", line 7, in main
        price_feed_contract = PriceFeedConsumer[-1]
      File ""brownie/network/contract.py"", line 175, in __getitem__
        return self._contracts[i]
    IndexError: list index out of range
    

ganache is set as default network in the brownie-config.yaml



Answers:
(Answered on: 2022-05-02 14:35:39)


Brownie doesn't save the location of deployed contracts to a local running
chain by default since they get deleted so often and would take up a ton of
space, so you have to tell brownie to remember stuff deployed to ganache.

In your `brownie-config.yaml` add

    
    
    dev_deployment_artifacts: true
    

And rerun your scripts



"
What is the Monte Carlo fallacy?,The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md'},The Monte Carlo fallacy describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,"#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let‚Äôs take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it‚Äôs more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.


:::NEXT DOC:::

Computers are deterministic machines. Per definition, they cannot produce randomness without any external inputs.
"
What was the error message received while executing the 'setAuthorizedSenders' method from remix?,Gas estimation errored with the following message (see below). The transaction execution will likely fail. Do you want to force sending? execution reverted: Cannot set authorized senders,{'source': 'https://stackoverflow.com/questions/75301080/unable-to-transact-operator-setauthorizedsenders-on-chainlink-goerli'},"The error message received while executing the 'setAuthorizedSenders' method from remix was ""execution reverted: Cannot set authorized senders"".","Question: (Asked on: 2023-01-31 17:44:37)
Unable to transact Operator.setAuthorizedSenders on Chainlink - Goerli
URL: https://stackoverflow.com/questions/75301080/unable-to-transact-operator-setauthorizedsenders-on-chainlink-goerli

Question Body:


Completed the local node setup on ubuntu 20.04, and the chainlink node is up
and running. Deployed the Operator.sol, while executing the
'setAuthorizedSenders' method from remix getting following error:

> Gas estimation errored with the following message (see below). The
> transaction execution will likely fail. Do you want to force sending?
> execution reverted: Cannot set authorized senders { ""originalError"": {
> ""code"": 3, ""data"":
> ""0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001d43616e6e6f742073657420617574686f72697a65642073656e64657273000000"",
> ""message"": ""execution reverted: Cannot set authorized senders"" } }



Answers:
(Answered on: 2023-02-01 06:55:44)


It is my mistake. Sent the node address as the admin address for owner during
the contract deployment. It is working as expected.





:::NEXT DOC:::

# Receiver

  * Overview
  * API Reference
  * Methods
  * Events

[AuthorizedReceiver](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/AuthorizedReceiver.sol)
is an abstract contract inherited by [operator](/chainlink-nodes/contracts/operator) and [forwarder](/chainlink-nodes/contracts/forwarder) contracts.

note

Calling setAuthorizedSenders has a different effect depending if it is called
from an [operator](/chainlink-nodes/contracts/operator) or a
[forwarder](/chainlink-nodes/contracts/forwarder) contract:

  * Owners of forwarder contracts allow authorized senders to call [forward](/chainlink-nodes/contracts/forwarder#forward).
  * Owners of operator contracts allow authorized senders to call the [fulfillOracleRequest](/chainlink-nodes/contracts/operator#fulfilloraclerequest) and [fulfillOracleRequest2](/chainlink-nodes/contracts/operator#fulfilloraclerequest2) methods.

## API Reference

### Methods

#### setAuthorizedSenders


    function setAuthorizedSenders(address[] senders) external

Sets the fulfillment permission for a given node. Use `true` to allow, `false`
to disallow. Emits an AuthorizedSendersChanged event.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| senders | address[] | The addresses of the authorized Chainlink node |
#### getAuthorizedSenders


    function getAuthorizedSenders() external view returns (address[])

Retrieve a list of authorized senders.

##### Return values

|   Name | Type      | Description        |
|-------:|:----------|:-------------------|
|    nan | address[] | array of addresses |
#### isAuthorizedSender


    function isAuthorizedSender(address sender) public view returns (bool)

Use this to check if a node is authorized to fulfill requests.

##### Parameters

| Name   | Type    | Description                       |
|:-------|:--------|:----------------------------------|
| sender | address | The address of the Chainlink node |
##### Return values

|   Name | Type   | Description                          |
|-------:|:-------|:-------------------------------------|
|    nan | bool   | The authorization status of the node |
### Events

#### AuthorizedSendersChanged


    event AuthorizedSendersChanged(address[] senders, address changedBy)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/contracts/receiver.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the VRFv2SubscriptionManager contract?,The purpose of the VRFv2SubscriptionManager contract is to manage subscriptions for the Chainlink Verifiable Random Function (VRF) service.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-9/solution.md'},"The purpose of the VRFv2SubscriptionManager contract is to create and manage a subscription contract for the Chainlink VRF v2, allowing for the creation of random values and the management of consumers and funding.","#####Chapter 5: VRF Subscriptions

# Subscription Manager Contract

Now that we learned more about the theoretical background, let‚Äôs get practical. We want to create and manage a subscription contract. We will use the example contract that you can find here on [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js). It shows an example implementation of a VRF v2 Subscription manager for the Goerli network. But you can also adjust it to work with other networks by changing the code's hardcoded addresses. You can find a complete list of available networks [here](https://docs.chain.link/docs/vrf-contracts/#configurations).

Hint: This course assumes you are already familiar with the Architecture of Chainlink VRF from [VRFv2 Introduction Chapter 4](https://www.chainlink.education/vrfIntroduction/chapter-4).

Generally, consumer contracts must implement the requestRandomWords() function providing coordinator parameters and subscription ID. This function is used to create random values. A second function, fulfillRandomWords(), must be implemented to receive the random values. Learn about how to implement the basics of such a contract in [chapters 6-12](https://www.chainlink.education/vrfIntroduction/chapter-6) from the introduction course.

We want to focus on the mentioned functions here and show how to manage subscriptions in this contract. So let‚Äôs start by creating a new subscription:

<Highlight class=""language-javascript"">
uint64 public s_subscriptionId;
 function createNewSubscription() private onlyOwner {
   s_subscriptionId = COORDINATOR.createSubscription();
   COORDINATOR.addConsumer(s_subscriptionId, address(this));
 }
</Highlight>

We shall call this function when the contract is initially deployed using the constructor. The COORDINATOR is set to the COORDINATOR address in your network of choice. It is used to call the createSubscription() function. This returns an ID which is then used to add a new consumer using the same COORDINATOR contract. That‚Äôs already all you need to create a subscription and add a consumer. Now we can expand this and add or remove consumers using the corresponding functions (addConsumer, removeConsumer) to generate random numbers.

<Highlight class=""language-javascript"">
 function addConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
 }
 
 function removeConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
 }
</Highlight>

This was pretty straight forward. Before we implement the mandatory functions mentioned in the beginning, we will also add a function to topup the subscription with LINK tokens. That means we pre-fund the subscription so it can then be used to request random numbers without paying again, like in VRF v1.

<Highlight class=""language-javascript"">
 function topUpSubscription(uint256 amount) external onlyOwner {
   LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subscriptionId));
 }
</Highlight>

We assume that the contract itself has Link that we can use here. LINKTOKEN is the Link token contract. Now that we have the ability to manage consumers and funding, we will implement a simple function to request random words and received a request ID that we can use to get the random words. If the subscription is not set and funded it will revert. Note that the request might take several minutes to process.

<Highlight

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  uint256[] public s_randomWords;
  uint256 public s_requestId;
  address s_owner;"
What is the correct way to mock a response using the _fulfillOracleRequest_ function in the MockOracle contract?,"The _fulfillOracleRequest_ function takes a bytes32 param for the response, so you need to encode it properly. This is how you can mock a response as part of the APIConsumer Unit Test: let mockResponse = '777'; const responseBytes = ethers.utils.formatBytes32String(mockResponse); const r = await mockOracle.fulfillOracleRequest(requestId, responseBytes);",{'source': 'https://stackoverflow.com/questions/70405858/how-to-mock-chainlink-oracle-api-responses-on-hardhat'},"The correct way to mock a response using the _fulfillOracleRequest_ function in the MockOracle contract is to properly encode the response as a bytes32 parameter using the `ethers.utils.formatBytes32String()` function. For example, to mock a response of ""777"", you would first define `let mockResponse = '777'`, then encode it as bytes32 using `const responseBytes = ethers.utils.formatBytes32String(mockResponse)`, and finally pass it as a parameter to the _fulfillOracleRequest_ function along with the requestId.","Question: (Asked on: 2021-12-18 18:10:26)
How to mock Chainlink/oracle API responses on hardhat
URL: https://stackoverflow.com/questions/70405858/how-to-mock-chainlink-oracle-api-responses-on-hardhat

Question Body:


On the hardhat starter kit, the unit test checks if you can make an api
request. But it doesn't actually fulfill the request. In the tasks, it
requests volume data but it isn't shown how to fulfill the request.

From looking at the code for the mockOracle I found this function.

    
    
    const r = await mockOracle.fulfillOracleRequest(requestId, data)
    

I dont have any idea how to make the data be what I want it to be. For example
when I pass the following data it returns the huge seamingly random number
24516769870864860957297836120308737325622166553046088662895407649136392011776.

    
    
    const data = ethers.utils.formatBytes32String(""64"")
    

How do I mock the api response with the data I pass to fulfillOracleRequest?
Also, because I couldn't find any examples of this in the chainlink starter
kit, is this even the right way to be doing this on the local hardhat network?



Answers:
(Answered on: 2021-12-20 01:22:18)


The _fulfillOracleRequest_ function in the [MockOracle
contract](https://github.com/smartcontractkit/hardhat-starter-
kit/blob/main/contracts/test/MockOracle.sol) takes a bytes32 param for the
response, so you need to encode it properly. This is how you can mock a
response as part of the [APIConsumer Unit
Test](https://github.com/smartcontractkit/hardhat-starter-
kit/blob/main/test/unit/APIConsumer_unit_test.js):

    
    
    let mockResponse = '777'
    const responseBytes = ethers.utils.formatBytes32String(mockResponse)
    const r = await mockOracle.fulfillOracleRequest(requestId, responseBytes)
    

To answer your second question, yes this is the correct thing to do when
working with local chains that aren't integrated to Chainlink oracles. There
is actually an [open issue](https://github.com/smartcontractkit/hardhat-
starter-kit/issues/67) to implement these for the unit tests. Feel free to
take it on if you want!





:::NEXT DOC:::

   
        const filter = mockOracle.filters.OracleRequest()
        const events = await mockOracle.queryFilter(filter)
        const {specId, requester, requestIdEvent, payment, callbackAddr, callbackFunctionId, cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
    
        const encodeRequestId = web3.eth.abi.encodeParameters(
            ['bytes32'],
            [requestId])
            
        await mockOracle.connect(mockNode).fulfillOracleRequest2(requestIdfirst, payment, callbackAddr, callbackFunctionId, cancelExpiration, encodeMwr)

To improve on this you could then look to add an API http GET call into your
test script for getting the rest of the callback data for fulfillOracleRequest
or fulfillOracleRequest2 function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I am guessing you are currently using the `oracle.sol` and
`ChainlinkClient.sol` in version v0.6. In version v0.6, AFAIK, ChainlinkClient
doesn't not help users to add function selector `oracleRequest` in the users'
Chainlink request, which means you will get the error if you doesn't manually
add the function selector in your request. In v0.7, ChainlinkClient helps you
add the selector in the request. Just check the function
`sendChainlinkRequestTo` in [ChainlinkClient
v0.6](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/ChainlinkClient.sol)
and [ChainlinkClient
v0.7](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/ChainlinkClient.sol)
by yourself.

Solutions:

  1. Use the v0.7 ChainlinkClient and [operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)(smart contract oracle.sol is renamed as operator.sol in v0.7) for your test. The document can be found [here](https://docs.chain.link/any-api/get-request/examples/single-word-response).
  2. There is a repo called [hardhat-starter-kit](https://github.com/smartcontractkit/hardhat-starter-kit) in Chainlink official github, there are sample codes you can try. Or you can directly use starterkit to test AnyApi and any other services.



"
What are events in Solidity and how can they be used?,Events in Solidity are a way to emit events that clients can listen to and react accordingly. They can also be used as a cheap form of storage. Events are write-only and cannot be read. They can be used to create an audit trail and communicate easy-to-access messages to listeners. Libraries like ethers.js allow us to listen to these events and react accordingly.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-7/course.md'},"Events in Solidity are a way to emit events that clients can listen to and react accordingly. They can be used as a cheap form of storage and are less expensive than using a storage location. However, events are write-only and cannot be read by the EVM. They can be used to communicate easy-to-access messages to listeners and create an audit trail. They are often used to communicate that a new token was minted.","#####Chapter 7:

# Events

When learning a new language, we often write a hello world program and log a string to the console. Solidity does not offer a console.log but has events that can be used in a similar fashion. You can use it to emit events that clients can listen to react accordingly. They can also be used as a cheap form of storage as it is less expensive to emit an event than to use the storage location (see chapter 2). But note that events are write-only. EVM does not allow to read events.

Let‚Äôs learn how we can use events in Solidity:

<Highlight class=""language-javascript"">
contract Event {
 event Log(address indexed sender, string message);
 
 function foo() public {
       emit Log(msg.sender, ""Hello World!"");
       emit Log(msg.sender, ""Another message"");
 }
}
</Highlight>

On the top we have defined a name of the Event and defined it‚Äôs parameters. You can see here that we have indexed and not index parameters. Indexed parameters are called ‚Äútopics‚Äù and are searchable parameters in events. We will explain why this is useful in a moment.

We can now use the keyword **emit** followed by the event name **Log** to emit an event of the type Log. These events can be read on an explorer like Etherscan. And there you will see that each event has the address of the contract or account the event is emitted from and Topics which is the indexed parameter of the event and the data itself. These are ABI-Encoded or hashed non-indexed parameters of the event. More on ABI in a future course.
Libraries like ethers.js allow us to listen to these events and react accordingly. The great thing about events is that applications not interested in writing or interacting with the blockchain can still react to events emitted from smart contracts. In other terms, you could consider events a simple way to communicate easy-to-access messages to listeners. You can either listen to them in real-time as they are written to a new block or also retrieve historical events from the past. It makes it easy to create an audit trail this way. You will often see events used to communicate that a new token was minted.


:::NEXT DOC:::

Solidity does not offer a console.log but has events that can be used in a similar fashion. You can use it to emit events that clients can listen to react accordingly. They can also be used as a cheap form of storage as it is less expensive to emit an event than to use the storage location. But note that events are write-only. EVM does not allow to read events.
"
What is an array in programming?,An array is many related pieces of data stored together in a single variable.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-8/course.md'},"An array in programming is a variable that stores many related pieces of data together in a single variable. It can only store one type of data, but can have multiple values of that type stored within it.","#####Chapter 8:

# Creating Arrays

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of ‚ÄúHybrid Smart Contracts‚Äù. 
    </div>
  </div>
</ContentWrapp> -->

It is common in programming to want to store many associated values together. For instance I may want to store the title of every book I own. We could put each book title in it‚Äôs own variable of type string, but it would be difficult to access all those variables at once, and keep track of each variable when I need to read this information. So instead we can store the book titles in an **array** of type string. What is an array? It‚Äôs many related pieces of data stored together in a single variable!

Just like regular variables arrays can only store one type of data, but can have multiple values of that type stored within it. To declare a variable as an array, we put square brackets next to the type of the variable. For example:

<Highlight class=""language-javascript"">
string[] myBooks;
</Highlight>

Creates a variable called ‚ÄúmyBooks‚Äù which is an array of strings.

You can then assign multiple values to the array by using the assignment operator. The difference from a regular variable assignment is that on the right side of the assignment operator you put the values you want in-between square brackets and separate each value by a comma for example:
<Highlight class=""language-javascript"">
string[] myBooks = [ ‚ÄúMastering Ethereum‚Äù, ‚ÄúProgramming Rust‚Äù, ‚ÄúZombie Survival Guide‚Äù]
</Highlight>

Or 

<Highlight class=""language-javascript"">
uint[] numbers;
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
</Highlight>

You can limit the amount of values that can go into the array by putting a number in the brackets by the array type when you declare it. For example:

<Highlight class=""language-javascript"">
uint[6] numbers;
</Highlight>

Limits the amount of values that can fit into the array called ‚Äúnumbers‚Äù to a max of 6 values.



:::NEXT DOC:::

#####Chapter 9:

# Reading Array Values

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of ‚ÄúHybrid Smart Contracts‚Äù. 
    </div>
  </div>
</ContentWrapp> -->

Now that we can store multiple related values into a single array our lives organizing our data should be much easier! But how do we access those stored values later? Data stored in arrays is associated with an index which describes the order of the data. Indexing in Solidity starts at 0. So this means the first values assigned to an array has the index of 0, the second value assigned to the array has an index of 1, the third value an index of 2 and so on.

You can access the values in an array by calling the array variable and putting the index of the value you want to access within square brackets. For example:

<Highlight class=""language-javascript"">
string[] myBooks = [ ‚ÄúMastering Ethereum‚Äù, ‚ÄúProgramming Rust‚Äù, ‚ÄúZombie Survival Guide‚Äù]
</Highlight>

And then

myBooks[0] will access the first value assigned to the myBooks array (since Solidity indexes at 0) which will be the value ‚ÄúMastering Ethereum‚Äù.

As another example I could take a value in an array and also assign it to another variable:

<Highlight class=""language-javascript"">
string myFirstBook = myBooks[0];
</Highlight>

Which will take the value indexed at zero in the ‚ÄúmyBooks‚Äù array (which is ‚ÄúMastering Ethereum‚Äù) and assign it to the string named ‚ÄúmyFirstBook‚Äù. This won‚Äôt erase it from the myBooks array but make a copy and assign to the new ‚ÄúmyFirstBook‚Äù variable.

"
What is the cryptocurrency symbol for Cardano?,ADA,{'source': 'https://docs.chain.link/data-feeds/price-feeds/addresses/'},The cryptocurrency symbol for Cardano is ADA.,"|
| üü¢ADA / USD                            | Cardano                                                  | Crypto         | 1%          | 86400s      |     8 | 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55 |
| üü¢ADX / USD                            | Adex                                                     | Crypto         | 2%          | 86400s      |     8 | 0x231e764B44b2C1b7Ca171fa8021A24ed520Cde10 |
| üü¢ALCX / ETH                           | Alchemix                                                 | Crypto         | 2%          | 86400s      |    18 | 0x194a9AaF2e0b67c35915cD01101585A33Fe25CAa |
| üü¢ALCX / USD                           | Alchemix                                                 | Crypto         | 2%          | 86400s      |     8 | 0xc355e4C0B3ff4Ed0B49EaACD55FE29B311f42976 |
| üü¢ALPHA / ETH                          | Alpha Finance                                            | Crypto         | 2%          | 86400s      |    18 | 0x89c7926c7c15fD5BFDB1edcFf7E7fC8283B578F6 |
| üü¢AMPL / ETH                           | Ampleforth                                               | Crypto         | 2%          | 86400s      |    18 | 0x492575FDD11a0fCf2C6C719867890a7648d526eB |
| üü°AMPL / USD                           | Ampleforth                                  

:::NEXT DOC:::

| 0x9a72298ae3886221820B1c878d12D872087D3a23 |
| üü¢OMG / ETH                            | Omisego                                                  | Crypto         | 2%          | 86400s      |    18 | 0x57C9aB3e56EE4a83752c181f241120a3DBba06a1 |
| üü¢OMG / USD                            | Omisego                                                  | Crypto         | 2%          | 86400s      |     8 | 0x7D476f061F8212A8C9317D5784e72B4212436E93 |
| üü¢ONT / USD                            | Ontology                                                 | Crypto         | 2%          | 86400s      |     8 | 0xcDa3708C5c2907FCca52BB3f9d3e4c2028b89319 |
| üü¢ORN / ETH                            | Orion Protocol                                           | Crypto         | 2%          | 86400s      |    18 | 0xbA9B2a360eb8aBdb677d6d7f27E12De11AA052ef |
| üü¢OXT / USD                            | Orchid Protocol                                          | Crypto         | 5%          | 86400s      |     8 | 0xd75AAaE4AF0c398ca13e2667Be57AF2ccA8B5de6 |
| üîµOrchid                               | Orchid bandwidth                                         | Crypto         | 200%        | 86400s      |     5 | 0xa175FA75795c6Fb2aFA48B72d22054ee0DeDa4aC |
| üîµPAX / ETH                            | Pax Dollar                   "
What are the three different locations to store variables in Solidity?,"The three different locations to store variables in Solidity are storage, memory, and calldata.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-2/course.md'},"The three different locations to store variables in Solidity are storage, memory, and calldata.","Variables can be declared as storage, memory or calldata to specify the location of the data. Learn how to and when to use storage and memory variables.


:::NEXT DOC:::

#####Chapter 2:

# Storage

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When someone says the data is stored on the blockchain, what does it actually mean from a perspective of a smart contract? Where is the data stored? How is it stored?
    </div>
  </div>
</ContentWrapp>

As we learned in the previous chapter, Ethereum could be described as a state machine. Transactions are then used to transition from one state to another state. The transactions are stored into individual blocks. These blocks are linked to each other creating the Ethereum blockchain. Everyone can take these transactions and follow the transition rules resulting in the same state for everyone.
But how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function calls. As block space is very valuable, storage variables are arranged in a compact way into storage slots into blocks of 32 bytes. Variables that take less than 32 bytes are combined into the same slot. Taking the least amount of space. Data is stored in order of the declaration in the contract in successive order. So we have slot 0x0, slot 0x1, slot 0x2, and so on.

```Solidity
contract StorageExample {
    uint256 nubmerOne = 1; // slot 0x0
    string customGreeting = ""Hello Chainlink""; // slot 0x1
    uint256 numberTwo; // slot 0x2

    string constant greeting = ""Hello World""; // no storage

    bool active; // slot 0x3
    bool admin; // slot 0x3
    bytes16 foo; // slot 0x3
    bytes16 bar; // slot 0x4
}
```

As you can see here, **numberOne**, **customGreeting** and **numberTwo** each take a full slot as they cannot be combined to consume less space. And constant variables (greeting) are not stored in storage slots. When a constant state variable is read the EVM uses the assigned value instead. the booleans active and admin just take 1 bit each and bytes16 takes 16 bits, so a total of 18 bits. That‚Äôs why they are all stored in slot 0x3. The last bytes16 variables bar takes another 16 bits but cannot be stored in slot 0x3 because the max size is 32 bytes. So a new slot is occupied.

Dynamic-sized arrays and structs are handled a little differently though as the size is unknown at the point of declaration. They always start with a slot that takes 32 bytes and their elements are stored in a different storage slot. The beginning of this storage slot is computed using a Keccack-256 hash.

**Memory** variables live only in memory and exist in the scope of a function. They are mutable inside that scope but cannot be called outside of the function. Once a function execution is completed, all variables"
What is a subscription in VRFv2?,A subscription is an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to 'consumer' contracts that want to request randomness.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-5/course.md'},"A subscription in VRFv2 is an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. It allows consumer contracts to have much more flexibility in requesting random numbers, such as specifying how many random numbers it wants to request, how much it's willing to pay for gas, and setting a limit to how much gas will be spent by the VRF when submitting the random number. The amount of LINK token to be paid to the VRF can be dynamic based on network conditions.","#####Chapter 5: VRF Subscriptions

# Subscribing to the VRF
Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number. 

## VRFv2
In VRFv2, the most recent version of the VRF, the concept of a subscription was added. What is a subscription? Essentially, it's an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. Once a subscription is set-up a consumer contract can then request randomness, the VRF respondes with a random number and proof, and then after the random number is included on-chain the VRF is paid with some of the LINK prepaid in the subscription.

The power that comes from this subscription model is that now consumer contracts have much more flexibility in requesting random numbers. Before subscriptions it was a static price, and the VRF always returned a single random number. 
 
But what if the consumer contract needs more than one random number? The consumer contract can now specify how many random numbers it wants to request.  
 
What if the consumer contract needs the random number to be included very fast by paying a higher gas price? The consumer contract can now request how much it's willing to pay for gas. This is called the **gas lane**. 
 
What if the consumer contract needs to run some heavy calculations after recieving the random number? It can set a limit to how much gas will be spent by the VRF when submitting the random number. This is called the **callbackGasLimit**.

And because this is all pre-paid via the subscription, and credited from the subscription amount after the VRF has responded with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! 

:::NEXT DOC:::

# Subscription Method

  * Overview
  * Subscriptions
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits
  * Subscription limits
  * Coordinator contract limits

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This section explains how to generate random numbers using the subscription
method.

## Subscriptions

VRF v2 requests receive funding from subscription accounts. The [Subscription
Manager](/vrf/v2/subscription/ui) lets you create an account and pre-pay for
VRF v2, so you don't provide funding each time your application requests
randomness. This reduces the total gas cost to use VRF v2. It also provides a
simple way to fund your use of Chainlink products from a single location, so
you don't have to manage multiple wallets across several different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends on current network conditions. The callback gas depends
on your callback function, and the number of random values in your request.
The cost of each request is final only after the transaction is complete, but
you define the limits you are willing to spend for the request with the
following variables:

  * **Gas lane:** The maximum gas price you are willing to pay for a request in wei. Define this limit by specifying the appropriate `keyHash` in your request. The limits of each gas lane are important for handling gas price spikes when Chainlink VRF bumps the gas price to fulfill your request quickly.

  * **Callback gas limit:** Specifies the maximum amount of gas you are willing to spend on the callback request. Define this limit by specifying the `callbackGasLimit` value in your request.

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle."
What caused the docker container to exit after the OCR keys creation step when setting up a Chainlink node in AWS ec2 + AWS RDS?,The AWS micro instance (1GB RAM) was running out of memory when OCR keys were generated.,{'source': 'https://stackoverflow.com/questions/70053634/there-are-no-ocr-keys-creating-a-new-key-encrypted-with-given-password-crashe'},"The docker container exited after the OCR keys creation step due to a memory problem, as the AWS micro instance (1GB RAM) was running out of memory when OCR keys were generated.","Question: (Asked on: 2021-11-21 10:23:07)
&quot;There are no OCR keys; creating a new key encrypted with given password&quot; Crashes when running Chainlink node
URL: https://stackoverflow.com/questions/70053634/there-are-no-ocr-keys-creating-a-new-key-encrypted-with-given-password-crashe

Question Body:


I am setting up a chainlink node in AWS ec2 + AWS RDS (PostgreSQL) and have
followed every step in the documentation
(<https://docs.chain.link/docs/running-a-chainlink-node/>).

Everything runs smoothly until the OCR keys creation step. Once it gets here,
it shows _"" There are no OCR keys; creating a new key encrypted with given
password""_. This is supposed to happen but **the docker container exits right
after** (see image below).

[Output after OCR keys creation](https://i.stack.imgur.com/oONjU.jpg)

I have tried the following:

  * Checking whether there is a problem with the specific table these keys are stored in the PostgreSQL database: `public.encrypted_ocr_key_bundles`, which gets populated if this step succeeds. Nothing here so far.
  * Using a different version of the Chainlink docker image (see [Chainlink Docker hub](https://hub.docker.com/r/smartcontract/chainlink/tags)). I am currently using version **0.10.0**. No success either, even if using latest ones.
  * Using AWS Cloudformation to ""let AWS + Chainlink"" take care of this, but even so I have encountered similar problems, so no success.

I have thought about populating the OCR table manually with a query, but I am
far from having proper OCR key generation knowledge/script in hand so I do not
like this option.

Does anybody know what else to try/where the problem could be?

Thanks a lot in advance!



Answers:
(Answered on: 2021-12-15 10:25:40)


**UPDATE:** It was a simple memory problem. The AWS micro instance (1GB RAM)
was running out of memory when OCR keys were generated. I only got a log of
the error after switching to an updated version of the CL docker image. In
conclusion: migrate to a bigger instance. Should've thought of that but
learning never stops!





:::NEXT DOC:::

Question: (Asked on: 2022-02-03 21:36:48)
Chainlink Quick Start problems connecting to the database?
URL: https://stackoverflow.com/questions/70978628/chainlink-quick-start-problems-connecting-to-the-database

Question Body:


I have gone through the AWS Chainlink quickstart successfully. I disabled the
ssl certificate and decided to use TCP enabled. The Chainlink node did not
launch on intial deployment. I used the .sh files to create .api, .password,
.env

I run the run script but get this error

opening db: failed to open db: failed to connect to `host=/tmp user=
database=`: dial error (dial unix /tmp/.s.PGSQL.5432: connect: no such file or
directory)

I have also gone through the step on the Chainlink docs to enable https
connections, and have configured the tls ports in the .env file.

I thought for sure it was the tls blocking me from the database. But still I
get this error

Here is my
DATABASE_URL=postgresql://user:password@writerendpointofcluster:5432/databasename

I used the writer endpoint of the cluster.

I don't know what to try next. Any help would be much appreciated.



Answers:
(Answered on: 2022-03-26 19:56:05)


In addition to !, * and _ can be used as the symbol requirement for the
database password.

The following characters also lead to an error: <, >, @, =. This is due to
some special characters requiring percent encoding, as discussed on this AWS
Chainlink QuickStart [GitHub issue](https://github.com/aws-
quickstart/quickstart-chainlinklabs-chainlink-
node/issues/23#issuecomment-970486800).


---
(Answered on: 2022-03-18 13:16:31)


The problem was the password for the database. There are certain characters
that throw an error.

The instructions on the AWS Chainlink quickstart on the database password
characters that are prohibited is not an exhaustive list.

In regards to AWS Chainlink quickstart, you can use the ""!"" as the symbol
requirement for the database password.

We are putting together a list of characters that throw an error, so far we
have #, ^, %, $ symbols that prevents you from connecting to the database.

*please comment which symbol gave you an error and I can add it to the list



"
What is the purpose of deprecating Data Feeds within the Chainlink ecosystem?,Deprecating Data Feeds helps preserve blockchains as public goods by optimizing blockspace usage and reduces unnecessary costs incurred by Chainlink node operators.,{'source': 'https://docs.chain.link/data-feeds/deprecating-feeds/'},"The purpose of deprecating Data Feeds within the Chainlink ecosystem is to optimize blockspace usage, reduce unnecessary costs incurred by Chainlink node operators, and maximize the adoption of the Chainlink protocol while optimizing for cost-efficiency and long-term economic sustainability. Data Feeds without publicly known active users may be scheduled for deprecation, and over time, new Data Feeds may be launched or relocated to alternative blockchains/layer-2s that better reflect current user demand.","# Deprecation of Chainlink Data Feeds

  * Overview
  * Ethereum Mainnet 

The smart contract ecosystem is constantly evolving. As a result, Data Feeds
within the Chainlink ecosystem are continuously evaluated for their usage and
economic viability across all the blockchains and layer-2 networks they are
deployed on.

Data Feeds without publicly known active users may be scheduled for
deprecation. Doing so not only helps preserve blockchains as public goods by
optimizing blockspace usage, but it helps reduce unnecessary costs incurred by
Chainlink node operators. This process is part of a broader ecosystem shift
towards Chainlink Economics 2.0, designed to maximize the adoption of the
Chainlink protocol while optimizing for cost-efficiency and long-term economic
sustainability. Over time, new Data Feeds may be launched or relocated to
alternative blockchains/layer-2s that better reflect current user demand.

For status updates regarding Data Feeds, users should join the official
Chainlink Discord and subscribe to the [data-feeds-user-notifications
channel](https://discord.gg/Dqy5N9UbsR).

Users with additional questions are encouraged to reach out
[here](https://chainlinkcommunity.typeform.com/s/dataFeedQs).

A list of data feeds designated for deprecation along with their corresponding
shutdown date can be found below.

## Ethereum Mainnet

| Pair                                       | Asset        | Type   | Deviation   | Heartbeat   |   Dec | Address                                    |
|:-------------------------------------------|:-------------|:-------|:------------|:------------|------:|:-------------------------------------------|
| ‚≠ïBCH / USDDeprecating: May 10th, 2023     | Bitcoin Cash | Crypto | 1%          | 86400s      |     8 | 0x9F0F69428F923D6c95B781F89E165C9b2df9789D |
| ‚≠ïEURS RESERVESDeprecating: May 10th, 2023 | Euro (EUR)   | Fiat   | 10%         | 432000s     |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67A |
| ‚≠ïREN / USDDeprecating: May 10th, 2023     | Ren          | Crypto | 1%          | 86400s      |     8 | 0x0f59666EDE214281e956cb3b2D0d69415AfF4A01 |
| ‚≠ïXMR / USDDeprecating: May 10th, 2023     | Monero       | Crypto | 1%          | 86400s      |     8 | 0xFA66458Cce7Dd15D8650015c4fce4D278271618F |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page

:::NEXT DOC:::

or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel: <https://discord.gg/Dqy5N9UbsR>

## Chainlink Community Deployments

Chainlink technology is used by many within the blockchain community to
support their use cases. Deployments built and run by community members are
not tracked in the Chainlink documentation. Chainlink's community is
continuously growing, and we believe they play a vital role in developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network"
What is the purpose of the Chainlink Data Feeds?,The Chainlink Data Feeds are used to provide price feed data to smart contracts.,{'source': 'https://docs.chain.link/any-api/introduction/'},"The purpose of the Chainlink Data Feeds is to provide aggregated data from multiple sources through a decentralized network of independent node operators, with a focus on providing industry-grade security and reliability for price data. The feeds are categorized based on their level of monitoring and verification, and users are advised to evaluate the properties of a feed to ensure it aligns with their intended use case and risk parameters. Specialized feeds are also available for large institutional users with deep expertise in their market space.","# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [‚Ä∫ Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [‚Ä∫ Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [‚Ä∫ Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [‚Ä∫ Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### üü° Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### üü† Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### üîµ Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ‚ö´ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs"
What is the EVM?,The EVM stands for Ethereum Virtual Machine and it is responsible for executing smart contracts on the Ethereum blockchain.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-2/description.md'},"The EVM stands for Ethereum Virtual Machine and it is what reads Solidity code when it is deployed to a blockchain. It is a virtual machine that executes bytecode and is used by blockchains such as Ethereum, Polygon, and Avalanche.","#####Chapter 2:

# EVM Intro

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Having a basic understanding of what‚Äôs going on under the hood in Solidity is important so let‚Äôs learn about the EVM!
    </div>
  </div>
</ContentWrapp>

Not so quick! I know you are ready to learn Solidity, but there is one other important subject you should know before moving on: the Ethereum Virtual Machine or EVM. The EVM is what reads your code when it is deployed to a blockchain. When Solidity code is compiled, it is turned into EVM bytecode. EVM bytecode is commands that the EVM can read and act on. When a smart contract is deployed to Ethereum, its bytecode lives there forever; always accessible. Any language other than Solidity that can compile to EVM bytecode can also be used to write smart contracts on blockchains that utilize the EVM. Another language that compiles to EVM bytecode is Vyper. Examples of blockchains that run the EVM are Ethereum, Polygon, and Avalanche (among many others). Many blockchains now use the EVM making Solidity an even more powerful smart contract language! 

Some blockchains have virtual machines other than the EVM and thus have different programming languages and bytecode compilation targets, but for this course, we‚Äôll stick with Solidity and the EVM.

<!-- <MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact legal contracts have become so notorousily difficult to enforce, more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a style=""color:green"" href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the american bar association </a>.
    </div>
</MissionContainer> -->


:::NEXT DOC:::

Having a basic understanding of what‚Äôs going on under the hood in Solidity is important so let‚Äôs learn about the EVM!
"
What is the issue that is causing the failure of the NFT transfer when using Chainlink automation?,The `allowance` issue is causing the failure of the NFT transfer when using Chainlink automation.,{'source': 'https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu'},"According to the question, the issue causing the failure of the NFT transfer when using Chainlink automation is related to the `allowance` problem.","Question: (Asked on: 2022-10-29 07:11:58)
How to Transfer NFTs using Chainlink&#39;s Automation/Keeper (checkUpkeep &amp; performUpKeep)
URL: https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu

Question Body:


I'm working on an NFT Auction contract. I'm trying to achieve 1. NFT transfer
to the highest bidder. 2. highest bidder's bid value to the prev NFT owner or
Auction creator. 3. A small platform cut sent to the contract's owner.

All this is working smoothly when I'm doing things manually. But when I'm
trying to achieve this using chainlink automation, It fails.

From my understanding, It is failing because of the `allowance` issue. My Qs
is, is it even possible to achieve this using chainlink automation? if yes,
then how?

When the NFT owner, lists his NFT for Auction, he is giving NFT transfer
allowance to the contract address.

    
    
        function checkUpkeep(bytes calldata /* checkData */) external view override returns(bool upkeepNeeded, bytes memory performData) {
            for(uint i=0; i < auctionIDs.length; i++){
                if(auctions[auctionIDs[i]].endTime != 0 && block.timestamp > auctions[auctionIDs[i]].endTime){
                    upkeepNeeded = true;
                    performData = abi.encodePacked(uint256(auctionIDs[i]));
                }
            }
            return (upkeepNeeded, performData);
        }
    
        function performUpkeep(bytes calldata performData) external override nonReentrant {
            uint256 auction_id = abi.decode(performData, (uint256));
    
            if(auctions[auction_id].endTime != 0 && block.timestamp > auctions[auction_id].endTime){
    
                auctions[auction_id].listed = false;
    
                safeTransferFrom(podcastId[auctions[auction_id].podcastId].nftOwner, bidders[auction_id].highestBidder, podcastId[auctions[auction_id].podcastId].tokenId);
    
                uint256 platformCut = (platformFee * bidders[auction_id].highestBid)/100;
                uint256 NftOwnerCut = bidders[auction_id].highestBid - platformCut;
    
                (bool pass, ) = platformFeeRecipient.call{value: platformCut}("""");
                require(pass, ""platformFee Transfer failed"");
                (bool success, ) = (podcastId[auctions[auction_id].podcastId].nftOwner).call{value: NftOwnerCut}("""");
       

:::NEXT DOC:::

am I doing wrong?

[Video](https://drive.google.com/file/d/1mCaq8RCxlZPN-
XJcO9kKzghWAiL-j2gW/view?usp=sharing)



Answers:
(Answered on: 2022-02-25 17:05:58)


`Gas estimation error` is a common error meaning that you don't have enough of
""something"" to send your transaction, maybe it's layer 1 (ETH) gas, or an
ERC20 token like LINK (technically, erc677, but I digress...)

Whenever you work with a Chainlink feature that uses the [request and
receive](https://docs.chain.link/docs/architecture-request-model/) method of
using chainlink, you need to [fund the consumer contract with LINK
token](https://docs.chain.link/docs/make-a-http-get-request/).

The issue here is you sent LINK to the oracle address and not the address of
your deployed contract.

[](https://i.stack.imgur.com/1ga4n.png)

If you copy the address of your deployed contract and send the LINK there, it
should work for you.



"
How can you loop through two arrays in one for loop?,You should make sure that they both have the same length first. Then you can use a for loop and iterate over both arrays simultaneously.,{'source': 'https://stackoverflow.com/questions/69440832/loop-through-2-arrays-in-one-for-loop'},"To loop through two arrays in one for loop, you should first ensure that both arrays have the same length. Then, you can use a for loop with a variable declaration and incrementation inside the loop body, iterating through both arrays simultaneously. An example code snippet is provided in one of the answers.","Question: (Asked on: 2021-10-04 18:34:58)
Loop through 2 arrays in one for loop?
URL: https://stackoverflow.com/questions/69440832/loop-through-2-arrays-in-one-for-loop

Question Body:


anyone know how we can loop through two arrays in one for loop?

    
    
    function setwinner() internal returns(address){
            for (uint stime = 0 ; stime < squareStartTimeArray.length; stime++ & uint etime = 0; etime = squareEndTimeArray.length etime++) {
                if (winningTime >= stime & winningTime <= etime) {
                    winningIndex = stime;
                    if (assert(stime == etime) == true) {
                        winningAddress = playerArray[stime];
                    }
                }
            }
        }
    



Answers:
(Answered on: 2021-10-04 18:47:12)


To loop through multiple arrays in the same loop you should make sure that
they both have the same length first. then you can use this:

    
    
    require(arrayOne.length == arrayTwo.length)
    for (i; arrayOne.length > i; i++) {
        arrayOne[i] = ....;
        arrayTwo[i] = ....;
    }
    





:::NEXT DOC:::

to the for loop, we also have a while loop that can be used. It is similar to the for loop that it has a condition that is tested each time the loop repeats. But the variable declaration is happening outside the loop header and incrementation is happening inside the loop body. One must be very careful not to forget to increment the index to meet the defined condition, or the loop may run forever.

<Highlight class=""language-javascript"">
function whileLoopExample() public {
  uint index;
  while (index < 4) {
      index++;
  }
}
</Highlight>

Always ensure you do not create a situation where your contract might get stuck when using loops. Imagine you have a dynamic array in storage that will grow over time as new values are added to it and some function is using a loop to iterate through the full array. You might run into a situation where loop iteration will hit the block's gas limit. This would result in an error and make it impossible for that function to complete that loop except you can somehow reduce the array size. So always take care when updating storage values in a loop!

You might think that for view and pure functions, you do not have to worry about this aspect, as nothing is added to a block and the state is read from the blockchain. And this is true as long as you call them directly. But if a non-pure/non-view function calls such a function, then gas is consumed and we might run into the same problem we just described.
"
What is the recommended version of Solidity to use in the given code?,The recommended version of Solidity to use in the given code is >=0.4.22 <0.9.0.,{'source': 'https://stackoverflow.com/questions/70905645/parsererror-source-file-requires-different-compiler-version-current-compiler-i'},"The recommended version of Solidity to use in the given code is not explicitly stated, as different answers suggest different versions ranging from 0.4.22 to 0.8.12.","Question: (Asked on: 2022-01-29 12:59:09)
ParserError: Source file requires different compiler version (current compiler is 0.8.7+commit.e28d00a7.Emscripten.clang)
URL: https://stackoverflow.com/questions/70905645/parsererror-source-file-requires-different-compiler-version-current-compiler-i

Question Body:


I was eventually trying to run this code in remix IDE, where I was running
this using 0.6.6 version of Solidity and ran into this error. I've tried using
some other versions like 0.8 and 0.6 as well.

    
    
    // SPDX-License-Identifier: MIT
    
    pragma solidity =0.8.7;
    
    import ""@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol"";
    
    contract myContract{
        using SafeMathChainlink for uint256;
        mapping(address => uint256) public payTo;
    
        function Payment() public payable {
            uint256 minimumUSD = 50 * 10 ** 18;
            require(getConversionRate(msg.value) >= minimumUSD, ""Doesn't satisfy the minimum condition"");
            payTo[msg.sender] += msg.value;
        }
    }
    



Answers:
(Answered on: 2023-04-08 20:32:35)


use this:

    
    
    pragma solidity >=0.5.0 < 0.9.0
    


---
(Answered on: 2022-08-04 12:56:43)


I was able to use pragma solidity ^0.8.0; as I fixed the issue by changing the
version in brownie-config.yaml

version: 0.8.0


---
(Answered on: 2022-05-17 07:41:56)


Now we can use this line of code to include a range of version of solidity to
use. I faced the similar issue and got fixed by doing this:

    
    
    pragma solidity >=0.4.22 <0.9.0;
    


---
(Answered on: 2022-01-29 13:14:02)


Your code requires Solidity 0.8.7, but the imported
[SafeMathChainlink.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/vendor/SafeMathChainlink.sol)
requires Solidity 0.6.*.

An easy solution is to change your code to require v0.6 as well and compile
with this version.

    
    
    pragma solidity ^0.6.0;
    

Or you can remove the `import` and `using ... for` of the SafeMath library, as
it's not needed on 0.8 anymore. All validations performed in the library are
now performed on the language level since version 0.8.0.





:::NEXT DOC:::

Question: (Asked on: 2022-06-09 13:14:15)
Lesson 7: Compiler Version Error -&gt; 10:43.16 (Full blockchain solidity course)
URL: https://stackoverflow.com/questions/72560937/lesson-7-compiler-version-error-1043-16-full-blockchain-solidity-course

Question Body:

    
    
    $ /home/ionmind/hardhat-fundme-fcc/node_modules/.bin/hardhat deploy --network rinkeby
    Error HH606: The project cannot be compiled, see reasons below.
    
    These files import other files that use a different and incompatible version of Solidity:
    
      * contracts/test/MockV3Aggregator.sol (^0.8.12) imports @chainlink/contracts/src/v0.6/tests/MockV3Aggregator.sol (^0.6.0)
    
    To learn more, run the command again with --verbose
    
    Read about compiler configuration at https://hardhat.org/config
    

After getting this error I modified the hardhat.config.js file as instructed
on the video

    
    
    module.exports = {
      //solidity: ""0.8.12"",
      solidity: {
        compilers: [{ version: ""0.8.12"" }, { version: ""0.6.0"" }],
      },
    

But still getting the error, so I also modified the compiler version in
solhint.js file

    
    
    {
      ""extends"": ""solhint:recommended"",
      ""rules"": {
        ""compiler-version"": [""error"", ""^0.8.12"", ""^0.6.0""],
        ""func-visibility"": [""warn"", { ""ignoreConstructors"": true }],
        ""var-name-mixedcase"": ""off"",
        ""avoid-low-level-calls"": ""off""
      }
    }
    

But still getting the error.

I created a separate AggregatorV2V3Interface file in test folder, locally
imported into MockV3Aggregator.sol & also declared solidity version ^0.8.12
for each of the files

    
    
    //SPDX-License-Identifier:MIT
    pragma solidity ^0.8.12;
    
    interface AggregatorInterface {
            //Code Here//
    }
    
    interface AggregatorV3Interface {
           //Code Here//
    }
    
    interface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}
    
    
    
    //SPDX-License-Identifier:MIT
    pragma solidity ^0.8.12;
    
    import ""./AggregatorV2V3Interface.sol"";
    

There are no errors or warnings in the code but I still get the same error
when trying to compile. I don't get why I seem to be the only person having
this compiler issue.Any help is appreciated. Thank you!



Answers:
(Answered on: 2022-06-09 16:11:22)


Update your solidity versions:

    
    
    module.exports = {
     "
What is the purpose of the imported LinkTokenInterface and VRFCoordinatorV2Interface in this Solidity code?,The imported LinkTokenInterface and VRFCoordinatorV2Interface are used to interact with the Chainlink oracle network for generating random numbers in the VRFConsumerBaseV2 contract.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-4/solution.md'},The imported LinkTokenInterface and VRFCoordinatorV2Interface in this Solidity code are used to interact programmatically with the Chainlink VRF Coordinator contract and the LINK token contract from the smart contract.,"Question: (Asked on: 2022-06-14 14:35:22)
what does VRFCoordinatorV2Interface(vrfCoordinator) mean in chain link documentation
URL: https://stackoverflow.com/questions/72618842/what-does-vrfcoordinatorv2interfacevrfcoordinator-mean-in-chain-link-documenta

Question Body:


I know that VRFCoordinatorV2Interface is an interface and we put the
respective chain coordinator address in it. what does it signifies and how to
visualise it. OR What will be the outcome when we put an address in a
interface.



Answers:
(Answered on: 2022-06-15 21:30:54)


The Chainlink VRF Coordinator is a contract that is deployed to a blockchain
that will check the randomness of each random number returned from a random
node.

By putting ""its address in an interface"" you can programmatically interact
with it from your smart contract. In other words, the function of your smart
contract can call some other function from the VRF Coordinator function, like
for example `createSubscription()`.





:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = ;
  address link_token_contract = ;
  bytes32 keyHash = ;
  uint32 callbackGasLimit = ;
  uint16 requestConfirmations = ;
  uint32 numWords =  ;
"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-2/hints.md'},"The topic of Chapter 1 is ""What will this course cover?"" in the Chainlink Introduction course.","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What does the Chainlink documentation specify about checking for a request before continuing?,The Chainlink documentation specifies that you should check that a request for a given `_requestId` exists before continuing.,{'source': 'https://stackoverflow.com/questions/76160005/what-are-the-chances-the-chainlink-oracle-will-respond-to-a-non-existent-request'},The Chainlink documentation specifies that you should check that a request for a given `_requestId` exists before continuing.,"Question: (Asked on: 2023-05-03 02:12:22)
What are the chances the Chainlink oracle will respond to a non-existent request?
URL: https://stackoverflow.com/questions/76160005/what-are-the-chances-the-chainlink-oracle-will-respond-to-a-non-existent-request

Question Body:


The Chainlink
[documentation](https://docs.chain.link/vrf/v2/subscription/examples/get-a-
random-number#analyzing-the-contract) specifies that you should check that a
request for a given `_requestId` exists before continuing.

[Chainlink Docs](https://i.stack.imgur.com/aLpGT.png)

I'm curious to further understand why this is, is it wrong to assume that the
Oracle should never attempt to fulfil a request that has never been
instantiated? For reference, I have reviewed the best practices section of the
documentation and all attached code snippets do not follow this behaviour.

Thanks :)

Whilst developing the contract I am working on, I noticed this and wanted to
gain a better understanding as to why the documentation validates a given
request exists before fulfilling it.



Answers:
(Answered on: 2023-05-07 09:49:35)


When the a randomness request is sent from VRFConsumer contract, a new
requestId is generated:

    
    
            requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
    

The contract has a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`.

After the oracle returns the random values to your contract, the mapping
`s_requests` is supposed to be updated, and the `RequestStatus` of a specific
request can be found by a specific `requestId`.

require statement in the fulfillment function is used to check if the
requestId is indeed sent from the vrfConsumer contract.





:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.



"
What are the two steps involved in billing for Chainlink Functions requests?,The two steps involved in billing for Chainlink Functions requests are the Request step and the Receive step.,{'source': 'https://docs.chain.link/chainlink-functions/resources/billing/'},"Billing for Chainlink Functions requests is done in two steps: during the Request step, the cost to fulfill a request is estimated and blocked on the Subscription balance by adding it to the Subscription reservation, and during the Receive step, the exact cost of the fulfillment is calculated and billed to the Subscription account.","# Chainlink Functions Billing

  * Overview
  * Concepts
  * Cost Simulation (Reservation)
  * Cost Calculation (Fulfillment)
  * Fees

## Concepts

For _Chainlink Functions_ to fulfill your requests, you must maintain a
sufficient amount of LINK in your _subscription balance_. Because _Chainlink
Functions_ follows the [Request and Receive Data](/chainlink-functions/resources/concepts) model, billing is also done in two steps:

  1. During the _Request_ step. the cost to fulfill a Chainlink Functions request is **estimated** and blocked on the _Subscription balance_ by adding it to the _Subscription reservation_.
  2. During the _Receive_ step, the exact cost of the fulfillment is **calculated** and billed to the _Subscription account_.

You can break down total costs into the following components:

  * Gas cost: This cost is paid back to the _Transmitter oracle_ for fulfilling the request.
  * Fees: 
    * DON fees: These fees are paid to the _DON_ in LINK to compensate the nodes for their work.
    * Registry fees: These fees are paid in LINK for the maintenance of the _Subscriptions Contract_.

Gas cost calculation includes the following variables:

  * Gas price: The current gas price fluctuates depending on network conditions.
  * Callback gas: The amount of gas used for the callback request. See the Cost Calculation section.
  * Estimated gas overhead: The amount of gas used by the _Subscriptions contract_ and _Functions Oracle contract_. It is an estimate of the total gas cost of fulfilling a request. See the Cost Simulation section.
  * Gas Report: The exact amount of gas used by the _Functions Oracle contract_ when fulfilling a request. See the Cost Calculation section.
  * Gas after payment: The amount of gas used to cover additional operations such as decrementing the subscription balance and incrementing the oracle's withdrawable balance.
  * Callback gas limit: This specifies the maximum amount of gas to spend for a client callback. It is an estimate of the total gas cost to fulfil a request. See the Cost Simulation section.
  * Native to LINK conversion: This allows your subscription balance to be billed only in LINK tokens. 
    * Convert the network's native currency to LINK: The total gas cost in _native_ units is converted to LINK using the correct [Price Feed](/data-feeds/price-feeds/addresses). On Sepolia, the conversion uses the ETH/LINK Price Feed. On Polygon Mumbai, the conversion uses the MATIC/LINK Price Feed.
    * Fallback Wei to LINK ratio: In the unlikely event that the _Native to LINK_ price data feed is unavailable, the fallback conversion is used. You can find this ratio by running the `gitConfig` function in the Oracle Registry proxy contract. See the [Supported Networks](/chainlink-functions/supported-networks) page to find the contract addresses for each network.

## Cost Simulation (Reservation)

During the _Request_ step:

  * The total cost in LINK is **estimated** using the following formula:
    
        (Gas price * (Estimated gas overhead + Callback gas limit + Gas after payment)) / Native to Link conversion = total estimated gas cost in LINK
    
    total estimated cost in LINK = total gas cost + DON fees + Registry fees

  * The total estimated cost is then added to the _Subscription reservation_.

## Cost Calculation (Fulfillment)

When a DON's oracle reports the response, subscription accounts are charged
based on the gas amount used in the callback:

  * The total cost in LINK is **calculated** using the following formula:
    
        (Gas price * (Gas Report + Callback gas + Gas after payment)) / Native to Link conversion = total gas cost in LINK
    
 

:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates"
Why does calling an external API in Chainlink not cause inconsistency?,"Because oracle responses are stored on-chain. Chainlink oracle network places the data on-chain in a transaction, and then it goes through the same validation process as every other transaction.",{'source': 'https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency'},"Calling an external API in Chainlink does not cause inconsistency because the oracle responses are stored on-chain. The Chainlink oracle network places the data on-chain in a transaction, and then it goes through the same validation process as every other transaction. This ensures that all nodes have access to the same data and can reach a consensus. Additionally, to make the process decentralized, many Chainlink nodes should be used to verify the data, ideally from many different data sources.","Question: (Asked on: 2021-11-26 22:39:12)
Why does calling an external API in chainlink not cause inconsistency?
URL: https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency

Question Body:


Suppose I have a smart contract that uses Chainlink's ""Call Any External API""
capability to get some data from an external URL. My understanding is that
each Ethereum full node runs each smart contract to verify the status; it does
so to verify the latest block. But what if, between the time one full node
runs the contract and another one does, the data returned by calling tha
external API changes. Then it would seem that different full nodes would get
different results for that smart contract, resulting in inconsistent states.
Why does that not happen?



Answers:
(Answered on: 2021-12-10 18:05:16)


Because oracle responses are stored on-chain.

You are right, if fetching external data was part of the validation process,
no nodes would be able to reach a consensus. So instead, a Chainlink oracle
network places the data on-chain in a transaction, and then it goes through
the same validation process as every other transaction.

You can read more about how Chainlink's [Basic Request
Model](https://docs.chain.link/docs/architecture-request-model/) looks, but
this is basically the reason why having an oracle system built into a
blockchain is impossible.





:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.



"
What is the purpose of the `cacheTTL` parameter in the Bridge task?,The `cacheTTL` parameter is a duration-formatted string indicating the maximum acceptable staleness for cached bridge responses in case of intermittent failures.,{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/all-tasks/'},The `cacheTTL` parameter in the Bridge task is used to indicate the maximum acceptable staleness for cached bridge responses in case of intermittent failures.,"external adapter.
  * `cacheTTL` (optional): a duration-formatted string indicating the maximum acceptable staleness for cached bridge responses in case of intermittent failures. This is disabled by default.
  * `headers` (optional): an array of strings. The number of strings must be even. Example: `foo [type=""bridge"" name=""foo"" headers=""[\\""X-Header-1\\"", \\""value1\\"", \\""X-Header-2\\"", \\""value2\\""]""]`

**Outputs**

A string containing the response body.

**Example**


    my_bridge_task [type=""bridge""
                    name=""some_bridge""
                    requestData=""{\\""data\\"":{\\""foo\\"": $(foo), \\""bar\\"": $(bar)}}""
                    ]

## CBOR Parse task

CBOR Parse tasks parse a CBOR payload, typically as part of a Direct Request
workflow. In Direct Request, a user makes an on-chain request using a
`ChainlinkClient` contract, which encodes the request parameters as CBOR. See
below for an example.

**Parameters**

  * `data`: A byte array containing the CBOR payload.
  * `mode`: An optional parameter that specifies how to parse the incoming CBOR. The default mode is `diet`, which expects the input to be a map. Set the mode to `standard` to pass literal values through ""as-is"". Empty inputs return nil.

**Outputs**

A map containing the request parameters. Parameters can be individually
accessed using `$(dot.accessors)`.

**Example**


    // First, we parse the request log and the CBOR payload inside of it
    decode_log  [type=""ethabidecodelog""
                 data=""$(jobRun.logData)""
                 topics=""$(jobRun.logTopics)""
                 abi=""SomeContractEvent(bytes32 requestID, bytes cborPayload)""]
    
    decode_cbor [type=""cborparse""
                 data=""$(decode_log.cborPayload)""]
    
    // Then, we use the decoded request parameters to make an HTTP fetch
    fetch [type=""http"" url=""$(decode_cbor.fetchURL)"" method=GET]
    parse [type=""jsonparse"" path=""$(decode_cbor.jsonPath)"" data=""$(fetch)""]
    
    // ... etc ...

See the [Direct Request page](/chainlink-nodes/oracle-jobs/all-jobs/#direct-request-jobs) for a more comprehensive example.

## Divide task

Divides the provided `input` by the `divisor` and returns the result with a
number of decimal places defined in the `precision` value.

**Parameters**

  * `input`: The value to be divided 
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`
  * `divisor`: The value by which to divide the `input`
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`
  * `precision`: The number of decimal places to retain in the result 
    * number
    * stringified number
    * bytes-ified number
    * `$(variable)`

**Outputs**

The result of the

:::NEXT DOC:::

# Tasks

  * Overview
  * What is a Task?
  * Shared attributes
  * Writing pipelines

## What is a Task?

Tasks

Tasks replace the [core adapters](/chainlink-nodes/oracle-jobs/v1/adapters)
from v1 jobs.

Tasks are a replacement for core adapters that is more flexible. Tasks can be
composed in arbitrary order into pipelines. Pipelines consist of one or more
threads of execution where tasks are executed in a well-defined order.

You can use Chainlink's [built-in tasks](/chainlink-nodes/oracle-jobs/all-tasks), or you can create your own [external adapters](/chainlink-nodes/external-adapters/external-adapters) for tasks which are accessed
through a `bridge`.

## Shared attributes

All tasks share a few common attributes:

`index`: when a task has more than one input (or the pipeline overall needs to
support more than one final output), and the ordering of the values matters,
the index parameter can be used to specify that ordering.


    data_1 [type=""http"" method=GET url=""https://chain.link/eth_usd""       index=0]
    data_2 [type=""http"" method=GET url=""https://chain.link/eth_dominance"" index=1]
    multiword_abi_encode [type=""eth_abi_encode"" method=""fulfill(uint256,uint256)""]
    
    data_1 -> multiword_abi_encode
    data_2 -> multiword_abi_encode

`timeout`: The maximum duration that the task is allowed to run before it is
considered to be errored. Overrides the `maxTaskDuration` value in the job
spec.

## Writing pipelines

Pipelines are composed of tasks arranged in a DAG (directed acyclic graph).
Pipelines are expressed in [DOT
syntax](https://en.wikipedia.org/wiki/DOT_%28graph_description_language%29#Directed_graphs).

Each node in the graph is a task with a user-specified ID and a set of
configuration parameters and attributes:


    my_fetch_task [type=""http"" method=GET url=""https://chain.link/eth_usd""]

The edges between tasks define how data flows from one task to the next. Some
tasks can have multiple inputs, such as `median`. Other tasks are limited to 0
(`http`) or 1 (`jsonparse`).


    data_source_1  [type=""http"" method=GET url=""https://chain.link/eth_usd""]
    data_source_2  [type=""http"" method=GET url=""https://coingecko.com/eth_usd""]
    medianize_data [type=""median""]
    submit_to_ea   [type=""bridge"" name=""my_bridge""]
    
    data_source_1 -> medianize_data
    data_source_2 -> medianize_data
    medianize_data -> submit_to_ea



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/tasks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the `performUpkeep` function?,"The `performUpkeep` function is called by the Automation Nodes to increase all elements whose balances are lower than the LIMIT, and to rebalance the elements if necessary.",{'source': 'https://docs.chain.link/chainlink-automation/flexible-upkeeps/'},"The purpose of the `performUpkeep` function is to increase the balances of elements that have balances lower than the specified limit, by calculating the increment needed, decreasing the contract liquidity accordingly, and rebalancing the element. This function is called by the Automation Nodes after the registration is confirmed and `checkUpkeep` returns `true`.","Question: (Asked on: 2022-11-10 05:44:34)
PeformUpkeep does not execute when checkUpkeep returns true using Chainlink automation
URL: https://stackoverflow.com/questions/74384621/peformupkeep-does-not-execute-when-checkupkeep-returns-true-using-chainlink-auto

Question Body:


We are using a custom logic automation. when checking checkUpkeep the boolean
returns true (pic attached) but our perform upkeep doesn't run. It is calling
another function to run that cost rougly 50k to 100k in gas (when run
manually) What are we missing? (p.s. when we do a simple toggle function call
the performUpkeep works - but not our function). I've even put the gas up to
2,500,000 for testing using a timebased option as well (calling a specific
function to execute same logic). Here is the repo
<https://github.com/billyjitsu/expir3/tree/main/packages/backend/contracts>

WE are expecting when the checkUpkeep returns true to execute the upkeep



Answers:
(Answered on: 2022-11-12 04:08:40)


In order to solve the problem like ""Why Chainlink checkUpkeep does not
execute"", I suggest doing the following things to debug your upkeep.

  1. Since `checkUpkeep` and `performUpkeep` are both triggered by [Chainlink automation](https://automation.chain.link/), you need to check your automation subscription first. In the automation app, double check the contract address is correct.
  2. Because the chainlink node has to change the state of blockchain(call `performUpkeep` in your consumer contract), it has to pay the gas fee. It is important to make sure there is a minimum balance of LINK in your subscription.
  3. Test if `checkUpkeep` works as expected. If the pre-defined condition for automation is satisfied in your smart contract, `checkUpkeep` should return true. Chainlink automation only calls `performUpkeep` when `checkUpkeep` returns `true`, so the upkeep does not work if `checkUpkeep` cannot return true. Call `checkUpkeep` by yourself to test if it works properly. If you cannot get `true` as returned value, automation cannot get `true` either.
  4. Test if `performUpkeep` works as expected. The mechanism of Chainlink automation is to call `performUpkeep` when `checkUpkeep` returns `true`, so you must make sure the `performUpkeep` can be called by automation. Try to call the `performUpkeep` manually to see if it works properly.

Hope it helps!





:::NEXT DOC:::

Nodes to check if `performUpkeep` should be performed
        function checkUpkeep(
            bytes calldata /* checkData */
        )
            external
            view
            override
            returns (bool upkeepNeeded, bytes memory performData)
        {
            upkeepNeeded = false;
            for (uint256 i = 0; i < SIZE && !upkeepNeeded; i++) {
                if (balances[i] < LIMIT) {
                    // if one element has a balance < LIMIT then rebalancing is needed
                    upkeepNeeded = true;
                }
            }
            return (upkeepNeeded, """");
        }
    
        /// @dev this method is called by the Automation Nodes. it increases all elements which balances are lower than the LIMIT
        function performUpkeep(bytes calldata /* performData */) external override {
            uint256 increment;
            uint256 _balance;
            for (uint256 i = 0; i < SIZE; i++) {
                _balance = balances[i];
                // best practice: reverify the upkeep is needed
                if (_balance < LIMIT) {
                    // calculate the increment needed
                    increment = LIMIT - _balance;
                    // decrease the contract liquidity accordingly
                    liquidity -= increment;
                    // rebalance the element
                    balances[i] = LIMIT;
                }
            }
        }
    }
    

Test this example using the following steps:

  1. Deploy the contract using Remix on the [supported testnet](/chainlink-automation/supported-networks) of your choice.

  2. Before registering the upkeep for your contract, decrease the balances of some elements. This simulates a situation where upkeep is required. In Remix, Withdraw 100 at indexes 10,100,300,350,500,600,670,700,900. Pass `100,[10,100,300,350,500,600,670,700,900]` to the withdraw function:

You can also perform this step after registering the upkeep if you need to.

  3. Register the upkeep for your contract as explained [here](/chainlink-automation/register-upkeep). Because this example has high gas requirements, specify the maximum allowed gas limit of `2,500,000`.

  4. After the registration is confirmed, Automation Nodes perform the"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-13/hints.md'},"The topic of Chapter 1 is ""What will this course cover?"" in the Chainlink Introduction course.","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What is a constructor in Solidity?,A constructor is a special function executed upon contract creation that allows us to set initial values for the state variables.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-9/course.md'},A constructor in Solidity is a special function executed upon contract creation that allows for setting initial values for state variables. It is used to avoid the need to write a new contract with updated initial values in the Solidity code.,"#####Chapter 9:

# Constructors

It is likely that you want to deploy the same contract with different initial values. Until now, you only learned how to set initial values. So you would always need to write a new contract with updated initial values in the Solidity code. This is unpractical. Fortunately, Solidity offers a constructor, a special function executed upon contract creation.

<Highlight class=""language-javascript"">
contract Foo {
uint public amount;
   constructor(uint _amount) {
       amountFoo = _amount;
   }
}
 
contract Bar {
uint public amount;
   constructor(uint _amount) {
       amountBar = _amount;
   }
}
</Highlight>

There can only be one constructor per contract and a constructor is defined using the constructor keyword. The arguments are passed during contract creation, allowing us to set initial values for the state variables. There is always a constructor in place. If you do not define one, there is a default constructor. Once the contract is created, the code is deployed on the blockchain.

Child contracts inhering from a parent contract can also call their parent constructors. You can do this either directly when defining the contract or in the child contract constructor:

<Highlight class=""language-javascript"">
contract A is Foo(42) {
}
 
contract B is Bar {
  constructor(uint \_amount) Bar(\_amount) {}
}
</Highlight>

It is important to note that parent constructors are always called in order of inheritance. So if you use the child constructor to pass the values, you should always check the order of inheritance They are always called from right to left. Let‚Äôs look at an example:

<Highlight class=""language-javascript"">
contract C is Foo, Bar {
 constructor() Bar(5) Foo(42) {}
}
</Highlight>

So here the constructor of Bar is called first with the value 5, then the Foo constructor is called with the value 42 and then the constructor of C is called. Remember this when using constructors because it might introduce weird behavior to your contracts if you have a different assumption.


:::NEXT DOC:::

It is likely that you want to deploy the same contract with different initial values. Until now, you only learned how to set initial values. So you would always need to write a new contract with updated initial values in the Solidity code. This is unpractical. Fortunately, Solidity offers a constructor, a special function executed upon contract creation.
"
What does Chainlink VRF allow you to customize?,Several randomness parameters.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-7/description.md'},Chainlink VRF allows you to customize several randomness parameters.,"Learn how Chainlink VRF allows you to customize several randomness parameters.


:::NEXT DOC:::

Learn how Chainlink VRF allows you to customize several randomness parameters.
"
What issue is the user facing when integrating Chainlink into their contract?,The API call doesn't work for them.,{'source': 'https://stackoverflow.com/questions/69816494/requesting-data-with-chainlink-response-not-what-expected'},The user is facing issues verifying their smart contract on Rinkeby Testnet using Chainlink v0.8.,"Question: (Asked on: 2021-09-21 16:17:59)
Chainlink v0.8 Smart Contract Deployment Issue
URL: https://stackoverflow.com/questions/69272249/chainlink-v0-8-smart-contract-deployment-issue

Question Body:


I am having issues verifying my smart contract on Rinkeby Testnet using
@chainlink. My contract is deploying to Rinkeby fine but runs into issues when
I have publish_source on. The contract verifies fine when using v0.6 and
Solidity 0.6.6, I seem to only have issues with v0.8. Anyone know why this
might be happening?

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
    
    /**
     * @title MyContract is an example contract which requests data from
     * the Chainlink network
     * @dev This contract is designed to work on multiple networks, including
     * local test networks
     */
    contract MyContract is ChainlinkClient, ERC721 {
        using Chainlink for Chainlink.Request;
    
        address constant RINKEBY_ORACLE =
            0x3A56aE4a2831C3d3514b5D7Af5578E45eBDb7a40;
        bytes32 constant RINKEBY_JOB_ID =
            bytes32(""187bb80e5ee74a139734cac7475f3c6e"");
    
        uint256 constant FEE = 0.1 * 10**18;
    
        uint256 public tokenCounter;
    
        bytes32 public data;
        string public image_url;
    
        struct Clip {
            string name;
            string url;
        }
    
        Clip[] public clips;
    
        mapping(bytes32 => string) public requestIdToClipName;
        mapping(bytes32 => address) public requestIdToSender;
        mapping(bytes32 => string) public requestIdToTokenURI;
        event requestedCollectible(bytes32 indexed requestId);
    
        mapping(bytes32 => uint256) public requestToTokenId;
        mapping(uint256 => string) public tokenIdToName;
        mapping(uint256 => string) public tokenIdToImgUrl;
    
        constructor(address _link) public ERC721(""Tests"", ""TST"") {
            if (_link == address(0)) {
                setPublicChainlinkToken();
            } else {
                setChainlinkToken(_link);
            }
            setChainlinkOracle(0x3A56aE4a2831C3d3514b5D7Af5578E45eBDb7a40);
   

:::NEXT DOC:::

Question: (Asked on: 2022-12-25 16:55:37)
Integrating Celo with Chainlink
URL: https://stackoverflow.com/questions/74914660/integrating-celo-with-chainlink

Question Body:


I have participated in a hackathon. So, we decided to use Celo + Chainlink.
But in Chianlink I saw there they don't have any smart contract in CELO
network.

Expect: A chainlink smart contract link like one of these:
<https://docs.chain.link/resources/link-token-contracts>.



Answers:
(Answered on: 2022-12-27 20:27:56)


Currently, there isn't a popular Chainlink network on the Celo network. You
could run your own node there if you'd like and [start a network
yourself](https://docs.chain.link/chainlink-nodes/).



"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-10/hints.md'},"The topic of Chapter 1 is ""What will this course cover?"" in the Chainlink Introduction course.","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What are the three methods used to provide off-chain reserves data?,"The three methods used to provide off-chain reserves data are third-party attestation, custodian, and self-attestation.",{'source': 'https://docs.chain.link/data-feeds/proof-of-reserve/'},"The three methods used to provide off-chain reserves data are third-party attestation, custodian data, and self-attestation.","# Proof of Reserve Feeds

  * Overview
  * Types of Proof of Reserve Feeds
  * Off-chain reserves
  * Cross-chain reserves
  * Using Proof of Reserve Feeds

Chainlink Proof of Reserve Feeds provide the status of the reserves for
several assets. You can read these feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

To find a list of available Proof of Reserve Feeds, see the [Proof of Reserve
Feed Addresses](/data-feeds/proof-of-reserve/addresses) page.

## Types of Proof of Reserve Feeds

Reserves are available for both cross-chain assets and off-chain assets. This
categorization describes the data attestation variations of Proof of Reserve
feeds and helps highlight some of the inherent market risks surrounding the
data quality of these feeds.

Reserves are available for both off-chain assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
  * ‚ö†Ô∏è Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

### Cross-chain reserves

Cross-chain reserves are sourced from the network where the reserves are held.
Chainlink node operators can report cross-chain reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import

:::NEXT DOC:::

Address Manager                       |
| ‚ö´PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ‚ö´PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| üîµSwell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ‚ö´TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| üîµWBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| üîµeFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                        "
What are the two steps involved in billing for Chainlink Functions requests?,The two steps involved in billing for Chainlink Functions requests are the Request step and the Receive step.,{'source': 'https://docs.chain.link/chainlink-functions/resources/billing/'},The two steps involved in billing for Chainlink Functions requests are estimating the cost during the Request step and calculating the exact cost during the Receive step.,"# Chainlink Functions Billing

  * Overview
  * Concepts
  * Cost Simulation (Reservation)
  * Cost Calculation (Fulfillment)
  * Fees

## Concepts

For _Chainlink Functions_ to fulfill your requests, you must maintain a
sufficient amount of LINK in your _subscription balance_. Because _Chainlink
Functions_ follows the [Request and Receive Data](/chainlink-functions/resources/concepts) model, billing is also done in two steps:

  1. During the _Request_ step. the cost to fulfill a Chainlink Functions request is **estimated** and blocked on the _Subscription balance_ by adding it to the _Subscription reservation_.
  2. During the _Receive_ step, the exact cost of the fulfillment is **calculated** and billed to the _Subscription account_.

You can break down total costs into the following components:

  * Gas cost: This cost is paid back to the _Transmitter oracle_ for fulfilling the request.
  * Fees: 
    * DON fees: These fees are paid to the _DON_ in LINK to compensate the nodes for their work.
    * Registry fees: These fees are paid in LINK for the maintenance of the _Subscriptions Contract_.

Gas cost calculation includes the following variables:

  * Gas price: The current gas price fluctuates depending on network conditions.
  * Callback gas: The amount of gas used for the callback request. See the Cost Calculation section.
  * Estimated gas overhead: The amount of gas used by the _Subscriptions contract_ and _Functions Oracle contract_. It is an estimate of the total gas cost of fulfilling a request. See the Cost Simulation section.
  * Gas Report: The exact amount of gas used by the _Functions Oracle contract_ when fulfilling a request. See the Cost Calculation section.
  * Gas after payment: The amount of gas used to cover additional operations such as decrementing the subscription balance and incrementing the oracle's withdrawable balance.
  * Callback gas limit: This specifies the maximum amount of gas to spend for a client callback. It is an estimate of the total gas cost to fulfil a request. See the Cost Simulation section.
  * Native to LINK conversion: This allows your subscription balance to be billed only in LINK tokens. 
    * Convert the network's native currency to LINK: The total gas cost in _native_ units is converted to LINK using the correct [Price Feed](/data-feeds/price-feeds/addresses). On Sepolia, the conversion uses the ETH/LINK Price Feed. On Polygon Mumbai, the conversion uses the MATIC/LINK Price Feed.
    * Fallback Wei to LINK ratio: In the unlikely event that the _Native to LINK_ price data feed is unavailable, the fallback conversion is used. You can find this ratio by running the `gitConfig` function in the Oracle Registry proxy contract. See the [Supported Networks](/chainlink-functions/supported-networks) page to find the contract addresses for each network.

## Cost Simulation (Reservation)

During the _Request_ step:

  * The total cost in LINK is **estimated** using the following formula:
    
        (Gas price * (Estimated gas overhead + Callback gas limit + Gas after payment)) / Native to Link conversion = total estimated gas cost in LINK
    
    total estimated cost in LINK = total gas cost + DON fees + Registry fees

  * The total estimated cost is then added to the _Subscription reservation_.

## Cost Calculation (Fulfillment)

When a DON's oracle reports the response, subscription accounts are charged
based on the gas amount used in the callback:

  * The total cost in LINK is **calculated** using the following formula:
    
        (Gas price * (Gas Report + Callback gas + Gas after payment)) / Native to Link conversion = total gas cost in LINK
    
 

:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates"
What are the trade-offs that bridge designs must compromise between?,"Bridge designs must compromise between trust-minimization, generalizability, extensibility, latency, and costs.",{'source': 'https://docs.chain.link/resources/bridge-risks/'},"Bridge designs must compromise between trust-minimization, generalizability, extensibility, latency, and costs.","As
explained in the [interoperability trilemma](https://blog.connext.network/the-interoperability-trilemma-657c2cf69f17) and [Ethereum foundation
docs](https://ethereum.org/en/developers/docs/bridges/#trade-offs), bridge
designs must compromise between the following characteristics:

  * **Trust-minimization:** The system does not introduce new trust or security assumptions beyond those of the underlying blockchains. Read trust-minimization for more details.
  * **Generalizability:** The system enables the transfer of complex arbitrary data. Data could be messages or assets/funds.
  * **Extensibility:** How hard is it to integrate a new blockchain?
  * **Latency:** How long does it take to complete a transaction?
  * **Costs:** How much does it cost to transfer data across chains via a bridge?

## Risks

When choosing a bridge, be aware of the following risks.

### Smart contract risks

Bugs and vulnerabilities can expose users' assets to different kinds of
exploits. Read this [detailed analysis](https://certik.medium.com/qubit-bridge-collapse-exploited-to-the-tune-of-80-million-a7ab9068e1a0) for an
example of a bridge exploit where the attacker could leverage a logical error
in the bridge‚Äôs smart contract.

### Systemic financial risks

To transfer tokens cross-chain, many bridges lock tokens on the source chain
and mint derivative or wrapped tokens on the destination chain representing
the locked tokens. A hack of the locked tokens or an infinite mint attack on
the wrapped tokens can make all wrapped tokens worthless and expose entire
blockchains to risk.

### Early stage

Given that bridges are relatively new, there are many unanswered questions
related to how bridges will perform in different market conditions.

### Trust-minimization (Counterparty risk)

To overcome cross-chain interoperability challenges, some bridges use off-
chain actors or validators. These actors introduce new trust assumptions in
addition to the underlying blockchain trust assumptions. These bridges act as
a custodian and are, therefore, trust-based. In contrast, some bridge designs
rely on underlying blockchains' validators and, therefore, do not add any
trust assumptions. To summarize:

  * Trusted (custodial) bridges require a third party to validate movements over the bridge. Users are required to give up control of their crypto assets, so trust is involved as they rely on the bridge operator's reputation.
  * Trustless (non-custodial) bridges leverage smart contracts to store and release funds on either side of the bridge. These bridges are trust-minimized because they don't make new trust assumptions beyond the underlying blockchains.

Trustlessness in bridges does not exist in an absolute form (trusted vs.
trustless). As explained in the blockchain-interoperability
[blog](https://blog.chain.link/blockchain-interoperability/), there are four
general interoperability solutions for validating the state of a source
blockchain and relaying the subsequent transaction to the destination
blockchain:

#### Web2 Verification

Web2 verification is when someone uses a web2 service to execute a cross-chain
transaction. The most common example in practice is when users leverage
centralized exchanges to swap or bridge their own tokens. The user simply
deposits their assets into an address on the source chain that's under the
control of the exchange and then withdraws the same tokens or different tokens
(via a swap on the exchange) to an address on a destination chain controlled
by the user.

Web2 verification can be fairly convenient for personal transactions and
requires less technical expertise. However, it is limited only to swapping and
bridging tokens which requires trust in a centralized

:::NEXT DOC:::

# Cross-chain bridges and associated risks

  * Overview
  * What is a Cross-chain bridge
  * Trade-offs
  * Risks
  * Smart contract risks
  * Systemic financial risks
  * Early stage
  * Trust-minimization (Counterparty risk)

When working with Chainlink on layer-2 chains and sidechains, you must export
your LINK tokens from Ethereum to the target chain using a cross-chain bridge.
Follow this [video](https://www.youtube.com/watch?v=WKvIGkBWRUA) for an
example of moving LINK tokens from Ethereum to Polygon.

Cross-chain bridges come with their own risks. In fact, bridge attacks
constitute some of the [largest cryptocurrency
hacks](https://rekt.news/leaderboard/) by value. When moving your LINK tokens
or any asset across chains, understand the risks that you are taking with your
assets. Chainlink Labs does not endorse any bridge. Ultimately, you are
responsible for assessing the bridge that you use to move your assets.

Read the What is a cross-chain bridge, Trade-offs, and Risks sections to learn
more about bridges and trust assumptions in their designs. After you read
these sections, you will have a better understanding of bridge risks and which
aspects you should evaluate when using a bridge.

## What is a Cross-chain bridge

With the [proliferation](https://defillama.com/chains) of layer-1 blockchains
and layer-2 scaling solutions, the web3 ecosystem has become multi-chain. Each
blockchain comes with its own approach to scalability, security, and trust.

However, blockchains are not natively capable of communicating with each
other, which makes [blockchain interoperability
protocols](https://blog.chain.link/blockchain-interoperability/) critical for
allowing dApps to interact with any on-chain environment and tap into each
blockchain's unique assets and features.

A [bridge](https://blog.chain.link/cross-chain-bridge/) is a core element of
cross-chain interoperability. Bridges exist to connect blockchain networks and
enable connectivity between them.

Bridges enable the following:

  * Cross-chain transfer of assets and information
  * dApps can leverage the strengths and benefits of different chains
  * Collaboration between developers from different blockchain ecosystems to build new platforms and products for users

As an analogy, you can use [the blockchains as cities mental
model](https://medium.com/dragonfly-research/blockchains-are-cities-564327013f86):

  * Layer-1 blockchains are like cities.
  * Layer-2 solutions are equivalent to skyscrapers. As described in the mental model, ‚ÄúEach rollup is like a vertical blockchain that extends from the ground L1‚Äù.
  * Bridges are like roads and streets that connect different cities and skyscrapers.

## Trade-offs

With the growing number of layer-1 and layer-2 chains, the number of bridges
has also grown, [surpassing one hundred](https://debridges.com/). So, how do
you choose the correct bridge?

When choosing a bridge, there is no perfect solution, only trade-offs. As
explained in the [interoperability trilemma](https://blog.connext.network/the-interoperability-trilemma-657c2cf69f17) and [Ethereum foundation
docs](https://ethereum.org/en/developers/docs/bridges/#trade-offs), bridge
designs must compromise between the following characteristics:

  * **Trust-minimization:** The system does not introduce new trust or security assumptions beyond those of the underlying blockchains. Read trust-minimization for more details.
  * **Generalizability:** The system enables the transfer of complex arbitrary data. Data could be messages or assets/funds.
  * **Extensibility:** How hard is it to integrate a new blockchain?
  * **Latency:** How long does it take to"
What are some ways to automatically purchase LINK tokens for a smart contract?,"Some ways to automatically purchase LINK tokens for a smart contract include: programatically swapping on a DEX like Uniswap, pre-funding the contract with LINK, doing it external to the blockchain, making use of meta-transactions, or paying an upfront cost to ensure the coordinator contracts are well funded with LINK.",{'source': 'https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically'},"Some ways to automatically purchase LINK tokens for a smart contract include: 
1) programatically swapping on a DEX like Uniswap, 
2) pre-funding the contract with LINK beforehand, 
3) having an external process running to fund the contract with LINK periodically, 
4) using meta-transactions with an external relayer, and 
5) paying an upfront cost to ensure the contract is well-funded with LINK and manually topping it up as needed using users' deposited funds.","Question: (Asked on: 2021-05-09 12:01:16)
How to make a Smart Contract purchase LINK (or other ERC20) tokens automatically?
URL: https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically

Question Body:


I am trying to interact with the Chainlink VRF function.

I have a Coordinator contract that needs random numbers to draw cards out of a
deck. The Coordinator calls a Random Number Generation Oracle that implements
Chainlink's VRFConsumerBase contract.

I want my Coordinator/Oracle to purchase LINK tokens automatically using the
Ether that the user sent for the draw price so that it can always provide the
required LINK fee to the VRF function and it does not need a human to manually
top up the contract with LINK.

Is there any working example/tutorial on how one could achieve this? I really
wish to avoid forcing the users of my contract to purchase LINK themselves.

Thanks!



Answers:
(Answered on: 2021-05-09 12:37:13)


A contract itself can't 'automatically have LINK transferred to it', because
to transfer LINK from one account to another, the owner of the LINK must be
the one that signs the transaction, however, there are a few other ways to
achieve the end result you're looking for.

1 - Rather than a straight transfer, you can do a swap on a DEX like Uniswap
programatically, ie <https://docs.uniswap.org/protocol/V2/guides/smart-
contract-integration/trading-from-a-smart-contract>

2 - If you know how much LINK will be required for the contract, you can
simply pre-fund it beforehand, or when it's created. Am guessing this isn't
the case for you though.

3 - Do it external to the blockchain. ie you can have a process running that
funds the contract with link every so often, checking if its empty or near
empty

4 - You can make use of meta-transactions so that the people playing the game
don't need any LINK. See [this example](https://github.com/pappas999/Link-Gas-
Station). Take note this still uses an external relayer like I mentioned in
the last point

5 - I've seen examples where others just pay an upfront cost to ensure the
coordinator contracts are well funded with LINK, and then they manually just
top them up as needed, using users deposited eth/funds as a kind of payment to
offset them having to send LINK to the contract.





:::NEXT DOC:::

# Fund Your Contracts

  * Overview
  * Retrieve the contract address
  * Send funds to your contract

Some smart contracts require funding at their addresses so they can operate
without you having to call functions manually and pay for the transactions
through MetaMask. This guide explains how to fund Solidity contracts with LINK
or ETH.

## Retrieve the contract address

  1. In Remix, deploy your contract and wait until you see a new contract in the **Deployed Contracts** section.
  2. On the left side panel, use the **Copy** button located near the contract title to copy the contract address to your clipboard.

## Send funds to your contract

  1. Open MetaMask.
  2. Select the network that you want to send funds on. For example, select the Sepolia testnet.
  3. Click the **Send** button to initiate a transaction.
  4. Paste your contract address in the address field.
  5. In the **Asset** drop down menu, select the type of asset that you need to send to your contract. For example, you can send LINK. If LINK is not listed, follow the guide to [Acquire testnet LINK](/resources/acquire-link).
  6. In the **Amount** field, enter the amount of LINK that you want to send.
  7. Click **Next** to review the transaction details and the Gas cost.
  8. If the transaction details are correct, click **Confirm** and wait for the transaction to process.

Transaction fee didn't update?

You may need to click **Fastest** , **Fast** , **Slow** , or **Advanced
Options** after entering the **Amount** to update the gas limit for the token
transfer to be successful.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/fund-your-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the 'validateMultiWordResponseId' modifier in the mock operator contract?,The 'validateMultiWordResponseId' modifier is used to ensure that the first word of the response matches the requestId.,{'source': 'https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat'},The 'validateMultiWordResponseId' modifier in the mock operator contract is used to compare the requestId value from the APIConsumer contract with the requestId value from the fulfill function arguments in order to validate a multi-word response for a Chainlink API call.,"I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:

    
    
      modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata _data) {
        require(_data.length >= 32, ""Response must be > 32 bytes""); 
        bytes memory firstDataWord = new bytes(32);
        for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript snippet for test script 
    //If local network - Set Authorised senders on Mock Oracle to account[1]
        const [owner, mockNode] = await ethers.getSigners();
        const mockNodeAccount = mockNode.address
        await mockOracle.setAuthorizedSenders([mockNodeAccount])
        
        
        const transaction: ContractTransaction = await apiConsumer.requestWithWords(ANY_ARGS_FOR_API)
        const transactionReceipt: ContractReceipt = await transaction.wait(1)
        const requestId = transactionReceipt.events[0].topics[1]
    
        const apiFilter = apiConsumer.filters.ChainlinkRequested()
        const apiEvents = await apiConsumer.queryFilter(apiFilter)
        console.log(apiEvents)
    
        const filter = mockOracle.filters.OracleRequest()
        const events = await mockOracle.queryFilter(filter)
        const {specId, requester, requestIdEvent, payment, callbackAddr, callbackFunctionId, cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
  

:::NEXT DOC:::

Question: (Asked on: 2021-11-25 07:47:35)
Chainlink Multi Variable Responses smart contract request not fulfilled by oracle.sol
URL: https://stackoverflow.com/questions/70107436/chainlink-multi-variable-responses-smart-contract-request-not-fulfilled-by-oracl

Question Body:


I have created an chainlink external adaptor and I have defined a Multi-Word
word request job. Now I have created a Multi Variable responses contract (i.e.
externalAPIConsumer.sol) for the job but when calling the
requestValidationData(), job runs and completes successfully but the
transaction fails because oracle.sol contract gives error as follow:

    
    
    Warning! Error encountered during contract execution [execution reverted] 
    

Here is externalAPIConsumer.sol:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract ExternalAPIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
    
        uint256 public allInSystem;
        uint256 public isProject;
        uint256 public senderAuthority;
        uint256 public receiverAuthority;
    
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        event requestFulfilled(
            uint256 isProject,
            uint256 senderAuthority,
            uint256 allInSystem,
            uint256 receiverAuthority
        );
    
        constructor(address _oracle) {
            setPublicChainlinkToken();
            oracle = _oracle;
            jobId = ""0b0e0c3944a94c989515e2dd81087356"";
            fee = 0.1 * 10**18; // (Varies by network and job)
        }
    
        /**
         * Initial request
         */
        function requestValidationData(
            string memory _jwtToken,
            string memory _jobId
        ) public {
            jobId = stringToBytes32(_jobId);
            Chainlink.Request memory request = buildChainlinkRequest(
                jobId,
                address(this),
                this.fulfill.selector
            );
            request.add(""orgAddress"", ""2021-11-02"");
            request.add(""senderAddress"", ""12111"");
            request.add(""receiverAddress"", ""FL"");
            request.add(""jwtToken"","
What is the benefit of smart contracts over traditional agreements?,"Smart contracts are transparent and open to the public by default, reducing counterparty risk since neither party has control over the execution of an agreement, and can create more efficient, automated processes that save business cost.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-4/course.md'},"Smart contracts provide reliable, guaranteed execution, transparency, tamper-proofness, and trust minimization over traditional agreements.","#####Chapter 4:

# Smart Contracts - The Future

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Check out this video on what smart contracts are and how they are changing the nature of agreements and the Internet. 
    </div>
  </div>
</ContentWrapp>

<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/Un7-hW6GAec"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>

Smart contracts result from the evolution of digital agreements. A smart contract is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract isn‚Äôt immediately executed after the conditions have been met. Rather, a lengthy review process is initiated and it could take months, even years before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial crisis were programmed as smart contracts, they would be completely transparent and any member of the public would have had the ability to audit them.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Trust Minimization</b></p>
  

:::NEXT DOC:::

Smart contracts result from the evolution of digital agreements. A Smart contract is a self-executing contract with the terms of the agreement being directly written into computer code.
"
What is the LINK token address for BNB Chain?,0x404460C6A5EdE2D891e8297795264fDe62ADBB75,{'source': 'https://docs.chain.link/vrf/v2/subscription/supported-networks/'},The LINK token address for BNB Chain is 0x404460C6A5EdE2D891e8297795264fDe62ADBB75.,"| LINK                                       |
| Decimals     | 18                                         |
## BNB Chain

### BNB Chain mainnet

BNB is used to pay for transactions on the BNB Chain mainnet.

ERC-677 LINK on BNB Chain

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
you cannot use it with Chainlink services or oracle nodes. Use the
[**Chainlink PegSwap service**](https://pegswap.chain.link/) to convert
bridged LINK to the official ERC-677 LINK token on BNB Chain.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 56                                         |
| Address        | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75 |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | bscscan.freshstatus.io                     |
### BNB Chain testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/chapel). Testnet BNB is
availalbe at [testnet.binance.org/faucet-
smart](https://testnet.binance.org/faucet-smart).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 97                                         |
| Address      | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06 |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Polygon (Matic)

### Polygon mainnet

MATIC is used to pay for transactions on Polygon. You can use the [Polygon
Bridge](https://wallet.polygon.technology/polygon/bridge/) to transfer

:::NEXT DOC:::

                                                   |
|:----------------|:-------------------------------------------------------------------|
| LINK Token      | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB                         |
| VRF Coordinator | 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255                         |
| Key Hash        | 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4 |
| Fee             | 0.0001 LINK                                                        |
## BNB Chain Mainnet

Important

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
cannot be used with Chainlink oracles. However, it can be [**converted to the
official LINK token on BNB Chain using Chainlink's PegSwap
service**](https://pegswap.chain.link/).

| Item            | Value                                                                                |
|:----------------|:-------------------------------------------------------------------------------------|
| LINK Token      | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75                                           |
| VRF Coordinator | 0x747973a5A2a4Ae1D3a8fDF5479f1514F65Db9C31                                           |
| Key Hash        | 0xc251acd21ec4fb7f31bb8868288bfdbaeb4fbfec2df3735ddbd4f7dc8d60103c                   |
| Fee             | 0.2 LINK - initial fees on BNB Chain are meant to cover the highest gas cost prices. |
## BNB Chain Testnet

BNB Chain Faucet

Testnet LINK is available from <https://faucets.chain.link/chapel>

| Item            | Value                                                              |
|:----------------|:-------------------------------------------------------------------|
| LINK            | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06                        "
What is the purpose of the code shown?,The code is a jobspec for a Chainlink node that fetches data from a YouTube channel and fulfills an oracle request with the data.,{'source': 'https://stackoverflow.com/questions/70017509/reverted-transaction-on-chainlink-node-while-fulfilling-request'},There is no code shown in the context information provided.,"Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions).
"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-8/hints.md'},"The topic of Chapter 1 is ""What will this course cover?"" in the Chainlink Introduction course.","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What are NFT Floor Price Feeds and what are they used for?,"NFT Floor Price Feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink‚Äôs oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. They can be used for use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.",{'source': 'https://docs.chain.link/data-feeds/nft-floor-price/'},"NFT Floor Price Feeds are a type of data feed provided by Chainlink that estimate a conservative and risk averse floor price for an NFT collection. They are used for various use cases that rely on high-quality NFT data, such as lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more. These feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink's oracle infrastructure to eliminate extreme price outliers and make them resistant to market manipulation.","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink‚Äôs oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) =

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * üü¢ [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * üü° [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * üü† [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * üîµ [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ‚ö´ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ‚≠ï [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ‚ö´Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ‚ö´BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ‚ö´Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ‚ö´CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |"
What is the ternary operator in Solidity and how is it used?,"The ternary operator is represented by the symbol '?'. It is used to assign a value to a variable based on a condition. For example, in the given code, if x is smaller than 5 then return 0 otherwise return 1.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-4/course.md'},"The ternary operator in Solidity is a conditional statement that allows for the execution of different code based on whether a condition is met or not. It is represented by the question mark symbol (?) and is used to assign values to a variable or to return a value in a function. The expression means if a certain condition is true, then return one value, otherwise return another value. It can also be used in place of a simple if/else statement.","#####Chapter 4:

# Conditional statements and loops

While we are now familiar with storage and basic data types in Solidity, we still have to learn about flow control. We will often run into situations where we need to decide the next step based on the value of a variable. This is where we can use conditional statements. The syntax is very similar to languages like JavaScript. Let‚Äôs have a look:

<Highlight class=""language-javascript"">
function foo(int x) public pure returns (uint) {
 if (x < 5) {
   return 0;
 } else if (x < 10) {
   return 1;
 } else {
   return 2;
 }
}
</Highlight>

As you can see, this allows us to execute different codes based on if a condition is met. If we do not have an else if case but a simple if/else case, Solidity also supports the ternary operator.

<Highlight class=""language-javascript"">
function bar(uint x) public pure returns (uint) {
  return x < 5 ? 0 : 1;
}
</Highlight>

The question mark **?** is called the ternary operator (learn more about operators in chapter 10). The expression means if x is smaller than 5 then return 0 otherwise return 1. We can also use these conditional statements to assign values to a variable:

<Highlight class=""language-javascript"">
function bar(uint x) public pure returns (uint) {
  uint conditionalResult = x < 5 ? 0 : 1;
  return conditionalResult;
}
</Highlight>

Here we are using the ternary expression to assign the value to the local variable called **conditionalResult**.

Next, to flow control, we often encounter a situation where repetition is needed. Loops are useful when we must repeat a block of code several times. Solidity offers two types of loops. For Loops and While Loops.

<Highlight class=""language-javascript"">
function forLoopExample() public returns (uint) {
  uint counter = 0;
  for (uint i = 0; i < 4; i++) {
      if (i == 0) {
          continue;
      }
      if (counter == 4) {
          break;
      }
      counter = counter + 2;
  }

return counter;
}
</Highlight>

As in JavaScript, we have the same syntax for the for loop: (initialization; condition; increment). The condition is an expression checked at the end of each loop cycle. You can also see that we are using the keywords **continue** and **break** here. They allow us to control the flow inside the loop. If a particular condition is met, we can skip the rest of the loop by using **continue**. So everything that would be executed after **continue** will be ignored. We can also completely exit the loop by using **break**. This is useful when we are looking for a specific condition to be met and do not need to run the loop anymore.

Next to the for loop, we also have a while loop that can be used. It is similar to the for loop that it has a condition that is tested each time the loop repeats. But the variable declaration is happening outside the loop header and incrementation is happening inside the loop body. One must be very careful not to forget to increment the index to meet the defined condition, or the loop may run forever.

<Highlight class=""language-javascript"">
function whileLoopExample() public {
  uint index;
  while (index < 4) {
      index++;
  }
}
</Highlight>

Always ensure you do not create a situation where your contract might get stuck when using loops. Imagine you have a dynamic array in storage that will grow over time as new values are added to it and some function is using a loop

:::NEXT DOC:::

There are actually quite a few pre-build operators in Solidity you can utilize to make programming smart contracts that much easier.
"
What is the purpose of the 'callbackGasLimit' parameter in the 'requestRandomWords()' function?,The 'callbackGasLimit' parameter specifies the limit for how much gas to use for the callback request to the contract's 'fulfillRandomWords()' function.,{'source': 'https://docs.chain.link/vrf/v2/subscription/examples/get-a-random-number/'},The 'callbackGasLimit' parameter in the 'requestRandomWords()' function is used to set the maximum gas limit supported for the callback function that will be called when the random words are received. It ensures that the callback function will not run out of gas and specifies the amount of gas that can be consumed by the callback function.,"        _randomWords.push(randomWords);
           // _randomWords = randomWords;
        }
    
        function requestRandomWords()public{
            uint256 requestId = _vrfCoordinator.requestRandomWords(
                gasLane,
                subscriptionId,
                REQUEST_CONFIRMATIONS,
                callbackGasLimit,
                NUM_WORDS
            );
            emit RequestedRandomWords(requestId, msg.sender);
        }
    
        function set_REQUEST_CONFIRMATIONS(uint16 comf)public{
            REQUEST_CONFIRMATIONS = comf;
        }
        function set_NUM_WORDS(uint32 num)public{
            NUM_WORDS = num;
        }
        function set_gasLimit(uint32 gasl) public{
            callbackGasLimit = gasl;
        }
    
        function getMaxLengthAndNum()public view returns(uint256,uint256){
            uint256 lth = _randomWords.length;
            uint256[] memory tmpArray = _randomWords[lth-1];
            uint256 lastNum = tmpArray[tmpArray.length-1];
            //uint256 maxNum = _randomWords[_randomWords.length-1];
    
            return (lth,lastNum);
        }
    }
    



Answers:
(Answered on: 2022-08-23 08:02:04)


I see that you are testing on Rinkeby. I advise you to test on Goerli. Rinkeby
is marked as deprecated (cf. <https://docs.chain.link/docs/vrf/v2/supported-
networks/>).

I've tested your contract and remarked that `fulfillRandomWords` runs out of
gas. In fact, The maximum number of random words that can be received per
request is 500, and the maximum gas limit supported for your callback function
is 2,500,000. Therefore, you must ensure that the callback function will not
run out of gas (meaning: your callback function cannot consume more than
2,500,000 of gas). In your example, you are trying to store 500 random words.
Setting a value from non-zero to zero takes about 20,000 of gas (cf. [Ethereum
yellow paper Appendix H](https://ethereum.github.io/yellowpaper/paper.pdf)).
With 2,500,000 of gas, you can store up to 125 words. And that‚Äôs why the
attached contract will not work with NUM_WORDS=500 (fulfillRandomWords runs
out of gas). If you want to store 10001 random values, I‚Äôd suggest making
multiple requests. For instance: inside `requestRandomWords` you can loop over
`vrfCoordinator.requestRandomWords` multiple times (e.g.: with NUM_WORDS=100
for 100 runs. and 1 for the last run). Your callback function will be called
multiple times (=number of requestIds) so make sure to implement a

:::NEXT DOC:::

the size of the request,
        // and the processing of the callback request in the fulfillRandomWords()
        // function.
        uint32 callbackGasLimit = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 requestConfirmations = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.
        uint32 numWords = 2;
    
        // Address LINK - hardcoded for Sepolia
        address linkAddress = 0x779877A7B0D9E8603169DdbD7836e478b4624789;
    
        // address WRAPPER - hardcoded for Sepolia
        address wrapperAddress = 0xab18414CD93297B0d12ac29E63Ca20f515b3DB46;
    
        constructor()
            ConfirmedOwner(msg.sender)
            VRFV2WrapperConsumerBase(linkAddress, wrapperAddress)
        {}
    
        function requestRandomWords()
            external
            onlyOwner
            returns (uint256 requestId)
        {
            requestId = requestRandomness(
                callbackGasLimit,
                requestConfirmations,
                numWords
            );
            s_requests[requestId] = RequestStatus({
                paid: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),
                randomWords: new uint256[](0),
                fulfilled: false
            });
            requestIds.push(requestId);
            lastRequestId = requestId;
            emit RequestSent(requestId, numWords);
            return requestId;
        }
    
        function fulfillRandomWords(
            uint256 _requestId,
            uint256[] memory _randomWords
        ) internal override {
            require(s_requests[_requestId].paid > 0, ""request not found"");
            s_requests[_requestId].fulfilled = true;
            s_requests[_requestId].randomWords = _randomWords;
            emit RequestFulfilled(
                _requestId,
                _randomWords,
                s_requests[_requestId].paid
            );
       "
What is the purpose of this chapter?,The purpose of this chapter is to teach the reader how to get a verifiably secure random number for use in a smart contract.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-13/course.md'},The purpose of this chapter is to provide a broad overview of the course and what will be learned.,"A broad overview of the course and what you will learn here.


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What error message did the user receive when calling the getVersion function in the FundMe smart contract?,The user received the error message 'call to FundMe.getVersion errored: execution reverted'.,{'source': 'https://stackoverflow.com/questions/69182406/solidiy-fundme-smart-contract-remix-chainlink-call-to-fundme-getversion-err'},"The user received the error message ""call to FundMe.getVersion errored: execution reverted"" when calling the getVersion function in the FundMe smart contract.","Question: (Asked on: 2021-09-14 17:49:25)
Solidiy FundMe Smart Contract - Remix - Chainlink `call to FundMe.getVersion errored: execution reverted`
URL: https://stackoverflow.com/questions/69182406/solidiy-fundme-smart-contract-remix-chainlink-call-to-fundme-getversion-err

Question Body:


I am learning to use Chain Link to get price conversions and also to implement
other functions provided by Chainlink. I have 2.9992 ETH on Rinkeby Test Net
and I am successfully able to compile and deploy the code using Remix IDE
using Injected Web3 Environment.

Whenever I call the function **getVersion** or any other function defined in
ChainLink. I get an error like this

> `""call to FundMe.getVersion errored: execution reverted""`
    
    
        pragma solidity >=0.6.6 <0.9.0;
        
        import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
        
        contract FundMe {
            
            mapping(address => uint256) public addressToAmountFunded;
            function fund() public payable {
                addressToAmountFunded[msg.sender] += msg.value;
            }
            
            function getVersion() public view returns(uint256) {
                AggregatorV3Interface priceFeed = AggregatorV3Interface(0x01BE23585060835E02B77ef475b0Cc51aA1e0709);
                return priceFeed.version();
            }
        }
    



Answers:
(Answered on: 2021-09-14 18:04:06)


So I found an answer to my question. I was using the wrong Ethereum Data Feed
Address. I updated address to **0x8A753747A1Fa494EC906cE90E9f37563A8AF630e**
which is for ETH/USD on Rinkeby Test Net and it compiles and deploys perfectly
with no errors





:::NEXT DOC:::

            // Given an address, the mapping will return the amount funded by such account - Note that these values will be reset every time withdraw is called
            funders.push(msg.sender);                                   // The funders' address will be added to the funders array - Note that these values will be reset every time withdraw is called
        }
    
        // ***** getVersion *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current version of the contract/library AggregatorV3Interface
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getVersion() public view returns(uint256)
        {      
            return AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e).version();     // .version method is contained inside of AggregatorV3Interface, the address can be find here
            //                                                                                                                                                                                 |
            // The function works also if written like this:                                                                                                                                   |
            // AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);  <--- Address                                                              |
            // return priceFeed.version();                                                                           <--- ABI                                       "
What is the error message that the user gets when trying to call the function AaveLendingPool.borrow()?,TypeError: Type int256 is not implicitly convertible to expected type uint256.,{'source': 'https://stackoverflow.com/questions/69783472/get-chainlink-eth-usd-price-feed-answer-as-uint256-instead-of-int-solidity'},There is no information provided about an error message related to the AaveLendingPool.borrow() function. The question and context information are about a different smart contract and function.,"Question: (Asked on: 2023-01-30 17:38:21)
Why is Chainlink oracle function call failing?
URL: https://stackoverflow.com/questions/75288132/why-is-chainlink-oracle-function-call-failing

Question Body:


While attempting to fund me contract is tell me it encountered an error
without specifying the error. I attempted to fund 0.1 eth through the fund
function, and in the terminal it says:

    
    
    [block:8404521 txIndex:12]
    from: 0x8a9...e4303
    to: FundMe.fund() 0x542...E109C
    value: 100000000000000000 wei
    data: 0xb60...d4288
    logs: 0
    hash: 0x29a...97939
    

and in the etherscan it says:status fail :

    
    
    Contract 0x5422f3458be343e378e7a399e16fff548e7e109c
     Warning! Error encountered during contract execution [execution reverted] 
    

I tried looking for problems with my code and found none.

    
    
    // SPDX-License-Identifier: MIT
    
    pragma solidity >=0.6.6 <0.9.0;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    //import ""@chainlink/contracts/src/v0.8/vendor/SafeMathChainlink.sol""; won't need in later complier versions.
    contract FundMe {
        
    
        mapping(address => uint256) public addressToAmountFunded;
    
        function fund() public payable {
            uint256 minimumUSD = 50 * 10 ** 18;
            require( getConversionRate(msg.value) >= minimumUSD,""You need to send more Eth"");
            addressToAmountFunded[msg.sender] += msg.value;
        }
    
        function getVersion() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
            return priceFeed.version();
        }
    
        function getPrice() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
            (,int256 answer,,,)=priceFeed.latestRoundData();
            return uint256(answer * 10000000000);
        }
        //10000000000 = Gwei which is why we added 10 zeros to getPrice(answer) to convert it to Wei amount
        function getConversionRate(uint256 ethAmount) public view returns (uint256){
            uint256 ethPrice = getPrice();
            uint256 ethAmountInUsd = (ethPrice * ethAmount)/ 1000000000000000000; //divide 2x because we added 10*((getPrice)answer))
       

:::NEXT DOC:::

= msg.sender;           
            amountDeposit = msg.value;      
            
            users.push(user);                     
            totalDeposited.push(amountDeposit);
    
            deadline = block.timestamp + (numberOfSeconds * 1 seconds);
    
            int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();
            ethPrice = uint(chainLinkEthPrice / 100000000);
            //return ethPrice = price;
            //price.push(ethPrice);
        }
    
        // Withdraw function for each user 
        function withdraw() public payable {
            require(block.timestamp >= deadline);
            uint amountToWithdraw = lockAmounts[msg.sender];
            lockAmounts[msg.sender] = 0; 
            msg.sender.transfer(amountToWithdraw); 
        }
    }
    



Answers:
(Answered on: 2022-06-01 17:02:50)


For the first issue, Solidity compiler said that you declared two variables
with the identifier. In details in your case, you give `ethPrice` for
`mapping` and `uint` variable. To solve this issue, try to change one of these
names in this way:

    
    
     uint256 price = ethPrice;
     mapping(uint => uint) mappingEthPrice;
    

Second issue refers that msg.sender keyword doesn't cast automatically with
address payable and to solve it you can use `payable()` function that allows
you convert an `address` to `address payable`. In your smart contract you must
to change in this way:

    
    
    payable(msg.sender).transfer(amountToWithdraw); 
    

This should be your smart contract fixed:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
        // EACAggregatorProxy is used for chainlink oracle
    interface EACAggregatorProxy {
        function latestAnswer() external view returns (int256);
    }
    
    contract oracleLink {
    
        // Address dev
        address public dev;
        // Dev's public deposit amount
        uint public devDeposit;
        // Array dev's public amount
        uint[] public devDeposits;
    
        // List each user and amount
        address[] public users;                   
        uint[] public totalDeposited;  
    
        // Mapping user's deposit
   "
What was the issue with the code that caused the error when running the call through the External Adapter?,The issue was with the line that made the artist ID uppercase.,{'source': 'https://stackoverflow.com/questions/69321235/trouble-with-chainlink-external-adapter-making-an-api-call-to-spotify'},The question does not provide enough information to determine the exact issue with the code that caused the error when running the call through the External Adapter.,"Question: (Asked on: 2021-09-24 21:23:50)
Trouble with Chainlink External Adapter making an API call to Spotify
URL: https://stackoverflow.com/questions/69321235/trouble-with-chainlink-external-adapter-making-an-api-call-to-spotify

Question Body:


I made an external adapter from the [Javascript External Adapter Template from
Chainlink](https://github.com/PatrickAlphaC/CL-EA-NodeJS-Template), trying to
use the Client Credentials flow for Spotify's API to return artist data,
documentation listed below.
<https://developer.spotify.com/documentation/general/guides/authorization-
guide/#client-credentials-flow> <https://developer.spotify.com/console/get-
artist/>

and I am able to make the call just fine with this code through Axios
[](https://i.stack.imgur.com/wRacs.png)

but when I try to run the same call through the External Adapter which uses
Axios for it's API calls as well, I get this error.
[](https://i.stack.imgur.com/BPUl6.png)

Here is a snippet of the main code of the external adapter from index.js

    
    
    const customParams = {
      artist: [''],
      
      endpoint: false
    }
    
    const createRequest = (input, callback) => {
      // The Validator helps you validate the Chainlink request data
    
      const apiID = process.env.API_ID
      const apiKey = process.env.API_KEY
    
      let token = 'BQDlkzka093OuR4tL7XyaI-Tag4R166FQGBSogBP6hEBxhsCjH8XfMRqs_apKFk0T87FGIrwPtT1bkuGCeE';
    
    
      const validator = new Validator(callback, input, customParams)
      const jobRunID = validator.validated.id
      const endpoint = validator.validated.data.endpoint
      const artistID = validator.validated.data.artist.toUpperCase()
      const url = `https://api.spotify.com/v1/artists/${artistID}`
    
      const params = {
        artistID
      }
    
      // curl -X ""GET"" ""https://api.spotify.com/v1/artists/5K4W6rqBFWDnAN6FQUkS6x"" -H ""Accept: application/json"" -H ""Content-Type: application/json"" -H ""Authorization: Bearer authtoken"" 
    
      
      // This is where you would add method and headers
      // you can add method like GET or POST and add it to the config
      // The default is GET requests
      // method = 'get' 
      // headers = 'headers.....'
      const head = {
        'Accept' : 'application/json',
        'Content-Type' : 'application/json',
        'Authorization' : 'Bearer ' + token
      }
     
      const config = {
        url,
        headers: head
      }
      console.log(""config:"", config)

and this is the

:::NEXT DOC:::

Question: (Asked on: 2022-11-09 23:44:03)
Chainlink node external adapter executes successfully, but keeps returning 0
URL: https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0

Question Body:


I'm trying to build an external adapter for a chainlink node to import API
information. On the chainlink node and API, everything seems like it worked,
however when I try to call the stored value from the smart contract, it's
always 0 despite the logs indicating that it ran successfully.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Mimi-Fund-EA""
    externalJobID = ""834d2179-321d-49ac-bf63-140635e3a606""
    forwardingAllowed = false
    maxTaskDuration = ""0s""
    contractAddress = ""0xAf644831B57E5625ac64cDa68248b810bE4D4D01""
    minContractPaymentLinkJuels = ""0""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""mimifund"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""year\\"": $(decode_cbor.year), \\""discount_rate\\"": $(decode_cbor.discount_rate)}}""]
        parse        [type=jsonparse path=""data,result"" data=""$(fetch)""]
        ds_multiply  [type=""multiply"" times=1000000000000000000]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(ds_multiply) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xAf644831B57E5625ac64cDa68248b810bE4D4D01"""
What is the difference between an agreement and a contract?,"Contracts are agreements that are enforceable in a court of law, while agreements are oftentimes informal and not legally binding.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md'},"An agreement is a concept that can be spoken orally, written down on paper, or even typed in digital documents, but its enforcement is oftentimes informal and based on factors such as reputation impact. On the other hand, a contract is an agreement that is enforceable in a court of law and once made, it is expected to be executed as written and enforced by a court of law.","#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend‚Äôs rare toy as a child. Perhaps you‚Äôve decided to lend your car to a friend as long as they don‚Äôt put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and ‚Äúwishy washy.‚Äù Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you‚Äôve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 1:

What will this course cover?
=============================

***Chainlink, smart contracts, blockchains, and the entire world of cryptocurrency have been a hot topic of discussion for several years now.***

Whether it‚Äôs companies like EY and Microsoft looking to use smart contracts to improve their business processes, artists and athletes like LaMelo Ball creating their own‚ÄúNFTs‚Äù, or up and coming companies looking to disrupt long standing industries such as insurance, Chainlink and smart contracts are looking to be the backbone for world changing applications.

The future of the internet, dubbed Web3.0, is being built in front of our eyes so let's dive in and start building the future! But wait, Chainlink? Smart contracts? Doesn‚Äôt blockchain have something to do with that Bitcoin stuff some people buy? In this course we will build up the intuition on what Chianlink is and the problems it solves.

## What are Contracts?
Agreements, deals, promises; these are concepts that humans seem to universally have an intuition on across cultures. Maybe as a child you agreed to trade 3 of your toys for 1 friend‚Äôs rare toy.

![The San Juan Mountains are beautiful!](/image_md.png ""test image"")

Or maybe you‚Äôve agreed to lend your car to your friend as long as they don‚Äôt put more than 100 miles on it and bring it back with a full tank. Or maybe you make an agreement with your health coach that you wont eat more than 2,500 calories a day.

<BlueParagraph>
    These are all examples of agreements and agreements can be spoken orally, written down on paper, or even typed in digital documents. Enforcement of agreements are handled outside of courts: you will probably lose trust in your friend who brings back your car with 600 miles on it and an almost empty tank of gas.
</BlueParagraph>

Your health coach will be very disappointed in you if you‚Äôve eaten 5,000 calories a day for the past week. Thus enforcement of standard agreements is often kind of ‚Äúwishy washy‚Äù and based on many hard measure factors such as reputation impact.

Contracts are agreements that are enforceable in a court of law. Maybe you‚Äôve signed a leasing contract to rent an apartment or house. Perhaps you‚Äôve run a restaurant and signed a futures contract with food suppliers to get corn at a specific price and time no matter what happens in the corn market.

Or perhaps you‚Äôve signed an employment agreement with the company you work for on what your pay rate will be and what benefits you will have. Either way, once these contractual agreements have been made it is expected that if they are not executed how they were written they will be enforced by a court of law i.e. a government and the power they have.
"
What is the purpose of the 'requestVolumeData' function?,To create a Chainlink request to retrieve API response and find the target data.,{'source': 'https://stackoverflow.com/questions/69297267/chainlink-api-get-request-isnt-returning-a-value'},"The purpose of the 'requestVolumeData' function is to build and send a Chainlink request to retrieve data from an API, and then process the response by extracting the desired data and multiplying it by a large number to remove decimal places. The function returns a request ID.","API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"": xxx.xxx,
            //     }
            //    }
            //   }
            //  }
            request.add(""currency"", ""ETH"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
    
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, bytes32 _volume) public recordChainlinkFulfillment(_requestId)
        {
            volume = _volume;
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    

The External Adapter should retrun something like
`{\""jobRunID\"":0,\""data\"":{\""account\"":\""0xdF392951284e8779C1e2Fdda5b452222\""},\""result\"":\""0dF392951284e8779C1e2Fdda5b45224\"",\""statusCode\"":200}
`

My Job Data lookies like:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""name""
    contractAddress = ""0x6A968f08Ba673EaD62b54Ec7FC4095213a679E63""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
         

:::NEXT DOC:::

from data).
         ************************************************************************************
         *                                    STOP!                                         * 
         *         THIS FUNCTION WILL FAIL IF THIS CONTRACT DOES NOT OWN LINK               *
         *         ----------------------------------------------------------               *
         *         Learn how to obtain testnet LINK and fund this contract:                 *
         *         ------- https://docs.chain.link/docs/acquire-link --------               *
         *         ---- https://docs.chain.link/docs/fund-your-contract -----               *
         *                                                                                  *
         ************************************************************************************/
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""http://dummy.restapiexample.com/api/v1/employees"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //      {""ETH"":
            //          {""USD"":
            //              {
            //                  ...,
            //                  ""VOLUME24HOUR"": xxx.xxx,
            //                  ...
            //              }
            //          }
            //      }
            //  }
            request.add(""path"", ""data.0.employee_age"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
          //"
What is the purpose of the contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code?,The contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code is a Chainlink Aggregator contract.,{'source': 'https://stackoverflow.com/questions/73734527/create-an-oracle-on-a-new-chain'},The purpose of the contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code is to serve as a Chainlink Aggregator contract for fetching token price data.,"Question: (Asked on: 2022-09-15 16:22:42)
Create an oracle on a new chain
URL: https://stackoverflow.com/questions/73734527/create-an-oracle-on-a-new-chain

Question Body:


If I deploy a contract like this one on a new chain:

<https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code>

Then I will still need some way to feed it data. How would I do this?



Answers:
(Answered on: 2022-09-16 05:24:19)


What you deployed is a Chainlink Aggregator contract, you do not need to
deploy Aggregator contract to get the token price data.

If you want to get some token price data in your contract, you should use
AggregatorInterface in your contract and then fetch price data from the
Aggregator contract deployed by Chainlink team. Instructions can be found
[here](https://docs.chain.link/docs/get-the-latest-price/).





:::NEXT DOC:::

smart contract when you deploy it. This contract has a constructor that sets an initial message when you deploy the contract.

  7. Click the **Deploy** button to deploy the contract and its initial message to the blockchain network. MetaMask opens and asks you to confirm payment to deploy the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  8. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  9. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  10. Click the `message` variable. Remix retrieves and prints the initial message that you set.

The contract has an address just like your wallet address. If you save this
address, you can return to your deployed contract at any time to retrieve
variables or execute functions. To see details about your deployed contract,
copy the contract address from the list in Remix and search for it in the
[Etherscan Sepolia Testnet Explorer](https://sepolia.etherscan.io/).

## Run functions in your contract

Because you deployed the contract to an actual blockchain, several nodes on
the test network confirmed your payment for the smart contract. The contract,
its variables, and its functions remain in the blockchain permanently. To
change the `message` variable that is stored with your contract, run the
`updateMessage` function.

  1. In your deployed contract, enter a new message next to the `updateMessage` function.

  2. Click the `updateMessage` button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.

  3. In the new MetaMask prompt, click **Confirm** to approve the transaction.

  4. Click the `message` variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

Now you know how to deploy example contracts to a test network and run the
functions in those contracts. You can write your own contracts and test them
using this same process.

Next, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds)
guide to learn how to connect your smart contracts to Chainlink Data Feeds and
retrieve on-chain data that your smart contracts can act on.

## What's next

  * [‚Ä∫ Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/deploy-your-first-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the recommended way to match randomness requests with their corresponding fulfillments?,We recommend using the `requestID` to match randomness requests with their corresponding fulfillments.,{'source': 'https://docs.chain.link/vrf/v1/security/'},The recommended way to match randomness requests with their corresponding fulfillments is to use the `requestID`.,"     keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
    
            if (input % 2 == 0) {
                requests[requestId] = Variable.A;
            } else if (input % 3 == 0) {
                requests[requestId] = Variable.B;
            } else {
                requests[requestId] = Variable.C;
            }
        }
    
        function fulfillRandomWords(
            uint256 requestId,
            uint256[] memory randomWords
        ) internal override {
            Variable variable = requests[requestId];
            if (variable == Variable.A) {
                fulfillA(requestId, randomWords[0]);
            } else if (variable == Variable.B) {
                fulfillB(requestId, randomWords[0]);
            } else if (variable == Variable.C) {
                fulfillC(requestId, randomWords[0]);
            }
        }
    
        function fulfillA(uint256 requestId, uint256 randomWord) private {
            // execution path A
            variableA = randomWord;
            emit FulfilledA(requestId, randomWord);
        }
    
        function fulfillB(uint256 requestId, uint256 randomWord) private {
            // execution path B
            variableB = randomWord;
            emit FulfilledB(requestId, randomWord);
        }
    
        function fulfillC(uint256 requestId, uint256 randomWord) private {
            // execution path C
            variableC = randomWord;
            emit FulfilledC(requestId, randomWord);
        }
    }
    

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/best-practices.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# VRF Security Considerations

  * Overview
  * Use requestId to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * fulfillRandomWords must not revert
  * Use VRFConsumerBaseV2 in your contract, to interact with the VRF service
  * Use VRFv2WrapperConsumer.sol in your contract, to interact with the VRF service

Gaining access to high quality randomness on-chain requires a solution like
Chainlink's VRF, but it also requires you to understand some of the ways that
miners or validators can potentially manipulate randomness generation. Here
are some of the top security considerations you should review in your project.

  * Use `requestId` to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * The `fulfillRandomWords` function must not revert
  * Use `VRFConsumerBaseV2` in your contract to interact with the VRF service

## Use `requestId` to match randomness requests with their fulfillment in
order

If your contract could have multiple VRF requests in flight simultaneously,
you must ensure that the order in which the VRF fulfillments arrive cannot be
used to manipulate your contract's user-significant behavior.

Blockchain miners/validators can control the order in which your requests
appear on-chain, and hence the order in which your contract responds to them.

For example, if you made randomness requests `A`, `B`, `C` in short
succession, there is no guarantee that the associated randomness fulfillments
will also be in order `A`, `B`, `C`. The randomness fulfillments might just as
well arrive at your contract in order `C`, `A`, `B` or any other order.

We recommend using the `requestID` to match randomness requests with their
corresponding fulfillments.

## Choose a safe block confirmation time, which will vary between blockchains

In principle, miners/validators of your underlying blockchain could rewrite
the chain's history to put a randomness request from your contract into a
different block, which would result in a different VRF output. Note that this
does not enable a miner to determine the random value in advance. It only
enables them to get a fresh random value that might or might not be to their
advantage. By way of analogy, they can only re-roll the dice, not predetermine
or predict which side it will land on.

You must choose an appropriate confirmation time for the randomness requests
you make. Confirmation time is how many blocks the VRF service waits before
writing a fulfillment to the chain to make potential rewrite attacks
unprofitable in the context of your application and its value-at-risk.

## Do not re-request randomness

Any re-request of randomness is an incorrect use of VRFv2. Doing so would give
the VRF service provider the option to withhold a VRF fulfillment if the
outcome is not favorable to them and wait for the re-request in the hopes that
they get a better outcome, similar to the considerations with block
confirmation time.

Re-requesting randomness is easily detectable on-chain and should be avoided
for use cases that want to be considered as using VRFv2 correctly.

## Don't accept bids/bets/inputs after you have made a randomness request

Consider the example of a contract that mints a random NFT in response to a
user's actions.

The contract should:

  1. Record whatever actions of the user may affect the generated NFT.
  2. **Stop accepting further user actions that might affect the generated NFT** and issue a randomness request.
  3. On randomness"
