question,answer,metadata,result,sources,retrieved_docs
give me a sample solidity contract to use Chainlink price feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"To call the `getLatestPrice` function from the Chainlink Price Feed, you need to import the `AggregatorV3Interface` into your contract and initialize the data feed in the constructor. You don't have to include the entire `PriceConsumerV3` contract from the Chainlink documentation in your own contract, but you can use it as an example to structure your contract. Here is an example of how to import and initialize the data feed:

```
import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract MyContract {
    AggregatorV3Interface internal priceFeed;

    constructor() {
        priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
    }

    function getPrice() public view returns (int) {
        (, int price, , , ) = priceFeed.latestRoundData();
        return price;
    }
}
```

In this example, `0x9326BFA02ADD2366b30bacB125260Af641031331` is the address of the data feed you want to use. You can replace it with the address of the specific data feed you want to access.

",- https://stackoverflow.com/questions/69818347/how-to-call-getlatestprice-function-chainlink-price-feed,"# Using Data Feeds Off-Chain (Solana)

  * Overview
  * The Chainlink Data Feeds Store Program
  * Adding Data Feeds to an existing off-chain project
  * Using the Solana Starter Kit
  * Install the required tools
  * Run the example program

Chainlink Data Feeds are the quickest way to access market prices for real-
world assets. This guide demonstrates how to read Chainlink Data Feeds on the
Solana Devnet using off-chain examples in the [Chainlink Solana Starter
Kit](https://github.com/smartcontractkit/solana-starter-kit). To learn how to
use Data Feeds in your on-chain Solana programs, see the [Using Data Feeds On-
Chain](/data-feeds/solana/using-data-feeds-solana) guide.

To get the full list of Chainlink Data Feeds on Solana, see the [Solana
Feeds](/data-feeds/price-feeds/addresses?network=solana) page.

Select quality data feeds

Be aware of the quality of the data that you use. [Learn more about making
responsible data quality decisions](/data-feeds/selecting-data-feeds).

## The Chainlink Data Feeds Store Program

The program that contains the logic required for the storing and retrieval of
Chainlink Data Feeds data on both Devnet and Mainnet is
[cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ](https://solscan.io/account/cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ?cluster=devnet).
This is the program ID that you use to read price data from off-chain. You can
find the source code for this program in the [smartcontractkit/chainlink-
solana](https://github.com/smartcontractkit/chainlink-solana/tree/develop/contracts/programs/store/src) on GitHub.

You can add data feeds to an existing off-chain project or use the Solana
Starter Kit.

## Adding Data Feeds to an existing off-chain project

You can read Chainlink Data Feeds off-chain in your existing project by using
the [Chainlink Solana NPM
library](https://www.npmjs.com/package/@chainlink/solana-sdk).

Reading feed data

Although you can directly query the data feed accounts, you should not rely on
the memory layout always being the same as it currently is. Based on this, the
recommendation is to always use the consumer library.

Install the necessary components and include the example code in your project.
Optionally, you can run the example code by itself to learn how it works
before you integrate it with your project.

  1. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  2. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  3. Change to your project directory or create a new directory.
    
        mkdir off-chain-project && cd off-chain-project

  4. Optionally [install Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to use as a package manager and initialize yarn if your project does not already have a `package.json` file:
    
        npm install -g yarn && yarn init

  5. Add the [Anchor library](https://www.npmjs.com/package/@project-serum/anchor) to your project:

npmyarn

    
        npm i @project-serum/anchor
    
        yarn add @project-serum/anchor

  6. Add the [Chainlink Solana NPM library](https://www.npmjs.com/package/@chainlink/solana-sdk) to your project:

npmyarn

    
        npm i -g @chainlink/solana-sdk
    
        yarn add @chainlink/solana-sdk

  7. Create a temporary Solana wallet to use for this example. Alternatively, if you have an existing wallet that you want to use, locate the path to your [keypair](https://docs.solana.com/terminology#keypair) file and use it as the keypair for the rest of this guide.
    
        solana-keygen new --outfile ./id.json

  8. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and how to get a connection to a Solana cluster. Because this example does not generate or sign any transactions, no lamports are required. The wallet is required only by the Anchor library. For a list of available networks and endpoints, see the [Solana Cluster RPC Endpoints](https://docs.solana.com/cluster/rpc-endpoints) documentation.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  9. Copy the sample code into your project. This example queries price data off-chain. By default, the script reads the SOL/USD feed, but you can change the `CHAINLINK_FEED_ADDRESS` variable to point to the [feed account addresses](/data-feeds/price-feeds/addresses?network=solana) that you want to query. You can take the components of these code samples and integrate them with your existing project. Because these examples read data feeds without making any on-chain changes, no lamports are required to run them.
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const anchor = require(""@project-serum/anchor"")
    const chainlink = require(""@chainlink/solana-sdk"")
    const provider = anchor.AnchorProvider.env()
    
    async function main() {
      anchor.setProvider(provider)
    
      const CHAINLINK_FEED_ADDRESS = ""99B2bTijsU6f1GCT73HmdR7HCFFjGMBcPZY6jZ96ynrR""
      const CHAINLINK_PROGRAM_ID = new anchor.web3.PublicKey(""cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ"")
      const feedAddress = new anchor.web3.PublicKey(CHAINLINK_FEED_ADDRESS) //SOL-USD Devnet Feed
    
      //load the data feed account
      let dataFeed = await chainlink.OCR2Feed.load(CHAINLINK_PROGRAM_ID, provider)
      let listener = null
    
      //listen for events agains the price feed, and grab the latest rounds price data
      listener = dataFeed.onRound(feedAddress, (event) => {
        console.log(event.answer.toNumber())
      })
    
      //block execution and keep waiting for events to be emitted with price data
      await new Promise(function () {})
    }
    
    main().then(
      () => process.exit(),
      (err) => {
        console.error(err)
        process.exit(-1)
      }
    )
    
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    import * as anchor from ""@project-serum/anchor""
    import { OCR2Feed } from ""@chainlink/solana-sdk""
    
    async function main() {
      const provider = anchor.AnchorProvider.env()
      anchor.setProvider(provider)
    
      const CHAINLINK_FEED_ADDRESS = ""99B2bTijsU6f1GCT73HmdR7HCFFjGMBcPZY6jZ96ynrR""
      const CHAINLINK_PROGRAM_ID = new anchor.web3.PublicKey(""cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ"")
      const feedAddress = new anchor.web3.PublicKey(CHAINLINK_FEED_ADDRESS) //SOL-USD Devnet Feed
    
      //load the data feed account
      let dataFeed = await OCR2Feed.load(CHAINLINK_PROGRAM_ID, provider)
      let listener = null
    
      //listen for events agains the price feed, and grab the latest rounds price data
      listener = dataFeed.onRound(feedAddress, (event) => {
        console.log(event.answer.toNumber())
      })
    
      //block execution and keep waiting for events to be emitted with price data
      await new Promise(function () {})
    }
    
    main().then(
      () => process.exit(),
      (err) => {
        console.error(err)
        process.exit(-1)
      }
    )
    

You can run these examples using the following commands:

JavascriptTypescript

    
        node javascript-example.js
    
        yarn add ts-node typescript && yarn ts-node typescript-example.ts

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://book.anchor-lang.com/).

## Using the Solana Starter Kit

This example reads price data from an off-chain client using the [Solana
Starter Kit](https://github.com/smartcontractkit/solana-starter-kit).

### Install the required tools

Before you begin, set up your environment for development on Solana:

  1. Install [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if it is not already configured on your system.

  2. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  3. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  4. [Install Anchor](https://book.anchor-lang.com/getting_started/installation.html). On some operating systems, you might need to build and install Anchor locally. See the [Anchor documentation](https://book.anchor-lang.com/getting_started/installation.html#build-from-source-for-other-operating-systems-without-avm) for instructions.

  5. Install [Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to simplify package management and run code samples in the Starter Kit.
    
        npm install -g yarn

### Run the example program

After you install the required tools, clone the example code from the [solana-
starter-kit](https://github.com/smartcontractkit/solana-starter-kit)
repository.

  1. In a terminal, clone the [solana-starter-kit](https://github.com/smartcontractkit/solana-starter-kit) repository and change to the `solana-starter-kit` directory:
    
        git clone https://github.com/smartcontractkit/solana-starter-kit &&
    cd ./solana-starter-kit

You can see the complete code for the example on
[GitHub](https://github.com/smartcontractkit/solana-starter-kit/).

  2. In the `./solana-starter-kit` directory, install Node.js dependencies defined in the `package.json` file:
    
        yarn install

  3. Create a temporary Solana wallet file to use for this example. Because your application runs off-chain and does not run any functions or alter data on-chain, the wallet does not require any SOL tokens to function.
    
        solana-keygen new --outfile ./id.json

  4. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and Solana cluster to use. Take note that because we are not generating or signing any transactions, the wallet isn't used, it's just required by the Anchor library. For a list of available networks and endpoints, see the [Solana Cluster RPC Endpoints](https://docs.solana.com/cluster/rpc-endpoints) documentation.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  5. Run the example:

JavascriptTypescript

    
        node read-data.js
    
        yarn run read-data

The example code retrieves and prints the current price feed data until you
close the application:

    
        4027000000
    4026439929
    4026476542
    4023000000

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://book.anchor-lang.com/).

## What's next

  * [› Use data feeds on-chain](/data-feeds/solana/using-data-feeds-solana)
  * [› See the available data feeds on Solana](/data-feeds/price-feeds/addresses?network=solana)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/solana/using-data-feeds-off-chain.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-11-03 00:21:58)
How to Call getLatestPrice function Chainlink Price Feed
URL: https://stackoverflow.com/questions/69818347/how-to-call-getlatestprice-function-chainlink-price-feed

Question Body:


I'm trying to use the chainlink price feed. Are we supposed to type all of our
code in the [PriceconsumerV3 contract](https://docs.chain.link/docs/get-the-
latest-price/)? Can we use inheritance to access the value? I tried putting
the PriceconsumerV3 contract and my contract in the same file. What is the
conventional setup?



Answers:
(Answered on: 2022-11-16 17:03:16)


Note the Rinkeby and Kovan Testnets are phased out which isn't well documented
in Solidity and Chainlink tutorials. Goerli as of now is the predominat
Testnet with different contract addresses hope this helps:

Scroll down the page to find Goerli contract addresses

<https://docs.chain.link/docs/data-feeds/price-
feeds/addresses/#Goerli%20Testnet>


---
(Answered on: 2021-11-03 14:25:01)


To access chainlink data feeds you simply need to import the AggregatorV3
Interface into whatever contract you would like to have use them like this:

    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    

Then initialize the exact data feed your contract is pointing to in the
constructor like this:

    
    
        constructor() {
            priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
        }
    

Where `0x9326....331` is the address of the data feed we are pointing to.

You do not have to actually put the entire [example PriceConsumer
contract](https://docs.chain.link/docs/get-the-latest-price/) from the
Chainlink docs into your own contract. That is just an example to show you how
to structure a contract to use data feeds as I explained above.



"
give me a sample solidity contract to use Chainlink VRF?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFD20 is VRFConsumerBaseV2 {

}
uint64 s_subscriptionId;
address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
uint32 callbackGasLimit = 40000;
uint16 requestConfirmations = 3;
uint32 numWords =  1;
)
(
give me a sample solidity contract to request data from a public API in a smart contract using chainlink?,
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req.add(
            ""get"",
            ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {""RAW"":
        //   {""ETH"":
        //    {""USD"":
        //     {
        //      ""VOLUME24HOUR"": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR""); // Chainlink nodes prior to 1.0.0 support this format
        req.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR""); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req.addInt(""times"", timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            ""Unable to transfer""
        );
    }
}",,"The VRF (Verifiable Random Function) used in Chainlink is based on Goldberg's Verifiable Random Function. It is a public-key pseudorandom function that allows for the generation of unpredictable and verifiable random numbers. The VRF generates a random number using a seed provided by a contract, and the output can be verified using the public key. The random number is then published on-chain with proof of its generation using the VRF.

","
- [Chainlink VRF Documentation](https://docs.chain.link/docs/chainlink-vrf/)
- [Goldberg's Verifiable Random Function Paper](https://eprint.iacr.org/2017/099.pdf)","# Subscription Method

  * Overview
  * Subscriptions
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits
  * Subscription limits
  * Coordinator contract limits

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This section explains how to generate random numbers using the subscription
method.

## Subscriptions

VRF v2 requests receive funding from subscription accounts. The [Subscription
Manager](/vrf/v2/subscription/ui) lets you create an account and pre-pay for
VRF v2, so you don't provide funding each time your application requests
randomness. This reduces the total gas cost to use VRF v2. It also provides a
simple way to fund your use of Chainlink products from a single location, so
you don't have to manage multiple wallets across several different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends on current network conditions. The callback gas depends
on your callback function, and the number of random values in your request.
The cost of each request is final only after the transaction is complete, but
you define the limits you are willing to spend for the request with the
following variables:

  * **Gas lane:** The maximum gas price you are willing to pay for a request in wei. Define this limit by specifying the appropriate `keyHash` in your request. The limits of each gas lane are important for handling gas price spikes when Chainlink VRF bumps the gas price to fulfill your request quickly.

  * **Callback gas limit:** Specifies the maximum amount of gas you are willing to spend on the callback request. Define this limit by specifying the `callbackGasLimit` value in your request.

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF subscription
request, and registering a smart contract with a VRF subscription account:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can only be initiated by EOAs.
  * Smart contract: A contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFConsumerBaseV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol).

  2. Your contract must implement the implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling `requestRandomWords` of the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol). Include the following parameters in your request:

    * `keyHash`: Identifier that maps to a job and a private key on the VRF service and that represents a specified gas lane. If your request is urgent, specify a gas lane with a higher gas price limit. The configuration for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).
    * `s_subscriptionId`: The subscription ID that the consuming contract is registered to. LINK funds are deducted from this subscription.
    * `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).
    * `callbackGasLimit`: The maximum amount of gas a user is willing to pay for completing the callback VRF function. Note that you cannot put a value larger than maxGasLimit of the VRF Coordinator contract (read coordinator contract limits for more details).
    * `numWords`: The number of random numbers to request. The maximum random values that can be requested for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).

### How VRF processes your request

After you submit your request, it is processed using the Request & Receive
Data cycle. The VRF coordinator processes the request and determines the final
charge to your subscription using the following steps:

  1. The VRF coordinator emits an event.

  2. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

  3. The VRF coordinator verifies the proof on-chain, then it calls back the consuming contract `fulfillRandomWords` function.

## Limits

Chainlink VRF v2 has some subscription limits and coordinator contract limits.

### Subscription limits

Subscriptions are required to maintain a minimum balance, and they can support
a limited number of consuming contracts.

#### Minimum subscription balance

Each subscription must maintain a minimum balance to fund requests from
consuming contracts. This minimum balance requirement serves as a buffer
against gas volatility by ensuring that all your requests have more than
enough funding to go through. If your balance is below the minimum, your
requests remain pending for up to 24 hours before they expire. After you add
sufficient LINK to a subscription, pending requests automatically process as
long as they have not expired.

In the Subscription Manager, the minimum subscription balance is displayed as
the **Max Cost** , and it indicates the amount of LINK you need to add for a
pending request to process. After the request is processed, only the amount
actually consumed by the request is deducted from your balance. For example,
if your minimum balance is 10 LINK, but your subscription balance is 5 LINK,
you need to add at least 5 more LINK for your request to process. This does
not mean that your request will ultimately cost 10 LINK. If the request
ultimately costs 3 LINK after it has processed, then 3 LINK is deducted from
your subscription balance.

The minimum subscription balance must be sufficient for each new consuming
contract that you add to a subscription. For example, the minimum balance for
a subscription that supports 20 consuming contracts needs to cover all the
requests for all 20 contracts, while a subscription with one consuming
contract only needs to cover that one contract.

For one request, the required size of the minimum balance depends on the gas
lane and the size of the request. For example, a consuming contract that
requests one random value will require a smaller minimum balance than a
consuming contract that requests 50 random values. In general, you can
estimate the required minimum LINK balance using the following formula where
max verification gas is always 200,000 gwei.


    (((Gas lane maximum * (Max verification gas + Callback gas limit)) / (1,000,000,000 Gwei/ETH)) / (ETH/LINK price)) + LINK premium = Minimum LINK

Here is the same formula, broken out into steps:


    Gas lane maximum * (Max verification gas + Callback gas limit) = Total estimated gas (Gwei)
    Total estimated gas (Gwei) / 1,000,000,000 Gwei/ETH = Total estimated gas (ETH)
    Total estimated gas (ETH) / (ETH/LINK price) = Total estimated gas (LINK)
    Total estimated gas (LINK) + LINK premium = Minimum subscription balance (LINK)

#### Maximum consuming contracts

Each subscription supports up to 100 consuming contracts. If you need more
than 100 consuming contracts, create multiple subscriptions.

### Coordinator contract limits

You can see the configuration for each network on the [Supported
networks](/vrf/v2/subscription/supported-networks) page. You can also view the
full configuration for each coordinator contract directly in Etherscan. As an
example, view the [Ethereum Mainnet VRF v2 coordinator
contract](https://etherscan.io/token/0x271682DEB8C4E0901D1a1550aD2e64D568E69909#readContract)
configuration.

  * Each coordinator has a `MAX_NUM_WORDS` parameter that limits the maximum number of random values you can receive in each request.
  * Each coordinator has a `maxGasLimit` parameter, which is the maximum allowed `callbackGasLimit` value for your requests. You must specify a sufficient `callbackGasLimit` to fund the callback request to your consuming contract. This depends on the number of random values you request and how you process them in your `fulfillRandomWords()` function. If your `callbackGasLimit` is not sufficient, the callback fails but your subscription is still charged for the work done to generate your requested random values.

## What's next

  * [› Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-05-09 08:07:14)
How to fund your contract with LINKs for VRF v2 subscription?
URL: https://stackoverflow.com/questions/72168793/how-to-fund-your-contract-with-links-for-vrf-v2-subscription

Question Body:


I've been learning solidity with brownie framework and python. I'm trying to
write a very simple contract which will generate a random number using
**ChainLink VRF v2**.

Here's the link of their sample **Subscription Manager Contract** :
<https://docs.chain.link/docs/chainlink-vrf/example-contracts/>

I've copied this exact same code in my **VRFv2SubscriptionManager.sol** file :

    
    
    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that also owns and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Rinkeby coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
    
        // Rinkeby LINK token contract. For other networks, see
        // https://docs.chain.link/docs/vrf-contracts/#configurations
        address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 keyHash =
            0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
    
        // A reasonable default is 100000, but this value could be different
        // on other networks.
        uint32 callbackGasLimit = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 requestConfirmations = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
        uint32 numWords = 2;
    
        // Storage parameters
        uint256[] public s_randomWords;
        uint256 public s_requestId;
        uint64 public s_subscriptionId;
        address public s_owner;
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            LINKTOKEN = LinkTokenInterface(link_token_contract);
            s_owner = msg.sender;
            //Create a new subscription when you deploy the contract.
            createNewSubscription();
        }
    
        // Assumes the subscription is funded sufficiently.
        function requestRandomWords() external onlyOwner {
            // Will revert if subscription is not set and funded.
            s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
        }
    
        function fulfillRandomWords(
            uint256, /* requestId */
            uint256[] memory randomWords
        ) internal override {
            s_randomWords = randomWords;
        }
    
        // Create a new subscription when the contract is initially deployed.
        function createNewSubscription() private onlyOwner {
            // Create a subscription with a new subscription ID.
            address[] memory consumers = new address[](1);
            consumers[0] = address(this);
            s_subscriptionId = COORDINATOR.createSubscription();
            // Add this contract as a consumer of its own subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumers[0]);
        }
    
        // Assumes this contract owns link.
        // 1000000000000000000 = 1 LINK
        function topUpSubscription(uint256 amount) external onlyOwner {
            LINKTOKEN.transferAndCall(
                address(COORDINATOR),
                amount,
                abi.encode(s_subscriptionId)
            );
        }
    
        function addConsumer(address consumerAddress) external onlyOwner {
            // Add a consumer contract to the subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
        }
    
        function removeConsumer(address consumerAddress) external onlyOwner {
            // Remove a consumer contract from the subscription.
            COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
        }
    
        function cancelSubscription(address receivingWallet) external onlyOwner {
            // Cancel the subscription and send the remaining LINK to a wallet address.
            COORDINATOR.cancelSubscription(s_subscriptionId, receivingWallet);
            s_subscriptionId = 0;
        }
    
        // Transfer this contract's funds to an address.
        // 1000000000000000000 = 1 LINK
        function withdraw(uint256 amount, address to) external onlyOwner {
            LINKTOKEN.transfer(to, amount);
        }
    
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }
    

This is my **deploy_first.py** :

    
    
    from brownie import VRFv2SubscriptionManager
    from scripts.helpful_scripts import get_account
    import time
    
    
    def deploy_random_number():
        account = get_account()
        random_number = VRFv2SubscriptionManager.deploy({""from"": account})
    
        print(""Deployed Random Number!!!"")
    
        owner = random_number.s_owner()
        print(""owner : "", owner)
    
        sub_id = random_number.s_subscriptionId()
        print(""sub_id : "", sub_id)
    
        random_number.topUpSubscription(9000000000000000000)
        print(""after the top up"")
        random_number.requestRandomWords()
        # time.sleep(60)
        print(""array : "", random_number.s_randomWords())
    
        return random_number
    
    
    def main():
        deploy_random_number()
    

I'm running this contract on Rinkeby TestNet and the account through which I'm
running this contract, has enough ETHER and LINK because I've tried
chainlink's official guide to generate the random number on **REMIX** and I
was able to generate it.

Here's the link of remix implementation of code :
<https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol>

**The Process on Remix :**

The new release of chainlink VRF v2 works this way from what I've understood
by implementing on **REMIX** :

  1. Inject web3, connect your Metamask (Rinkeby testnet) account to deploy the contract

  2. You deploy the contract and the contract creates a subscription for you in the constructor using **COORDINATOR.createSubscription();** where COOORDINATOR is **VRFCoordinatorV2Interface**

  3. Your Metamask account -- owns --> deployed contract

  4. Your deployed contract -- owns --> created subscription

  5. Consumers under a subscription account are allowed to use LINKs of that account and we are assigning our contract as the first consumer in the constructor

  6. To make calls to oracle our subscription account pays in LINKs, to send my subscription account LINKs I transferred LINKs from my metamask account to the address of the deployed contract, then used the function :
    
         // Assumes this contract owns link.
     // 1000000000000000000 = 1 LINK
     function topUpSubscription(uint256 amount) external onlyOwner {
         LINKTOKEN.transferAndCall(
             address(COORDINATOR),
             amount,
             abi.encode(s_subscriptionId)
         );
     }
    

to send LINKs from my contract to the subscription account.

  7. This worked completely fine in **REMIX** and I was able to generate the random number

**The Problem :**

Funding subscription and contracts is easy with Metamask wallet and Remix but
not scalable so I've got 2 main problems :

  1. How do I transfer LINKs from my Metamask (Rinkeby testnet) account (basically the **first msg.sender** i.e. **owner of the contract** ) to the contract that has been in deployed using my **VRFv2SubscriptionManager.sol** and **python_first.py**? Is there a way to do this using **web3.py**? (basically automate the process of funding the subscription account with LINKs while deploying the contract and creating subscription in the code only)

  2. In this example the **deployed contract** \-- owns --> **subscription account** after deploying the contract and creating a subscription using following functions :
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        LINKTOKEN = LinkTokenInterface(link_token_contract);
        s_owner = msg.sender;
        //Create a new subscription when you deploy the contract.
        createNewSubscription();
    }
    
    
        // Create a new subscription when the contract is initially deployed.
    function createNewSubscription() private onlyOwner {
        // Create a subscription with a new subscription ID.
        address[] memory consumers = new address[](1);
        consumers[0] = address(this);
        s_subscriptionId = COORDINATOR.createSubscription();
        // Add this contract as a consumer of its own subscription.
        COORDINATOR.addConsumer(s_subscriptionId, consumers[0]);
    }
    

Is there any way to create subscription, programatically, so that
**msg.sender** i.e. my Metamask (Rinkeby Testnet) account is the owner of
subscription account so that I don't have to transfer the LINKs to contract
first and can directly send it to the subscription account? On browser you can
do it easily here : <https://vrf.chain.link/>

  1. Link you Metamask wallet to the website
  2. Create a subscription account using you Metamask (Rinkeby Testnet) account
  3. Fund it with LINKs directly and in consumers you can add your deployed previously contracts using their addresses for them to use the LINKs to interact with VRF

I've tried changing the Gas Limit pre set in the contract, doublechecked my
values that I'm sending but I'm getting following error when python compiler
reaches the line : `random_number.topUpSubscription(9000000000000000000)` in
my **python_first.py**

**error :**

    
    
    Deployed Random Number!!!
    owner :  0xD8154fBD7cf816CdFde8cBC397b7cF5C604d7154
    sub_id :  4091
      File ""brownie/_cli/run.py"", line 51, in main
        return_value, frame = run(
      File ""brownie/project/scripts.py"", line 103, in run
        return_value = f_locals[method_name](*args, **kwargs)
      File ""./scripts/deploy_first.py"", line 28, in main
        deploy_random_number()
      File ""./scripts/deploy_first.py"", line 18, in deploy_random_number
        random_number.topUpSubscription(9000000000000000000)
      File ""brownie/network/contract.py"", line 1710, in __call__
        return self.transact(*args)
      File ""brownie/network/contract.py"", line 1583, in transact
        return tx[""from""].transfer(
      File ""brownie/network/account.py"", line 644, in transfer
        receipt, exc = self._make_transaction(
      File ""brownie/network/account.py"", line 727, in _make_transaction
        raise VirtualMachineError(e) from None
      File ""brownie/exceptions.py"", line 93, in __init__
        raise ValueError(str(exc)) from None
    ValueError: Gas estimation failed: 'execution reverted'. This transaction will likely revert. If you wish to broadcast, you must set the gas limit manually.
    

I assume this is because my contract doesn't have any LINK or ETHER i don't
know, I need more clarity on this error too.

I've been stuck on this problem for a day now. Please help. Thanks in advance.



Answers:
(Answered on: 2022-05-09 20:10:29)


As you said, the easiest way is to go to the
[vrf.chain.link](https://vrf.chain.link/), connect your wallet, and manage
your subscription(s). The initial flow is:

  * connect your wallet and select the proper network
  * create a new subscription, save your subscription id
  * fund your subscription
  * deploy VRF consumer smart contract
  * add it as a subscription consumer

[The Subscription Manager page](https://vrf.chain.link/) allows us to easily
manage subscription funds, add/remove multiple consumer contracts to/from one
subscription, and so much more.

Since you want to automate this process from the brownie CLI in a way that
your smart contract is not the owner of a subscription (and doesn't need to
worry about the funds), I suggest you move ""subscription logic"" from the smart
contract to python scripts, as described [in Chainlink Brownie Starter
Kit](https://github.com/smartcontractkit/chainlink-
mix/tree/main/scripts/vrf_scripts).

  1. To transfer LINKs from your Metamask (Rinkeby testnet) account to the contract that has been deployed, just perform the regular ERC20 transfer, but add your contract's address as the receiver/destination address. More examples [here](https://stackoverflow.com/questions/50764686/send-erc20-token-with-web3-py-using-a-local-private-key) and [here](https://web3py.readthedocs.io/en/stable/examples.html#sending-tokens).
  2. Probably because of that, try to set gas manually, as described in previous URLs, to some high value to confirm





:::NEXT DOC:::

Question: (Asked on: 2022-03-23 16:08:28)
transaction fails when I call getRandomNumber() function from chainlink VRF v1
URL: https://stackoverflow.com/questions/71590473/transaction-fails-when-i-call-getrandomnumber-function-from-chainlink-vrf-v1

Question Body:


I am using chainlink VRF v1 to get a random number. I am using ethers.js to
call the getRandomNumber() function but it always fails with this message:
`Error: transaction failed [ See: https://links.ethers.org/v5-errors-
CALL_EXCEPTION ] `

I have enought LINK in my contract so that is not the reason for this. Is
there any other possible or anything wrong with my code?

my smart contract:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.12;
    
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    
    contract VRFConsumer is VRFConsumerBase {
        bytes32 keyHash;
        uint256 requiredFee;
        uint256 public randomResult;
    
        constructor()
            VRFConsumerBase(
                0x844ECf0B33EB65e1EC34AEa0d082D39879169890,
                0xa36085F69e2889c224210F603D836748e7dC0088
            )
        {
            keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
            requiredFee = 0.1 * 10**18;
        }
    
        function getRandomNumber() public returns (bytes32 requestId) {
            require(
                LINK.balanceOf(address(this)) >= requiredFee,
                ""Not enough LINK - fill contract with faucet""
            );
            return requestRandomness(keyHash, requiredFee);
        }
    
        function fulfillRandomness(
            bytes32, /*requestId*/
            uint256 randomness
        ) internal override {
            randomResult = randomness;
        }
    }
    
    

my frontend code:

    
    
    const provider: ethers.providers.Web3Provider = new ethers.providers.Web3Provider((window as any).ethereum;
          );
    const signer: ethers.providers.JsonRpcSigner = provider.getSigner();
        const vrfConsumer = new ethers.Contract(
          this.address,
          vrfConsumerABI,
          provider
        );
        console.log(""Start"");
        const vrfConsumerWithSigner = vrfConsumer.connect(signer);
        const tx = await vrfConsumerWithSigner.getRandomNumber({
          gasPrice: 3000000000,
          gasLimit: 2000000,
        });
        await tx.wait();
        const result: BigNumber = await vrfConsumer.randomResult();
        console.log(result.toNumber());
        console.log(""done"");
    



Answers:
(Answered on: 2022-03-24 14:33:05)


I suggest you to check some functions in [Chainlink hardhat-starter-
kit](https://github.com/smartcontractkit/hardhat-starter-kit)

  * helper-functions.js
  * tasks\random-number-consumer\request-random-number.js
  * tasks\random-number-consumer\read-random-number.js





:::NEXT DOC:::

#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.
"
give me a sample solidity contract to use NFT Floor Price Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}",,"Here is a sample Solidity contract that can be used to consume NFT Floor Price Feeds:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}
```

","
- https://docs.chain.link/data-feeds/nft-floor-price/
- https://docs.chain.link/getting-started/consuming-data-feeds/","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = nftFloorPriceFeed.latestRoundData();
            return nftFloorPrice;
        }
    }
    

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for NFT Floor Price Feeds](/data-feeds/nft-floor-price/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
| ⚫VeeFriends Floor Price                 | ETH           | 2%          |       86400 |    18 | 0x35bf6767577091E7f04707c0290b3f889e968307 |
| ⚫World of Women Floor Price             | ETH           | 2%          |       86400 |    18 | 0xDdf0B85C600DAF9e308AFed9F597ACA212354764 |
## Goerli Testnet

| NFT Floor Pricing Feed     | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:---------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| Azuki Floor Price          | ETH           | 2%          |        3600 |    18 | 0x9F6d70CDf08d893f0063742b51d3E9D1e18b7f74 |
| BAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xB677bfBc9B09a3469695f40477d05bc9BcB15F50 |
| CloneX Floor Price         | ETH           | 2%          |        3600 |    18 | 0xE42f272EdF974e9c70a6d38dCb47CAB2A28CED3F |
| CoolCats Floor Price       | ETH           | 2%          |        3600 |    18 | 0x13F38938A18ff26394c5ac8df94E349A97AaAb4e |
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price      | ETH           | 2%          |        3600 |    18 | 0x870bc8BfEe8A7Bbd63Dc1ef09F2fF37DeBCfEF35 |
| Doodles Floor Price        | ETH           | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
give me a sample solidity contract to use Proof of Reserve Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}",,"Here is a sample Solidity contract that can be used to utilize Proof of Reserve Feeds:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest reserve
     */
    function getLatestReserve() public view returns (int) {
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}
```

","
- https://docs.chain.link/data-feeds/proof-of-reserve/
- https://docs.chain.link/data-feeds/proof-of-reserve/addresses/","# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like [AAVE](https://aave.com/) use Data Feeds to ensure the total
value of the collateral.

Data Feeds aggregate many data sources and publish them on-chain using a
combination of the [Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) and [Off-Chain
Reporting](/architecture-overview/off-chain-reporting?parent=dataFeeds).

To learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility Feeds](/data-feeds/rates-feeds)
documentation.

See the [Rate and Volatility Contract Addresses](/data-feeds/rates-feeds/addresses) page for a list of available networks and addresses.

### L2 sequencer uptime feeds

L2 sequencer feeds track the last known status of the sequencer on an L2
network at a given point in time. This helps you prevent mass liquidations by
providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds feeds, see the [L2 Sequencer
Uptime Feeds](/data-feeds/l2-sequencer-feeds) documentation.

## Components of a data feed

Data Feeds are an example of a decentralized oracle network and include the
following components:

  * **Consumer** : A consumer is an on-chain or off-chain application that uses Data Feeds. Consumer contracts use the [`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) to call functions on the proxy contract and retrieve information from the aggregator contract. For a complete list of functions available in the `AggregatorV3Interface`, see the [Data Feeds API Reference](/data-feeds/api-reference/#aggregatorv3interface).
  * **Proxy contract** : Proxy contracts are on-chain proxies that point to the aggregator for a particular data feed. Using proxies enables the underlying aggregator to be upgraded without any service interruption to consuming contracts. Proxy contracts can vary from one data feed to another, but the [`AggregatorProxy.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol) on Github is a common example.
  * **Aggregator contract** : An aggregator is a contract that receives periodic data updates from the oracle network. Aggregators store aggregated data on-chain so that consumers can retrieve it and act upon it within the same transaction. For a complete list of functions and variables available on most aggregator contracts, see the [Data Feeds API Reference](/data-feeds/api-reference/#accesscontrolledoffchainaggregator).

To learn how to create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

## Reading proxy and aggregator configurations

Because the proxy and aggregator contracts are all on-chain, you can see the
current configuration by reading the variables through an
[ABI](https://docs.soliditylang.org/en/latest/abi-spec.html) or using a
blockchain explorer for your network. For example, you can see the [BTC/USD
proxy
configuration](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#readContract)
on the Ethereum network using Etherscan.

If you read the BTC/USD proxy configuration, you can query all of the
functions and variables that are publicly accessible for that contract
including the `aggregator` address, `latestRoundData()` function,
`latestAnswer` variable, `owner` address, `latestTimestamp` variable, and
several others. To see descriptions for the proxy contract variables and
functions, see the source code for your specific data feed on
[Etherscan](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#code#L568).

The proxy contract points to an aggregator. This allows you to retrieve data
through the proxy even if the aggregator is upgraded. If you view the
`aggregator` address defined in the proxy configuration, you can see the
aggregator and its configuration. For example, see the [BTC/USD aggregator
contract](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#code)
in Etherscan. This contract includes several variables and functions,
including another `latestRoundData()`. To see descriptions for the aggregator
variables and functions, see the source code on
[GitHub](https://github.com/smartcontractkit/libocr/blob/master/contract/AccessControlledOffchainAggregator.sol)
or
[Etherscan](https://etherscan.io/address/0xae74faa92cb67a95ebcab07358bc222e33a34da7#code#F1#L1).

You can call the `latestRoundData()` function directly on the aggregator, but
it is a best practice to use the proxy instead so that changes to the
aggregator do not affect your application. Similar to the proxy contract, the
aggregator contract has a `latestAnswer` variable, `owner` address,
`latestTimestamp` variable, and several others.

## Components of an aggregator

The aggregator contract has several variables and functions that might be
useful for your application. Although aggregator contracts are similar for
each data feed, some aggregators have different variables. Use the
`typeAndVersion()` function on the aggregator to identify what type of
aggregator it is and what version it is running.

Always check the contract source code and configuration to understand how
specific data feeds operate. For example, the [aggregator contract for BTC/USD
on
Arbitrum](https://arbiscan.io/address/0x942d00008d658dbb40745bbec89a93c253f9b882#code)
is different from the aggregators on other networks.

For examples of the contracts that are typically used in aggregator
deployments, see the [libocr
repository](https://github.com/smartcontractkit/libocr/blob/master/contract/)
on GitHub.

For a complete list of functions and variables available on most aggregator
contracts, see the [Data Feeds API Reference](/data-feeds/api-reference/#accesscontrolledoffchainaggregator).

## Updates to proxy and aggregator contracts

To accommodate the dynamic nature of off-chain environments, Chainlink Data
Feeds are updated from time to time to add new features and capabilities as
well as respond to externalities such as token migrations, protocol rebrands,
extreme market events, and upstream issues with data or node operations.

These updates include changes to the aggregator configuration or a complete
replacement of the aggregator that the proxy uses. If you consume data feeds
through the proxy, your applications can continue to operate during these
changes.

Proxy and aggregator contracts all have an `owner` address that has permission
to change variables and functions. For example, if you read the [BTC/USD proxy
contract](https://etherscan.io/address/0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c#readContract)
in Etherscan, you can see the `owner` address. This address is a [multi-
signature safe](https://docs.gnosis-safe.io/introduction/the-programmable-account/gnosis-safe) (multisig) that you can also inspect.

If you [view the multisig
contract](https://etherscan.io/address/0x21f73d42eb58ba49ddb685dc29d3bf5c0f0373ca#readProxyContract)
in Etherscan using the _Read as Proxy_ feature, you can see the full details
of the multisig including the list of addresses that can sign and the number
of signers required for the multisig to approve actions on any contracts that
it owns.

The multisig-coordinated upgradability of Chainlink Data Feeds involves time-
tested processes that balance collusion-resistance with the flexibility
required to implement improvements and swiftly react to external conditions.
The approach taken to upgradability will continue to evolve over time to meet
user requirements.

## Monitoring data feeds

When you build applications and protocols that depend on data feeds, include
monitoring and safeguards to protect against the negative impact of extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, and outages.

Create your own monitoring alerts based on deviations in the answers that data
feeds provide. This will notify you when potential issues occur so you can
respond to them.

### Check the latest answer against reasonable limits

The data feed aggregator includes both [`minAnswer` and `maxAnswer`
values](https://github.com/smartcontractkit/libocr/blob/9e4afd8896f365b964bdf769ca28f373a3fb0300/contract/AccessControlledOffchainAggregator.sol#L33).
These variables prevent the aggregator from updating the `latestAnswer`
outside the agreed range of acceptable values, but they do not stop your
application from reading the most recent answer.

Configure your application to detect when the reported answer is close to
reaching `minAnswer` or `maxAnswer` and issue an alert so you can respond to a
potential market event. Separately, configure your application to detect and
respond to extreme price volatility or prices that are outside of your
acceptable limits.

### Check the timestamp of the latest answer

Chainlink Data Feeds do not provide streaming data. Rather, the aggregator
updates its `latestAnswer` when the value deviates beyond a specified
threshold or when the heartbeat idle time has passed. You can find the
heartbeat and deviation values for each data feed at
[data.chain.link](https://data.chain.link/) or in the [Contract
Addresses](/data-feeds/price-feeds/addresses) lists.

Your application should track the `latestTimestamp` variable or use the
`updatedAt` value from the `latestRoundData()` function to make sure that the
latest answer is recent enough for your application to use it. If your
application detects that the reported answer is not updated within the
heartbeat or within time limits that you determine are acceptable for your
application, pause operation or switch to an alternate operation mode while
identifying the cause of the delay.

During periods of low volatility, the heartbeat triggers updates to the latest
answer. Some heartbeats are configured to last several hours, so your
application should check the timestamp and verify that the latest answer is
recent enough for your application.

Users should build applications with the understanding that data feeds for
wrapped or liquid staking assets might have different heartbeat and deviation
thresholds than that of the underlying asset. Heartbeat and deviation
thresholds can also differ for the same asset across different blockchains.
Combining data from multiple feeds, even those with a common denominator,
might result in a margin of error that users must account for in their risk
mitigation practices.

To learn more about the heartbeat and deviation threshold, read the
[Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds#aggregator) page.

## What's next

  * [› Using Data Feeds](/data-feeds/using-data-feeds)
  * [› Read the API reference for using Data Feeds](/data-feeds/api-reference)
  * [› Price Feed Addresses](/data-feeds/price-feeds/addresses)
  * [› Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
  * [› NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Proof of Reserve Feeds

  * Overview
  * Types of Proof of Reserve Feeds
  * Off-chain reserves
  * Cross-chain reserves
  * Using Proof of Reserve Feeds

Chainlink Proof of Reserve Feeds provide the status of the reserves for
several assets. You can read these feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

To find a list of available Proof of Reserve Feeds, see the [Proof of Reserve
Feed Addresses](/data-feeds/proof-of-reserve/addresses) page.

## Types of Proof of Reserve Feeds

Reserves are available for both cross-chain assets and off-chain assets. This
categorization describes the data attestation variations of Proof of Reserve
feeds and helps highlight some of the inherent market risks surrounding the
data quality of these feeds.

Reserves are available for both off-chain assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
  * ⚠️ Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

### Cross-chain reserves

Cross-chain reserves are sourced from the network where the reserves are held.
Chainlink node operators can report cross-chain reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Give sample code for an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"This Agreement is governed by English law.
",28-pl,"# Code Examples

  * Overview
  * Reading data feeds on-chain
  * Solidity
  * Vyper
  * Reading data feeds off-chain
  * Javascript
  * Python
  * Golang
  * Getting a different price denomination
  * More Aggregator Functions

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same. To read a
feed, specify the following variables:

  * **RPC endpoint URL:** This determines which network that your smart contracts will run on. You can use a [node provider service](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) or point to your own [client](https://ethereum.org/en/developers/docs/nodes-and-clients/). If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the [Remix IDE](https://remix-project.org/) will automatically detect them for you.
  * **LINK token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
    const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""latestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
    priceFeed.methods
      .latestRoundData()
      .call()
      .then((roundData) => {
        // Do something with roundData
        console.log(""Latest Round Data"", roundData)
      })
    


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const { ethers } = require(""ethers"") // for nodejs only
    const provider = new ethers.providers.JsonRpcProvider(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""latestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new ethers.Contract(addr, aggregatorV3InterfaceABI, provider)
    priceFeed.latestRoundData().then((roundData) => {
      // Do something with roundData
      console.log(""Latest Round Data"", roundData)
    })
    

Latest Price

### Python

This example uses [Web3.py](https://web3py.readthedocs.io/en/stable/) to
retrieve feed data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    from web3 import Web3
    
    # Change this to use your own RPC URL
    web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
    # AggregatorV3Interface ABI
    abi = '[{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""description"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint80"",""name"":""_roundId"",""type"":""uint80""}],""name"":""getRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""latestRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""version"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""}]'
    # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0 <0.8.0`, use
[OpenZeppelin's SafeMath version
3.4](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    /**
     * Network: Sepolia
     * Base: BTC/USD
     * Base Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     * Quote: EUR/USD
     * Quote Address: 0x1a81afB8146aeFfCFc5E50e8479e826E7D55b910
     * Decimals: 8
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract PriceConverter {
        function getDerivedPrice(
            address _base,
            address _quote,
            uint8 _decimals
        ) public view returns (int256) {
            require(
                _decimals > uint8(0) && _decimals <= uint8(18),
                ""Invalid _decimals""
            );
            int256 decimals = int256(10 ** uint256(_decimals));
            (, int256 basePrice, , , ) = AggregatorV3Interface(_base)
                .latestRoundData();
            uint8 baseDecimals = AggregatorV3Interface(_base).decimals();
            basePrice = scalePrice(basePrice, baseDecimals, _decimals);
    
            (, int256 quotePrice, , , ) = AggregatorV3Interface(_quote)
                .latestRoundData();
            uint8 quoteDecimals = AggregatorV3Interface(_quote).decimals();
            quotePrice = scalePrice(quotePrice, quoteDecimals, _decimals);
    
            return (basePrice * decimals) / quotePrice;
        }
    
        function scalePrice(
            int256 _price,
            uint8 _priceDecimals,
            uint8 _decimals
        ) internal pure returns (int256) {
            if (_priceDecimals < _decimals) {
                return _price * int256(10 ** uint256(_decimals - _priceDecimals));
            } else if (_priceDecimals > _decimals) {
                return _price / int256(10 ** uint256(_priceDecimals - _decimals));
            }
            return _price;
        }
    }
    

## More Aggregator Functions

Getting the latest price is not the only data that aggregators can retrieve.
You can also retrieve historical price data. To learn more, see the
[Historical Price Data](/data-feeds/historical-data) page.

To understand different use cases for Chainlink Price Feeds, refer to [Other
Tutorials](/getting-started/other-tutorials).

## What's next

  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/examples.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds Off-Chain (Solana)

  * Overview
  * The Chainlink Data Feeds Store Program
  * Adding Data Feeds to an existing off-chain project
  * Using the Solana Starter Kit
  * Install the required tools
  * Run the example program

Chainlink Data Feeds are the quickest way to access market prices for real-
world assets. This guide demonstrates how to read Chainlink Data Feeds on the
Solana Devnet using off-chain examples in the [Chainlink Solana Starter
Kit](https://github.com/smartcontractkit/solana-starter-kit). To learn how to
use Data Feeds in your on-chain Solana programs, see the [Using Data Feeds On-
Chain](/data-feeds/solana/using-data-feeds-solana) guide.

To get the full list of Chainlink Data Feeds on Solana, see the [Solana
Feeds](/data-feeds/price-feeds/addresses?network=solana) page.

Select quality data feeds

Be aware of the quality of the data that you use. [Learn more about making
responsible data quality decisions](/data-feeds/selecting-data-feeds).

## The Chainlink Data Feeds Store Program

The program that contains the logic required for the storing and retrieval of
Chainlink Data Feeds data on both Devnet and Mainnet is
[cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ](https://solscan.io/account/cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ?cluster=devnet).
This is the program ID that you use to read price data from off-chain. You can
find the source code for this program in the [smartcontractkit/chainlink-
solana](https://github.com/smartcontractkit/chainlink-solana/tree/develop/contracts/programs/store/src) on GitHub.

You can add data feeds to an existing off-chain project or use the Solana
Starter Kit.

## Adding Data Feeds to an existing off-chain project

You can read Chainlink Data Feeds off-chain in your existing project by using
the [Chainlink Solana NPM
library](https://www.npmjs.com/package/@chainlink/solana-sdk).

Reading feed data

Although you can directly query the data feed accounts, you should not rely on
the memory layout always being the same as it currently is. Based on this, the
recommendation is to always use the consumer library.

Install the necessary components and include the example code in your project.
Optionally, you can run the example code by itself to learn how it works
before you integrate it with your project.

  1. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  2. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  3. Change to your project directory or create a new directory.
    
        mkdir off-chain-project && cd off-chain-project

  4. Optionally [install Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to use as a package manager and initialize yarn if your project does not already have a `package.json` file:
    
        npm install -g yarn && yarn init

  5. Add the [Anchor library](https://www.npmjs.com/package/@project-serum/anchor) to your project:

npmyarn

    
        npm i @project-serum/anchor
    
        yarn add @project-serum/anchor

  6. Add the [Chainlink Solana NPM library](https://www.npmjs.com/package/@chainlink/solana-sdk) to your project:

npmyarn

    
        npm i -g @chainlink/solana-sdk
    
        yarn add @chainlink/solana-sdk

  7. Create a temporary Solana wallet to use for this example. Alternatively, if you have an existing wallet that you want to use, locate the path to your [keypair](https://docs.solana.com/terminology#keypair) file and use it as the keypair for the rest of this guide.
    
        solana-keygen new --outfile ./id.json

  8. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and how to get a connection to a Solana cluster. Because this example does not generate or sign any transactions, no lamports are required. The wallet is required only by the Anchor library. For a list of available networks and endpoints, see the [Solana Cluster RPC Endpoints](https://docs.solana.com/cluster/rpc-endpoints) documentation.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  9. Copy the sample code into your project. This example queries price data off-chain. By default, the script reads the SOL/USD feed, but you can change the `CHAINLINK_FEED_ADDRESS` variable to point to the [feed account addresses](/data-feeds/price-feeds/addresses?network=solana) that you want to query. You can take the components of these code samples and integrate them with your existing project. Because these examples read data feeds without making any on-chain changes, no lamports are required to run them.
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const anchor = require(""@project-serum/anchor"")
    const chainlink = require(""@chainlink/solana-sdk"")
    const provider = anchor.AnchorProvider.env()
    
    async function main() {
      anchor.setProvider(provider)
    
      const CHAINLINK_FEED_ADDRESS = ""99B2bTijsU6f1GCT73HmdR7HCFFjGMBcPZY6jZ96ynrR""
      const CHAINLINK_PROGRAM_ID = new anchor.web3.PublicKey(""cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ"")
      const feedAddress = new anchor.web3.PublicKey(CHAINLINK_FEED_ADDRESS) //SOL-USD Devnet Feed
    
      //load the data feed account
      let dataFeed = await chainlink.OCR2Feed.load(CHAINLINK_PROGRAM_ID, provider)
      let listener = null
    
      //listen for events agains the price feed, and grab the latest rounds price data
      listener = dataFeed.onRound(feedAddress, (event) => {
        console.log(event.answer.toNumber())
      })
    
      //block execution and keep waiting for events to be emitted with price data
      await new Promise(function () {})
    }
    
    main().then(
      () => process.exit(),
      (err) => {
        console.error(err)
        process.exit(-1)
      }
    )
    
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    import * as anchor from ""@project-serum/anchor""
    import { OCR2Feed } from ""@chainlink/solana-sdk""
    
    async function main() {
      const provider = anchor.AnchorProvider.env()
      anchor.setProvider(provider)
    
      const CHAINLINK_FEED_ADDRESS = ""99B2bTijsU6f1GCT73HmdR7HCFFjGMBcPZY6jZ96ynrR""
      const CHAINLINK_PROGRAM_ID = new anchor.web3.PublicKey(""cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ"")
      const feedAddress = new anchor.web3.PublicKey(CHAINLINK_FEED_ADDRESS) //SOL-USD Devnet Feed
    
      //load the data feed account
      let dataFeed = await OCR2Feed.load(CHAINLINK_PROGRAM_ID, provider)
      let listener = null
    
      //listen for events agains the price feed, and grab the latest rounds price data
      listener = dataFeed.onRound(feedAddress, (event) => {
        console.log(event.answer.toNumber())
      })
    
      //block execution and keep waiting for events to be emitted with price data
      await new Promise(function () {})
    }
    
    main().then(
      () => process.exit(),
      (err) => {
        console.error(err)
        process.exit(-1)
      }
    )
    

You can run these examples using the following commands:

JavascriptTypescript

    
        node javascript-example.js
    
        yarn add ts-node typescript && yarn ts-node typescript-example.ts

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://book.anchor-lang.com/).

## Using the Solana Starter Kit

This example reads price data from an off-chain client using the [Solana
Starter Kit](https://github.com/smartcontractkit/solana-starter-kit).

### Install the required tools

Before you begin, set up your environment for development on Solana:

  1. Install [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if it is not already configured on your system.

  2. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  3. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  4. [Install Anchor](https://book.anchor-lang.com/getting_started/installation.html). On some operating systems, you might need to build and install Anchor locally. See the [Anchor documentation](https://book.anchor-lang.com/getting_started/installation.html#build-from-source-for-other-operating-systems-without-avm) for instructions.

  5. Install [Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to simplify package management and run code samples in the Starter Kit.
    
        npm install -g yarn

### Run the example program

After you install the required tools, clone the example code from the [solana-
starter-kit](https://github.com/smartcontractkit/solana-starter-kit)
repository.

  1. In a terminal, clone the [solana-starter-kit](https://github.com/smartcontractkit/solana-starter-kit) repository and change to the `solana-starter-kit` directory:
    
        git clone https://github.com/smartcontractkit/solana-starter-kit &&
    cd ./solana-starter-kit

You can see the complete code for the example on
[GitHub](https://github.com/smartcontractkit/solana-starter-kit/).

  2. In the `./solana-starter-kit` directory, install Node.js dependencies defined in the `package.json` file:
    
        yarn install

  3. Create a temporary Solana wallet file to use for this example. Because your application runs off-chain and does not run any functions or alter data on-chain, the wallet does not require any SOL tokens to function.
    
        solana-keygen new --outfile ./id.json

  4. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and Solana cluster to use. Take note that because we are not generating or signing any transactions, the wallet isn't used, it's just required by the Anchor library. For a list of available networks and endpoints, see the [Solana Cluster RPC Endpoints](https://docs.solana.com/cluster/rpc-endpoints) documentation.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  5. Run the example:

JavascriptTypescript

    
        node read-data.js
    
        yarn run read-data

The example code retrieves and prints the current price feed data until you
close the application:

    
        4027000000
    4026439929
    4026476542
    4023000000

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://book.anchor-lang.com/).

## What's next

  * [› Use data feeds on-chain](/data-feeds/solana/using-data-feeds-solana)
  * [› See the available data feeds on Solana](/data-feeds/price-feeds/addresses?network=solana)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/solana/using-data-feeds-off-chain.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Give code examples to demonstrate how to deploy a consumer contract on-chain that reads a data feed and stores the value?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"The contract is governed by English law.
",28-pl,"# Code Examples

  * Overview
  * Reading data feeds on-chain
  * Solidity
  * Vyper
  * Reading data feeds off-chain
  * Javascript
  * Python
  * Golang
  * Getting a different price denomination
  * More Aggregator Functions

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same. To read a
feed, specify the following variables:

  * **RPC endpoint URL:** This determines which network that your smart contracts will run on. You can use a [node provider service](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) or point to your own [client](https://ethereum.org/en/developers/docs/nodes-and-clients/). If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the [Remix IDE](https://remix-project.org/) will automatically detect them for you.
  * **LINK token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
    const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""latestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
    priceFeed.methods
      .latestRoundData()
      .call()
      .then((roundData) => {
        // Do something with roundData
        console.log(""Latest Round Data"", roundData)
      })
    


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const { ethers } = require(""ethers"") // for nodejs only
    const provider = new ethers.providers.JsonRpcProvider(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""latestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new ethers.Contract(addr, aggregatorV3InterfaceABI, provider)
    priceFeed.latestRoundData().then((roundData) => {
      // Do something with roundData
      console.log(""Latest Round Data"", roundData)
    })
    

Latest Price

### Python

This example uses [Web3.py](https://web3py.readthedocs.io/en/stable/) to
retrieve feed data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    from web3 import Web3
    
    # Change this to use your own RPC URL
    web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
    # AggregatorV3Interface ABI
    abi = '[{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""description"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint80"",""name"":""_roundId"",""type"":""uint80""}],""name"":""getRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""latestRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""version"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""}]'
    # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0 <0.8.0`, use
[OpenZeppelin's SafeMath version
3.4](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    /**
     * Network: Sepolia
     * Base: BTC/USD
     * Base Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     * Quote: EUR/USD
     * Quote Address: 0x1a81afB8146aeFfCFc5E50e8479e826E7D55b910
     * Decimals: 8
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract PriceConverter {
        function getDerivedPrice(
            address _base,
            address _quote,
            uint8 _decimals
        ) public view returns (int256) {
            require(
                _decimals > uint8(0) && _decimals <= uint8(18),
                ""Invalid _decimals""
            );
            int256 decimals = int256(10 ** uint256(_decimals));
            (, int256 basePrice, , , ) = AggregatorV3Interface(_base)
                .latestRoundData();
            uint8 baseDecimals = AggregatorV3Interface(_base).decimals();
            basePrice = scalePrice(basePrice, baseDecimals, _decimals);
    
            (, int256 quotePrice, , , ) = AggregatorV3Interface(_quote)
                .latestRoundData();
            uint8 quoteDecimals = AggregatorV3Interface(_quote).decimals();
            quotePrice = scalePrice(quotePrice, quoteDecimals, _decimals);
    
            return (basePrice * decimals) / quotePrice;
        }
    
        function scalePrice(
            int256 _price,
            uint8 _priceDecimals,
            uint8 _decimals
        ) internal pure returns (int256) {
            if (_priceDecimals < _decimals) {
                return _price * int256(10 ** uint256(_decimals - _priceDecimals));
            } else if (_priceDecimals > _decimals) {
                return _price / int256(10 ** uint256(_priceDecimals - _decimals));
            }
            return _price;
        }
    }
    

## More Aggregator Functions

Getting the latest price is not the only data that aggregators can retrieve.
You can also retrieve historical price data. To learn more, see the
[Historical Price Data](/data-feeds/historical-data) page.

To understand different use cases for Chainlink Price Feeds, refer to [Other
Tutorials](/getting-started/other-tutorials).

## What's next

  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/examples.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds on StarkNet

  * Overview
  * Requirements
  * Running the on-chain example
  * Running the off-chain example

StarkNet is a permissionless decentralized ZK-Rollup operating as an L2
network over Ethereum. Unlike other Ethereum L2 networks, StarkNet is not EVM-
compatible and uses [Cairo](https://www.cairo-lang.org/docs/index.html) as its
smart contract language. Chainlink Data Feeds are available on the StarkNet
testnet as Cairo smart contracts.

You can read Chainlink Data Feeds on StarkNet using an on-chain contract that
you compile and deploy. Alternatively, you can read the data feed off-chain
without a StarkNet account. You can complete these steps using only the
[StarkNet CLI
commands](https://docs.starknet.io/documentation/tools/CLI/commands/), but the
example scripts demonstrate how to compile, deploy, and interact with StarkNet
contracts programmatically. [StarkNet.js](https://www.starknetjs.com/),
[HardHat](https://hardhat.org/), and the [StarkNet Hardhat
Plugin](https://shard-labs.github.io/starknet-hardhat-plugin/) simplify the
processes, which normally require you to keep track of your class hashes and
ABI files. See
[https://docs.starknet.io/](https://docs.starknet.io/documentation/getting_started/intro/)
for more information about writing and compiling Cairo contracts for StarkNet.

For a complete list of Chainlink Price Feeds available on StarkNet testnet,
see the [Price Feed Contract Addresses](/data-feeds/price-feeds/addresses?network=starknet) page.

## Requirements

Set up your environment to run the examples.

  * [Set up your local StarkNet environment](https://docs.starknet.io/documentation/getting_started/setting_up_the_environment/). Note that a Python version in the `>=3.6 <=3.9` range is required for compiling and deploying contracts on-chain. The [`cairo-lang` Python package](https://pypi.org/project/cairo-lang/) is not compatible with newer versions of Python as of the [`cairo-lang` 0.10.3](https://pypi.org/project/cairo-lang/0.10.3/) package. Check [starknet.io](https://docs.starknet.io/documentation/getting_started/setting_up_the_environment/) for the latest requirements.

  * [Install NodeJS](https://nodejs.org/en/download/) in the version in the `>=14 <=18` version range.

  * [Install Yarn](https://classic.yarnpkg.com/lang/en/docs/install/).

  * Clone and configure the code examples:

    1. Clone the [smartcontractkit/chainlink-starknet](https://github.com/smartcontractkit/chainlink-starknet) repository, which includes the example contracts for this guide:
        
                git clone https://github.com/smartcontractkit/chainlink-starknet.git

    2. In your clone of the [chainlink-starknet](https://github.com/smartcontractkit/chainlink-starknet) repository, change directories to the proxy consumer example:
        
                cd ./chainlink-starknet/examples/contracts/proxy-consumer/

    3. Run `yarn install` to install the required packages including [StarkNet.js](https://www.starknetjs.com/), [HardHat](https://hardhat.org/), and the [StarkNet Hardhat Plugin](https://shard-labs.github.io/starknet-hardhat-plugin/).
        
                yarn install

  * If you want to run the on-chain examples, you must [set up a StarkNet account](https://docs.starknet.io/documentation/getting_started/account_setup/) on StarkNet's `alpha-goerli` network and fund it with [testnet ETH](https://faucet.goerli.starknet.io/). These examples expect the OpenZeppelin wallet, which stores your addresses and private keys in the following default path:
    
        ~/.starknet_accounts/starknet_open_zeppelin_accounts.json

After you prepare the requirements, check to make sure the required tools are
configured correctly:

  * StarkNet CLI:
    
        starknet -v
    starknet 0.10.3

  * Cairo CLI:
    
        cairo-compile -v
    cairo-compile 0.10.3

  * NodeJS:
    
        node -v
    v18.12.1

  * Yarn:
    
        yarn --version
    1.22.19

## Running the on-chain example

The on-chain [proxy consumer](https://github.com/smartcontractkit/chainlink-starknet/tree/develop/examples/contracts/proxy-consumer/) example uses a local
OpenZeppelin wallet as the account to deploy a contract on-chain. This
contract reads a specified Chainlink data feed and stores the information for
the latest round of data. This example has the following components:

  * The example [Proxy_consumer.cairo](https://github.com/smartcontractkit/chainlink-starknet/tree/develop/examples/contracts/proxy-consumer/contracts/Proxy_consumer.cairo) contract: You will compile and deploy this example contract to the StarkNet Goerli testnet where it can read and store values from one of the [data feed proxy contracts](https://docs.chain.link/data-feeds/price-feeds/addresses?network=starknet). The proxy address is defined in the constructor when you deploy the contract.
  * The [deployConsumer.ts](https://github.com/smartcontractkit/chainlink-starknet/tree/develop/examples/contracts/proxy-consumer/scripts/deployConsumer.ts) script: This script uses [StarkNet.js](https://www.starknetjs.com/) to identify your OpenZeppelin wallet and deploy the compiled contract.
  * The [readLatestRound.ts](https://github.com/smartcontractkit/chainlink-starknet/tree/develop/examples/contracts/proxy-consumer/scripts/readLatestRound.ts) script: This script submits an invoke transaction on the `get_stored_round` function in your contract and prints the result.

Build, deploy, and invoke the example contract:

  1. Find the account address and private key for your funded StarkNet testnet account. By default, the OpenZeppelin wallet contains these values at `~/.starknet_accounts/starknet_open_zeppelin_accounts.json`.

  2. Export your address to the `DEPLOYER_ACCOUNT_ADDRESS` environment variable and your private key to the `DEPLOYER_PRIVATE_KEY` environment variable.
    
        export DEPLOYER_ACCOUNT_ADDRESS=<YOUR_WALLET_ADDRESS>
    
        export DEPLOYER_PRIVATE_KEY=<YOUR_KEY>

  3. In the `./chainlink-starknet/examples/contracts/proxy-consumer/` directory, run `yarn build` to run Hardhat and create `./starknet-artifacts/` with the compiled contracts. The [`@shardlabs/starknet-hardhat-plugin` package](https://www.npmjs.com/package/@shardlabs/starknet-hardhat-plugin) handles the compile step.

  4. Run `yarn deploy` to deploy the example consumer contract to the StarkNet Goerli testnet. The deployment might take several minutes depending on network conditions. The console prints the contract address and transaction hash. Record the contract address.
    
        yarn deploy
    yarn run v1.22.19
    
    Contract address: 0x297d4d4e0dc667c82a452cf809176c50a3e3707408ce39d0f1a1a881d35a83f
    Transaction hash: 0x545bf14dd55447c95065092a142cdf240806a594af39e25fd283e3059131f7d
    Done in 110.04s.

  5. Run `yarn readLatestRound <CONTRACT_ADDRESS>` to send an invoke transaction to the deployed contract. Specify the contract address printed by the deploy step. The deployed contract reads the latest round data from the proxy, stores the values, and prints the resulting values.
    
        yarn readLatestRound 0x297d4d4e0dc667c82a452cf809176c50a3e3707408ce39d0f1a1a881d35a83f
    
    Invoking the get_latest_round_data function.
    Transaction hash: 0x44ce5582f0ae7d144fec2d47ffa879096f7b01a540d7b1d2169aa1fe3798d4f
    Waiting for transaction...
    Transaction status is: NOT_RECEIVED
    Transaction status is: RECEIVED
    Transaction status is: PENDING
    Transaction is: ACCEPTED_ON_L2
    
    Stored values are:
    round_id = 3.402823669209385e+38
    answer = 6
    block_num = 613094
    observation_timestamp = 1673365796
    transmission_timestamp = 1673365809
    Done in 99.10s.

If the invoke request is successful, you can see the stored values in the
[StarkScan testnet explorer](https://testnet.starkscan.co/). Search for your
contract by the address. Under the **Read Contract** tab, run a query on the
`get_stored_round()` method. For example, you can see the [contract
methods](https://testnet.starkscan.co/contract/0x0297d4d4e0dc667c82a452cf809176c50a3e3707408ce39d0f1a1a881d35a83f#read-contract) from the previous output examples.

You can achieve a similar result by running the `starknet-compile`, `starknet
declare`, `starknet deploy`, and `starknet invoke` [CLI
commands](https://docs.starknet.io/documentation/tools/CLI/commands/), but the
scripts are useful for interacting with StarkNet contracts and accounts
programmatically.

## Running the off-chain example

This example reads the proxy contract to get the latest values with no account
or contract compiling steps required. The
[readLatestRoundOffChain.ts](https://github.com/smartcontractkit/chainlink-
starknet/tree/develop/examples/contracts/proxy-consumer/scripts/readLatestRoundOffChain.ts) script uses
[StarkNet.js](https://www.starknetjs.com/) to make a call directly to the data
feed proxy address. By default, the script reads the [LINK / USD
feed](https://testnet.starkscan.co/contract/0x02579940ca3c41e7119283ceb82cd851c906cbb1510908a913d434861fdcb245),
but you can change the address to read any of the [available data
feeds](https://docs.chain.link/data-feeds/price-feeds/addresses?network=starknet) on the StarkNet testnet.

In the `./chainlink-starknet/examples/contracts/proxy-consumer/` directory,
run `yarn readLatestRoundOffChain`.


    yarn readLatestRoundOffChain
    yarn run v1.22.19
    
    round_id = 3.402823669209385e+38
    answer = 6
    block_num = 613151
    observation_timestamp = 1673367749
    transmission_timestamp = 1673367801
    Done in 3.09s.

You can achieve a similar result by running the [`starknet call` CLI
command](https://docs.starknet.io/documentation/tools/CLI/commands/#starknet_call)
and specifying the proxy address, function, and the ABI file for the data feed
proxy contract. For this example, the ABI file is available in the repository,
but you can also generate the ABI yourself from the
[aggregator_proxy.cairo](https://github.com/smartcontractkit/chainlink-starknet/blob/develop/contracts/src/chainlink/cairo/ocr2/aggregator_proxy.cairo)
contract source file.


    starknet call --address 0x2579940ca3c41e7119283ceb82cd851c906cbb1510908a913d434861fdcb245 --function latest_round_data --abi ./contracts/aggregator_proxy_abi.json

The command prints the result:


    0x100000000000000000000000000017c51 6 613174 1673368490 1673368507

## What's next

  * [› Starknet Price Feed Contract Addresses](/data-feeds/price-feeds/addresses?network=starknet)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/starknet/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Deploy Your First Smart Contract

  * Overview
  * Install and fund your MetaMask wallet
  * Write, compile, and deploy your first smart contract
  * Run functions in your contract

You can write your first smart contract and run it in your browser without any
knowledge about Ethereum or blockchains. This guide shows you how easy it is
to develop smart contracts using the [Solidity
language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io)
and the [Remix Development Environment](https://remix.ethereum.org/). You can
use all of these tools in your browser for free with no signup required.

Already know Solidity and have MetaMask configured?

If you are already familiar with how to deploy Smart Contracts and use
MetaMask, you can skip to the [Consuming Data Feeds](/getting-started/consuming-data-feeds) guide to learn how to connect your smart
contracts to Chainlink data feeds.

In general, you create and deploy your smart contracts operate using the
following process:

  1. **Write:** Write a contract to define how the contract functions, what data it can store, what other contracts it interacts with, and what external APIs it might call.

  2. **Compile:** Pass your smart contract code through a compiler to translate the contract into byte code that the blockchain can understand. For example, [Solidity](https://soliditylang.org) code must be compiled before it can run in the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/).

  3. **Deploy:** Send the compiled smart contract to the blockchain. From that point forward, the contract cannot be altered. However, you can still interact with the contract in several ways.

  4. **Run functions:** When you run the functions that you defined for the contract, the network processes those functions and modifies the state of your contract. For some functions, the network charges a small fee to complete the work. Your contract can also have functions that transfer funds to other contracts or wallets.

This guide walks you through each step, but you must install and fund your
MetaMask wallet first.

## Install and fund your MetaMask wallet

Deploying smart contracts on-chain requires a wallet and ETH. The ETH pays for
the work required by the Ethereum network to add the contract to the
blockchain and store the variables. The wallet holds the ETH that you need to
pay for the transaction. Install MetaMask, configure it to use the [Sepolia
testnet](https://sepolia.dev/), and fund your wallet with free testnet ETH.

  1. [Install and configure the MetaMask extension](https://metamask.io/download) in your browser.

  2. After you install the extension, open your browser extension list and click MetaMask to open MetaMask.

  3. Follow the instructions in MetaMask to create a new MetaMask wallet. The new wallet includes a 12-word mnemonic phrase. This phrase is the key to your wallet. Copy that phrase down in a very secure location that only you can access. You can use this phrase to retrieve your wallet later or add it to another browser.

  4. Set MetaMask to use the Sepolia test network.

  5. Choose a Sepolia ETH [faucet](https://faucetlink.to/sepolia) and follow the steps to send testnet ETH to your MetaMask wallet address. You can copy your wallet address by clicking your account name in MetaMask. After the faucet completes the transaction, you should have testnet ETH in your MetaMask wallet on the Sepolia testnet.

Now that you configured your wallet and funded it with testnet ETH, you can
write, compile, and deploy your contract.

## Write, compile, and deploy your first smart contract

Your first contract is a simple `HelloWorld.sol` example. This example shows
you how to set and retrieve variables in a smart contract on-chain.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol) in the Remix IDE. Remix opens and shows the contents of the smart contract. You can modify the code in this editor when you write your own contract.

[ Open in Remix
](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol)
[What is Remix?](/getting-started/conceptual-overview#what-is-remix)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. For this contract, use the default compiler settings. Click the **Compile HelloWorld.sol** button to compile the contract. This converts the contract from Solidity into bytecode that the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/) can understand. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract.

  4. After Remix compiles the contract, deploy it. On the left side of Remix, click the **Deploy and Run** tab to view the deployment settings.

  5. In the deployment settings, select the **Injected Provider** environment. This tells Remix that you want to deploy your contract to the blockchain that you configured in MetaMask. You could optionally use one of the Javascript VM options, but they run in a virtual environment with no connection to an actual blockchain or Chainlink oracles.

  6. Next to the **Deploy** button, enter a message that you want to send with the smart contract when you deploy it. This contract has a constructor that sets an initial message when you deploy the contract.

  7. Click the **Deploy** button to deploy the contract and its initial message to the blockchain network. MetaMask opens and asks you to confirm payment to deploy the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  8. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  9. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  10. Click the `message` variable. Remix retrieves and prints the initial message that you set.

The contract has an address just like your wallet address. If you save this
address, you can return to your deployed contract at any time to retrieve
variables or execute functions. To see details about your deployed contract,
copy the contract address from the list in Remix and search for it in the
[Etherscan Sepolia Testnet Explorer](https://sepolia.etherscan.io/).

## Run functions in your contract

Because you deployed the contract to an actual blockchain, several nodes on
the test network confirmed your payment for the smart contract. The contract,
its variables, and its functions remain in the blockchain permanently. To
change the `message` variable that is stored with your contract, run the
`updateMessage` function.

  1. In your deployed contract, enter a new message next to the `updateMessage` function.

  2. Click the `updateMessage` button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.

  3. In the new MetaMask prompt, click **Confirm** to approve the transaction.

  4. Click the `message` variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

Now you know how to deploy example contracts to a test network and run the
functions in those contracts. You can write your own contracts and test them
using this same process.

Next, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds)
guide to learn how to connect your smart contracts to Chainlink Data Feeds and
retrieve on-chain data that your smart contracts can act on.

## What's next

  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/deploy-your-first-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Write code to show how to use web3.js to retrieve feed data from a price feed?,"/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
    name: ""getRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""latestRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""version"",
    outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
]
const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log(""Latest Round Data"", roundData)
  })",,"To retrieve feed data from a price feed using web3.js, you can use the following code:

```javascript
const Web3 = require('web3');
const web3 = new Web3('https://rpc.ankr.com/eth_sepolia');

const aggregatorV3InterfaceABI = [
  // ABI code here
];

const addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43';
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr);

priceFeed.methods.latestRoundData().call()
  .then((roundData) => {
    // Do something with roundData
    console.log('Latest Round Data', roundData);
  });
```

","
- [Chainlink Data Feeds Examples](https://docs.chain.link/data-feeds/examples/)
- [Using Data Feeds Off-Chain (Solana)](https://docs.chain.link/data-feeds/solana/using-data-feeds-off-chain/)","# Code Examples

  * Overview
  * Reading data feeds on-chain
  * Solidity
  * Vyper
  * Reading data feeds off-chain
  * Javascript
  * Python
  * Golang
  * Getting a different price denomination
  * More Aggregator Functions

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same. To read a
feed, specify the following variables:

  * **RPC endpoint URL:** This determines which network that your smart contracts will run on. You can use a [node provider service](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) or point to your own [client](https://ethereum.org/en/developers/docs/nodes-and-clients/). If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the [Remix IDE](https://remix-project.org/) will automatically detect them for you.
  * **LINK token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
    const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""latestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
    priceFeed.methods
      .latestRoundData()
      .call()
      .then((roundData) => {
        // Do something with roundData
        console.log(""Latest Round Data"", roundData)
      })
    


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const { ethers } = require(""ethers"") // for nodejs only
    const provider = new ethers.providers.JsonRpcProvider(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""latestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new ethers.Contract(addr, aggregatorV3InterfaceABI, provider)
    priceFeed.latestRoundData().then((roundData) => {
      // Do something with roundData
      console.log(""Latest Round Data"", roundData)
    })
    

Latest Price

### Python

This example uses [Web3.py](https://web3py.readthedocs.io/en/stable/) to
retrieve feed data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    from web3 import Web3
    
    # Change this to use your own RPC URL
    web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
    # AggregatorV3Interface ABI
    abi = '[{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""description"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint80"",""name"":""_roundId"",""type"":""uint80""}],""name"":""getRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""latestRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""version"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""}]'
    # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0 <0.8.0`, use
[OpenZeppelin's SafeMath version
3.4](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/math/SafeMath.sol).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    /**
     * Network: Sepolia
     * Base: BTC/USD
     * Base Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     * Quote: EUR/USD
     * Quote Address: 0x1a81afB8146aeFfCFc5E50e8479e826E7D55b910
     * Decimals: 8
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract PriceConverter {
        function getDerivedPrice(
            address _base,
            address _quote,
            uint8 _decimals
        ) public view returns (int256) {
            require(
                _decimals > uint8(0) && _decimals <= uint8(18),
                ""Invalid _decimals""
            );
            int256 decimals = int256(10 ** uint256(_decimals));
            (, int256 basePrice, , , ) = AggregatorV3Interface(_base)
                .latestRoundData();
            uint8 baseDecimals = AggregatorV3Interface(_base).decimals();
            basePrice = scalePrice(basePrice, baseDecimals, _decimals);
    
            (, int256 quotePrice, , , ) = AggregatorV3Interface(_quote)
                .latestRoundData();
            uint8 quoteDecimals = AggregatorV3Interface(_quote).decimals();
            quotePrice = scalePrice(quotePrice, quoteDecimals, _decimals);
    
            return (basePrice * decimals) / quotePrice;
        }
    
        function scalePrice(
            int256 _price,
            uint8 _priceDecimals,
            uint8 _decimals
        ) internal pure returns (int256) {
            if (_priceDecimals < _decimals) {
                return _price * int256(10 ** uint256(_decimals - _priceDecimals));
            } else if (_priceDecimals > _decimals) {
                return _price / int256(10 ** uint256(_priceDecimals - _decimals));
            }
            return _price;
        }
    }
    

## More Aggregator Functions

Getting the latest price is not the only data that aggregators can retrieve.
You can also retrieve historical price data. To learn more, see the
[Historical Price Data](/data-feeds/historical-data) page.

To understand different use cases for Chainlink Price Feeds, refer to [Other
Tutorials](/getting-started/other-tutorials).

## What's next

  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/examples.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds Off-Chain (Solana)

  * Overview
  * The Chainlink Data Feeds Store Program
  * Adding Data Feeds to an existing off-chain project
  * Using the Solana Starter Kit
  * Install the required tools
  * Run the example program

Chainlink Data Feeds are the quickest way to access market prices for real-
world assets. This guide demonstrates how to read Chainlink Data Feeds on the
Solana Devnet using off-chain examples in the [Chainlink Solana Starter
Kit](https://github.com/smartcontractkit/solana-starter-kit). To learn how to
use Data Feeds in your on-chain Solana programs, see the [Using Data Feeds On-
Chain](/data-feeds/solana/using-data-feeds-solana) guide.

To get the full list of Chainlink Data Feeds on Solana, see the [Solana
Feeds](/data-feeds/price-feeds/addresses?network=solana) page.

Select quality data feeds

Be aware of the quality of the data that you use. [Learn more about making
responsible data quality decisions](/data-feeds/selecting-data-feeds).

## The Chainlink Data Feeds Store Program

The program that contains the logic required for the storing and retrieval of
Chainlink Data Feeds data on both Devnet and Mainnet is
[cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ](https://solscan.io/account/cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ?cluster=devnet).
This is the program ID that you use to read price data from off-chain. You can
find the source code for this program in the [smartcontractkit/chainlink-
solana](https://github.com/smartcontractkit/chainlink-solana/tree/develop/contracts/programs/store/src) on GitHub.

You can add data feeds to an existing off-chain project or use the Solana
Starter Kit.

## Adding Data Feeds to an existing off-chain project

You can read Chainlink Data Feeds off-chain in your existing project by using
the [Chainlink Solana NPM
library](https://www.npmjs.com/package/@chainlink/solana-sdk).

Reading feed data

Although you can directly query the data feed accounts, you should not rely on
the memory layout always being the same as it currently is. Based on this, the
recommendation is to always use the consumer library.

Install the necessary components and include the example code in your project.
Optionally, you can run the example code by itself to learn how it works
before you integrate it with your project.

  1. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  2. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  3. Change to your project directory or create a new directory.
    
        mkdir off-chain-project && cd off-chain-project

  4. Optionally [install Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to use as a package manager and initialize yarn if your project does not already have a `package.json` file:
    
        npm install -g yarn && yarn init

  5. Add the [Anchor library](https://www.npmjs.com/package/@project-serum/anchor) to your project:

npmyarn

    
        npm i @project-serum/anchor
    
        yarn add @project-serum/anchor

  6. Add the [Chainlink Solana NPM library](https://www.npmjs.com/package/@chainlink/solana-sdk) to your project:

npmyarn

    
        npm i -g @chainlink/solana-sdk
    
        yarn add @chainlink/solana-sdk

  7. Create a temporary Solana wallet to use for this example. Alternatively, if you have an existing wallet that you want to use, locate the path to your [keypair](https://docs.solana.com/terminology#keypair) file and use it as the keypair for the rest of this guide.
    
        solana-keygen new --outfile ./id.json

  8. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and how to get a connection to a Solana cluster. Because this example does not generate or sign any transactions, no lamports are required. The wallet is required only by the Anchor library. For a list of available networks and endpoints, see the [Solana Cluster RPC Endpoints](https://docs.solana.com/cluster/rpc-endpoints) documentation.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  9. Copy the sample code into your project. This example queries price data off-chain. By default, the script reads the SOL/USD feed, but you can change the `CHAINLINK_FEED_ADDRESS` variable to point to the [feed account addresses](/data-feeds/price-feeds/addresses?network=solana) that you want to query. You can take the components of these code samples and integrate them with your existing project. Because these examples read data feeds without making any on-chain changes, no lamports are required to run them.
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const anchor = require(""@project-serum/anchor"")
    const chainlink = require(""@chainlink/solana-sdk"")
    const provider = anchor.AnchorProvider.env()
    
    async function main() {
      anchor.setProvider(provider)
    
      const CHAINLINK_FEED_ADDRESS = ""99B2bTijsU6f1GCT73HmdR7HCFFjGMBcPZY6jZ96ynrR""
      const CHAINLINK_PROGRAM_ID = new anchor.web3.PublicKey(""cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ"")
      const feedAddress = new anchor.web3.PublicKey(CHAINLINK_FEED_ADDRESS) //SOL-USD Devnet Feed
    
      //load the data feed account
      let dataFeed = await chainlink.OCR2Feed.load(CHAINLINK_PROGRAM_ID, provider)
      let listener = null
    
      //listen for events agains the price feed, and grab the latest rounds price data
      listener = dataFeed.onRound(feedAddress, (event) => {
        console.log(event.answer.toNumber())
      })
    
      //block execution and keep waiting for events to be emitted with price data
      await new Promise(function () {})
    }
    
    main().then(
      () => process.exit(),
      (err) => {
        console.error(err)
        process.exit(-1)
      }
    )
    
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    import * as anchor from ""@project-serum/anchor""
    import { OCR2Feed } from ""@chainlink/solana-sdk""
    
    async function main() {
      const provider = anchor.AnchorProvider.env()
      anchor.setProvider(provider)
    
      const CHAINLINK_FEED_ADDRESS = ""99B2bTijsU6f1GCT73HmdR7HCFFjGMBcPZY6jZ96ynrR""
      const CHAINLINK_PROGRAM_ID = new anchor.web3.PublicKey(""cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ"")
      const feedAddress = new anchor.web3.PublicKey(CHAINLINK_FEED_ADDRESS) //SOL-USD Devnet Feed
    
      //load the data feed account
      let dataFeed = await OCR2Feed.load(CHAINLINK_PROGRAM_ID, provider)
      let listener = null
    
      //listen for events agains the price feed, and grab the latest rounds price data
      listener = dataFeed.onRound(feedAddress, (event) => {
        console.log(event.answer.toNumber())
      })
    
      //block execution and keep waiting for events to be emitted with price data
      await new Promise(function () {})
    }
    
    main().then(
      () => process.exit(),
      (err) => {
        console.error(err)
        process.exit(-1)
      }
    )
    

You can run these examples using the following commands:

JavascriptTypescript

    
        node javascript-example.js
    
        yarn add ts-node typescript && yarn ts-node typescript-example.ts

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://book.anchor-lang.com/).

## Using the Solana Starter Kit

This example reads price data from an off-chain client using the [Solana
Starter Kit](https://github.com/smartcontractkit/solana-starter-kit).

### Install the required tools

Before you begin, set up your environment for development on Solana:

  1. Install [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if it is not already configured on your system.

  2. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  3. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  4. [Install Anchor](https://book.anchor-lang.com/getting_started/installation.html). On some operating systems, you might need to build and install Anchor locally. See the [Anchor documentation](https://book.anchor-lang.com/getting_started/installation.html#build-from-source-for-other-operating-systems-without-avm) for instructions.

  5. Install [Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to simplify package management and run code samples in the Starter Kit.
    
        npm install -g yarn

### Run the example program

After you install the required tools, clone the example code from the [solana-
starter-kit](https://github.com/smartcontractkit/solana-starter-kit)
repository.

  1. In a terminal, clone the [solana-starter-kit](https://github.com/smartcontractkit/solana-starter-kit) repository and change to the `solana-starter-kit` directory:
    
        git clone https://github.com/smartcontractkit/solana-starter-kit &&
    cd ./solana-starter-kit

You can see the complete code for the example on
[GitHub](https://github.com/smartcontractkit/solana-starter-kit/).

  2. In the `./solana-starter-kit` directory, install Node.js dependencies defined in the `package.json` file:
    
        yarn install

  3. Create a temporary Solana wallet file to use for this example. Because your application runs off-chain and does not run any functions or alter data on-chain, the wallet does not require any SOL tokens to function.
    
        solana-keygen new --outfile ./id.json

  4. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and Solana cluster to use. Take note that because we are not generating or signing any transactions, the wallet isn't used, it's just required by the Anchor library. For a list of available networks and endpoints, see the [Solana Cluster RPC Endpoints](https://docs.solana.com/cluster/rpc-endpoints) documentation.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  5. Run the example:

JavascriptTypescript

    
        node read-data.js
    
        yarn run read-data

The example code retrieves and prints the current price feed data until you
close the application:

    
        4027000000
    4026439929
    4026476542
    4023000000

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://book.anchor-lang.com/).

## What's next

  * [› Use data feeds on-chain](/data-feeds/solana/using-data-feeds-solana)
  * [› See the available data feeds on Solana](/data-feeds/price-feeds/addresses?network=solana)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/solana/using-data-feeds-off-chain.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the LINK token contract on ethereum mainnet?,0x514910771AF9Ca656af840dff83E8264EcF986CA,,"The state/country's law that governs the interpretation of the contract is English law.
",28-pl,"# Making flexible, secure, and low-cost contracts

  * Overview
  * Prerequisites
  * Problem: On-chain computation leads to high gas fees
  * Solution: Perform complex computations with no gas fees
  * Conclusion

In this guide, you will learn how the flexibility of [Chainlink
Automation](https://chain.link/automation) enables important design patterns
that reduce gas fees, enhance the resilience of dApps, and improve end-user
experience. Smart contracts themselves cannot self-trigger their functions at
arbitrary times or under arbitrary conditions. Transactions can only be
initiated by another account.

Start by integrating an example contract to Chainlink Automation that has not
yet been optimized. Then, deploy a comparison contract that shows you how to
properly use the flexibility of Chainlink Automation to perform complex
computations without paying high gas fees.

## Prerequisites

This guide assumes you have a basic understanding of [Chainlink
Automation](https://chain.link/keepers). If you are new to Keepers, complete
the following guides first:

  * Know how to [deploy solidity contracts using Remix and Metamask](/getting-started/deploy-your-first-contract)
  * Learn how to make [compatible contracts](/chainlink-automation/compatible-contracts)
  * [Register UpKeep for a Contract](/chainlink-automation/register-upkeep)

Chainlink Automation is supported on several [networks](/chainlink-automation/supported-networks).

ERC677 Link

  * Get [LINK](/resources/link-token-contracts) on the supported testnet that you want to use.
  * For funding on Mainnet, you need ERC-677 LINK. Many token bridges give you ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be ERC-677 compatible](https://pegswap.chain.link/).

## Problem: On-chain computation leads to high gas fees

In the guide for [Creating Compatible Contracts](/chainlink-automation/compatible-contracts), you deployed a basic [counter
contract](/chainlink-automation/compatible-contracts/#example-contract) and
verified that the counter increments every 30 seconds. However, more complex
use cases can require looping over arrays or performing expensive computation.
This leads to expensive gas fees and can increase the premium that end-users
have to pay to use your dApp. To illustrate this, deploy an example contract
that maintains internal balances.

The contract has the following components:

  * A fixed-size(1000) array `balances` with each element of the array starting with a balance of 1000.
  * The `withdraw()` function decreases the balance of one or more indexes in the `balances` array. Use this to simulate changes to the balance of each element in the array.
  * Automation Nodes are responsible for regularly re-balancing the elements using two functions: 
    * The `checkUpkeep()` function checks if the contract requires work to be done. If one array element has a balance of less than `LIMIT`, the function returns `upkeepNeeded == true`.
    * The `performUpkeep()` function to re-balances the elements. To demonstrate how this computation can cause high gas fees, this example does all of the computation within the transaction. The function finds all of the elements that are less than `LIMIT`, decreases the contract `liquidity`, and increases every found element to equal `LIMIT`.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol"";
    
    /**
     * @dev Example contract which perform all the computation in `performUpkeep`
     * @notice important to implement {AutomationCompatibleInterface}
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract BalancerOnChain is AutomationCompatibleInterface {
        uint256 public constant SIZE = 1000;
        uint256 public constant LIMIT = 1000;
        uint256[SIZE] public balances;
        uint256 public liquidity = 1000000;
    
        constructor() {
            // On the initialization of the contract, all the elements have a balance equal to the limit
            for (uint256 i = 0; i < SIZE; i++) {
                balances[i] = LIMIT;
            }
        }
    
        /// @dev called to increase the liquidity of the contract
        function addLiquidity(uint256 liq) public {
            liquidity += liq;
        }
    
        /// @dev withdraw an `amount`from multiple elements of `balances` array. The elements are provided in `indexes`
        function withdraw(uint256 amount, uint256[] memory indexes) public {
            for (uint256 i = 0; i < indexes.length; i++) {
                require(indexes[i] < SIZE, ""Provided index out of bound"");
                balances[indexes[i]] -= amount;
            }
        }
    
        /// @dev this method is called by the Automation Nodes to check if `performUpkeep` should be performed
        function checkUpkeep(
            bytes calldata /* checkData */
        )
            external
            view
            override
            returns (bool upkeepNeeded, bytes memory performData)
        {
            upkeepNeeded = false;
            for (uint256 i = 0; i < SIZE && !upkeepNeeded; i++) {
                if (balances[i] < LIMIT) {
                    // if one element has a balance < LIMIT then rebalancing is needed
                    upkeepNeeded = true;
                }
            }
            return (upkeepNeeded, """");
        }
    
        /// @dev this method is called by the Automation Nodes. it increases all elements which balances are lower than the LIMIT
        function performUpkeep(bytes calldata /* performData */) external override {
            uint256 increment;
            uint256 _balance;
            for (uint256 i = 0; i < SIZE; i++) {
                _balance = balances[i];
                // best practice: reverify the upkeep is needed
                if (_balance < LIMIT) {
                    // calculate the increment needed
                    increment = LIMIT - _balance;
                    // decrease the contract liquidity accordingly
                    liquidity -= increment;
                    // rebalance the element
                    balances[i] = LIMIT;
                }
            }
        }
    }
    

Test this example using the following steps:

  1. Deploy the contract using Remix on the [supported testnet](/chainlink-automation/supported-networks) of your choice.

  2. Before registering the upkeep for your contract, decrease the balances of some elements. This simulates a situation where upkeep is required. In Remix, Withdraw 100 at indexes 10,100,300,350,500,600,670,700,900. Pass `100,[10,100,300,350,500,600,670,700,900]` to the withdraw function:

You can also perform this step after registering the upkeep if you need to.

  3. Register the upkeep for your contract as explained [here](/chainlink-automation/register-upkeep). Because this example has high gas requirements, specify the maximum allowed gas limit of `2,500,000`.

  4. After the registration is confirmed, Automation Nodes perform the upkeep.

  5. Click the transaction hash to see the transaction details in Etherscan. You can find how much gas was used in the upkeep transaction.

In this example, the `performUpkeep()` function used **2,481,379** gas. This
example has two main issues:

  * All computation is done in `performUpkeep()`. This is a state modifying function which leads to high gas consumption.
  * This example is simple, but looping over large arrays with state updates can cause the transaction to hit the gas limit of the [network](/chainlink-automation/supported-networks), which prevents `performUpkeep` from running successfully.

To reduce these gas fees and avoid running out of gas, you can make some
simple changes to the contract.

## Solution: Perform complex computations with no gas fees

Modify the contract and move the computation to the `checkUpkeep()` function.
This computation _doesn’t consume any gas_ and supports multiple upkeeps for
the same contract to do the work in parallel. The main difference between this
new contract and the previous contract are:

  * The `checkUpkeep()` function receives [`checkData`](/chainlink-automation/compatible-contracts/#checkdata), which passes arbitrary bytes to the function. Pass a `lowerBound` and an `upperBound` to scope the work to a sub-array of `balances`. This creates several upkeeps with different values of `checkData`. The function loops over the sub-array and looks for the indexes of the elements that require re-balancing and calculates the required `increments`. Then, it returns `upkeepNeeded == true` and `performData`, which is calculated by encoding `indexes` and `increments`. Note that `checkUpkeep()` is a view function, so computation does not consume any gas.
  * The `performUpkeep()` function takes [performData](/chainlink-automation/compatible-contracts/#performdata-1) as a parameter and decodes it to fetch the `indexes` and the `increments`.

Note on performData

This data should always be validated against the contract’s current state to
ensure that `performUpkeep()` is idempotent. It also blocks malicious
Automation Nodes from sending non-valid data. This example, tests that the
state is correct after re-balancing: `require(_balance == LIMIT, ""Provided
increment not correct"");`


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol"";
    
    /**
     * @dev Example contract which perform most of the computation in `checkUpkeep`
     *
     * @notice important to implement {AutomationCompatibleInterface}
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract BalancerOffChain is AutomationCompatibleInterface {
        uint256 public constant SIZE = 1000;
        uint256 public constant LIMIT = 1000;
        uint256[SIZE] public balances;
        uint256 public liquidity = 1000000;
    
        constructor() {
            // On the initialization of the contract, all the elements have a balance equal to the limit
            for (uint256 i = 0; i < SIZE; i++) {
                balances[i] = LIMIT;
            }
        }
    
        /// @dev called to increase the liquidity of the contract
        function addLiquidity(uint256 liq) public {
            liquidity += liq;
        }
    
        /// @dev withdraw an `amount`from multiple elements of the `balances` array. The elements are provided in `indexes`
        function withdraw(uint256 amount, uint256[] memory indexes) public {
            for (uint256 i = 0; i < indexes.length; i++) {
                require(indexes[i] < SIZE, ""Provided index out of bound"");
                balances[indexes[i]] -= amount;
            }
        }
    
        /* @dev this method is called by the Chainlink Automation Nodes to check if `performUpkeep` must be done. Note that `checkData` is used to segment the computation to subarrays.
         *
         *  @dev `checkData` is an encoded binary data and which contains the lower bound and upper bound on which to perform the computation
         *
         *  @dev return `upkeepNeeded`if rebalancing must be done and `performData` which contains an array of indexes that require rebalancing and their increments. This will be used in `performUpkeep`
         */
        function checkUpkeep(
            bytes calldata checkData
        )
            external
            view
            override
            returns (bool upkeepNeeded, bytes memory performData)
        {
            // perform the computation to a subarray of `balances`. This opens the possibility of having several checkUpkeeps done at the same time
            (uint256 lowerBound, uint256 upperBound) = abi.decode(
                checkData,
                (uint256, uint256)
            );
            require(
                upperBound < SIZE && lowerBound < upperBound,
                ""Lowerbound and Upperbound not correct""
            );
            // first get number of elements requiring updates
            uint256 counter;
            for (uint256 i = 0; i < upperBound - lowerBound + 1; i++) {
                if (balances[lowerBound + i] < LIMIT) {
                    counter++;
                }
            }
            // initialize array of elements requiring increments as long as the increments
            uint256[] memory indexes = new uint256[](counter);
            uint256[] memory increments = new uint256[](counter);
    
            upkeepNeeded = false;
            uint256 indexCounter;
    
            for (uint256 i = 0; i < upperBound - lowerBound + 1; i++) {
                if (balances[lowerBound + i] < LIMIT) {
                    // if one element has a balance < LIMIT then rebalancing is needed
                    upkeepNeeded = true;
                    // store the index which needs increment as long as the increment
                    indexes[indexCounter] = lowerBound + i;
                    increments[indexCounter] = LIMIT - balances[lowerBound + i];
                    indexCounter++;
                }
            }
            performData = abi.encode(indexes, increments);
            return (upkeepNeeded, performData);
        }
    
        /* @dev this method is called by the Automation Nodes. it increases all elements whose balances are lower than the LIMIT. Note that the elements are bounded by `lowerBound`and `upperBound`
         *  (provided by `performData`
         *
         *  @dev `performData` is an encoded binary data which contains the lower bound and upper bound of the subarray on which to perform the computation.
         *  it also contains the increments
         *
         *  @dev return `upkeepNeeded`if rebalancing must be done and `performData` which contains an array of increments. This will be used in `performUpkeep`
         */
        function performUpkeep(bytes calldata performData) external override {
            (uint256[] memory indexes, uint256[] memory increments) = abi.decode(
                performData,
                (uint256[], uint256[])
            );
            // important to always check that the data provided by the Automation Node is not corrupted.
            require(
                indexes.length == increments.length,
                ""indexes and increments arrays' lengths not equal""
            );
    
            uint256 _balance;
            uint256 _liquidity = liquidity;
    
            for (uint256 i = 0; i < indexes.length; i++) {
                _balance = balances[indexes[i]] + increments[i];
                // important to always check that the data provided by the Automation Nodes is not corrupted. Here we check that after rebalancing, the balance of the element is equal to the LIMIT
                require(_balance == LIMIT, ""Provided increment not correct"");
                _liquidity -= increments[i];
                balances[indexes[i]] = _balance;
            }
            liquidity = _liquidity;
        }
    }
    

Run this example to compare the gas fees:

  1. Deploy the contract using Remix on the [supported testnet](/chainlink-automation/supported-networks) of your choice.

  2. Withdraw 100 at 10,100,300,350,500,600,670,700,900. Pass `100,[10,100,300,350,500,600,670,700,900]` to the withdraw function the same way that you did for the previous example.

  3. Register three upkeeps for your contract as explained [here](/chainlink-automation/register-upkeep). Because the Automation Nodes handle much of the computation off-chain, a gas limit of 200,000 is sufficient. For each registration, pass the following `checkData` values to specify which balance indexes the registration will monitor. **Note** : You must remove any breaking line when copying the values.

Upkeep Name| CheckData(base16)| Remark: calculated using
[`abi.encode()`](https://docs.soliditylang.org/en/develop/abi-spec.html#strict-encoding-mode)  
---|---|---  
balancerOffChainSubset1| 0x000000000000000000000000  
00000000000000000000000000  
00000000000000000000000000  
00000000000000000000000000  
0000000000000000000000014c| lowerBound: 0  
upperBound: 332  
balancerOffChainSubset2| 0x000000000000000000000000  
00000000000000000000000000  
0000000000014d000000000000  
00000000000000000000000000  
0000000000000000000000029a| lowerBound: 333  
upperBound: 666  
balancerOffChainSubset3| 0x000000000000000000000000  
00000000000000000000000000  
0000000000029b000000000000  
00000000000000000000000000  
000000000000000000000003e7| lowerBound: 667  
upperBound: 999  
  4. After the registration is confirmed, the three upkeeps run:

  5. Click each transaction hash to see the details of each transaction in Etherscan. Find the gas used by each of the upkeep transactions:

In this example the total gas used by each `performUpkeep()` function was
133,464 + 133,488 + 133,488 = **400,440**. This is an improvement of about 84%
compared to the previous example, which used **2,481,379** gas.

## Conclusion

Using Chainlink Automation efficiently not only allows you to reduce the gas
fees, but also keeps them within predictable limits. That’s the reason why
[several Defi protocols](https://chainlinktoday.com/prominent-founders-examine-chainlink-keepers-role-in-defis-evolution/) outsource their
maintenance tasks to Chainlink Automation.

## What's next

  * [› Example Contracts](/chainlink-automation/util-overview/)
  * [› FAQs](/chainlink-automation/faqs/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/flexible-upkeeps.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# LINK Token Contracts

  * Overview
  * Ethereum
  * Ethereum Mainnet
  * Sepolia testnet
  * Goerli testnet
  * BNB Chain
  * BNB Chain mainnet
  * BNB Chain testnet
  * Polygon (Matic)
  * Polygon mainnet
  * Mumbai testnet
  * RSK
  * RSK mainnet
  * Gnosis Chain (xDai)
  * Gnosis Chain mainnet
  * Avalanche
  * Avalanche mainnet
  * Fuji testnet
  * Fantom
  * Fantom mainnet
  * Fantom testnet
  * Arbitrum
  * Arbitrum mainnet
  * Arbitrum Goerli testnet
  * Optimism
  * Optimism mainnet
  * Optimism Goerli testnet
  * Harmony
  * Harmony mainnet
  * Moonriver
  * Moonriver mainnet
  * Moonbeam
  * Moonbeam mainnet
  * Metis
  * Andromeda mainnet
  * BASE
  * BASE Goerli testnet

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=Contracts) to talk to an expert
about the networks that support the LINK token.

LINK tokens are used to pay node operators for retrieving data for smart
contracts and also for deposits placed by node operators as required by
contract creators. The smallest denomination of LINK is called a Juel, and
1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to
Wei, which is the [smallest denomination of
ETH](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations).

The LINK token is an ERC677 token that inherits functionality from the ERC20
token standard and allows token transfers to contain a data payload. Read more
about the [ERC677 transferAndCall token
standard](https://github.com/ethereum/EIPs/issues/677).

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

## Ethereum

### Ethereum Mainnet

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1                                          |
| Address        | 0x514910771AF9Ca656af840dff83E8264EcF986CA |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | ethstats.dev                               |
### Sepolia testnet

Testnet LINK and ETH are available at
[faucets.chain.link](https://faucets.chain.link/sepolia). Testnet ETH is also
available from several public [faucets](https://faucetlink.to/sepolia).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 11155111                                   |
| Address      | 0x779877A7B0D9E8603169DdbD7836e478b4624789 |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
### Goerli testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 5                                          |
| Address      | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## BNB Chain

### BNB Chain mainnet

BNB is used to pay for transactions on the BNB Chain mainnet.

ERC-677 LINK on BNB Chain

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
you cannot use it with Chainlink services or oracle nodes. Use the
[**Chainlink PegSwap service**](https://pegswap.chain.link/) to convert
bridged LINK to the official ERC-677 LINK token on BNB Chain.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 56                                         |
| Address        | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75 |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | bscscan.freshstatus.io                     |
### BNB Chain testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/chapel). Testnet BNB is
availalbe at [testnet.binance.org/faucet-
smart](https://testnet.binance.org/faucet-smart).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 97                                         |
| Address      | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06 |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Polygon (Matic)

### Polygon mainnet

MATIC is used to pay for transactions on Polygon. You can use the [Polygon
Bridge](https://wallet.polygon.technology/polygon/bridge/) to transfer tokens
to Polygon mainnet and then use [Polygon Gas
Swap](https://wallet.polygon.technology/polygon/gas-swap/) to swap supported
tokens to MATIC.

ERC-677 LINK on Polygon

The LINK provided by the [Polygon (Matic)
Bridge](https://wallet.polygon.technology/polygon/bridge/) is not ERC-677
compatible, so you cannot use it with Chainlink services or oracle nodes. Use
the [**Chainlink PegSwap service**](https://pegswap.chain.link/) to convert
bridged LINK to the official ERC-677 LINK token on Polygon.

Watch the [Moving Chainlink Cross-
Chains](https://www.youtube.com/watch?v=WKvIGkBWRUA) video to learn more.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 137                                        |
| Address        | 0xb0897686c545045aFc77CF20eC7A532E3120E0F1 |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | polygon.io/system                          |
### Mumbai testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/mumbai). Testnet MATIC is
available at the [Polygon faucet](https://faucet.polygon.technology/).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 80001                                      |
| Address      | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## RSK

### RSK mainnet

RBTC is used to pay for transactions on RSK mainnet. Use [RSK’s built in
PowPeg](https://developers.rsk.co/guides/get-crypto-on-rsk/powpeg-btc-rbtc/)
to transfer BTC to RSK mainnet as RBTC. You can use the [RSK
bridge](https://tokenbridge.rsk.co/) to send LINK from Ethereum Mainnet to
RSK.

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 30                                         |
| Address      | 0x14ADAE34beF7Ca957ce2DDe5AdD97EA050123827 |
| Name         | rLINK                                      |
| Symbol       | rLINK                                      |
| Decimals     | 18                                         |
## Gnosis Chain (xDai)

### Gnosis Chain mainnet

xDAI is used to pay for transactions on Gnosis Chain mainnet. Use the [xDai
Bridge](https://bridge.gnosischain.com/) to send DAI from Ethereum Mainnet to
Gnosis Chain and convert it to xDAI. Use
[OmniBridge](https://omni.gnosischain.com/bridge) to send LINK from Ethereum
Mainnet to Gnosis Chain.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 100                                        |
| Address        | 0xE2e73A1c69ecF83F464EFCE6A5be353a37cA09b2 |
| Name           | Chainlink Token on Gnosis Chain (xDai)     |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | gnosisscan.io                              |
## Avalanche

### Avalanche mainnet

AVAX is the token you use to pay for transactions on Avalanche mainnet. Use
the [Avalanche Bridge](https://bridge.avax.network/) to transfer LINK from
Ethereum Mainnet to Avalanche.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 43114                                      |
| Address        | 0x5947BB275c521040051D82396192181b413227A3 |
| Name           | Chainlink Token on Avalanche               |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | status.avax.network                        |
### Fuji testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/fuji). Testnet AVAX is
available at [faucet.avax.network](https://faucet.avax.network/).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 43113                                      |
| Address      | 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846 |
| Name         | Chainlink Token on Avalanche               |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Fantom

### Fantom mainnet

FTM is used to pay for transactions on Fantom Mainnet. Use
[bridge.multichain.org](https://bridge.multichain.org/#/router) to transfer
FTM and LINK to Fantom mainnet.

ERC-677 LINK on Fantom

You must use ERC-677 LINK on Fantom. ERC-20 LINK will not work with Chainlink
services. When you use
[bridge.multichain.org](https://bridge.multichain.org/#/router) to send LINK
to the Fantom network, be sure to select LINK-ERC677 as the token you will
receive on Fantom mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 250                                        |
| Address        | 0x6F43FF82CCA38001B6699a8AC47A2d0E66939407 |
| Name           | Chainlink Token on Fantom                  |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | ftmscan.com                                |
### Fantom testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/fantom-testnet). Testnet FTM
is available at [faucet.fantom.network](https://faucet.fantom.network/).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 4002                                       |
| Address      | 0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F |
| Name         | Chainlink Token on Fantom                  |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Arbitrum

### Arbitrum mainnet

ETH is used to pay for transactions on the Arbitrum mainnet. You can use the
[Arbitrum Bridge](https://bridge.arbitrum.io/) to transfer ETH and LINK to
from Ethereum Mainnet to Arbitrum.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 42161                                      |
| Address        | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4 |
| Name           | Chainlink Token on Arbitrum Mainnet        |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | arbiscan.freshstatus.io                    |
### Arbitrum Goerli testnet

Testnet ETH is used to pay for transactions on Arbitrum Goerli. Use the
[Arbitrum Bridge](https://bridge.arbitrum.io/) to transfer testnet ETH and
LINK from Ethereum Goerli to Arbitrum Goerli. Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 421613                                     |
| Address      | 0xd14838A68E8AFBAdE5efb411d5871ea0011AFd28 |
| Name         | Chainlink Token on Arbitrum Goerli         |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Optimism

### Optimism mainnet

ETH is used to pay for transactions on Optimism. Use the [Optimism
Bridge](https://app.optimism.io/bridge) to transfer ETH and LINK from Ethereum
Mainnet to Optimism mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 10                                         |
| Address        | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 |
| Name           | Chainlink Token on Optimism Mainnet        |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | status.optimism.io                         |
### Optimism Goerli testnet

Testnet ETH is used to pay for transactions on Optimism. Use the [Optimism
Bridge](https://app.optimism.io/bridge) to transfer testnet ETH and LINK from
Ethereum Goerli to Optimistim Goerli. Select Optimism Goerli in your wallet to
access the Optimism Goerli bridge. Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 420                                        |
| Address      | 0xdc2CC710e42857672E7907CF474a69B63B93089f |
| Name         | Chainlink Token on Optimism Goerli         |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Harmony

### Harmony mainnet

ONE is used to pay for transactions on Harmony mainnet. You can use the
[Harmony Bridge](https://bridge.harmony.one/) to transfer ONE and LINK token
from Ethereum Mainnet to Harmony mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1666600000                                 |
| Address        | 0x218532a12a389a4a92fC0C5Fb22901D1c19198aA |
| Name           | Chainlink Token on Harmony Mainnet         |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | status.harmony.one                         |
## Moonriver

### Moonriver mainnet

MOVR is used to pay transaction fees on Moonriver mainnet. You can use
[bridge.multichain.org](https://bridge.multichain.org/#/router) to transfer
LINK to Moonriver mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1285                                       |
| Address        | 0x8b12Ac23BFe11cAb03a634C1F117D64a7f2cFD3e |
| Name           | Chainlink Token on Moonriver Mainnet       |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | moonscan.freshstatus.io                    |
## Moonbeam

### Moonbeam mainnet

GLMR is used to pay transaction fees on Moonbeam mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1284                                       |
| Address        | 0x012414A392F9FA442a3109f1320c439C45518aC3 |
| Name           | Chainlink Token on Moonbeam Mainnet        |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | moonscan.freshstatus.io                    |
## Metis

### Andromeda mainnet

METIS is the currency that you use to pay for transactions on Metis mainnet.
You can use the [Metis Bridge](https://bridge.metis.io/) to transfer METIS and
LINK from Ethereum Mainnet to Metis mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1088                                       |
| Address        | 0x79892E8A3Aea66C8F6893fa49eC6208ef07EC046 |
| Name           | Chainlink Token on Metis Mainnet           |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | andromeda-explorer.metis.io                |
## BASE

### BASE Goerli testnet

Testnet ETH is used to pay for transactions on BASE. Testnet ETH is available
from one of the [BASE Network Faucets](https://docs.base.org/tools/network-faucets). Alternatively, you can get testnet ETH from the faucets listed at
[faucetlink.to/goerli](https://faucetlink.to/goerli) and use the [BASE
Bridge](https://bridge.base.org/deposit) to transfer testnet ETH from Ethereum
Goerli to BASE Goerli.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 84531                                      |
| Address        | 0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3 |
| Name           | Chainlink Token on the BASE Goerli testnet |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | goerli.basescan.org                        |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/link-token-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Configuration

  * Overview
  * Coordinator parameters
  * Fee parameters
  * Configurations
  * Ethereum mainnet
  * Sepolia testnet
  * Goerli testnet
  * BNB Chain
  * BNB Chain testnet
  * Polygon (Matic) mainnet
  * Polygon (Matic) Mumbai testnet
  * Avalanche mainnet
  * Avalanche Fuji testnet
  * Fantom mainnet
  * Fantom testnet
  * Arbitrum mainnet
  * Arbitrum Goerli testnet

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Chainlink VRF allows you to integrate provably fair and verifiably random data
in your smart contract.

For implementation details, read [Introduction to Chainlink
VRF](/vrf/v2/introduction).

## Coordinator parameters

These parameters are configured in the coordinator contract. You can view
these values by running `getConfig` on the coordinator or by viewing the
coordinator contracts in a blockchain explorer.

  * `uint16 minimumRequestConfirmations`: The minimum number of confirmation blocks on VRF requests before oracles respond
  * `uint32 maxGasLimit`: The maximum gas limit supported for a `fulfillRandomWords` callback.
  * `uint32 stalenessSeconds`: How long the coordinator waits until we consider the ETH/LINK price used for converting gas costs to LINK is stale and use `fallbackWeiPerUnitLink`
  * `uint32 gasAfterPaymentCalculation`: How much gas is used outside of the payment calculation. This covers the additional operations required to decrement the subscription balance and increment the balance for the oracle that handled the request.

## Fee parameters

Fee parameters are configured in the coordinator contract and specify the
premium you pay per request in addition to the gas cost for the transaction.
You can view them by running `getFeeConfig` on the coordinator. The `uint32
fulfillmentFlatFeeLinkPPMTier1` parameter defines the fees per request
specified in millionths of LINK. The details for calculating the total
transaction cost can be found [here](/vrf/v2/subscription/#request-and-receive-data).

## Configurations

VRF v2 coordinators for subscription funding are available on several
networks. To see a list of coordinators for direct funding, see the [Direct
Funding Configurations](/vrf/v2/direct-funding/supported-networks) page.

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

### Ethereum mainnet

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x514910771AF9Ca656af840dff83E8264EcF986CA                         |
| VRF Coordinator       | 0x271682DEB8C4E0901D1a1550aD2e64D568E69909                         |
| 200 gwei Key Hash     | 0x8af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef |
| 500 gwei Key Hash     | 0xff8dedfbfa60af186cf3c830acbc32c05aae823045ae5ea7da1e45fbfaba4f92 |
| 1000 gwei Key Hash    | 0x9fe0eebf5e446e3c998ec9bb19951541aee00bb90ea201ae456421a2ded86805 |
| Premium               | 0.25 LINK                                                          |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Sepolia testnet

Sepolia Faucets

Testnet LINK and ETH are available from
[faucets.chain.link](https://faucets.chain.link/sepolia).  
Testnet ETH is also available from several public [ETH
faucets](https://faucetlink.to/sepolia).

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x779877A7B0D9E8603169DdbD7836e478b4624789                         |
| VRF Coordinator       | 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625                         |
| 30 gwei Key Hash      | 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c |
| Premium               | 0.25 LINK                                                          |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Goerli testnet

Goerli Faucets

Testnet LINK is available from <https://faucets.chain.link/goerli>

Testnet ETH is available from <https://goerlifaucet.com/> or faucets listed at
<https://faucetlink.to/goerli>

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB                         |
| VRF Coordinator       | 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D                         |
| 150 gwei Key Hash     | 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15 |
| Premium               | 0.25 LINK                                                          |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### BNB Chain

Important

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
cannot be used with Chainlink oracles. However, it can be [**converted to the
official LINK token on BNB Chain using Chainlink's PegSwap
service**](https://pegswap.chain.link/).

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75                         |
| VRF Coordinator       | 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE                         |
| 200 gwei Key Hash     | 0x114f3da0a805b6a67d6e9cd2ec746f7028f1b7376365af575cfea3550dd1aa04 |
| 500 gwei Key Hash     | 0xba6e730de88d94a5510ae6613898bfb0c3de5d16e609c5b7da808747125506f7 |
| 1000 gwei Key Hash    | 0x17cd473250a9a479dc7f234c64332ed4bc8af9e8ded7556aa6e66d83da49f470 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### BNB Chain testnet

BNB Chain Faucet

Testnet LINK is available from <https://faucets.chain.link/chapel>

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06                         |
| VRF Coordinator       | 0x6A2AAd07396B36Fe02a22b33cf443582f682c82f                         |
| 50 gwei Key Hash      | 0xd4bb89654db74673a187bd804519e65e3f71a52bc55f11da7601a13dcf505314 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Polygon (Matic) mainnet

Important

The LINK provided by the [Polygon (Matic)
Bridge](https://wallet.polygon.technology/polygon/bridge) is not ERC-677
compatible, so cannot be used with Chainlink oracles. However, it can be
[**converted to the official LINK token on Polygon (Matic) using Chainlink's
PegSwap service**](https://pegswap.chain.link/)

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0xb0897686c545045aFc77CF20eC7A532E3120E0F1                         |
| VRF Coordinator       | 0xAE975071Be8F8eE67addBC1A82488F1C24858067                         |
| 200 gwei Key Hash     | 0x6e099d640cde6de9d40ac749b4b594126b0169747122711109c9985d47751f93 |
| 500 gwei Key Hash     | 0xcc294a196eeeb44da2888d17c0625cc88d70d9760a69d58d853ba6581a9ab0cd |
| 1000 gwei Key Hash    | 0xd729dc84e21ae57ffb6be0053bf2b0668aa2aaf300a2a7b2ddf7dc0bb6e875a8 |
| Premium               | 0.0005 LINK                                                        |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Polygon (Matic) Mumbai testnet

Mumbai Faucet

Testnet LINK and MATIC are available from [the Polygon
faucet](https://faucet.polygon.technology/) and
<https://faucets.chain.link/mumbai>.

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB                         |
| VRF Coordinator       | 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed                         |
| 500 gwei Key Hash     | 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f |
| Premium               | 0.0005 LINK                                                        |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Avalanche mainnet

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x5947BB275c521040051D82396192181b413227A3                         |
| VRF Coordinator       | 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634                         |
| 200 gwei Key Hash     | 0x83250c5584ffa93feb6ee082981c5ebe484c865196750b39835ad4f13780435d |
| 500 gwei Key Hash     | 0x89630569c9567e43c4fe7b1633258df9f2531b62f2352fa721cf3162ee4ecb46 |
| 1000 gwei Key Hash    | 0x06eb0e2ea7cca202fc7c8258397a36f33d88568d2522b37aaa3b14ff6ee1b696 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Avalanche Fuji testnet

Avax Fuji Faucet

Testnet LINK is available from <https://faucets.chain.link/fuji>

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846                         |
| VRF Coordinator       | 0x2eD832Ba664535e5886b75D64C46EB9a228C2610                         |
| 300 gwei Key Hash     | 0x354d2f95da55398f44b7cff77da56283d9c6c829a4bdf1bbcaf2ad6a4d081f61 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Fantom mainnet

Important

You must use ERC-677 LINK on Fantom. ERC-20 LINK will not work with Chainlink
services.

Use [bridge.multichain.org](https://bridge.multichain.org/#/router) to send
LINK to the Fantom network and be sure to select LINK-ERC677 as the token you
will receive on the Fantom mainnet.

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x6F43FF82CCA38001B6699a8AC47A2d0E66939407                         |
| VRF Coordinator       | 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634                         |
| 4000 gwei Key Hash    | 0xb4797e686f9a1548b9a2e8c68988d74788e0c4af5899020fb0c47784af76ddfa |
| 10000 gwei Key Hash   | 0x5881eea62f9876043df723cf89f0c2bb6f950da25e9dfe66995c24f919c8f8ab |
| 20000 gwei Key Hash   | 0x64ae04e5dba58bc08ba2d53eb33fe95bf71f5002789692fe78fb3778f16121c9 |
| Premium               | 0.0005 LINK                                                        |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Fantom testnet

Fantom Testnet Faucet

Testnet LINK is available from <https://faucets.chain.link/fantom-testnet>

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F                         |
| VRF Coordinator       | 0xbd13f08b8352A3635218ab9418E340c60d6Eb418                         |
| 3000 gwei Key Hash    | 0x121a143066e0f2f08b620784af77cccb35c6242460b4a8ee251b4b416abaebd4 |
| Premium               | 0.0005 LINK                                                        |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Arbitrum mainnet

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4                         |
| VRF Coordinator       | 0x41034678D6C633D8a95c75e1138A360a28bA15d1                         |
| 2 gwei Key Hash       | 0x08ba8f62ff6c40a58877a106147661db43bc58dabfb814793847a839aa03367f |
| 30 gwei Key Hash      | 0x72d2b016bb5b62912afea355ebf33b91319f828738b111b723b78696b9847b63 |
| 150 gwei Key Hash     | 0x68d24f9a037a649944964c2a1ebd0b2918f4a243d2a99701cc22b548cf2daff0 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### Arbitrum Goerli testnet

Arbitrum Goerli Testnet Faucet

Testnet LINK is available from <https://faucets.chain.link/arbitrum-goerli>

| Item                  | Value                                                              |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0xd14838A68E8AFBAdE5efb411d5871ea0011AFd28                         |
| VRF Coordinator       | 0x6D80646bEAdd07cE68cab36c27c626790bBcf17f                         |
| 50 gwei Key Hash      | 0x83d1b6e3388bed3d76426974512bb0d270e9542a765cd667242ea26c0cc0b730 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/supported-networks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the chainlink price feed address for 1INCH / ETH?,0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8,,"The answer to the question ""What is the chainlink price feed address for 1INCH / ETH?"" is not provided in the given extracted parts of the document and the provided sources.",,"# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside off-chain.
  * **LP Token Feeds:** These feeds use a decentralized feed for the underlying asset as well as calculations to value the LP tokens.
  * **Wrapped Calculated Feeds:** These feeds are typically pegged 1:1 to the underlying token or asset. Under normal market conditions, these feeds track their underlying value accurately. However, the price is a derivative formed from a calculated method and might not always track value precisely.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⭕ Deprecating

These feeds are being deprecated. To find the deprecation dates for specific
feeds, see the [Feeds Scheduled For Deprecation](/data-feeds/deprecating-feeds) page.

## Risk Mitigation

As a development best practice, design your systems and smart contracts to be
resilient and mitigate risk to your protocol and your users. Ensure that your
systems can tolerate known and unknown exceptions that might occur. Some
examples include but are not limited to volatile market conditions, the
degraded performance of infrastructure, chains, or networks, and any other
upstream outage related to data providers or node operators. You bear
responsibility for any manner in which you use the Chainlink Network, its
software, and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel: <https://discord.gg/Dqy5N9UbsR>

## Chainlink Community Deployments

Chainlink technology is used by many within the blockchain community to
support their use cases. Deployments built and run by community members are
not tracked in the Chainlink documentation. Chainlink's community is
continuously growing, and we believe they play a vital role in developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Fast Gas Reliability

### Liquidity and its Distribution

If your smart contract relies on pricing data for a specific asset, make sure
that the asset has sufficient liquidity in the market to avoid price
manipulation. Assets with low liquidity can be volatile, which might
negatively impact your application and its users. Malicious actors might try
to exploit volatility to take advantage of the logic in a smart contract and
cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather
than from aggregated price tracking services that gather their data from
multiple exchanges. These are marked as such in the docs page for that feed.
Assess the liquidity and reliability of that specific exchange.

_Liquidity migrations_ occur when a project moves its tokens from one
liquidity provider (such as a DEX, a CEX, or a new DeFi application) to
another. When liquidity migrations occur, it can result in low liquidity in
the original pool, making the asset susceptible to market manipulation. If
your project is considering a liquidity migration, you should coordinate with
relevant stakeholders, including liquidity providers, exchanges, oracle node
operators, and users, to ensure prices are accurately reported throughout the
migration.

Feeds for assets with low market liquidity where data providers exhibit an
abnormal price spread may, on occasion, see a price oscillate between two or
more price points within regular intervals. To mitigate risk associated with
such price oscillation, users must regularly monitor & assess the quality of
an asset’s liquidity. Similarly, assets with low market liquidity may
experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk
management measures to protect your assets. For example, create mock tests
that return various oracle responses.

### Single Source Data Providers

Some data providers use a single data source, which might be necessary if only
one source exists off-chain for a specific type of data. Evaluate data
providers to make sure they provide high-quality data that your smart
contracts can rely on. Any error or omission in the provider's data might
negatively impact your application and its users.

### Crypto and Blockchain Actions

Price data quality is subject to crypto actions by the crypto and blockchain
project teams. Crypto actions are similar to [corporate
actions](https://en.wikipedia.org/wiki/Corporate_action) but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on. Periods of
high network congestion might impact the frequency of Chainlink Price Feeds.
It is advised that you configure your applications to detect such chain
performance issues and to respond appropriately.

### Unknown and Known Users

Routine maintenance is carried out on Chainlink Data Feeds, including
decommissioning, on an ad-hoc basis. These maintenance periods might require
users to take action in order to maintain business continuity.

Notifications are sent to inform known users regarding such occurrences, and
it is strongly encouraged for all users, including those users utilizing data
feeds for off-chain purposes, [to provide their contact
information](https://chain.link/contact?ref_id=DataFeed) before utilizing data
feeds. Without providing contact information, users will be unable to receive
notifications regarding important price feed updates.

If you are using Price Feeds but have not provided your contact information,
you can do so [here](https://chain.link/contact?ref_id=DataFeed). Users that
fail to provide notification information do so at their own risk.

## Evaluating Wrapped or Bridged Assets

### Assessing how to Price Wrapped or Bridged Assets

When assessing a Chainlink Price Feed for a wrapped or bridged asset such as
WBTC, users should evaluate the tradeoffs between using a price feed
specifically built for the wrapped or bridged asset or a price feed built for
the underlying asset.

Decisions should be made on a case-by-case basis considering the liquidity,
depth, and trading volatility of the underlying asset compared to its
derivative. In addition, users must consider the security mechanism that is
designed to keep the wrapped or bridged asset coupled to its underlying asset.
Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets

Chainlink Price Feeds are designed to provide the market-wide price of various
assets, as determined by a volume-weighted average across a wide range of
exchanges. On blockchain networks where assets are wrapped and/or bridged from
another environment using a cross-chain token bridge, Chainlink Price Feeds
built for the underlying asset will continue to report the market-wide price
of the underlying asset as opposed to the price of the wrapped/bridged asset.
This methodology reduces risks around market manipulation because
wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price
deviations between the wrapped/bridged asset and its underlying counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible for reviewing the quality of the data that you integrate into your
smart contracts.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/selecting-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2023-05-15 09:46:33)
Find price feed contracts Addresses of chainlink within smart contracts
URL: https://stackoverflow.com/questions/76252825/find-price-feed-contracts-addresses-of-chainlink-within-smart-contracts

Question Body:


I am developing a contract in which I have to check whether the incoming token
is paired with USD to get the price feed of Chainlink from the smart contract.
Only such tokens are going to be added to my smart contract. Does Chainlink
have any functions to get the verified or registered list of pairs from a
smart contract?

I have gone through <https://docs.chain.link/data-feeds/feed-registry>, which
supports only a few tokens on the Ethereum Mainnet. I am developing my
application on the Polygon mainnet.

  1. I have to only accept tokens that are verified feed pairs with USD on the Polygon Mainnet.
  2. Query Chainlink data feeds of such pairs from asset addresses directly from the smart contract.



Answers:
(Answered on: 2023-05-18 10:06:40)


The [Feed Registry](https://docs.chain.link/data-feeds/feed-registry) is only
avaiable on [Ethereum Mainnet](https://docs.chain.link/data-feeds/feed-
registry#contract-addresses)

I suggest you create your own table to manage it on Polygon.





:::NEXT DOC:::

Question: (Asked on: 2023-01-30 17:38:21)
Why is Chainlink oracle function call failing?
URL: https://stackoverflow.com/questions/75288132/why-is-chainlink-oracle-function-call-failing

Question Body:


While attempting to fund me contract is tell me it encountered an error
without specifying the error. I attempted to fund 0.1 eth through the fund
function, and in the terminal it says:

    
    
    [block:8404521 txIndex:12]
    from: 0x8a9...e4303
    to: FundMe.fund() 0x542...E109C
    value: 100000000000000000 wei
    data: 0xb60...d4288
    logs: 0
    hash: 0x29a...97939
    

and in the etherscan it says:status fail :

    
    
    Contract 0x5422f3458be343e378e7a399e16fff548e7e109c
     Warning! Error encountered during contract execution [execution reverted] 
    

I tried looking for problems with my code and found none.

    
    
    // SPDX-License-Identifier: MIT
    
    pragma solidity >=0.6.6 <0.9.0;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    //import ""@chainlink/contracts/src/v0.8/vendor/SafeMathChainlink.sol""; won't need in later complier versions.
    contract FundMe {
        
    
        mapping(address => uint256) public addressToAmountFunded;
    
        function fund() public payable {
            uint256 minimumUSD = 50 * 10 ** 18;
            require( getConversionRate(msg.value) >= minimumUSD,""You need to send more Eth"");
            addressToAmountFunded[msg.sender] += msg.value;
        }
    
        function getVersion() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
            return priceFeed.version();
        }
    
        function getPrice() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
            (,int256 answer,,,)=priceFeed.latestRoundData();
            return uint256(answer * 10000000000);
        }
        //10000000000 = Gwei which is why we added 10 zeros to getPrice(answer) to convert it to Wei amount
        function getConversionRate(uint256 ethAmount) public view returns (uint256){
            uint256 ethPrice = getPrice();
            uint256 ethAmountInUsd = (ethPrice * ethAmount)/ 1000000000000000000; //divide 2x because we added 10*((getPrice)answer))
            return ethAmountInUsd;
        }
    }
    



Answers:
(Answered on: 2023-01-31 03:09:55)


  * Aggregator contract address ""0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"" belongs to [mainnet](https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd)

[From here](https://docs.chain.link/data-feeds/price-feeds/addresses/) get the
`ETH/USD` goerli testnet address:""0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e""

  * Now in order to call chainlink oracle you have to have `LINK` token in your contract. Get some link token to your conract address [from the faucet](https://faucets.chain.link/)

  * Import the token in metamask. you will see the amount

  * send link token from your metamask to your contract

  * deploy your contract. if you are using `Remix IDE` chose the `injected provider` to connect to metamask. Because chainlink contract is on goerli, so you need to be on Goerli testnet. Once deployment goes through you can call the `fund` function.

  * Since the `fund` function has no argument, you need to send the value alongside the transaction. That is why inside the function you have `msg.value` to access to the sent amount.

  * In `Remix` ide, under ""GAS LIMIT`input there is`VALUE`input. you need to pass the amount in there before you call the`fund` function.





:::NEXT DOC:::

Question: (Asked on: 2021-11-03 00:21:58)
How to Call getLatestPrice function Chainlink Price Feed
URL: https://stackoverflow.com/questions/69818347/how-to-call-getlatestprice-function-chainlink-price-feed

Question Body:


I'm trying to use the chainlink price feed. Are we supposed to type all of our
code in the [PriceconsumerV3 contract](https://docs.chain.link/docs/get-the-
latest-price/)? Can we use inheritance to access the value? I tried putting
the PriceconsumerV3 contract and my contract in the same file. What is the
conventional setup?



Answers:
(Answered on: 2022-11-16 17:03:16)


Note the Rinkeby and Kovan Testnets are phased out which isn't well documented
in Solidity and Chainlink tutorials. Goerli as of now is the predominat
Testnet with different contract addresses hope this helps:

Scroll down the page to find Goerli contract addresses

<https://docs.chain.link/docs/data-feeds/price-
feeds/addresses/#Goerli%20Testnet>


---
(Answered on: 2021-11-03 14:25:01)


To access chainlink data feeds you simply need to import the AggregatorV3
Interface into whatever contract you would like to have use them like this:

    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    

Then initialize the exact data feed your contract is pointing to in the
constructor like this:

    
    
        constructor() {
            priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
        }
    

Where `0x9326....331` is the address of the data feed we are pointing to.

You do not have to actually put the entire [example PriceConsumer
contract](https://docs.chain.link/docs/get-the-latest-price/) from the
Chainlink docs into your own contract. That is just an example to show you how
to structure a contract to use data feeds as I explained above.



"
What is the proof of reserve address for CacheGold PoR USD on Goerli Testnet?,Not provided in the context,,"The proof of reserve address for CacheGold PoR USD on Goerli Testnet is 0x5586bF404C7A22A4a4077401272cE5945f80189C.
",https://docs.chain.link/data-feeds/proof-of-reserve/addresses/,"# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the rate and Volatility Feed Address for 30-Day ETH APR?,0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29,,"The rate and Volatility Feed Address for 30-Day ETH APR is 0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29.
",https://docs.chain.link/data-feeds/rates-feeds/addresses/,"# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is met.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find heartbeat and deviation information for each
feed. If you have questions or would like to request an enhancement to
Realized Volatility Feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Rate and Volatility Feeds](/data-feeds/rates-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Rate and Volatility Feed Addresses

  * Overview
  * Sepolia Testnet 

To learn how to use these feeds, see the [Using Data Feeds](/data-feeds/using-data-feeds) guide.

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Track the status of this network at <https://ethstats.dev/>

## Sepolia Testnet

| Pair                                     |   Asset |   Type | Deviation   | Heartbeat   |   Dec | Address                                    |
|:-----------------------------------------|--------:|-------:|:------------|:------------|------:|:-------------------------------------------|
| 30-Day ETH APR                           |     nan |    nan | 50%         | 86400s      |     7 | 0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29 |
| 90-Day ETH APR                           |     nan |    nan | 50%         | 86400s      |     7 | 0x7422A64372f95F172962e2C0f371E0D9531DF276 |
| BTC Interest Rate Benchmark Curve 1 Day  |     nan |    nan | 0.01%       | 86400s      |     8 | 0x7DE89d879f581d0D56c5A7192BC9bDe3b7a9518e |
| BTC Interest Rate Benchmark Curve 1 Week |     nan |    nan | 0.01%       | 86400s      |     8 | 0x2583E47DF3F959B055F4Efa90C4927658669F499 |
| BTC Interest Rate Benchmark Curve 2 Week |     nan |    nan | 0.01%       | 86400s      |     8 | 0x39545d0c11CD62d787bB971B6a802150e1f54D8f |
| BTC-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x28f9134a15cf0aAC9e1F0CD09E17f32925254C77 |
| BTC-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2 |
| ETH-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 | 0xd599cEF88Bbd27F1392A544bD0F343ec8893124C |
| LINK-USD 7-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x03121C1a9e6b88f56b27aF5cc065ee1FaF3CB4A9 |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net?,0x352f2Bc3039429fC2fe62004a1575aE74001CfcE,,"The NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on the Ethereum main net is 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE.
",https://docs.chain.link/data-feeds/nft-floor-price/addresses/,"# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = nftFloorPriceFeed.latestRoundData();
            return nftFloorPrice;
        }
    }
    

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for NFT Floor Price Feeds](/data-feeds/nft-floor-price/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
| ⚫VeeFriends Floor Price                 | ETH           | 2%          |       86400 |    18 | 0x35bf6767577091E7f04707c0290b3f889e968307 |
| ⚫World of Women Floor Price             | ETH           | 2%          |       86400 |    18 | 0xDdf0B85C600DAF9e308AFed9F597ACA212354764 |
## Goerli Testnet

| NFT Floor Pricing Feed     | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:---------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| Azuki Floor Price          | ETH           | 2%          |        3600 |    18 | 0x9F6d70CDf08d893f0063742b51d3E9D1e18b7f74 |
| BAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xB677bfBc9B09a3469695f40477d05bc9BcB15F50 |
| CloneX Floor Price         | ETH           | 2%          |        3600 |    18 | 0xE42f272EdF974e9c70a6d38dCb47CAB2A28CED3F |
| CoolCats Floor Price       | ETH           | 2%          |        3600 |    18 | 0x13F38938A18ff26394c5ac8df94E349A97AaAb4e |
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price      | ETH           | 2%          |        3600 |    18 | 0x870bc8BfEe8A7Bbd63Dc1ef09F2fF37DeBCfEF35 |
| Doodles Floor Price        | ETH           | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Why does calling an external API in chainlink not cause inconsistency?,"Because oracle responses are stored on-chain. Instead of fetching external data during the validation process, Chainlink oracle network places the data on-chain in a transaction. This ensures that all nodes go through the same validation process and reach a consensus. Having an oracle system built into a blockchain is not possible.",{'source': 'https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency'},"Calling an external API in Chainlink does not cause inconsistency because the oracle responses are stored on-chain. The data fetched from the external API is placed on-chain in a transaction, and it goes through the same validation process as every other transaction. This ensures that all nodes reach a consensus on the data, preventing inconsistent states. The Chainlink oracle network ensures the integrity and consistency of the data fetched from external sources.

","- [Stack Overflow: Why does calling an external API in Chainlink not cause inconsistency?](https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency)
- [Stack Overflow: When a make a call to a public API, how does Chainlink verify the response or it does not?](https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or)
- [Stack Overflow: Chainlink node external adapter executes successfully, but keeps returning 0](https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0)
- [Stack Overflow: Why is recordChainlinkfulfillment not being executed?](https://stackoverflow.com/questions/74913265/why-is-recordchainlinkfulfillment-not-being-executed)","Question: (Asked on: 2022-12-25 12:25:30)
Why is recordChainlinkfulfillment not being executed?
URL: https://stackoverflow.com/questions/74913265/why-is-recordchainlinkfulfillment-not-being-executed

Question Body:


Anyone any idea why the recordChainlinkfulfillment is not being executed?

I've checked the API call and it's yield the correct results. I managed to got
this working with the chainlink job for fetching 1 value, but not for multiple
values.

As far as I can tell and was able to check, the API url was correctly set and
the request function was correctly executed. My contract is funded with enough
LINK.

    
    
        // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.9;
    
    
    import ""@openzeppelin/contracts/access/Ownable.sol"";
    import ""@openzeppelin/contracts/utils/Counters.sol"";
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    contract RealEstateBonus is ChainlinkClient, Ownable {
        using Chainlink for Chainlink.Request;
    
        bytes32 private jobId;
        uint256 private fee;
        string public url;
        string public urlresult;
        string public lastselldate;
        string public lastapn;
        bytes32 public lastrequestid;
    
        event RequestMultipleFulfilled(bytes32 indexed requestId, string selldate, string apn);
    
        constructor() {
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            setChainlinkOracle(0xCC79157eb46F5624204f47AB42b3906cAA40eaB7);
            jobId = ""53f9755920cd451a8fe46f5087468395"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
            url=""https://api.bridgedataoutput.com/api/v2/pub/transactions?access_token=d555ec24e3f182c86561b09d0a85c3dc&limit=1&sortBy=recordingDate&order=desc&fields=recordingDate,parcels.apn&recordingDate.gt=2015-01-01&parcels.apn="";
            
        }
        
        struct Bonus {
            string parcelid;
            address seller;
            address realtor;
            uint256 amount;
            uint startdate;
            uint sellbydays;
        }
        
        mapping (string => Bonus) public parcelbonus;
        mapping (string => string) public parcellastselldate;
        
        function createBonus (string memory _parcelid, address _realtor, uint _sellbydays) public payable {
            parcelbonus[_parcelid]=Bonus(_parcelid, msg.sender,_realtor, msg.value, block.timestamp, _sellbydays);
        }
        
        function createBonusTest (string memory _parcelid, address _realtor, uint _startdate, uint _sellbydays) public payable {
            parcelbonus[_parcelid]=Bonus(_parcelid, msg.sender,_realtor, msg.value, _startdate, _sellbydays);
        
        }
        
        function realtorwithdraw (string memory parcelid) public {}
        
        function sellerwithdraw (string memory parcelid) public {}
        
        function formurl (string memory _parcelid) public {
            
            urlresult=string(abi.encodePacked(url,_parcelid));
            
            
        }
        
        function requestSellData(string memory _parcelid) public returns (bytes32 requestId) {
            formurl(_parcelid);
            Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfillMultipleParameters.selector);
            // Set the URL to perform the GET request on
            req.add(""urlRECD"", urlresult);
            req.add(""pathRECD"", ""bundle,0,recordingDate"");
            req.add(""urlAPN"", urlresult);
            req.add(""pathAPN"", ""bundle,0,parcels,0,apn"");  
            // Sends the request
            return sendChainlinkRequest(req, fee);
        }
    
        function fulfillMultipleParameters(
            bytes32 _requestId,
            string memory _selldate,
            string memory _apn
        ) public recordChainlinkFulfillment(_requestId) {
            emit RequestMultipleFulfilled(_requestId, _selldate, _apn);
            lastrequestid = _requestId;
            lastselldate = _selldate;
            lastapn = _apn;
            parcellastselldate[_apn] = _selldate;
        }
        
        
    }
    



Answers:
(Answered on: 2022-12-26 02:20:04)


What oracle job did you select to fulfil your requests? have you checked that
the job returns the string data type as you are expecting? See ""Response
Types"" [here](https://docs.chain.link/any-api/get-request/examples/multi-
variable-responses)





:::NEXT DOC:::

Question: (Asked on: 2022-11-09 23:44:03)
Chainlink node external adapter executes successfully, but keeps returning 0
URL: https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0

Question Body:


I'm trying to build an external adapter for a chainlink node to import API
information. On the chainlink node and API, everything seems like it worked,
however when I try to call the stored value from the smart contract, it's
always 0 despite the logs indicating that it ran successfully.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Mimi-Fund-EA""
    externalJobID = ""834d2179-321d-49ac-bf63-140635e3a606""
    forwardingAllowed = false
    maxTaskDuration = ""0s""
    contractAddress = ""0xAf644831B57E5625ac64cDa68248b810bE4D4D01""
    minContractPaymentLinkJuels = ""0""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""mimifund"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""year\\"": $(decode_cbor.year), \\""discount_rate\\"": $(decode_cbor.discount_rate)}}""]
        parse        [type=jsonparse path=""data,result"" data=""$(fetch)""]
        ds_multiply  [type=""multiply"" times=1000000000000000000]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(ds_multiply) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xAf644831B57E5625ac64cDa68248b810bE4D4D01"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> ds_multiply-> encode_data -> encode_tx -> submit_tx
    """"""
    

These are the run logs from the Node. Everything compiled just fine and the
values look good however, they never update in a smart contract, it's always
0.

[](https://i.stack.imgur.com/ZUw17.png)

This is my smart contract for reference.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@openzeppelin/contracts/utils/Strings.sol"";
    
    contract mimifundCO2 is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
        bytes32 private jobId;
        uint256 private fee;
    
        event RequestVolume(bytes32 indexed requestId, uint256 volume);
    
        /**
         * @notice Initialize the link token and target oracle
         *
         * Goerli Testnet details:
         * Link Token: 0x326C977E6efc84E512bB9C30f76E30c160eD06FB
         * Oracle: 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 (Chainlink DevRel)
         * jobId: ca98366cc7314957b8c012c72f05aeeb
         *
         */
        constructor() ConfirmedOwner(msg.sender) {
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            setChainlinkOracle(0xAf644831B57E5625ac64cDa68248b810bE4D4D01);
            jobId = ""834d2179321d49acbf63140635e3a606"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        }
    
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestCO2PricingData(uint256 _year) public returns (bytes32 requestId) {
            Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
            req.add('year', Strings.toString(_year)); // Chainlink nodes 1.0.0 and later support this format
            req.add('discount_rate', '0.0'); // Chainlink nodes 1.0.0 and later support this format
    
            // Sends the request
            return sendChainlinkRequest(req, fee);
        }
    
        /**
         * Receive the response in the form of uint256
         */
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
            emit RequestVolume(_requestId, _volume);
            volume = _volume;
        }
    
        /**
         * Allow withdraw of Link tokens from the contract
         */
        function withdrawLink() public onlyOwner {
            LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
            require(link.transfer(msg.sender, link.balanceOf(address(this))), 'Unable to transfer');
        }
    }
    
    

I feel like there is some update to either my fulfill function or submit_tx
that I need to update, but I am out of ideas about what to change.

I've tried changing all the parameters and both the API and chainlink node
accurate update and reflect the correct input. The smart contract seems to
work perfectly, it's just that calling volume in the code always returns 0 and
I've got no clue what the issue is.



Answers:
(Answered on: 2022-11-11 06:51:31)


According to your description, Chainlink node received your request and run
the job successfully, but failed to write the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.





:::NEXT DOC:::

Question: (Asked on: 2021-11-26 22:39:12)
Why does calling an external API in chainlink not cause inconsistency?
URL: https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency

Question Body:


Suppose I have a smart contract that uses Chainlink's ""Call Any External API""
capability to get some data from an external URL. My understanding is that
each Ethereum full node runs each smart contract to verify the status; it does
so to verify the latest block. But what if, between the time one full node
runs the contract and another one does, the data returned by calling tha
external API changes. Then it would seem that different full nodes would get
different results for that smart contract, resulting in inconsistent states.
Why does that not happen?



Answers:
(Answered on: 2021-12-10 18:05:16)


Because oracle responses are stored on-chain.

You are right, if fetching external data was part of the validation process,
no nodes would be able to reach a consensus. So instead, a Chainlink oracle
network places the data on-chain in a transaction, and then it goes through
the same validation process as every other transaction.

You can read more about how Chainlink's [Basic Request
Model](https://docs.chain.link/docs/architecture-request-model/) looks, but
this is basically the reason why having an oracle system built into a
blockchain is impossible.



"
How do I install dependencies for Yarn?,"To install dependencies for Yarn, you can use the command 'yarn install' in the main node's folder.",{'source': 'https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn'},"To install dependencies for Yarn, you can use the command ""yarn install"" in the main node's folder. This will install the required packages and dependencies for your project. If you encounter any errors, you can try running ""yarn install"" again or refer to the Yarn documentation for further assistance.

",- [Stack Overflow: How do I install dependencies for Yarn?](https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn),"# Getting Started

  * Overview
  * Set up your environment
  * Configure your on-chain resources
  * Run the example request

Use the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) with
[Hardhat](https://hardhat.org/) to set up your on-chain contracts, test your
requests, and send your requests to be fulfilled by the Chainlink Functions
Decentralized Oracle Network (DON). Chainlink Functions is available on
Sepolia and Polygon Mumbai, but this guide uses Polygon Mumbai to simplify
access to testnet funds. Complete the following tasks to get started with
Chainlink Functions:

  * Set up your Web3 wallet and find your private key
  * Install the required frameworks
  * Configure the starter kit with your environment variables
  * Simulate a Chainlink Functions request
  * Set up a subscription for Chainlink Functions
  * Send a Chainlink Functions request to the DON

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

## Set up your environment

You must provide the private key from a testnet wallet to run the examples in
this documentation. Install a Web3 wallet, configure
[Node.js](https://nodejs.org/en/download/), clone the [Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit.git),
and configure a `.env` file with the required variables.

Install and configure your Web3 wallet for Polygon Mumbai:

  1. [Install the MetaMask wallet](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) or other Ethereum Web3 wallet.

  2. Set the network for your wallet to the Polygon Mumbai testnet. If you need to add Mumbai to your wallet, you can find the chain ID and the LINK token contract address on the [LINK Token Contracts](/resources/link-token-contracts#mumbai-testnet) page.

    * [Polygon Mumbai testnet

](/resources/link-token-contracts#mumbai-testnet)

  3. Request testnet MATIC from the [Polygon Faucet](https://faucet.polygon.technology/).

  4. Request testnet LINK from [faucets.chain.link/mumbai](https://faucets.chain.link/mumbai).

Install the required frameworks and dependencies:

  1. [Install Node.js 18](https://nodejs.org/en/download/). Optionally, you can use the [nvm package](https://www.npmjs.com/package/nvm) to switch between Node.js versions with `nvm use 18`.

**Note** : The starter kit only supports node versions at 18 or higher. To
ensure you are running the correct version in a terminal, type `node -v`.

    
        node -v
    
        $ node -v
    v18.7.0

  2. In a terminal, clone the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit.git) repository and change directories.
    
        git clone https://github.com/smartcontractkit/functions-hardhat-starter-kit.git && \
    cd functions-hardhat-starter-kit/

  3. Run `npm install` to install the dependencies.
    
        npm install

  4. For higher security, the starter kit encrypts your environment variables at rest.

    1. Set an encryption password for your environment variables.
        
                npx env-enc set-pw

    2. Run `npx env-enc set` to configure a `.env.enc` file with the basic variables that you need to send your requests to the Polygon Mumbai network.

      * `POLYGON_MUMBAI_RPC_URL`: Set a URL for the Polygon Mumbai testnet. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.

      * `PRIVATE_KEY`: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to [Export a Private Key](https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key). Set this in the `.env` file. **Note** : The Chainlink Functions hardhat starter kit uses your private key to sign any transactions you make such as deploying your consumer contract, creating subscriptions, and making requests.
        
                npx env-enc set

  5. Compile the contracts in the repository. You will see several compile warnings, but no errors.
    
        npx hardhat compile

Simulate a request to test your environment and make sure everything is
configured correctly. Run the `npx hardhat functions-simulate` command. The
simulation runs on a local Hardhat network (a local Ethereum network node
designed for development) and executes a request defined in the default
[Functions-request-config.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/Functions-request-config.js) file. The starter
kit includes the capability to simulate transactions so you can quickly test
your code before you send it to the DON.


    npx hardhat functions-simulate

If the simulation is successful, the output includes the simulated on-chain
response:


    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000000f50ed
    Decoded as a uint256: 1003757
    
    Gas used by sendRequest: 360602
    Gas used by client callback function: 75029

## Configure your on-chain resources

After you configure your local environment, configure some on-chain resources
to process your requests, receive the responses, and pay for the work done by
the DON.

Deploy an on-chain
[FunctionsConsumer.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/FunctionsConsumer.sol) contract, create a
[subscription](/chainlink-functions/resources/subscriptions), and fund the
subscription with LINK to pay for requests after they are fulfilled.

  1. Deploy the consumer contract and record the contract address. For now, you can skip on-chain contract verification with the `--verify false` flag. If you do need to [verify](https://blog.chain.link/how-to-verify-a-smart-contract-on-etherscan) your contract on-chain, sign up for a [free Polygonscan API key](https://polygonscan.com/login) and include the key in your `.env.enc` file by running `npx env-enc set` and set `POLYGONSCAN_API_KEY`.
    
        npx hardhat functions-deploy-client --network polygonMumbai --verify false

Find the contract address in the output:

    
        FunctionsConsumer contract deployed to 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea on mumbai

  2. Create a Chainlink Functions subscription and add your contract as an approved consumer contract. You can do this with a single transaction if you include your contract address with the `--contract` flag. For this example, 1 LINK is more than enough on the Mumbai testnet. You can always get more LINK from [faucets.chain.link](https://faucets.chain.link/mumbai) and later add it to the subscription. See the [Subscriptions Management](/chainlink-functions/resources/subscriptions#fund-a-subscription) page for details.
    
        npx hardhat functions-sub-create --network polygonMumbai --amount 1 --contract YOUR_CONSUMER_CONTRACT_ADDRESS

Record the subscription ID from the output.

    
        Created subscription with ID: 443
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 1.0 LINK
    1 authorized consumer contract:
    [ '0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea' ]

## Run the example request

After your environment and on-chain resources are configured, you can send
your request to the DON to execute the request defined in the [Functions-
request-config.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/Functions-request-config.js) file. Run `npx hardhat
functions-request`. Specify your subscription ID with the `--subid` flag and
specify your consumer contract address with the `--contract` flag.


    npx hardhat functions-request --subid YOUR_SUBSCRIPTION_ID --contract YOUR_CONSUMER_CONTRACT_ADDRESS --network polygonMumbai

The on-chain transaction and request will take longer to complete than the
simulation. The output includes a decoded response:


    Actual amount billed to subscription #443:
    ┌──────────────────────┬─────────────────────────────┐
    │         Type         │           Amount            │
    ├──────────────────────┼─────────────────────────────┤
    │  Transmission cost:  │  0.000074413446128386 LINK  │
    │      Base fee:       │          0.2 LINK           │
    │                      │                             │
    │     Total cost:      │  0.200074413446128386 LINK  │
    └──────────────────────┴─────────────────────────────┘
    
    
    ✔ Request 0x4b97078053700c816e6ba1cd54fa5a5b4c279f36c6e4a4be690a71ba84d26819 fulfilled! Data has been written on-chain.
    
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000000f50ed
    Decoded as a uint256: 1003757

If your request is successful, you have all the tools that you need to make
your own custom requests. Edit the [Functions-request-
config.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/Functions-request-config.js) file and the [calculation-
example.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/calculation-example.js) source file with your own code. Then,
run the `npx hardhat functions-request` command again to test your changes.
You can re-use the same consumer contract and subscription for different
requests.

Chainlink Functions is capable of much more than just computation. Try one of
the [Tutorials](/chainlink-functions/tutorials) to see examples that can GET
and POST to public APIs, securely handle API secrets, handle custom responses,
and query multiple APIs.

## What's next

  * [› Try out the Chainlink Functions Tutorials](/chainlink-functions/tutorials)
  * [› Read the Concepts page to learn about the core concepts behind Chainlink Functions](/chainlink-functions/resources/concepts)
  * [› Read the Architecture to understand how Chainlink Functions operates](/chainlink-functions/resources/architecture)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/getting-started.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-04-27 00:13:16)
Issue Brownie setup, not sure if ganache installed properly - chainlink hackathon
URL: https://stackoverflow.com/questions/72021879/issue-brownie-setup-not-sure-if-ganache-installed-properly-chainlink-hackatho

Question Body:


I am new to this space and having an issue getting brownie to run my first
deploy script. I am learning through the Chainlink Hackathon and following the
brownie tutorial by Patrick Collins. I think the problem is with ganache. Any
help would be appreciated.

When I ask for the version of ganache - it says not found (see below). when I
try to install via npm, I receive error no 13. Is this related to Mac OS?

Error message when trying to deploy script:

` brownie run scripts/deploy.py`

    
    
    >Brownie v1.18.1 - Python development framework for Ethereum
    
    (base) x:brownie-hack mariposa$ brownie run scripts/deploy.py
    Brownie v1.18.1 - Python development framework for Ethereum
    
    BrownieHackProject is the active project.
      File ""brownie/_cli/__main__.py"", line 64, in main
        importlib.import_module(f""brownie._cli.{cmd}"").main()
      File ""brownie/_cli/run.py"", line 45, in main
        network.connect(CONFIG.argv[""network""])
      File ""brownie/network/main.py"", line 50, in connect
        rpc.launch(active[""cmd""], **active[""cmd_settings""])
      File ""brownie/network/rpc/__init__.py"", line 75, in launch
        self.process = self.backend.launch(cmd, **kwargs)
      File ""brownie/network/rpc/ganache.py"", line 69, in launch
        ganache_version = get_ganache_version(cmd_list[0])
      File ""brownie/network/rpc/ganache.py"", line 110, in get_ganache_version
        ganache_version_proc = psutil.Popen([ganache_executable, ""--version""], stdout=PIPE)
      File ""psutil/__init__.py"", line 1319, in __init__
        self.__subproc = subprocess.Popen(*args, **kwargs)
      File ""//anaconda3/lib/python3.7/subprocess.py"", line 775, in __init__
        restore_signals, start_new_session)
      File ""//anaconda3/lib/python3.7/subprocess.py"", line 1522, in _execute_child
        raise child_exception_type(errno_num, err_msg, err_filename)
    FileNotFoundError: [Errno 2] No such file or directory: 'ganache-cli': 'ganache-cli'
    

Dependencies /versions installed:

` $ node -v`

> v16.14.2

`$ npm -v`

> 8.5.0

` $ yarn -v`

> 3.2.0

`$ python --version`

> Python 2.7.10

`$ brownie `

> Brownie v1.18.1 - Python development framework for Ethereum

`ganache-cli --version`

> bash: ganache-cli: command not found

`npm install -g ganache-cli`

    
    
    npm ERR! code EACCES
    npm ERR! syscall mkdir
    npm ERR! path /usr/local/lib/node_modules/ganache-cli
    npm ERR! errno -13
    npm ERR! Error: EACCES: permission denied, mkdir '/usr/local/lib/node_modules/ganache-cli'
    npm ERR!  [Error: EACCES: permission denied, mkdir '/usr/local/lib/node_modules/ganache-cli'] {
    npm ERR!   errno: -13,
    npm ERR!   code: 'EACCES',
    npm ERR!   syscall: 'mkdir',
    npm ERR!   path: '/usr/local/lib/node_modules/ganache-cli'
    npm ERR! }
    npm ERR! 
    npm ERR! The operation was rejected by your operating system.
    npm ERR! It is likely you do not have the permissions to access this file as the current user
    npm ERR! 
    npm ERR! If you believe this might be a permissions issue, please double-check the
    npm ERR! permissions of the file and its containing directories, or try running
    npm ERR! the command again as root/Administrator.
    
    npm ERR! A complete log of this run can be found in:
    npm ERR!     /Users/mariposa/.npm/_logs/2022-04-29T18_59_01_563Z-debug-0.log
    (base) x:brownie-hack mariposa$ npm install ganache-cli@latest -g
    npm ERR! code EACCES
    npm ERR! syscall mkdir
    npm ERR! path /usr/local/lib/node_modules/ganache-cli
    npm ERR! errno -13
    npm ERR! Error: EACCES: permission denied, mkdir '/usr/local/lib/node_modules/ganache-cli'
    npm ERR!  [Error: EACCES: permission denied, mkdir '/usr/local/lib/node_modules/ganache-cli'] {
    npm ERR!   errno: -13,
    npm ERR!   code: 'EACCES',
    npm ERR!   syscall: 'mkdir',
    npm ERR!   path: '/usr/local/lib/node_modules/ganache-cli'
    npm ERR! }
    npm ERR! 
    npm ERR! The operation was rejected by your operating system.
    npm ERR! It is likely you do not have the permissions to access this file as the current user
    npm ERR! 
    npm ERR! If you believe this might be a permissions issue, please double-check the
    npm ERR! permissions of the file and its containing directories, or try running
    npm ERR! the command again as root/Administrator.
    
    npm ERR! A complete log of this run can be found in:
    npm ERR!     /Users/mariposa/.npm/_logs/2022-04-29T19_24_54_189Z-debug-0.log
    (base) x:brownie-hack mariposa$ ganache-cli --version
    
    

` $brownie --network ganache-cli`

    
    
    > Brownie v1.18.1 - Python development framework for Ethereum
    
    > Usage:  brownie <command> [<args>...] [options <args>]...
    

This is the deploy script provided by chainlink hackathon. Error message in
visual studio code that highlights brownie (""Import ""brownie"" could not be
resolved pylance..."")

    
    
    from brownie import SimpleStorage, accounts
    
    def main():
        account = accounts[0]
        simple_storage_contract = SimpleStorage.deploy({""from"": account})
        print(simple_storage_contract.number())
    



Answers:
(Answered on: 2022-09-06 10:40:11)


Write terminal

    
    
    sudo strong textnpm install -g ganache-cli
    


---
(Answered on: 2022-04-27 21:52:49)


The error isn't actually to do with Ganache (the fact that Ganache gets stuck
there is supposed to happen; that means it is running at that IP address and
port).

What is happening is you have a syntax error in your `deploy.py` file at line
8. It is saying you have `simple.storage` when what you want is
`simple_storage` (with the underscore instead of the period). Make sure you
fix line 8 in the script **and save the file**.





:::NEXT DOC:::

Question: (Asked on: 2021-11-30 19:30:53)
How do I install dependencies for Yarn?
URL: https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn

Question Body:


trying to install yarn for my chainlink node. This is the error I'm getting.
Any thoughts?

    
    
    node -e ""if(process.env.npm_execpath.indexOf('yarn') === -1) throw new Error('Please use yarn to install dependencies\n\n')""
    



Answers:
(Answered on: 2021-12-01 16:51:27)


Did you try

    
    
    yarn install
    

in the main node's folder?





:::NEXT DOC:::

Question: (Asked on: 2021-11-24 16:18:20)
Chainlink Node step 5. Build and Install: getting error code 137 for yarn
URL: https://stackoverflow.com/questions/70099478/chainlink-node-step-5-build-and-install-getting-error-code-137-for-yarn

Question Body:


I am trying to run a [chainlink node from
source](https://github.com/smartcontractkit/chainlink#install) and am
following the install instructions.

I'm currently running `make install`

It looks like the error code says there is not enough memory on my machine,
but my linux container on my chrome duet has 50GB. I don't know the problem. I
ran the command:

These are the errors

    
    
    error Command failed with exit code 137.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 137.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
     | `yarn setup` failed with exit code 137
    Stopping 2 active children
    Aborted execution due to previous error
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    

What do I do?



Answers:
(Answered on: 2021-11-24 21:02:02)


Per the
[documentation](https://github.com/smartcontractkit/chainlink#install):

> If you got any errors regarding locked yarn package, try running yarn
> install before this step

So run `yarn install`



"
How can I change the price feed token from ETH/USD to BUSD/USD using the Chainlink oracle?,"If you are trying to get BUSD/USD via a price feed on Kovan testnet, it is not available on that specific network. It is available on Ethereum mainnet however. If you are testing using the price feed, you can always use a mock contract to mock the behavior of the feeds for testing purposes only.",{'source': 'https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin'},"To change the price feed token from ETH/USD to BUSD/USD using the Chainlink oracle, you need to update the address of the price feed contract. However, it seems that there is no BUSD/USD price feed available on the Kovan testnet. The available price feed on Kovan is for ETH/USD. If you want to use BUSD/USD, you would need to switch to the Ethereum mainnet where the BUSD/USD price feed is available. Make sure to use the correct address for the BUSD/USD price feed on the Ethereum mainnet.

","- https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin
- https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet","Question: (Asked on: 2023-04-27 01:03:24)
How to run test for ETH to USD conversion with chainlink?
URL: https://stackoverflow.com/questions/76116055/how-to-run-test-for-eth-to-usd-conversion-with-chainlink

Question Body:


I have the following code for Bank.sol

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity >=0.4.22 <0.9.0;
    
    import ""@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";
    import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";
    import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
    
    contract Bank is Initializable, AccessControlUpgradeable {
        // Code to handle two different roles: Manager and User
        bytes32 public constant MANAGER_ROLE = keccak256(""MANAGER_ROLE"");
        bytes32 public constant USER_ROLE = keccak256(""USER_ROLE"");
        mapping(address => uint256) private _balances;
    
    
        // Code for initializer
        function initialize() public initializer {
    
        }
    
        function deposit() public payable {
            _balances[msg.sender] += msg.value;
    
        }
    
        function convertToUSD(address account) public view returns (uint256) {
            uint256 ethAmount = _balances[account];
            int256 price = getLatestPrice();
            uint256 usdAmount = uint256(price) * ethAmount / 1e18;
            return usdAmount;
        }
    
        function getLatestPrice() public view returns (int256) {
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);
            (, int256 price, , , ) = priceFeed.latestRoundData();
            return price;
        }
    
        function balanceOf(address account) public view returns (uint256) {
            return _balances[account];
        }
    
        function withdraw(uint _amount) public {
            require (_balances[msg.sender] >= _amount, ""Insufficient balance"");
            _balances[msg.sender] -= _amount;
            (bool sent,) = msg.sender.call{value: _amount}(""sent"");
            require(sent, ""Failed to Complete"");
        }
    }
    

And I am trying to run a test for it using Truffle

    
    
    const Bank = artifacts.require('Bank.sol')
    
    contract(""Bank"", async accounts => {
        it(""User should be able to deposit funds"", async () => {
            const bank = await Bank.new()
            const depositer = accounts[1]
            const amount = web3.utils.toWei('10', 'ether')
            await bank.deposit({from: depositer, value: amount})
            let balance = await bank.balanceOf(depositer)
            balance = parseInt(web3.utils.fromWei(balance, 'ether'))
            assert.equal(balance, 10)
            let usd = await bank.convertToUSD(depositer)
            console.log(usd)
        })
    })
    

The test works without the last 2 lines. However, I am trying to get the code
to print out in USD, the amount a user has in his account. For some reason, I
am getting a `VM Exception while processing transaction: revert` error on
bank.convertToUSD(depositer)

It would be great if someone could shed light on what I may have done wrong as
it is my first time learning this. Thank you!



Answers:
(Answered on: 2023-04-27 19:08:13)


I found the solution. When using chainlink, you need to specifically choose
what address from chainlink you want to do your conversion with, and when you
do normal testing, it is done locally where such an address doesn't exist. The
problem is fixed when you use the correct address and test it with the
contract being deployed on the correct testnet.





:::NEXT DOC:::

Question: (Asked on: 2023-01-30 17:38:21)
Why is Chainlink oracle function call failing?
URL: https://stackoverflow.com/questions/75288132/why-is-chainlink-oracle-function-call-failing

Question Body:


While attempting to fund me contract is tell me it encountered an error
without specifying the error. I attempted to fund 0.1 eth through the fund
function, and in the terminal it says:

    
    
    [block:8404521 txIndex:12]
    from: 0x8a9...e4303
    to: FundMe.fund() 0x542...E109C
    value: 100000000000000000 wei
    data: 0xb60...d4288
    logs: 0
    hash: 0x29a...97939
    

and in the etherscan it says:status fail :

    
    
    Contract 0x5422f3458be343e378e7a399e16fff548e7e109c
     Warning! Error encountered during contract execution [execution reverted] 
    

I tried looking for problems with my code and found none.

    
    
    // SPDX-License-Identifier: MIT
    
    pragma solidity >=0.6.6 <0.9.0;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    //import ""@chainlink/contracts/src/v0.8/vendor/SafeMathChainlink.sol""; won't need in later complier versions.
    contract FundMe {
        
    
        mapping(address => uint256) public addressToAmountFunded;
    
        function fund() public payable {
            uint256 minimumUSD = 50 * 10 ** 18;
            require( getConversionRate(msg.value) >= minimumUSD,""You need to send more Eth"");
            addressToAmountFunded[msg.sender] += msg.value;
        }
    
        function getVersion() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
            return priceFeed.version();
        }
    
        function getPrice() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
            (,int256 answer,,,)=priceFeed.latestRoundData();
            return uint256(answer * 10000000000);
        }
        //10000000000 = Gwei which is why we added 10 zeros to getPrice(answer) to convert it to Wei amount
        function getConversionRate(uint256 ethAmount) public view returns (uint256){
            uint256 ethPrice = getPrice();
            uint256 ethAmountInUsd = (ethPrice * ethAmount)/ 1000000000000000000; //divide 2x because we added 10*((getPrice)answer))
            return ethAmountInUsd;
        }
    }
    



Answers:
(Answered on: 2023-01-31 03:09:55)


  * Aggregator contract address ""0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"" belongs to [mainnet](https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd)

[From here](https://docs.chain.link/data-feeds/price-feeds/addresses/) get the
`ETH/USD` goerli testnet address:""0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e""

  * Now in order to call chainlink oracle you have to have `LINK` token in your contract. Get some link token to your conract address [from the faucet](https://faucets.chain.link/)

  * Import the token in metamask. you will see the amount

  * send link token from your metamask to your contract

  * deploy your contract. if you are using `Remix IDE` chose the `injected provider` to connect to metamask. Because chainlink contract is on goerli, so you need to be on Goerli testnet. Once deployment goes through you can call the `fund` function.

  * Since the `fund` function has no argument, you need to send the value alongside the transaction. That is why inside the function you have `msg.value` to access to the sent amount.

  * In `Remix` ide, under ""GAS LIMIT`input there is`VALUE`input. you need to pass the amount in there before you call the`fund` function.





:::NEXT DOC:::

Question: (Asked on: 2021-11-21 09:18:55)
How to get price information from Chainlink?
URL: https://stackoverflow.com/questions/70053205/how-to-get-price-information-from-chainlink

Question Body:


I would like to get USD price of DeFi tokens from Chainlink.

However, it looks like, I can get the price of an asset through either the
[Chainlink API calls](https://docs.chain.link/docs/make-a-http-get-request/),
or [Chainlink price feeds](https://docs.chain.link/docs/get-the-latest-
price/).

What are the costs associated with each and the differences and tradeoffs?



Answers:
(Answered on: 2021-11-22 19:28:33)


**With[Chainlink price feeds](https://docs.chain.link/docs/get-the-latest-
price/)**, each data feed is updated by a decentralized oracle network. Each
oracle in the set publishes data during an aggregation round. That data is
validated and aggregated by a smart contract, which forms the feed's latest
and trusted answer.

Each oracle operator is rewarded for publishing data. On mainnet, [sponsors
are paying the LINK
associated](https://ethereum.stackexchange.com/questions/90728/what-is-the-
cost-of-using-a-chainlink-oracle/90752#90752) to keep those feeds live,
decentralized, and secure, so they are not free. This allows the network to be
a shared resource where everyone chips in a tiny bit and makes them even
cheaper than running even your own centralized feed.

That being said, the price feeds are currently a simple `view` function, and
anyone can technically use them as access controls are on the roadmap to be
built at some point. It’s not really economical or fair for those backers who
are paying to support them for everyone else. Until access controls are built,
please reach out if you are using them on mainnet and learn how you can
contribute to keep them reliable honest, and secure.

**With API calls** , Chainlink enables your contracts to access any external
data source, through their decentralized oracle network. Making a HTTP GET
request will fail unless your deployed contract has enough LINK to pay for it,
therefore one needs to fund that smart contract.

If your contract is calling a public API endpoint, an Oracle job may already
exist for it. To check available jobs and GET request prices, visit
<https://market.link/>





:::NEXT DOC:::

Question: (Asked on: 2021-09-23 11:16:52)
how do i change the price feed token from eth /usd to busd/usd with the chainlink oracle?
URL: https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin

Question Body:


I am trying to get the price feed for BUSD/USD using the chainlink pricefeed
oracle but it tells me that the code was reverted. this is also happening when
i switch to any other token, i am using the kovan test net

this is the error i get

> call to PriceConsumerV3.getLatestPrice call to
> PriceConsumerV3.getLatestPrice errored: VM execution error. Reverted 0x

and this is my code

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.7;
    
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
    
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Kovan
         * Aggregator: ETH/USD
         * Address: 0x9326BFA02ADD2366b30bacB125260Af641031331
         */
        constructor() public {
            priceFeed = AggregatorV3Interface(0xcBb98864Ef56E9042e7d2efef76141f15731B82f);
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            (
                uint80 roundID, 
                int price,
                uint startedAt,
                uint timeStamp,
                uint80 answeredInRound
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    



Answers:
(Answered on: 2021-09-27 03:10:51)


If you are trying to get BUSD/USD via a price feed on Kovan testnet, [it is
not available on that specific network](https://docs.chain.link/docs/ethereum-
addresses/#Kovan%20Testnet). It is [available on Ethereum
mainnet](https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet)
however.

If you are testing using the price feed, you can always use a mock contract to
mock the behavior of the feeds for testing purposes only.


---
(Answered on: 2021-09-23 22:11:12)


You have set incorrect ChainLink address!

correct ETH/USD address: `0x9326BFA02ADD2366b30bacB125260Af641031331`

Address you are using in on BSC network, not Kovan network!



"
Why are no job runs appearing on my local Chainlink node when trying to fulfill requests?,"There are a couple of possible reasons why no job runs are appearing on your local Chainlink node. First, make sure that the external job id in the Jobs screen on the Operator UI does not contain dashes. If it does, remove the dashes when using it in the ATestnetConsumer contract. Additionally, the direct request toml may not work as is. Try appending 'allowunrestrictednetworkaccess=""true""' to the fetch section in the toml file.",{'source': 'https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally'},"The state/country's law that governs the interpretation of the contract is English law. 
",28-pl,"# Fulfilling Requests

  * Overview
  * Requirements
  * Address Types
  * Setup your Operator contract
  * Deploy your own Operator contract
  * Whitelist your node address in the Operator contract
  * Add a job to the node
  * Create a request to your node
  * Withdrawing LINK

Run a Chainlink node

This guide assumes you have a running Chainlink node. To learn how to run a
node, see the [Running a Chainlink Node locally](/chainlink-nodes/v1/running-a-chainlink-node) guide.

You can use your Chainlink nodes to fulfill requests. This guide shows you how
to deploy your own operator contract and add jobs to your node so that it can
provide data to smart contracts.

Chainlink nodes can fulfill requests from open or unauthenticated APIs without
the need for [External Adapters](/chainlink-nodes/external-adapters/external-adapters) as long as you've added the jobs to the node. For these requests,
requesters supply the URL to the open API that they want each node to
retrieve. The Chainlink node will use [tasks](/chainlink-nodes/oracle-jobs/tasks) to fulfill the request.

Some APIs require authentication by providing request headers for the
operator's API key, which the Chainlink node supports. If you would like to
provide access to an API that requires authentication, you must create a job
that is specific for that API either using an [external adapter](/chainlink-nodes/external-adapters/external-adapters) or by using the parameters of the
[HTTP task](/chainlink-nodes/oracle-jobs/all-tasks/#http-task).

## Requirements

Before you begin this guide, complete the following tasks to make sure you
have all of the tools that you need:

  * [Set up MetaMask](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) and [obtain testnet LINK](/resources/acquire-link).

  * [Run a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node).

  * Fund the Ethereum address that your Chainlink node uses. You can find the address in the node Operator GUI under the **Key Management** configuration. The address of the node is the `Regular` type. You can obtain test ETH from several [faucets](/resources/link-token-contracts). For this tutorial to work, you will have to fund the node's Ethereum address with Sepolia ETH. Here is an example:

## Address Types

Your node works with several different types of addresses. Each address type
has a specific function:

  * **Node address:** This is the address for your Chainlink node wallet. The node requires native blockchain tokens at all times to respond to requests. For this example, the node uses Sepolia ETH. When you start a Chainlink node, it automatically generates this address. You can find this address on the Node Operator GUI under **Key Management > EVM Chain Accounts**.
  * **Oracle contract address:** This is the address for contracts like `Operator.sol` or `Oracle.sol` that are deployed to a blockchain. Do not fund these addresses with native blockchain tokens such as ETH. When you make API call requests, the funds pass through this contract to interact with your Chainlink node. This will be the address that smart contract developers point to when they choose a node for an API call.
  * **Admin wallet address:** This is the address that owns your `Operator.sol` or `Oracle.sol` contract addresses. If you're on OCR, this is the wallet address that receives LINK tokens.

## Setup your Operator contract

### Deploy your own Operator contract

  1. Go to Remix and open the [`Operator.sol` smart contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkNodes/Operator.sol).

  2. On the **Compile** tab, click the **Compile** button for `Operator.sol`. Remix automatically selects the compiler version and language from the `pragma` line unless you select a specific version manually.

  3. On the **Deploy and Run** tab, configure the following settings:

    * Select ""Injected Provider"" as your **Environment**. The Javascript VM environment cannot access your oracle node. Make sure your Metamask is connected to Sepolia testnet.

    * Select the ""Operator"" contract from the **Contract** menu.

    * Copy the [LINK token contract address](/resources/link-token-contracts) for the network you are using and paste it into the `LINK` field next to the **Deploy** button. For Sepolia, you can use this address:
        
                0x779877A7B0D9E8603169DdbD7836e478b4624789

    * Copy the _Admin wallet address_ into the `OWNER` field.

  4. Click **transact**. MetaMask prompts you to confirm the transaction.

MetaMask doesn't pop up?

If MetaMask does not prompt you and instead displays the error below, disable
""Privacy Mode"" in MetaMask. You can do this by clicking on your unique account
icon at the top-right, then go to the Settings. Privacy Mode will be a switch
near the bottom.

  

Error: **Send transaction failed: Invalid address. If you use an injected
provider, please check it is properly unlocked.**

  5. If the transaction is successful, a new address displays in the **Deployed Contracts** section.

  6. Keep note of the Operator contract address. You need it later for your consuming contract.

### Whitelist your node address in the Operator contract

  1. In the Chainlink node GUI, find and copy the address of your chainlink node. see Requirements.

  2. In Remix, call the `setAuthorizedSenders` function with the address of your node. Note the function expects an array.

  3. Click the `transact` function to run it. Approve the transaction in MetaMask and wait for it to confirm on the blockchain.

  4. Call `isAuthorizedSender` function with the address of your node to verify that your chainlink node address can call the operator contract. The function must return `true`.

## Add a job to the node

You will create a job that calls an OpenAPI , parses the response and then
return a `uint256`.

  1. In the Chainlink Operator UI on the **Jobs** tab, click **New Job**.

  2. Paste the job specification from above into the text field.
    
        # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    name = ""Get > Uint256 - (TOML)""
    schemaVersion = 1
    type = ""directrequest""
    # Optional External Job ID: Automatically generated if unspecified
    # externalJobID = ""b1d42cd5-4a3a-4200-b1f7-25a68e48aad8""
    contractAddress = ""YOUR_OPERATOR_CONTRACT_ADDRESS""
    maxTaskDuration = ""0s""
    minIncomingConfirmations = 0
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=""cborparse"" data=""$(decode_log.data)""]
        fetch        [type=""http"" method=GET url=""$(decode_cbor.get)"" allowUnrestrictedNetworkAccess=""true""]
        parse        [type=""jsonparse"" path=""$(decode_cbor.path)"" data=""$(fetch)""]
    
        multiply     [type=""multiply"" input=""$(parse)"" times=""$(decode_cbor.times)""]
    
        encode_data  [type=""ethabiencode"" abi=""(bytes32 requestId, uint256 value)"" data=""{ \\""requestId\\"": $(decode_log.requestId), \\""value\\"": $(multiply) }""]
        encode_tx    [type=""ethabiencode""
                      abi=""fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes calldata data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"":   $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                      ]
        submit_tx    [type=""ethtx"" to=""YOUR_OPERATOR_CONTRACT_ADDRESS"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> multiply -> encode_data -> encode_tx -> submit_tx
    """"""
    

  3. Replace `YOUR_OPERATOR_CONTRACT_ADDRESS` with the address of your deployed operator contract address from the previous steps.

  4. Click **Create Job**. If the node creates the job successfully, a notice with the job number appears.

  5. Click the job number to view the job details. You can also find the job listed on the **Jobs** tab in the Node Operators UI. Save the `externalJobID` value because you will need it later to tell your consumer contract what job ID to request from your node.

## Create a request to your node

After you add jobs to your node, you can use the node to fulfill requests.
This section shows what a requester does when they send requests to your node.
It is also a way to test and make sure that your node is functioning
correctly.

  1. Open [ATestnetConsumer.sol in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol).

  2. Note that `setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789)` is configured for _Sepolia_.

  3. On the **Compiler** tab, click the **Compile** button for `ATestnetConsumer.sol`.

  4. On the **Deploy and Run** tab, configure the following settings:

    * Select _Injected Provider_ as your environment. Make sure your metamask is connected to Sepolia.
    * Select _ATestnetConsumer_ from the **Contract** menu.
  5. Click **Deploy**. MetaMask prompts you to confirm the transaction.

  6. Fund the contract by sending LINK to the contract's address. See the [Fund your contract](/resources/fund-your-contract) page for instructions. The address for the `ATestnetConsumer` contract is on the list of your deployed contracts in Remix. You can fund your contract with 1 LINK.

  7. After you fund the contract, create a request. Input your operator contract address and the job ID for the `Get > Uint256` job into the `requestEthereumPrice` request method **without dashes**. The job ID is the `externalJobID` parameter, which you can find on your job's definition page in the Node Operators UI.

  8. Click the **transact** button for the `requestEthereumPrice` function and approve the transaction in Metamask. The `requestEthereumPrice` function asks the node to retrieve `uint256` data specifically from [https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD](https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD).

  9. After the transaction processes, you can see the details for the complete the job run the **Runs** page in the Node Operators UI.

  10. In Remix, click the `currentPrice` variable to see the current price updated on your consumer contract.

## Withdrawing LINK

You can withdraw LINK from the operator contract. In Remix under the list of
deployed contracts, click on your Operator contract and find the `withdraw`
function in the function list. Note that only the admin (see Admin wallet
address) can withdraw LINK.



Paste the address you want to withdraw to, and specify the amount of LINK that
you want to withdraw. Then, click `withdraw`. Confirm the transaction in
MetaMask when the popup appears.

## What's next

  * [› Performing System Maintenance](/chainlink-nodes/resources/performing-system-maintenance)
  * [› v2 Jobs](/chainlink-nodes/oracle-jobs/jobs)
  * [› Security and Operation Best Practices](/chainlink-nodes/resources/best-security-practices)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/fulfilling-requests.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-05-11 08:55:38)
No job show up in Runs page while trying to run a Chainlink node locally
URL: https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally

Question Body:


I am trying to fulfil requests on my local test chainlink node on rinkeby
(following <https://docs.chain.link/docs/fulfilling-requests/>) but can't see
any job runs appear on my operator ui.

The Oracle contract is at
[0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C](https://rinkeby.etherscan.io/address/0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C)

The ATestnetConsumer contract is at
[0x977129EE2f404F4327A2A60C5fD9E57890D85FD0](https://rinkeby.etherscan.io/address/0x977129ee2f404f4327a2a60c5fd9e57890d85fd0)

My job toml screenshot below [](https://i.stack.imgur.com/uabGd.png)

Have confirmed my .env that it is running the rinkeby wss url from infura and
the chain is 4 and the link token contract address is
0x01BE23585060835E02B77ef475b0Cc51aA1e0709

My node wallet has ETH and LINK. Both the contracts have Link too (but no
ETH).

I run the setFulfillmentPermission function in remix with my Node wallet
address and true

[](https://i.stack.imgur.com/tqQGo.png)

When I execute the requestEthereumPrice function with my oracle address and
job id, I can see the LINK being sent by the [ATestnetConsumer contract to the
Oracle
contract](https://rinkeby.etherscan.io/tx/0xd1b71dd8ec83b7e204de5d2d0a95fdde2be41d0eadb181231ee21596ef661f78)
but no job run gets created in my local Chainlink node.

[](https://i.stack.imgur.com/wK7ha.png)

Confirming that the job hasn't run, I get the 0 value when I run the
currentPrice function on ATestnetConsumer.

Can anyone please point me to where I am going wrong? Thanks in advance!



Answers:
(Answered on: 2022-05-11 12:13:48)


Finally got it to work. Posting my two findings as I do think the
documentation needs an update to account for these.

  1. The external job id in the Jobs screen on the Operator UI has dashes in them. To use them in the ATestnetConsumer contract you need to remove the dashes (so 0e84f38985eb4edb98c2e2a09b589666 and not 0e84f389-85eb-4edb-98c2-e2a09b589666).

  2. The direct request toml doesn't seem to work as is. I had to append allowunrestrictednetworkaccess=""true"" to the fetch section so it becomes

fetch [type=""http"" method=GET url=""$(decode_cbor.get)""
allowunrestrictednetworkaccess=""true""]





:::NEXT DOC:::

Question: (Asked on: 2021-12-28 14:32:36)
Chainlink job not executing but node receiving link fee
URL: https://stackoverflow.com/questions/70508478/chainlink-job-not-executing-but-node-receiving-link-fee

Question Body:


I have a chainlink node running in a evm testnet. I have deployed the link
token and oracle contract, funded my node account with ether, created a job
and a smartcontract that send a request to that job. I use the externalJobID
from job definition in my Chainlink.Request. My oracle account is receieving
the link fee from contract execution and request but my job is not executing.
I dont see anything in my chainlink node logs.

Here is my contract code

    
    
    contract Metadata is ChainlinkClient{
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        //event variables
        struct EMetaData{
            address dataToken;
            bytes   flags;
            bytes   data;
            address sender;
        }
    
        mapping(bytes32 => EMetaData) public metadatas;
    
        constructor() public {
            setChainlinkOracle(0x6a61789194260F0BE95a18d0116d883A4b5284ed);
            setChainlinkToken(0xa38F087411e0908ad87b40Ab4D7Ca9247DE0052e);
            jobId  = ""3a3e489f1fd145b385a18728c6947508"";
            fee    = 0.1 * 10 ** 18; // (0.1 LINK)
        }
    
    
        event MetadataCreated(
            address indexed dataToken,
            address indexed createdBy,
            bytes flags,
            bytes data
        );
    
        function testCreate(
            address _dataToken,
            bytes memory _flags,
            bytes memory _data
         ) public returns (bytes32 requestId){
    
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
            metadatas[request.id].dataToken = _dataToken;
            metadatas[request.id].flags = _flags;
            metadatas[request.id].data = _data;
            metadatas[request.id].sender = msg.sender;
    
            return sendChainlinkRequest(request, fee);
        }
    
        function fulfill(bytes32 _requestId, bool result) public{
            require(result == true, ""Validation Failed"");
             emit MetadataCreated(
                metadatas[_requestId].dataToken,
                metadatas[_requestId].sender,
                metadatas[_requestId].flags,
                metadatas[_requestId].data
            );
        }
    
      }
    }
    

And here is my job spec

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Shacl validation""
    contractAddress = ""0x95D57363B491CF743970c640fe419541386ac8BF""
    maxTaskDuration = ""20s""
    observationSource = """"""
        decode_log  [type=""ethabidecodelog""
                    data=""$(jobRun.logData)""
                    topics=""$(jobRun.logTopics)""
                    abi=""SomeContractEvent(bytes32 requestID, bytes cborPayload)""]
    
        decode_cbor [type=""cborparse""
                    data=""$(decode_log.cborPayload)""]
    
        ds          [type=""http"" method=POST url=""http://localhost:3000/api/v1/aquarius/assets/ddo/validate""]
        ds_parse    [type=""jsonparse"" path=""""]
        encode_response [type=""ethabiencode""
                         abi=""(bool data)""
                         data=""{\\""data\\"": $(ds_parse) }""]
        encode_tx [type=""ethabiencode""
                   abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                   data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_response)}""
                   ]
        submit_tx [type=""ethtx"" to=""0x95D57363B491CF743970c640fe419541386ac8BF"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> ds -> ds_parse -> encode_response -> encode_tx -> submit_tx
    """"""
    externalJobID = ""3a3e489f-1fd1-45b3-85a1-8728c6947508""
    

\----------- edit 0x6a61789194260F0BE95a18d0116d883A4b5284ed was the chainlink
node account

0x95D57363B491CF743970c640fe419541386ac8BF was the oracle contract address



Answers:
(Answered on: 2021-12-28 19:35:57)


After some discussion on Chainlink discord I got some help

The problem was that I was passing my chainlink node account ou the
Chainlink.Request object and the correct is to pass the oracle contract
address.


---
(Answered on: 2021-12-29 08:32:35)


Just pulling the answer out of Discord so that others can find it more easily
(as the terms node address and oracle address are regularly confused):

`0x6a61789194260F0BE95a18d0116d883A4b5284ed` is the address of your Chainlink
node (you can see in the key tab of the GUI), which needs to be funded with
ETH in order to send transactions on-chain. The Chainlink node listens to
event logs emitted by the oracle smart contract used in the job spec, the
oracle address is not the account you used to deploy it, but the address of
the newly deployed oracle smart contract, make sure to follow these steps:
<https://docs.chain.link/docs/fulfilling-requests/#deploy-your-own-oracle-
contract>

You can find the oracle contract address in Remix and the block explorer of
the underlying network, that's what you need to use in your consumer contract
in order to make successful requests, the LINK rewards can then be withdrawn
from the oracle contract.





:::NEXT DOC:::

Question: (Asked on: 2021-11-24 17:00:49)
Chainlink node external adapter job not returning value
URL: https://stackoverflow.com/questions/70100103/chainlink-node-external-adapter-job-not-returning-value

Question Body:


I am following the ""Chainlink Hackathon | Building and using External
Adapters"" video tutorial (Oct 2021) and have done the following:

-Successfully set up and ran my own Chainlink node (per ""Chainlink Hackathon | Running a Chainlink node, 1.0.0 update"" video tutorial [Oct 2021].

-Created `Oracle.sol` contract and `setFulfillmentPermission` to `true`

-Successfully created Job Run on my node for the `Get > Uint256` example

-Added Eth to my node.

Added the following bridge to my node:

    
    
    URL http://localhost:8080
    Confirmations   0
    Minimum Contract Payment    0
    Outgoing Token  OKKkCQpl84Kiw38WNZ77fg1UKLgyB5+c
    

Added the Job definition:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""soccer-data-ea-2""
    contractAddress = ""0x4664A91f79999fd9DD4587dDf3daA3D01Ec50825""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=""cborparse"" data=""$(decode_log.data)""]
        fetch        [type=bridge name=hackathon requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": {\\""PlayerId\\"": $(decode_cbor.PlayerId)}}""]
        parse        [type=""jsonparse"" path=""data,0,Games"" data=""$(fetch)""]
        encode_data  [type=""ethabiencode"" abi=""(uint256 value)"" data=""{ \\""value\\"": $(parse) }""]
        encode_tx    [type=""ethabiencode""
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=""ethtx"" to=""0x4664A91f79999fd9DD4587dDf3daA3D01Ec50825"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx
    """"""
    externalJobID = ""88cafd3a-e04b-453d-9521-26372a9c1ab0""
    

Added my Oracle address and JobId (without dashes) to the APIConsumer.sol
contract:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
     */
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public games;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Kovan
         * Oracle: 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 (Chainlink Devrel   
         * Node)
         * Job ID: d5270d1c311941d0b08bead21fea7747
         * Fee: 0.1 LINK
         */
        constructor() {
            setPublicChainlinkToken();
            oracle = 0x4664A91f79999fd9DD4587dDf3daA3D01Ec50825;
            jobId = ""88cafd3ae04b453d952126372a9c1ab0"";
            fee = 0.1 * 10 ** 18; // (Varies by network and job)
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"": xxx.xxx,
            //     }
            //    }
            //   }
            //  }
            request.add(""PlayerId"", ""90026531"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
          
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, uint256 _games) public recordChainlinkFulfillment(_requestId)
        {
            games = _games;
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    

I deployed and sent LINK to the APIConsumer contract, hit `requestVolumeData`,
funded the transaction, however the job never runs and I get no error. Have
been reviewing the tutorial and building it from scratch several times but the
bridge external adapter on my node never runs the job.

Not sure why it's not working?



Answers:
(Answered on: 2021-12-27 02:36:55)


I've found the solution: in your consumer contract: set fee = 1 * 10 ** 18;
not 0.1 or in your .env file:
MINIMUM_CONTRACT_PAYMENT_LINK_JUELS=100000000000000000 set fee = 1


---
(Answered on: 2021-12-27 02:26:00)


Modify the fee to 1 * 10**18 in your consumer contract, or add a line to your
`.env` file and reboot your CL node:

    
    
    MINIMUM_CONTRACT_PAYMENT_LINK_JUELS=100000000000000000
    

which means, change the minimum link payment to 0.1LINK globally.



"
Is it possible for Chainlink VRF to return two same randomnesses in one request?,Chainlink VRF generates one or more random values and cryptographic proof for each request. It is unlikely for Chainlink VRF to return the same randomness in one request.,{'source': 'https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request'},"For each request, Chainlink VRF generates one or more random values and cryptographic proof of how those values were determined. It is unlikely that a Chainlink VRF would return the same randomness in one request.
",https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request,"# Random Numbers: Using Chainlink VRF

  * Overview
  * How is randomness generated on blockchains? What is Chainlink VRF?
  * What is the Request and Receive cycle?
  * What is the payment process for generating a random number?
  * How can I use Chainlink VRF?
  * Create and fund a subscription
  * Importing VRFConsumerBaseV2 and VRFCoordinatorV2Interface
  * Contract variables
  * Initializing the contract
  * rollDice function
  * fulfillRandomWords function
  * house function
  * How do I deploy to testnet?
  * How do I add my contract to my subscription account?
  * How do I test rollDice?
  * Further Reading

Requirements

This guide assumes that you have basic knowledge about writing and deploying
smart contracts. If you are new to smart contract development, read the
[Consuming Data Feeds](/getting-started/consuming-data-feeds) guide before you
begin.

VRF v2 - Developer Walkthrough

In this guide, you will learn about generating randomness on blockchains. This
includes learning how to implement a Request and Receive cycle with Chainlink
oracles and how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation of Chainlink VRF, see [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number). In this section,
you will create an application that uses Chainlink VRF to generate randomness.
The contract used in this application has a [_Game of
Thrones_](https://en.wikipedia.org/wiki/Game_of_Thrones) theme.

After the contract requests randomness from Chainlink VRF, the result of the
randomness will transform into a number between 1 and 20, mimicking the
rolling of a 20 sided die. Each number represents a _Game of Thrones_ house.
If the dice land on the value 1, the user is assigned house Targaryan, 2 for
Lannister, and so on. A full list of houses can be found
[here](https://gameofthrones.fandom.com/wiki/Great_House).

When rolling the dice, it uses an `address` variable to track which address is
assigned to each house.

The contract has the following functions:

  * `rollDice`: This submits a randomness request to Chainlink VRF
  * `fulfillRandomWords`: The function that the Oracle uses to send the result back
  * `house`: To see the assigned house of an address

**Note** : to jump straight to the entire implementation, you can [open the
VRFD20.sol
contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFD20.sol)
in remix.

### Create and fund a subscription

Chainlink VRF requests receive funding from subscription accounts. The
[Subscription Manager](https://vrf.chain.link) lets you create an account and
pre-pay your use of Chainlink VRF requests. For this example, create a new
subscription on the Sepolia testnet as explained
[here](/vrf/v2/subscription/examples/get-a-random-number/#create-and-fund-a-subscription).

### Importing `VRFConsumerBaseV2` and `VRFCoordinatorV2Interface`

Chainlink maintains a [library of
contracts](https://github.com/smartcontractkit/chainlink/tree/master/contracts)
that make consuming data from oracles easier. For Chainlink VRF, you will use:

  * [`VRFConsumerBaseV2`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/VRFConsumerBaseV2.sol) that must be imported and extended from the contract that you create.
  * [`VRFCoordinatorV2Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol) that must be imported to communicate with the VRF coordinator.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
    
    }

### Contract variables

This example is adapted for [Sepolia testnet](/vrf/v2/subscription/supported-networks/#sepolia-testnet) but you can change the configuration and make it
run for any [supported network](/vrf/v2/subscription/supported-networks/#configurations).


    uint64 s_subscriptionId;
    address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
    bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
    uint32 callbackGasLimit = 40000;
    uint16 requestConfirmations = 3;
    uint32 numWords =  1;

  * `uint64 s_subscriptionId`: The subscription ID that this contract uses for funding requests. Initialized in the `constructor`.
  * `address vrfCoordinator`: The address of the Chainlink VRF Coordinator contract.
  * `bytes32 s_keyHash`: The gas lane key hash value, which is the maximum gas price you are willing to pay for a request in wei. It functions as an ID of the off-chain VRF job that runs in response to requests.
  * `uint32 callbackGasLimit`: The limit for how much gas to use for the callback request to your contract's `fulfillRandomWords` function. It must be less than the `maxGasLimit` on the coordinator contract. Adjust this value for larger requests depending on how your `fulfillRandomWords` function processes and stores the received random values. If your `callbackGasLimit` is not sufficient, the callback will fail and your subscription is still charged for the work done to generate your requested random values.
  * `uint16 requestConfirmations`: How many confirmations the Chainlink node should wait before responding. The longer the node waits, the more secure the random value is. It must be greater than the `minimumRequestBlockConfirmations` limit on the coordinator contract.
  * `uint32 numWords`: How many random values to request. If you can use several random values in a single callback, you can reduce the amount of gas that you spend per random value. In this example, each transaction requests one random value.

To keep track of addresses that roll the dice, the contract uses mappings.
[Mappings](https://medium.com/upstate-interactive/mappings-in-solidity-explained-in-under-two-minutes-ecba88aff96e) are unique key-value pair data
structures similar to hash tables in Java.


    mapping(uint256 => address) private s_rollers;
    mapping(address => uint256) private s_results;

  * `s_rollers` stores a mapping between the `requestID` (returned when a request is made), and the address of the roller. This is so the contract can keep track of who to assign the result to when it comes back.
  * `s_results` stores the roller and the result of the dice roll.

### Initializing the contract

The coordinator and subscription id must be initialized in the `constructor`
of the contract. To use `VRFConsumerBaseV2` properly, you must also pass the
VRF coordinator address into its constructor. The address that creates the
smart contract is the owner of the contract. the modifier `onlyOwner()` checks
that only the owner is allowed to do some tasks.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // variables
        // ...
    
        // constructor
        constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            s_owner = msg.sender;
            s_subscriptionId = subscriptionId;
        }
    
        //...
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }

### `rollDice` function

The `rollDice` function will complete the following tasks:

  1. Check if the roller has already rolled since each roller can only ever be assigned to a single house.
  2. Request randomness by calling the VRF coordinator.
  3. Store the `requestId` and roller address.
  4. Emit an event to signal that the dice is rolling.

You must add a `ROLL_IN_PROGRESS` constant to signify that the dice has been
rolled but the result is not yet returned. Also add a `DiceRolled` event to
the contract.

Only the owner of the contract can execute the `rollDice` function.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // variables
        uint256 private constant ROLL_IN_PROGRESS = 42;
        // ...
    
        // events
        event DiceRolled(uint256 indexed requestId, address indexed roller);
        // ...
    
        // ...
        // { constructor }
        // ...
    
        // rollDice function
        function rollDice(address roller) public onlyOwner returns (uint256 requestId) {
            require(s_results[roller] == 0, ""Already rolled"");
            // Will revert if subscription is not set and funded.
            requestId = COORDINATOR.requestRandomWords(
            s_keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
           );
    
            s_rollers[requestId] = roller;
            s_results[roller] = ROLL_IN_PROGRESS;
            emit DiceRolled(requestId, roller);
        }
    }

### `fulfillRandomWords` function

`fulfillRandomWords` is a special function defined within the
`VRFConsumerBaseV2` contract that our contract extends from. The coordinator
sends the result of our generated `randomWords` back to `fulfillRandomWords`.
You will implement some functionality here to deal with the result:

  1. Change the result to a number between 1 and 20 inclusively. Note that `randomWords` is an array that could contain several random values. In this example, request 1 random value.
  2. Assign the transformed value to the address in the `s_results` mapping variable.
  3. Emit a `DiceLanded` event.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // ...
        // { variables }
        // ...
    
        // events
        // ...
        event DiceLanded(uint256 indexed requestId, uint256 indexed result);
    
        // ...
        // { constructor }
        // ...
    
        // ...
        // { rollDice function }
        // ...
    
        // fulfillRandomWords function
        function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
    
            // transform the result to a number between 1 and 20 inclusively
            uint256 d20Value = (randomWords[0] % 20) + 1;
    
            // assign the transformed value to the address in the s_results mapping variable
            s_results[s_rollers[requestId]] = d20Value;
    
            // emitting event to signal that dice landed
            emit DiceLanded(requestId, d20Value);
        }
    }

### `house` function

Finally, the `house` function returns the house of an address.

To have a list of the house's names, create the `getHouseName` function that
is called in the `house` function.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // ...
        // { variables }
        // ...
    
        // ...
        // { events }
        // ...
    
        // ...
        // { constructor }
        // ...
    
        // ...
        // { rollDice function }
        // ...
    
        // ...
        // { fulfillRandomWords function }
        // ...
    
        // house function
        function house(address player) public view returns (string memory) {
            // dice has not yet been rolled to this address
            require(s_results[player] != 0, ""Dice not rolled"");
    
            // not waiting for the result of a thrown dice
            require(s_results[player] != ROLL_IN_PROGRESS, ""Roll in progress"");
    
            // returns the house name from the name list function
            return getHouseName(s_results[player]);
        }
    
        // getHouseName function
        function getHouseName(uint256 id) private pure returns (string memory) {
            // array storing the list of house's names
            string[20] memory houseNames = [
                ""Targaryen"",
                ""Lannister"",
                ""Stark"",
                ""Tyrell"",
                ""Baratheon"",
                ""Martell"",
                ""Tully"",
                ""Bolton"",
                ""Greyjoy"",
                ""Arryn"",
                ""Frey"",
                ""Mormont"",
                ""Tarley"",
                ""Dayne"",
                ""Umber"",
                ""Valeryon"",
                ""Manderly"",
                ""Clegane"",
                ""Glover"",
                ""Karstark""
            ];
    
            // returns the house name given an index
            return houseNames[id - 1];
        }
    }

You have now completed all necessary functions to generate randomness and
assign the user a _Game of Thrones_ house. We've added a few helper functions
in there to make using the contract easier and more flexible. You can deploy
and interact with the complete contract in Remix.

## How do I deploy to testnet?

You will deploy this contract on the Sepolia test network. You need to [have
some Sepolia ETH](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) in your MetaMask account to pay for the gas.

This deployment is slightly different than the example in the [Deploy Your
First Contract](/getting-started/deploy-your-first-contract) guide. In this
case, you pass in parameters to the constructor upon deployment.

Once compiled, you'll see a dropdown menu that looks like this in the deploy
pane:



Select the `VRFD20` contract or the name that you gave to your contract.

Click the caret arrow on the right hand side of **Deploy** to expand the
parameter fields, and paste your subscription ID.



Then click the `Deploy` button and use your MetaMask account to confirm the
transaction.

Address, Key Hashes and more

For a full reference of the addresses, key hashes and fees for each network,
see [VRF Supported Networks](/vrf/v2/subscription/supported-networks/#configurations).

At this point, your contract should be successfully deployed. However, it
can't request anything because it is not yet approved to use the LINK balance
in your subscription. If you click `rollDice`, the transaction will revert.

## How do I add my contract to my subscription account?

After you deploy your contract, you must add it as an approved consumer
contract so it can use the subscription balance when requesting for
randomness. Go to the [Subscription Manager](https://vrf.chain.link) and add
your deployed contract address to the list of consumers. Find your contract
address in Remix under **Deployed Contracts** on the bottom left.



## How do I test `rollDice`?

After you open the deployed contract tab in the bottom left, the function
buttons are available. Find `rollDice` and click the caret to expand the
parameter fields. Enter an Ethereum address to specify a ""dice roller"", and
click 'rollDice'.

It takes a few minutes for the transaction to confirm and the response to be
sent back. You can get your house by clicking the `house` function button with
the address passed in `rollDice`. After the response is sent back, you'll be
assigned a _Game of Thrones_ house!

## Further Reading

To read more about generating random numbers in Solidity, read our blog posts:

  * [35+ Blockchain RNG Use Cases Enabled by Chainlink VRF](https://blog.chain.link/blockchain-rng-use-cases-enabled-by-chainlink-vrf/)
  * [How to Build Dynamic NFTs on Polygon](https://blog.chain.link/how-to-build-dynamic-nfts-on-polygon/)
  * [Chainlink VRF v2 Now Live on Ethereum Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/)

## What's next

  * [› Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number)
  * [› Programmatic Subscription](/vrf/v2/subscription/examples/programmatic-subscription)
  * [› Security Considerations](/vrf/v2/security)
  * [› Best Practices](/vrf/v2/best-practices)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/intermediates-tutorial.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2023-01-19 03:22:56)
Possible Chainlink VRF returns two same randomnesses in one request?
URL: https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request

Question Body:


as the title, i am thinking if it's possible that Chainlink VRF returns two
same randomnesses in one request? As of ""random"", i assume the answer is YES.
Thanks.



Answers:
(Answered on: 2023-01-19 08:57:48)


For each request, Chainlink VRF generates one or more random values and
cryptographic proof of how those values were determined. It is unlikely that a
Chainlink VRF would return the same randomness in one request.





:::NEXT DOC:::

Question: (Asked on: 2022-10-03 17:21:45)
Chainlink VRF or RANDAO?
URL: https://stackoverflow.com/questions/73938799/chainlink-vrf-or-randao

Question Body:

    
    
        bytes9 private _randomness;
    
        function getRandomness() public view returns (uint256) {
            return uint256(keccak256(abi.encode(_randomness, address(this))));
        }
        
         modifier updateRandomness() {
            bytes32 randomness = _randomness;
            assembly {
                // Pick any of the last 256 blocks psuedorandomly for the blockhash.
                // Store the blockhash, the current `randomness` and the `coinbase()`
                // into the scratch space.
                mstore(0x00, blockhash(sub(number(), add(1, byte(0, randomness)))))
                // `randomness` is left-aligned.
                // `coinbase()` is right-aligned.
                // `difficulty()` is right-aligned.
                // After the merge, if [EIP-4399](https://eips.ethereum.org/EIPS/eip-4399)
                // is implemented, the randomness will be determined by the beacon chain.
                mstore(0x20, xor(randomness, xor(coinbase(), difficulty())))
                // Compute the new `randomness` by hashing the scratch space.
                randomness := keccak256(0x00, 0x40)
            }
            _randomness = bytes9(randomness);
            _;
        }
    
        function generateNFT() external updateRandomness {
            uint256 randomNum = getRandomness();
            uint256 remaining = MAX_SUPPLY - totalSupply();
            uint256 newId = (randomNum % remaining);
            // ...
        }
    
    

seems like after the merge, getting a solid random value might be feasible.

this could be a good replacement for chainlink vrf?



Answers:
(Answered on: 2022-10-13 13:09:03)


# Summary

For pseudorandomness you can use something like
[EIP-4399](https://eips.ethereum.org/EIPS/eip-4399):

    
    
    uint256 randomness = uint(keccak256(abi.encodePacked(msg.sender, block.difficulty, block.timestamp)));
    

(You don't even need to use assembly, `difficulty` is directly exposed in
solidity)

But for true randomness, you'd need something like [Chainlink
VRF](https://docs.chain.link/docs/vrf/v2/subscription/examples/get-a-random-
number/).

    
    
        function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
            uint256 randomness = _randomWords[0];
        }
    

## Why is `difficulty` or `PREVRANDAO` pseudo-random in a post-merge ETH?

When a validator is due to propose a block, they face a [fairly minimal
penalty](https://ethereum.stackexchange.com/questions/90781/what-is-the-
penalty-of-having-eth2-validator-offline) for failing to do so. Given a smart
contract that is trying to make itself unpredictable/uncontrollable via
`PREVRANDAO`, this option allows them to cheaply bias the behavior of the
contract in the following ways.

### 1\. You always need a validator to propose two blocks in a row

`PREVRANDAO`'s value has no
[entropy](https://en.wikipedia.org/wiki/Entropy_\(computing\)) given the
`PREVRANDAO` value from the previous block if no block is proposed. When you
propose a block, that's a piece of the math equation that `PREVRANDAO` uses to
make a random number. So if you don't propose a block, you get a ""less"" random
number.

So users of `PREVRANDAO` would need to check that a validator has provided a
block since the last time they called `PREVRANDAO`. Otherwise, they won't
necessarily be drawing statistically independent random outputs on successive
calls to PREVRANDAO.

This means that the validator committed to proposing a particular block can
effectively set the PREVRANDAO value for the next block to two possible
values:

  * the one which results from its mandated `PREVRANDAO` input value
  * whatever `PREVRANDAO` gets deterministically set to if no block is proposed

This choice alone allows validators to influence the random number, no longer
making the number random.

Even if the contract does something cleverer, like taking the `PREVRANDAO`
output from the first block to be proposed after some height, every validator
after that height has the same option. No matter which way the contract tries
to access `PREVRANDAO`, the last validator to contribute will always have
predictable control over the random output which controls the contract.

These issues don't arise for Chainlink VRF, because the output is
deterministic, given the blockhash (just infeasible to compute for anyone who
doesn't know the secret key.)

### 2\. Validators can choose to not post if a number is unfavorable

Once again, you still run into this issue from pre-merge. The penalty of not
posting a block is almost negligible, so a node might be financially
incentivized not to propose blocks in a lottery-type smart contract if the
`PREVRAND` value isn't what they want. Enough nodes do this and you run into
issues.

Just taking the current `PREVRANDAO` value without looking at recent history
gives a validator some control over the output the contract will use, even if
it doesn't want to abort, because the validator can decide whether or not the
block it proposes contains a transaction which will trigger the use of
PREVRANDAO. The only cost involved there is the transaction fee/tip.

### 3\. If all applications use `PREVRANDAO` as their seed

If all applications use `PREVRANDAO` as their seed, in a way, you could
""chain"" together wins or hacks based on this.

### More information

There is also an interesting thread on this in the [Ethereum
Magicians](https://ethereum-magicians.org/t/eip-4399-supplant-difficulty-
opcode-with-random/7368/48) forum.





:::NEXT DOC:::

#####Chapter 7:

# VRF Simultaneous Requests

As miners/validators decide on the order of randomness requests on-chain, you must be careful that your contracts consider it in their implementation. Let’s assume your contract creates multiple VRF requests in short succession. There is no guarantee that the order of completion and fulfillment will also be in the same order. It’s easy to prevent this issue using the requestID to match randomness requests and fulfillments. But you must be aware that this is a potential issue in the first place. See more details [here](https://docs.chain.link/docs/vrf/v2/best-practices/#processing-simultaneous-vrf-requests).

<Highlight class=""language-javascript"">
mapping(uint256 => uint256[]) public s_requestIdToRandomWords;
mapping(uint256 => address) public s_requestIdToAddress;
uint256 public s_requestId;
 
function requestRandomWords() external onlyOwner returns (uint256) {
 uint256 requestId = COORDINATOR.requestRandomWords(
   keyHash,
   s_subscriptionId,
   requestConfirmations,
   callbackGasLimit,
   numWords
 );
 s_requestIdToAddress[requestId] = msg.sender;
 
 // Store the latest requestId for this example.
 s_requestId = requestId;
 
 // Return the requestId to the requester.
 return requestId;
}
 
function fulfillRandomWords(
   uint256 requestId,
   uint256[] memory randomWords
 ) internal override {
 // You can return the value to the requester,
 // but this example simply stores it.
 s_requestIdToRandomWords[requestId] = randomWords;
}
</Highlight>

As you can see, this contract uses a mapping to handle the different requests and assign the results based on the requestId. This way, the order of the results does not matter.
"
How can I ensure that `performUpkeep` is not called again before it finishes performing work?,"In the given scenario, there is no waiting or asynchronous behavior in the EVM. One suggestion is to use the `block.number` to create an additional entry condition. This can be done by adding a requirement in the `checkUpkeep` function that checks if the current block number is greater than or equal to the last upkeep block number plus a certain value. Another option is to use OpenZeppelin's `nonReentrant` modifier to prevent reentrancy issues. These approaches can help ensure that `performUpkeep` is not called again before it finishes performing work.",{'source': 'https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per'},"To ensure that `performUpkeep` is not called again before it finishes performing work, it is recommended to revalidate the conditions and data in `performUpkeep` before work is performed. This can be done by implementing checks within `performUpkeep` to ensure that state changes occur only when necessary. Additionally, it is important to validate the data received via `performData` before execution to prevent unauthorized actions. It is also suggested to use block numbers or OpenZeppelin's `nonReentrant` modifier to create additional entry conditions and prevent multiple calls to `performUpkeep` before it finishes its work.

","- [Chainlink Automation Compatible Contract Best Practice](https://docs.chain.link/chainlink-automation/compatible-contract-best-practice/)
- [Stack Overflow: How to avoid another upkeep run my checkUpkeep function Chainlink](https://stackoverflow.com/questions/75637468/how-to-avoid-another-upkeep-run-my-checkupkeep-function-chainlink)
- [Stack Overflow: Is there a way to ensure performUpkeep isn't called again before it finishes performing work?](https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per)","# Best Practices for Compatible Contracts

  * Overview
  * Revalidate performUpkeep on Automation-compatible contracts
  * Performing actions ONLY when conditions are met in performUpkeep
  * Perform upkeep ONLY when data is verified via performData
  * When performing actions in Automation-compatible contracts is not harmful
  * Always test your contract

This guide outlines the best practices when using Chainlink Automation. These
best practices are important for using Chainlink Automation securely and
reliably when you [Create Compatible Contracts](/chainlink-automation/compatible-contracts).

### Revalidate `performUpkeep` on Automation-compatible contracts

We recommend that you revalidate the conditions and data in `performUpkeep`
before work is performed. By default the `performUpkeep` is `external` and
thus any party can call it, so revalidation is recommended. If you send data
from your `checkUpkeep` to your `performUpkeep` and this data drives a
critical function, please ensure you put adequate checks in place.

### Performing actions ONLY when conditions are met in `performUpkeep`

Some actions must be performed only when specific conditions are met. Check
all of the preconditions within `performUpkeep` to ensure that state change
occurs only when necessary.

In this pattern, it is undesirable for the state change to occur until the
next time the Upkeep is checked by the network and the conditions are met. It
is a best practice to stop any state change or effects by performing the same
checks or similar checks that you use in `checkUpkeep`. These checks validate
the conditions before doing the work.

For example, if you have a contract where you create a timer in `checkUpkeep`
that is designed to start a game at a specific time, validate the condition to
ensure third-party calls to your `performUpkeep` function do not start the
game at a different time.

### Perform upkeep ONLY when data is verified via `performData`

Some actions must be performed using data you intend to use. Revalidate that
the `performData` is allowed before execution.

For example, if you have a `performUpkeep` that funds a wallet and the address
of the wallet is received via the `performData` parameter, ensure you have a
list of permissable addresses to compare against to prevent third-party
calling your function to send money to their address.

### When performing actions in Automation-compatible contracts is not harmful

Sometimes actions must be performed when conditions are met, but performing
actions when conditions are not met is still acceptable. Condition checks
within `performUpkeep` might not be required, but it can still be a good
practice to short circuit expensive and unnecessary on-chain processing when
it is not required.

It might be desirable to call `performUpkeep` when the `checkUpkeep`
conditions haven't yet been tested by Chainlink Automation, so any specific
checks that you perform are entirely use case specific.

### Always test your contract

As with all smart contract testing, it is important to test the boundaries of
your smart contract in order to ensure it operates as intended. Similarly, it
is important to make sure the compatible contract operates within the
parameters of the `KeeperRegistry`.

Test all of your mission-critical contracts, and stress-test the contract to
confirm the performance and correct operation of your use case under load and
adversarial conditions. The Chainlink Automation Network will continue to
operate under stress, but so should your contract. For a list of supported
testnet blockchains, please review the [supported networks page](/chainlink-automation/supported-networks).

## What's next

  * [› Build flexible contracts](/chainlink-automation/flexible-upkeeps/)
  * [› Manage your Upkeeps](/chainlink-automation/manage-upkeeps/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/compatible-contract-best-practice.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2023-03-04 17:42:18)
How to avoid another upkeep run my checkUpkeep function Chainlink
URL: https://stackoverflow.com/questions/75637468/how-to-avoid-another-upkeep-run-my-checkupkeep-function-chainlink

Question Body:


I don't know if this is a too simple question but I'm wondering how to avoid
an external Upkeep run my checkUpkeep function of my contract if, at the end,
my contract's address is public and that's the only thing you need to run the
checkUpkeep. I want to avoid that someone can call this function of my
contract and modify the state.

<https://docs.chain.link/chainlink-automation/flexible-upkeeps/>

Thank yoou!!!



Answers:
(Answered on: 2023-03-09 17:00:14)


For those who are facing this problem, I found a solution that could be
applicable for some of you. The caller address for checkUpkeep and
performUpkeep is the registry address you can find in the dashboard to manage
your upkeeps. So, what I've done is to create a modifier that allows only my
registry address to run these functions. I hope this information could be
helpful for any of you!


---
(Answered on: 2023-03-06 14:13:15)


TLDR; Use [revalidation](https://docs.chain.link/chainlink-
automation/compatible-contracts/#revalidate-performupkeep) in `performUpkeep`
prior to running.

The best method for preventing the upkeep functions from being called when
they should be is through revalidating the conditions for calling them. You
could require that the caller be the `Automation Registry`, which would limit
who could execute the function, but this would not prevent someone else from
creating upkeep to call it.

See the [FAQ](https://docs.chain.link/chainlink-automation/faqs/#can-i-
require-that-performupkeep-is-only-callable-by-the-automation-registry) for
more information





:::NEXT DOC:::

Question: (Asked on: 2021-11-04 03:31:44)
Is there a way to ensure performUpkeep isn&#39;t called again before it finishes performing work?
URL: https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per

Question Body:


I have a keeper that calls checkUpkeep and it returns true, however in
performUpkeep, the condition that would cause checkUpkeep to return false is
not set until data is returned from offchain (this is bc I want to make sure
that if for some reason that fails, the checkUpkeep will return true again to
retry)

How would I handle this so that checkUpkeep is not called again while data is
being retrieved triggering a second performUpkeep?

ex:

    
    
      function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
        requestVolumeData(); // latestDateChecked is updated once requestVolumeData successfully receives data offchain and calls fulfill function
      }
    



Answers:
(Answered on: 2021-11-09 18:59:39)


I am not sure if what you are concerned about is possible.

In the EVM a transaction either succeeds or fails. There is no waiting or
async. Or maybe there's some chainlink magic (involving transactions that do
not occur in the same block) happening that I have not learned about yet.

My suggestion: use blocknumber (block.number) to create an aditional entry
condition. That's what I'm using for a keeper to call a function approx. once
a day.

    
    
        function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        **require(block.number >= lastUpkeepBlock + 10 )** //if you can afford artificial constraint
    
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
        
        **uint lastUpkeepBlock = block.number;**
        
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
        requestVolumeData(); // latestDateChecked is updated once requestVolumeData successfully receives data offchain and calls fulfill function
      }
    

or OpenZeppelin's
[nonReentrant](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard)
modifier.

Related Concepts: [Reentrancy](https://swcregistry.io/docs/SWC-107) [Race
condition](https://swcregistry.io/docs/SWC-114)



"
Why is the value of volume always returning 0 in the Chainlink example?,"The value of volume is always returning 0 in the Chainlink example because there is an error in the code. The line `request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");` should be `request.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR"");` (notice the commas instead of dots). Chainlink nodes 1.0.0 and later support this new ""comma based"" format. Chainlink nodes prior to 1.0.0 support the ""dots based"" format. The official docs have been updated to include this change.",{'source': 'https://stackoverflow.com/questions/71619589/chainlink-example-not-updating-value'},"The value of volume is always returning 0 in the Chainlink example because there might be an issue with the Chainlink node calling the function `fulfillOracleRequest2` in the Operator.sol contract and failing to write the result back to the smart contract. Possible reasons for this issue could be insufficient funds in the Chainlink node or lack of permission to call the `fulfillOracleRequest2` function. It is recommended to check the balance of the Chainlink node and ensure that it has enough ETH, as well as grant the Chainlink node permission to call the `fulfillOracleRequest2` function. Additionally, in another example, the issue was caused by using dots instead of commas in the `request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");` line of code. It is important to use commas instead of dots in the path parameter. If none of these solutions work, further debugging may be required. 
","
- https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0
- https://stackoverflow.com/questions/71619589/chainlink-example-not-updating-value
- https://stackoverflow.com/questions/71302194/chainlink-node-cant-get-value-of-bytes32","Question: (Asked on: 2022-11-09 23:44:03)
Chainlink node external adapter executes successfully, but keeps returning 0
URL: https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0

Question Body:


I'm trying to build an external adapter for a chainlink node to import API
information. On the chainlink node and API, everything seems like it worked,
however when I try to call the stored value from the smart contract, it's
always 0 despite the logs indicating that it ran successfully.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Mimi-Fund-EA""
    externalJobID = ""834d2179-321d-49ac-bf63-140635e3a606""
    forwardingAllowed = false
    maxTaskDuration = ""0s""
    contractAddress = ""0xAf644831B57E5625ac64cDa68248b810bE4D4D01""
    minContractPaymentLinkJuels = ""0""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""mimifund"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""year\\"": $(decode_cbor.year), \\""discount_rate\\"": $(decode_cbor.discount_rate)}}""]
        parse        [type=jsonparse path=""data,result"" data=""$(fetch)""]
        ds_multiply  [type=""multiply"" times=1000000000000000000]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(ds_multiply) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xAf644831B57E5625ac64cDa68248b810bE4D4D01"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> ds_multiply-> encode_data -> encode_tx -> submit_tx
    """"""
    

These are the run logs from the Node. Everything compiled just fine and the
values look good however, they never update in a smart contract, it's always
0.

[](https://i.stack.imgur.com/ZUw17.png)

This is my smart contract for reference.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@openzeppelin/contracts/utils/Strings.sol"";
    
    contract mimifundCO2 is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
        bytes32 private jobId;
        uint256 private fee;
    
        event RequestVolume(bytes32 indexed requestId, uint256 volume);
    
        /**
         * @notice Initialize the link token and target oracle
         *
         * Goerli Testnet details:
         * Link Token: 0x326C977E6efc84E512bB9C30f76E30c160eD06FB
         * Oracle: 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 (Chainlink DevRel)
         * jobId: ca98366cc7314957b8c012c72f05aeeb
         *
         */
        constructor() ConfirmedOwner(msg.sender) {
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            setChainlinkOracle(0xAf644831B57E5625ac64cDa68248b810bE4D4D01);
            jobId = ""834d2179321d49acbf63140635e3a606"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        }
    
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestCO2PricingData(uint256 _year) public returns (bytes32 requestId) {
            Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
            req.add('year', Strings.toString(_year)); // Chainlink nodes 1.0.0 and later support this format
            req.add('discount_rate', '0.0'); // Chainlink nodes 1.0.0 and later support this format
    
            // Sends the request
            return sendChainlinkRequest(req, fee);
        }
    
        /**
         * Receive the response in the form of uint256
         */
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
            emit RequestVolume(_requestId, _volume);
            volume = _volume;
        }
    
        /**
         * Allow withdraw of Link tokens from the contract
         */
        function withdrawLink() public onlyOwner {
            LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
            require(link.transfer(msg.sender, link.balanceOf(address(this))), 'Unable to transfer');
        }
    }
    
    

I feel like there is some update to either my fulfill function or submit_tx
that I need to update, but I am out of ideas about what to change.

I've tried changing all the parameters and both the API and chainlink node
accurate update and reflect the correct input. The smart contract seems to
work perfectly, it's just that calling volume in the code always returns 0 and
I've got no clue what the issue is.



Answers:
(Answered on: 2022-11-11 06:51:31)


According to your description, Chainlink node received your request and run
the job successfully, but failed to write the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

Question: (Asked on: 2022-03-25 15:38:20)
Chainlink example not updating value
URL: https://stackoverflow.com/questions/71619589/chainlink-example-not-updating-value

Question Body:


I'm following the example within the [Chainlink
documentation](https://docs.chain.link/docs/advanced-tutorial/) (also below),
and have been testing it within remix. I've deployed the contract on the kovan
testnet & sent LINK to it, I'm able to execute the requestVolumeData() and get
the notification that the transaction was completed and I'm able to view it on
etherscan.

However, when checking the value of volume it always returns 0. I'm aware that
it can take some time, but the value hasn't changed after waiting 20 minutes.

I've done tests with the following oracle addresses / job id's. From the
example (0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 &
d5270d1c311941d0b08bead21fea7747) From the accompanying youtube video
(0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e &
29fa9aa13bf1468788b7cc4a500a45b8) And from
[chainlink](https://market.link/jobs/8b2792ab-24a3-4ed7-b7f4-f56f44828d9b)
market (set to kovan network). (0xA1d76ABD287d87d6E1d92262F7D53Cbe4f290505 &
fc3ea215bb9e44e088107b29bb495e2d)

I'm not sure where things go wrong, I don't think it's the code since it's
copy pasted from the example. But non of the adreses have worked.

    
    
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public volume;
    
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        constructor() {
            setPublicChainlinkToken();
            oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
            jobId = ""d5270d1c311941d0b08bead21fea7747"";
            fee = 0.1 * 10 ** 18;
        }
        
        function requestVolumeData() public returns (bytes32 requestId) {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");        
            request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");
            int timesAmount = 10**18;
            request.addInt(""times"", timesAmount);
            
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
            volume = _volume;
        }
    }
    



Answers:
(Answered on: 2022-03-29 22:21:18)


Line `request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");` should be
`request.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR"");` (notice the commas instead
of dots).

Chainlink nodes 1.0.0 and later support this new ""comma based"" format.
Chainlink nodes prior to 1.0.0 support the ""dots based"" format you provided in
the original question.

From what I can see now, the official docs have been updated to include this
change.





:::NEXT DOC:::

Question: (Asked on: 2022-02-28 23:33:09)
Chainlink node, can&#39;t get value of bytes32
URL: https://stackoverflow.com/questions/71302194/chainlink-node-cant-get-value-of-bytes32

Question Body:


I created my own eternal Adapter, that retruns a string as result. The node
runs the job correctly and woun't give any error. I think the error happens in
the smart contract.

Here is my current smart contract, edited from the Chainlink docs.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
     */
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        bytes32 public volume;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Kovan
         * Oracle: 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 (Chainlink Devrel   
         * Node)
         * Job ID: d5270d1c311941d0b08bead21fea7747
         * Fee: 0.1 LINK
         */
        constructor() {
            setPublicChainlinkToken();
            oracle = 0x6A968f08Ba673EaD62b54Ec7FC4095213a679E63;
            jobId = ""bf7f39c102594b46b8acd2db6c0cc84d"";
            fee = 0.1 * 10 ** 18; // (Varies by network and job)
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"": xxx.xxx,
            //     }
            //    }
            //   }
            //  }
            request.add(""currency"", ""ETH"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
    
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, bytes32 _volume) public recordChainlinkFulfillment(_requestId)
        {
            volume = _volume;
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    

The External Adapter should retrun something like
`{\""jobRunID\"":0,\""data\"":{\""account\"":\""0xdF392951284e8779C1e2Fdda5b452222\""},\""result\"":\""0dF392951284e8779C1e2Fdda5b45224\"",\""statusCode\"":200}
`

My Job Data lookies like:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""name""
    contractAddress = ""0x6A968f08Ba673EaD62b54Ec7FC4095213a679E63""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""yokuPayBeta2"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""currency\\"": $(decode_cbor.currency)}}""]
        parse        [type=jsonparse path=""result"" data=""$(fetch)""]
        encode_data  [type=ethabiencode abi=""(bytes32 value)"" data=""{ \\""value\\"": $(parse) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0x6A968f08Ba673EaD62b54Ec7FC4095213a679E63"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx
    """""" 
    

If I click on **requestVolumeData** in remix, the SC gets executed. As
response the volume prints
`0x00000000000000000000000000000000000000000000000000000000000000`

Where is the error and how to solve it?



Answers:
(Answered on: 2022-03-14 22:10:51)


Send ETH to your chainlink oracle address.



"
Why does Chainlink VRF take a long time to get random numbers?,"Chainlink VRF follows a request and receive cycle to get a random number, which involves two transactions: the requesting transaction and the response transaction. This is necessary to look outside the blockchain and ensure randomness. The speed at which the random number is returned depends on the block time of the blockchain being used. For Ethereum, the fastest time possible is 2 times the block time, which is around 30 seconds. On faster chains like Polygon, the time is significantly lower.",{'source': 'https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers'},"Chainlink VRF takes a long time to get random numbers because it follows a request and receive cycle, which involves two transactions and depends on the block time of the blockchain being used. The response time can vary depending on the blockchain network. For example, on Ethereum, it can take around 30 seconds, while on faster chains like Polygon, it can be much lower. The delay in receiving a response may also be influenced by the downtime or performance issues of the specific testnet being used, such as Rinkeby. Switching to a different testnet, like Kovan, may provide faster responses. 
","
- https://stackoverflow.com/questions/70718394/chainlink-vrfcoordinator-taking-a-long-time-to-respond
- https://stackoverflow.com/questions/70711267/chainlink-vrf-very-slow-20-minutes-for-response-to-fulfillrandomness-on-rinke
- https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers","Question: (Asked on: 2022-01-15 02:15:51)
Chainlink VRFCoordinator taking a long time to respond
URL: https://stackoverflow.com/questions/70718394/chainlink-vrfcoordinator-taking-a-long-time-to-respond

Question Body:


This is a blockchain question. I'm following the tutorial from freecodecamp
and every time we use the vrfcoordinator from chainlink it works perfectly in
the development network, but not when I deploy my smart contract to the
rinkeby test net.

My issue is when I try to get a verified random number from the
VRFcoordinator(0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B) it takes about 40
minutes to get a response back.

Is this normal? or is it because I'm deploying it to a test-net

If so, is this the best way to get a random number considering it takes 40
minutes to get one?



Answers:
(Answered on: 2022-01-15 22:41:51)


Currently, it looks [like Rinkeby is down](https://rinkeby.etherscan.io/) (as
of writing this answer the last Rinekby block was mined almost 9 hours ago.)
You'll have to wait for Rinkeby to come back online.





:::NEXT DOC:::

Question: (Asked on: 2022-01-14 13:25:29)
Chainlink VRF very slow - 20+ minutes for response to fulfillRandomness on Rinkeby
URL: https://stackoverflow.com/questions/70711267/chainlink-vrf-very-slow-20-minutes-for-response-to-fulfillrandomness-on-rinke

Question Body:


I have implemented a basic Chainlink VRF function in Solidity and deployed to
Ethereum test network Rinkeby

    
    
      function getRandomNumber() public returns (bytes32 requestId)
      {
        require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK"");
        return requestRandomness(keyHash, fee);
      }
    
      function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override 
      {
        randomResult = randomness;
        _requestId = requestId;
      }
    

This works fine, deducts the LINK fee from my wallet, and eeeeeventually does
call back `fulfillRandomness` with a random hex value, however it takes
forever!

Just did a test and it took 30 minutes. Could I be doing something wrong or
why is it taking so long? I know it's async and there's lots of stuff going on
to fetch the random number, but at these speeds it's basically unusable right



Answers:
(Answered on: 2022-01-17 16:19:42)


I switched to Kovan and I'm reliably getting ~1 min VRF responses


---
(Answered on: 2022-01-17 01:21:45)


The Rinkeby testenet has had some downtime issues this weekend. You can use
the Kovan testnet and VRF until Rinkeby is operating normally again.





:::NEXT DOC:::

Question: (Asked on: 2021-06-23 23:02:20)
Chain Link VRF takes a long time to get random numbers
URL: https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers

Question Body:


**Description**

Getting a random number takes a really long time. After executing the
getRandomNumber function, a few minutes go by before I can interact with my
random number.

Basically I click getRandomNumber and have to wait 2-3 minutes until the
random number shows up in the randomResult variable.

**Steps to Reproduce**

  1. Head over to the documentation here : <https://docs.chain.link/docs/get-a-random-number/>
  2. Scroll down and click on ""Deploy this contract using Remix"" (blue outline btn)
  3. Click on one of the folders that looks like 536123b61468ad4442cfc4278e8de577 then RandomNumberConsumer.sol
  4. Replace the LINK Token, VRF Coordinator, and Key Hash to be unique to rinkeby <https://docs.chain.link/docs/vrf-contracts/>
  5. Navigation to the Solidity Compiler Tab and click on Compile RandomNumber.sol.
  6. Deploy the contract on Rinkeby
  7. Copy to contract address and send LINK token to fund the contract.
  8. Click on the orange getRandomNumber btn in remix
  9. Click on randomResult and observe how long it takes for the value in randomResult to change. (Keep clicking until it finally changes)

**Additional Information**

I am not sure if this behavior is intentional or if I need to change up the
code. Ideally I would like to have the value of randomResult once the
getRandomNumber function finishes executing. Right now I don't know when the
value of randomResult will show up.



Answers:
(Answered on: 2021-06-23 23:24:42)


Chainlink VRF follows the [request and
receive](https://docs.chain.link/docs/intermediates-tutorial/#1-request--
receive) cycle of getting a number. This means, it has to look outside the
blockchain to get a response.

So, 2 transactions actually take place:

  1. Your requesting transaction
  2. The response transaction

This is necessary to look outside the blockchain like this, otherwise you'll
get a deterministic number as opposed to random. The speed at which the random
number is returned, is dictated by the block time of the blockchain you're
using.

So for Ethereum, the fastest time possible for a Random Number to be returned
is 2 * block time, or about 30ish seconds.

On faster chains like polygon, this is drastically lower.



"
How can I make my Chainlink node wait longer for a response from an external adapter?,You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by referring to the documentation for Chainlink nodes configuration at https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout.,{'source': 'https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response'},"To make your Chainlink node wait longer for a response from an external adapter, you can increase the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This will extend the timeout period for HTTP requests made by the node. You can find more information on how to configure your Chainlink node in the Chainlink documentation [here](https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout).

","- [Stack Overflow: Chainlink jobs returns error if external adapter takes too long for response](https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response)
- [Stack Overflow: Chainlink node external adapter executes successfully, but keeps returning 0](https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0)
- [Stack Overflow: Chainlink node can't make requests to Chainlink external adapter (on localhost)](https://stackoverflow.com/questions/72400311/chainlink-node-cant-make-requests-to-chainlink-external-adapter-on-localhost)
- [Stack Overflow: Can chainlink external adapters be made so they can only called by a specific smart contract?](https://stackoverflow.com/questions/70479339/can-chainlink-external-adapters-be-made-so-they-can-only-called-by-a-specific-sm)","Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

Question: (Asked on: 2022-11-09 23:44:03)
Chainlink node external adapter executes successfully, but keeps returning 0
URL: https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0

Question Body:


I'm trying to build an external adapter for a chainlink node to import API
information. On the chainlink node and API, everything seems like it worked,
however when I try to call the stored value from the smart contract, it's
always 0 despite the logs indicating that it ran successfully.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Mimi-Fund-EA""
    externalJobID = ""834d2179-321d-49ac-bf63-140635e3a606""
    forwardingAllowed = false
    maxTaskDuration = ""0s""
    contractAddress = ""0xAf644831B57E5625ac64cDa68248b810bE4D4D01""
    minContractPaymentLinkJuels = ""0""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""mimifund"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""year\\"": $(decode_cbor.year), \\""discount_rate\\"": $(decode_cbor.discount_rate)}}""]
        parse        [type=jsonparse path=""data,result"" data=""$(fetch)""]
        ds_multiply  [type=""multiply"" times=1000000000000000000]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(ds_multiply) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xAf644831B57E5625ac64cDa68248b810bE4D4D01"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> ds_multiply-> encode_data -> encode_tx -> submit_tx
    """"""
    

These are the run logs from the Node. Everything compiled just fine and the
values look good however, they never update in a smart contract, it's always
0.

[](https://i.stack.imgur.com/ZUw17.png)

This is my smart contract for reference.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@openzeppelin/contracts/utils/Strings.sol"";
    
    contract mimifundCO2 is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
        bytes32 private jobId;
        uint256 private fee;
    
        event RequestVolume(bytes32 indexed requestId, uint256 volume);
    
        /**
         * @notice Initialize the link token and target oracle
         *
         * Goerli Testnet details:
         * Link Token: 0x326C977E6efc84E512bB9C30f76E30c160eD06FB
         * Oracle: 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 (Chainlink DevRel)
         * jobId: ca98366cc7314957b8c012c72f05aeeb
         *
         */
        constructor() ConfirmedOwner(msg.sender) {
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            setChainlinkOracle(0xAf644831B57E5625ac64cDa68248b810bE4D4D01);
            jobId = ""834d2179321d49acbf63140635e3a606"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        }
    
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestCO2PricingData(uint256 _year) public returns (bytes32 requestId) {
            Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
            req.add('year', Strings.toString(_year)); // Chainlink nodes 1.0.0 and later support this format
            req.add('discount_rate', '0.0'); // Chainlink nodes 1.0.0 and later support this format
    
            // Sends the request
            return sendChainlinkRequest(req, fee);
        }
    
        /**
         * Receive the response in the form of uint256
         */
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
            emit RequestVolume(_requestId, _volume);
            volume = _volume;
        }
    
        /**
         * Allow withdraw of Link tokens from the contract
         */
        function withdrawLink() public onlyOwner {
            LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
            require(link.transfer(msg.sender, link.balanceOf(address(this))), 'Unable to transfer');
        }
    }
    
    

I feel like there is some update to either my fulfill function or submit_tx
that I need to update, but I am out of ideas about what to change.

I've tried changing all the parameters and both the API and chainlink node
accurate update and reflect the correct input. The smart contract seems to
work perfectly, it's just that calling volume in the code always returns 0 and
I've got no clue what the issue is.



Answers:
(Answered on: 2022-11-11 06:51:31)


According to your description, Chainlink node received your request and run
the job successfully, but failed to write the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

Question: (Asked on: 2022-05-27 03:56:23)
Chainlink node can&#39;t make requests to Chainlink external adapter (on localhost)
URL: https://stackoverflow.com/questions/72400311/chainlink-node-cant-make-requests-to-chainlink-external-adapter-on-localhost

Question Body:


I have a chainlink Node which is running on port 6688. I'm running it with
docker, with the following command:

    
    
    cd ~/.chainlink-rinkeby && docker run -p 6688:6688  \
    -v ~/.chainlink-rinkeby:/chainlink  \
    -it --env-file=.env \
     smartcontract/chainlink:1.4.0-root local n -p /chainlink/.password -a /chainlink/.api
    

And I have an external adapter running on port 8080.

If I request it `{ ""id"": 0, ""data"":{ ""columns"": [""blood"",""heath""],
""linesAmount"":500 } }` it returns me a correct payload, in the format that is
expected from the external adapter:

    
    
    {
        ""jobRunID"": 0,
        ""data"": {
            ""ipfsHash"": ""anIpfshashShouldBeHere"",
            ""providers"": [
                ""0x03996eF07f84fEEe9f1dc18B255A8c01A4986701""
            ],
            ""result"": ""anIpfshashShouldBeHere""
        },
        ""result"": ""anIpfshashShouldBeHere"",
        ""statusCode"": 200
    }
    

The problem is, in the chainlink node, specifically in the `fetch` method it
gives me an error: `error making http request: Post ""http://localhost:8080"":
dial tcp 127.0.0.1:8080: connect: connection refused`

Is it related to the docker container? I don't see why it wouldn't be able to
request resuources from another port in the same machine. Am I missing some
configuration maybe? From what I've read from the docs it's possible to run
the adapter locally. Below, a picture with more information:

[](https://i.stack.imgur.com/MnUK7.png)



Answers:
(Answered on: 2022-05-27 07:43:44)


If you're External Adapter (EA) is running on `http://localhost:8080` and
you're trying to reach that EA from a Chainlink node running inside Docker,
then you can't use `localhost`, you need to get out of the Docker container
and onto the host running the Docker engine (your Windows or Mac machine).

To do, so define your bridge to use `http://host.docker.internal:8080`.

Further details can be found in the [Docker
Docs](https://docs.docker.com/desktop/windows/networking/).





:::NEXT DOC:::

Question: (Asked on: 2021-12-25 10:24:04)
Can chainlink external adapters be made so they can only called by a specific smart contract?
URL: https://stackoverflow.com/questions/70479339/can-chainlink-external-adapters-be-made-so-they-can-only-called-by-a-specific-sm

Question Body:


I want to make an external adapter which can only be called by a specific
function in a smart contract so that I can assure that the caller is an
authorized address. Is anyone able to make a call to an external adapter or
can I restrict it to a certain smart contract? If anyone is able to make a
call, is there a way for me to ensure that the caller is from the smart
contract?

What I am trying to do is to have a smart contract which can provide a
decryption key for a file. Essentially, the smart contract would store a
decryption key encrypted to the adapter's public key. Then, when an event in
the smart contract occurs where someone should gain access to the file, the
smart contract makes a call to the adapter. The adapter would then take the
encrypted decryption key, decrypt it, and return the decryption key encrypted
to the recipient's public key. The smart contract would then receive the
decryption key encrypted to the recipient's public key and store this so that
the recipient could use this to decrypt the file. Is something like this
possible with an external adapter?



Answers:
(Answered on: 2022-06-23 04:07:05)


If whitelisting addresses doesn't do the trick, I believe you can do the
following to the oracle contract:

    
    
        /**
         * @notice Creates the Chainlink request. This is a backwards compatible API
         * with the Oracle.sol contract, but the behavior changes because
         * callbackAddress is assumed to be the same as the request sender.
         * @param callbackAddress The consumer of the request
         * @param payment The amount of payment given (specified in wei)
         * @param specId The Job Specification ID
         * @param callbackAddress The address the oracle data will be sent to
         * @param callbackFunctionId The callback function ID for the response
         * @param nonce The nonce sent by the requester
         * @param dataVersion The specified data version
         * @param data The extra request parameters
         */
        function oracleRequest(
            address sender,
            uint256 payment,
            bytes32 specId,
            address callbackAddress,
            bytes4 callbackFunctionId,
            uint256 nonce,
            uint256 dataVersion,
            bytes calldata data
        ) external override validateFromLINK validateIsAuthorizedConsumer(sender) {
            revert(""use the operatorRequest only"");
        }
    
        /**
         * @notice Creates the Chainlink request
         * @dev Stores the hash of the params as the on-chain commitment for the request.
         * Emits OracleRequest event for the Chainlink node to detect.
         * @param sender The sender of the request
         * @param payment The amount of payment given (specified in wei)
         * @param specId The Job Specification ID
         * @param callbackFunctionId The callback function ID for the response
         * @param nonce The nonce sent by the requester
         * @param dataVersion The specified data version
         * @param data The extra request parameters
         */
        function operatorRequest(
            address sender,
            uint256 payment,
            bytes32 specId,
            bytes4 callbackFunctionId,
            uint256 nonce,
            uint256 dataVersion,
            bytes calldata data
        ) external override validateIsAuthorizedConsumer(sender) validateFromLINK {
            (
                bytes32 requestId,
                uint256 expiration
            ) = _verifyAndProcessOracleRequest(
                    sender,
                    payment,
                    sender,
                    callbackFunctionId,
                    nonce,
                    dataVersion
                );
            emit OracleRequest(
                specId,
                sender,
                requestId,
                payment,
                sender,
                callbackFunctionId,
                expiration,
                dataVersion,
                data
            );
        }
    
    

I removed the `oracleRequest()` function because it exceeds stack size by
adding more modifiers to it and since I can use `operatorRequest()` to fulfill
both multi-word and single-word requests I will make that method deprecated by
reverting everytime it's called.

The modifier that sets the authorized consumer is basically the following:

    
    
        /**
         * @dev function used to change the authorized consumer. Can only be set once
         */
        function setAuthorizedConsumer(address _consumer) public onlyOwner {
            require(
                authorizedConsumer == address(0),
                ""authorized consumer is already set""
            );
            authorizedConsumer = _consumer;
        }
    
        /**
         * @notice validates the consumer is an authorized consumer
         */
        function _validateIsAuthorizedConsumer(address _consumer) internal view {
            require(_consumer == authorizedConsumer, ""Not authorized sender"");
        }
    
        /**
         * @notice prevents non-authorized addresses from calling this method
         */
        modifier validateIsAuthorizedConsumer(address _consumer) {
            _validateIsAuthorizedConsumer(_consumer);
            _;
        }
    
    
    


---
(Answered on: 2021-12-29 08:59:47)


You can restrict the access by adding whitelisted requesters (authorized smart
contract addresses) to the database of the Chainlink node that is picking up
your requests and running the job calling your external adapter.

We wrote a short guide on how to do this:
<https://github.com/Linkriver/Chainlink-node-whitelisting>



"
How can I make my Chainlink node wait longer for a response from an external adapter?,You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by referring to the documentation for Chainlink nodes configuration at https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout.,{'source': 'https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response'},"To make your Chainlink node wait longer for a response from an external adapter, you can increase the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This will extend the timeout period for HTTP requests made by the node. You can find more information on how to configure your Chainlink node in the Chainlink documentation [here](https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout).

","- [Stack Overflow: Chainlink jobs returns error if external adapter takes too long for response](https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response)
- [Stack Overflow: Chainlink node external adapter executes successfully, but keeps returning 0](https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0)
- [Stack Overflow: Chainlink node can't make requests to Chainlink external adapter (on localhost)](https://stackoverflow.com/questions/72400311/chainlink-node-cant-make-requests-to-chainlink-external-adapter-on-localhost)
- [Stack Overflow: Can chainlink external adapters be made so they can only called by a specific smart contract?](https://stackoverflow.com/questions/70479339/can-chainlink-external-adapters-be-made-so-they-can-only-called-by-a-specific-sm)","Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

Question: (Asked on: 2022-11-09 23:44:03)
Chainlink node external adapter executes successfully, but keeps returning 0
URL: https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0

Question Body:


I'm trying to build an external adapter for a chainlink node to import API
information. On the chainlink node and API, everything seems like it worked,
however when I try to call the stored value from the smart contract, it's
always 0 despite the logs indicating that it ran successfully.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Mimi-Fund-EA""
    externalJobID = ""834d2179-321d-49ac-bf63-140635e3a606""
    forwardingAllowed = false
    maxTaskDuration = ""0s""
    contractAddress = ""0xAf644831B57E5625ac64cDa68248b810bE4D4D01""
    minContractPaymentLinkJuels = ""0""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""mimifund"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""year\\"": $(decode_cbor.year), \\""discount_rate\\"": $(decode_cbor.discount_rate)}}""]
        parse        [type=jsonparse path=""data,result"" data=""$(fetch)""]
        ds_multiply  [type=""multiply"" times=1000000000000000000]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(ds_multiply) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xAf644831B57E5625ac64cDa68248b810bE4D4D01"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> ds_multiply-> encode_data -> encode_tx -> submit_tx
    """"""
    

These are the run logs from the Node. Everything compiled just fine and the
values look good however, they never update in a smart contract, it's always
0.

[](https://i.stack.imgur.com/ZUw17.png)

This is my smart contract for reference.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@openzeppelin/contracts/utils/Strings.sol"";
    
    contract mimifundCO2 is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
        bytes32 private jobId;
        uint256 private fee;
    
        event RequestVolume(bytes32 indexed requestId, uint256 volume);
    
        /**
         * @notice Initialize the link token and target oracle
         *
         * Goerli Testnet details:
         * Link Token: 0x326C977E6efc84E512bB9C30f76E30c160eD06FB
         * Oracle: 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 (Chainlink DevRel)
         * jobId: ca98366cc7314957b8c012c72f05aeeb
         *
         */
        constructor() ConfirmedOwner(msg.sender) {
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            setChainlinkOracle(0xAf644831B57E5625ac64cDa68248b810bE4D4D01);
            jobId = ""834d2179321d49acbf63140635e3a606"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        }
    
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestCO2PricingData(uint256 _year) public returns (bytes32 requestId) {
            Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
            req.add('year', Strings.toString(_year)); // Chainlink nodes 1.0.0 and later support this format
            req.add('discount_rate', '0.0'); // Chainlink nodes 1.0.0 and later support this format
    
            // Sends the request
            return sendChainlinkRequest(req, fee);
        }
    
        /**
         * Receive the response in the form of uint256
         */
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
            emit RequestVolume(_requestId, _volume);
            volume = _volume;
        }
    
        /**
         * Allow withdraw of Link tokens from the contract
         */
        function withdrawLink() public onlyOwner {
            LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
            require(link.transfer(msg.sender, link.balanceOf(address(this))), 'Unable to transfer');
        }
    }
    
    

I feel like there is some update to either my fulfill function or submit_tx
that I need to update, but I am out of ideas about what to change.

I've tried changing all the parameters and both the API and chainlink node
accurate update and reflect the correct input. The smart contract seems to
work perfectly, it's just that calling volume in the code always returns 0 and
I've got no clue what the issue is.



Answers:
(Answered on: 2022-11-11 06:51:31)


According to your description, Chainlink node received your request and run
the job successfully, but failed to write the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

Question: (Asked on: 2022-05-27 03:56:23)
Chainlink node can&#39;t make requests to Chainlink external adapter (on localhost)
URL: https://stackoverflow.com/questions/72400311/chainlink-node-cant-make-requests-to-chainlink-external-adapter-on-localhost

Question Body:


I have a chainlink Node which is running on port 6688. I'm running it with
docker, with the following command:

    
    
    cd ~/.chainlink-rinkeby && docker run -p 6688:6688  \
    -v ~/.chainlink-rinkeby:/chainlink  \
    -it --env-file=.env \
     smartcontract/chainlink:1.4.0-root local n -p /chainlink/.password -a /chainlink/.api
    

And I have an external adapter running on port 8080.

If I request it `{ ""id"": 0, ""data"":{ ""columns"": [""blood"",""heath""],
""linesAmount"":500 } }` it returns me a correct payload, in the format that is
expected from the external adapter:

    
    
    {
        ""jobRunID"": 0,
        ""data"": {
            ""ipfsHash"": ""anIpfshashShouldBeHere"",
            ""providers"": [
                ""0x03996eF07f84fEEe9f1dc18B255A8c01A4986701""
            ],
            ""result"": ""anIpfshashShouldBeHere""
        },
        ""result"": ""anIpfshashShouldBeHere"",
        ""statusCode"": 200
    }
    

The problem is, in the chainlink node, specifically in the `fetch` method it
gives me an error: `error making http request: Post ""http://localhost:8080"":
dial tcp 127.0.0.1:8080: connect: connection refused`

Is it related to the docker container? I don't see why it wouldn't be able to
request resuources from another port in the same machine. Am I missing some
configuration maybe? From what I've read from the docs it's possible to run
the adapter locally. Below, a picture with more information:

[](https://i.stack.imgur.com/MnUK7.png)



Answers:
(Answered on: 2022-05-27 07:43:44)


If you're External Adapter (EA) is running on `http://localhost:8080` and
you're trying to reach that EA from a Chainlink node running inside Docker,
then you can't use `localhost`, you need to get out of the Docker container
and onto the host running the Docker engine (your Windows or Mac machine).

To do, so define your bridge to use `http://host.docker.internal:8080`.

Further details can be found in the [Docker
Docs](https://docs.docker.com/desktop/windows/networking/).





:::NEXT DOC:::

Question: (Asked on: 2021-12-25 10:24:04)
Can chainlink external adapters be made so they can only called by a specific smart contract?
URL: https://stackoverflow.com/questions/70479339/can-chainlink-external-adapters-be-made-so-they-can-only-called-by-a-specific-sm

Question Body:


I want to make an external adapter which can only be called by a specific
function in a smart contract so that I can assure that the caller is an
authorized address. Is anyone able to make a call to an external adapter or
can I restrict it to a certain smart contract? If anyone is able to make a
call, is there a way for me to ensure that the caller is from the smart
contract?

What I am trying to do is to have a smart contract which can provide a
decryption key for a file. Essentially, the smart contract would store a
decryption key encrypted to the adapter's public key. Then, when an event in
the smart contract occurs where someone should gain access to the file, the
smart contract makes a call to the adapter. The adapter would then take the
encrypted decryption key, decrypt it, and return the decryption key encrypted
to the recipient's public key. The smart contract would then receive the
decryption key encrypted to the recipient's public key and store this so that
the recipient could use this to decrypt the file. Is something like this
possible with an external adapter?



Answers:
(Answered on: 2022-06-23 04:07:05)


If whitelisting addresses doesn't do the trick, I believe you can do the
following to the oracle contract:

    
    
        /**
         * @notice Creates the Chainlink request. This is a backwards compatible API
         * with the Oracle.sol contract, but the behavior changes because
         * callbackAddress is assumed to be the same as the request sender.
         * @param callbackAddress The consumer of the request
         * @param payment The amount of payment given (specified in wei)
         * @param specId The Job Specification ID
         * @param callbackAddress The address the oracle data will be sent to
         * @param callbackFunctionId The callback function ID for the response
         * @param nonce The nonce sent by the requester
         * @param dataVersion The specified data version
         * @param data The extra request parameters
         */
        function oracleRequest(
            address sender,
            uint256 payment,
            bytes32 specId,
            address callbackAddress,
            bytes4 callbackFunctionId,
            uint256 nonce,
            uint256 dataVersion,
            bytes calldata data
        ) external override validateFromLINK validateIsAuthorizedConsumer(sender) {
            revert(""use the operatorRequest only"");
        }
    
        /**
         * @notice Creates the Chainlink request
         * @dev Stores the hash of the params as the on-chain commitment for the request.
         * Emits OracleRequest event for the Chainlink node to detect.
         * @param sender The sender of the request
         * @param payment The amount of payment given (specified in wei)
         * @param specId The Job Specification ID
         * @param callbackFunctionId The callback function ID for the response
         * @param nonce The nonce sent by the requester
         * @param dataVersion The specified data version
         * @param data The extra request parameters
         */
        function operatorRequest(
            address sender,
            uint256 payment,
            bytes32 specId,
            bytes4 callbackFunctionId,
            uint256 nonce,
            uint256 dataVersion,
            bytes calldata data
        ) external override validateIsAuthorizedConsumer(sender) validateFromLINK {
            (
                bytes32 requestId,
                uint256 expiration
            ) = _verifyAndProcessOracleRequest(
                    sender,
                    payment,
                    sender,
                    callbackFunctionId,
                    nonce,
                    dataVersion
                );
            emit OracleRequest(
                specId,
                sender,
                requestId,
                payment,
                sender,
                callbackFunctionId,
                expiration,
                dataVersion,
                data
            );
        }
    
    

I removed the `oracleRequest()` function because it exceeds stack size by
adding more modifiers to it and since I can use `operatorRequest()` to fulfill
both multi-word and single-word requests I will make that method deprecated by
reverting everytime it's called.

The modifier that sets the authorized consumer is basically the following:

    
    
        /**
         * @dev function used to change the authorized consumer. Can only be set once
         */
        function setAuthorizedConsumer(address _consumer) public onlyOwner {
            require(
                authorizedConsumer == address(0),
                ""authorized consumer is already set""
            );
            authorizedConsumer = _consumer;
        }
    
        /**
         * @notice validates the consumer is an authorized consumer
         */
        function _validateIsAuthorizedConsumer(address _consumer) internal view {
            require(_consumer == authorizedConsumer, ""Not authorized sender"");
        }
    
        /**
         * @notice prevents non-authorized addresses from calling this method
         */
        modifier validateIsAuthorizedConsumer(address _consumer) {
            _validateIsAuthorizedConsumer(_consumer);
            _;
        }
    
    
    


---
(Answered on: 2021-12-29 08:59:47)


You can restrict the access by adding whitelisted requesters (authorized smart
contract addresses) to the database of the Chainlink node that is picking up
your requests and running the job calling your external adapter.

We wrote a short guide on how to do this:
<https://github.com/Linkriver/Chainlink-node-whitelisting>



"
Why am I unable to create external initiators from the Chainlink CLI?,"To create external initiators from the Chainlink CLI, you need to ensure that the `FEATURE_EXTERNAL_INITIATORS` environment variable is set to true in your .env file. Once this variable is set, you will have access to the `initiators` command in the Chainlink CLI and can proceed with the instructions.",{'source': 'https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli'},"The error ""unsupported metadata version 13"" is related to the Substrate RPC API, not the Chainlink node. It is suggested to ensure that the latest version of the Substrate RPC API is being used and try again (""SOURCE: https://stackoverflow.com/questions/69905090/chainlink-external-initiator-unsupported-metadata-version-13""). As for the inability to create external initiators from the Chainlink CLI, it is likely due to the missing environment variable `FEATURE_EXTERNAL_INITIATORS` set to true in the .env file. Setting this variable to true will enable access to the `initiators` command in the Chainlink CLI (""SOURCE: https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli"").",,"Question: (Asked on: 2021-11-09 21:05:52)
chainlink external-initiator unsupported metadata version 13
URL: https://stackoverflow.com/questions/69905090/chainlink-external-initiator-unsupported-metadata-version-13

Question Body:


i'm trying to connect the external-initiator with my chainlink node, but here
is the error I get when I try to add a new job in the Chainlink node. This is
the logs of my external-initiator:

    
    
    2021-11-09T15:09:14Z [ERROR] Failed testing subscriber: unsupported metadata version 13 client/web.go:192                stacktrace=github.com/smartcontractkit/external-initiator/client.(HttpService).CreateSubscription
        /external-initiator/client/web.go:192
    github.com/gin-gonic/gin.(Context).Next
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/context.go:152
    github.com/smartcontractkit/external-initiator/client.authenticate.func1
        /external-initiator/client/web.go:120
    github.com/gin-gonic/gin.(Context).Next
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/context.go:152
    github.com/Depado/ginprom.(Prometheus).Instrument.func1
        /go/pkg/mod/github.com/!depado/ginprom@v1.2.1-0.20200115153638-53bbba851bd8/prom.go:215
    github.com/gin-gonic/gin.(Context).Next
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/context.go:152
    github.com/smartcontractkit/external-initiator/client.loggerFunc.func1
        /external-initiator/client/web.go:259
    github.com/gin-gonic/gin.(Context).Next
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/context.go:152
    github.com/gin-gonic/gin.RecoveryWithWriter.func1
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/recovery.go:83
    github.com/gin-gonic/gin.(Context).Next
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/context.go:152
    github.com/gin-gonic/gin.(Engine).handleHTTPRequest
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/gin.go:409
    github.com/gin-gonic/gin.(Engine).ServeHTTP
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/gin.go:367
    net/http.serverHandler.ServeHTTP
        /usr/local/go/src/net/http/server.go:2878
    net/http.(conn).serve
        /usr/local/go/src/net/http/server.go:1929
    

  1. **How can I check the metadata version of the[external-initiator](https://github.com/smartcontractkit/external-initiator)**, In here I used the latest version in the master branch.

  2. **How can I change it to accept metadataV13?** my substrate is using metadataV13

Thank you so much for your helping!



Answers:
(Answered on: 2021-11-12 00:38:17)


Looks like your error is coming from the [Substrate RPC
API](https://github.com/centrifuge/go-substrate-rpc-
client/search?q=unsupported%20metadata), and not the Chainlink node. Suggest
[ensuring you are using the latest
version](https://githubmemory.com/repo/centrifuge/go-substrate-rpc-
client/issues/176) and trying again





:::NEXT DOC:::

Question: (Asked on: 2021-09-22 09:33:38)
Can&#39;t create external initiators from chainlink CLI
URL: https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli

Question Body:


We're trying to set external initiators to our chainlink containers deployed
in GKE cluster according to the docs: <https://docs.chain.link/docs/external-
initiators-in-nodes/>

I log into the the pod:

`kubectl exec -it -n chainlink chainlink-75dd5b6bdf-b4kwr -- /bin/bash`

And there I attempt to create external initiators:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink initiators create xxx xxx
    No help topic for 'initiators'
    

I don’t even see initiators in chainlink cli options:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink
    NAME:
       chainlink - CLI for Chainlink
    
    USAGE:
       chainlink [global options] command [command options] [arguments...]
    
    VERSION:
       0.9.10@7cd042c1a94c57219ed826a6eab46752d63fa67a
    
    COMMANDS:
       admin           Commands for remotely taking admin related actions
       attempts, txas  Commands for managing Ethereum Transaction Attempts
       bridges         Commands for Bridges communicating with External Adapters
       config          Commands for the node's configuration
       job_specs       Commands for managing Job Specs (jobs V1)
       jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json, -j     json output as opposed to table
       --help, -h     show help
       --version, -v  print the version
    

Chainlink version 0.9.10.

Could you please clarify what am I doing wrong?



Answers:
(Answered on: 2021-09-28 21:51:21)


You need to make sure you have the `FEATURE_EXTERNAL_INITIATORS` environment
variable set to true in your .env file as such:

`FEATURE_EXTERNAL_INITIATORS=true`

This will open up access to the `initiators` command in the Chainlink CLI and
you can resume the instructions from there.



"
How can I transfer NFTs using Chainlink's Automation/Keeper (checkUpkeep & performUpKeep)?,"The issue with the `upkeepNeeded` returning false is because the auction end time is set to 0. To transfer NFTs using Chainlink's Automation/Keeper, you need to ensure that the `endTime` is properly set for each auction. Make sure that the `endTime` is a valid timestamp and is greater than the current block timestamp. Additionally, check that the `listed` flag is properly set to `true` when the NFT is listed for auction. Double-check your code to ensure that these conditions are met for the automation to work correctly.",{'source': 'https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu'},"To transfer NFTs using Chainlink's Automation/Keeper, you can use the `checkUpkeep` and `performUpkeep` functions. The `checkUpkeep` function checks if an upkeep is needed, while the `performUpkeep` function performs the actual transfer of the NFTs. You can refer to the provided code examples for more details on how to implement these functions.

","- https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu (Answered on: 2022-10-29 07:11:58)
- https://stackoverflow.com/questions/74233765/chainlink-automation-upkeep-not-working-checkupkeep-is-not-calling-performupkee (Answered on: 2022-10-28 10:04:53)
- https://stackoverflow.com/questions/73335353/chainlinks-dynamic-upkeep-registration-example-failing-upkeepidconsumerexample (Answered on: 2022-08-12 14:00:57)
- https://stackoverflow.com/questions/70276632/chainlink-keeper-not-performing-upkeep (Answered on: 2021-12-08 14:26:10)","Question: (Asked on: 2022-10-29 07:11:58)
How to Transfer NFTs using Chainlink&#39;s Automation/Keeper (checkUpkeep &amp; performUpKeep)
URL: https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu

Question Body:


I'm working on an NFT Auction contract. I'm trying to achieve 1. NFT transfer
to the highest bidder. 2. highest bidder's bid value to the prev NFT owner or
Auction creator. 3. A small platform cut sent to the contract's owner.

All this is working smoothly when I'm doing things manually. But when I'm
trying to achieve this using chainlink automation, It fails.

From my understanding, It is failing because of the `allowance` issue. My Qs
is, is it even possible to achieve this using chainlink automation? if yes,
then how?

When the NFT owner, lists his NFT for Auction, he is giving NFT transfer
allowance to the contract address.

    
    
        function checkUpkeep(bytes calldata /* checkData */) external view override returns(bool upkeepNeeded, bytes memory performData) {
            for(uint i=0; i < auctionIDs.length; i++){
                if(auctions[auctionIDs[i]].endTime != 0 && block.timestamp > auctions[auctionIDs[i]].endTime){
                    upkeepNeeded = true;
                    performData = abi.encodePacked(uint256(auctionIDs[i]));
                }
            }
            return (upkeepNeeded, performData);
        }
    
        function performUpkeep(bytes calldata performData) external override nonReentrant {
            uint256 auction_id = abi.decode(performData, (uint256));
    
            if(auctions[auction_id].endTime != 0 && block.timestamp > auctions[auction_id].endTime){
    
                auctions[auction_id].listed = false;
    
                safeTransferFrom(podcastId[auctions[auction_id].podcastId].nftOwner, bidders[auction_id].highestBidder, podcastId[auctions[auction_id].podcastId].tokenId);
    
                uint256 platformCut = (platformFee * bidders[auction_id].highestBid)/100;
                uint256 NftOwnerCut = bidders[auction_id].highestBid - platformCut;
    
                (bool pass, ) = platformFeeRecipient.call{value: platformCut}("""");
                require(pass, ""platformFee Transfer failed"");
                (bool success, ) = (podcastId[auctions[auction_id].podcastId].nftOwner).call{value: NftOwnerCut}("""");
                require(success, ""NftOwnerCut Transfer Failed"");
    
                podcastId[auctions[auction_id].podcastId].nftOwner = bidders[auction_id].highestBidder;
                emit AuctionResulted(auction_id, bidders[auction_id].highestBidder, bidders[auction_id].highestBid);
                bidders[auction_id].highestBid = 0;
                auctions[auction_id].endTime = 0;
                
            }
    
        }
    

Full Code/Contracts:
<https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8>

Chainlink upKeep:
<https://automation.chain.link/mumbai/21891159634677518530356555981285976030474691922841692133624884405593696766700>

Pls help, Thanks.



Answers:
(Answered on: 2022-10-31 15:26:20)


I believe the issue is that your `upkeepNeeded` is returning false due to the
auction end time being 0

    
    
     if(auctions[auctionIDs[i]].endTime != 0
    

[](https://i.stack.imgur.com/hdqIM.png)





:::NEXT DOC:::

Question: (Asked on: 2022-10-28 10:04:53)
Chainlink Automation upKeep not working. checkUpKeep is not calling performUpKeep
URL: https://stackoverflow.com/questions/74233765/chainlink-automation-upkeep-not-working-checkupkeep-is-not-calling-performupkee

Question Body:


Our Dapp will have an NFT Auction functionality, which we are trying to
automate 100% using chainlink. The auction winner will get the NFT and the
Previous owner will get the highest Bid, Platform will get a small cut as
well. To do that, we are using CHainlink Keeper/Automation. I've set the
`checkUpKeep` & `performUpKeep`, both are working fine when I'm doing
everything manually. But when I am registering an upKeep for automaton.

When I input the deployed contract's address into the register upkeep box, it
says `Unable to verify if this is an Automation compatible contract`. Why this
warning? How do I make the contract Automation compatible contract?
[](https://i.stack.imgur.com/nykbp.jpg)

`checkUpKeep` is working good: [](https://i.stack.imgur.com/HFmZ5.jpg)

If I pass this `performData` into `performUpKeep` everything will work fine.

Code/Contracts:
<https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8>

Chainlink upKeep:
<https://automation.chain.link/mumbai/21891159634677518530356555981285976030474691922841692133624884405593696766700>

Pls help, Thanks.



Answers:
(Answered on: 2022-10-28 15:46:58)


`Unable to verify if this is an Automation compatible contract` usually stems
from a contract that is not verified on the block explorer. The [contract you
linked](https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8)
is verified and if you create an automation with it everything is good
[](https://i.stack.imgur.com/6eSCb.png)

Your `checkUpKeep` function does return `true` when supplied with the input
you show(`checkData`). However, you have the `checkData` set to `0x` in your
automation. [](https://i.stack.imgur.com/kQaVD.png)

With that input, it returns false.

[](https://i.stack.imgur.com/W8ZYh.png)

You will need to change the `checkData` to match your screenshot.





:::NEXT DOC:::

Question: (Asked on: 2022-08-12 14:00:57)
Chainlink&#39;s dynamic upkeep registration example failing: UpkeepIDConsumerExample.registerAndPredictID errored: execution reverted
URL: https://stackoverflow.com/questions/73335353/chainlinks-dynamic-upkeep-registration-example-failing-upkeepidconsumerexample

Question Body:


I'm playing around with Chainlink's ""Register an Upkeep using your own
deployed contract"" example: <https://docs.chain.link/docs/chainlink-
keepers/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract>

However, once the UpkeepIDConsumerExample is deployed with the Link Token
Contact, Registry and Registrar parameters for the respective chain, I am
unable to use the UpkeepIDConsumerExample.registerAndPredictID function as it
fails.

_(Gas estimation errored with the following message (see below). The
transaction execution will likely fail. Do you want to force sending? Internal
JSON-RPC error. { ""code"": -32000, ""message"": ""execution reverted"" })_

I've tried on Rinkeby, Mumbai and Polygon Mainnet, incase testnets weren't
live yet. And I've used the parameters suggested by the docs for calling the
function. And I have sufficient Link in my metamask.

Is it correct to use these: <https://docs.chain.link/docs/link-token-
contracts/> as the Link Token Interfrace parameter?

Thanks!



Answers:
(Answered on: 2022-08-18 02:47:27)


I was able to make this work (though I tried only on Goerli)using the code
from the [offical docs](https://docs.chain.link/docs/chainlink-
keepers/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract)
that you linked to.

For the benefit of others that read this post, I will break it down into
detailed steps - perhaps more than you needed for an answer!

**Prerequisites**

  1. [Get some LINK tokens](https://faucets.chain.link/goerli) in your browser wallet
  2. Deploy a Chainlink Keepers-compatible contract -- this is your Upkeep contract; the one that will be automated. [Here is the example Upkeep smart contract](https://docs.chain.link/docs/chainlink-keepers/compatible-contracts/#example-contract) that you can copy and deploy right away. You can use `10` as the `interval` \-- that's 10 seconds. This way you can see the upkeep happen fast. **Note this Upkeep's address**
  3. Next, deploy the `UpkeepIDConsumerExample` from the [example in the docs](https://docs.chain.link/docs/chainlink-keepers/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract), which is the smart contract that programmatically registers your Upkeep Contract. This contract handles registering the Upkeep Contract you deployed in Step #2 with Chainlink's Keepers network, so that the Keepers Network can automate the running of functions in your Upkeep contract. **Note this Contracts Address**

**Making it work**

  1. From your wallet, which should now have LINK in it, send 5 LINK to the deployed `UpkeepIDConsumerExample` address. This is funding it will need to send onwards to your Upkeep (Upkeeps need funding so they can pay the Keepers Network for the compute work they do in performing the automations).

  2. Using Remix, connect to the right network and then connect to your deployed `UpkeepIDConsumerExample` contract by using its address.

  3. When Remix shows your contract and its interactions in the DEPLOYED CONTRACTS section of the UI, fill in the parameters for the `registerAndPredictID()` function using [this table in the docs](https://docs.chain.link/docs/chainlink-keepers/register-upkeep/#registerandpredictid-parameters).

While following the table referred to above, please note:

    * upkeepContract is the Upkeep Contracts address - the one you deployed in Step 2 in **Prerequisites**
    * gasLimit - I used `3000000`
    * adminAddress - this can just be your wallet address. The one that you're deployed from, sending LINK from etc.
    * Amount - 5 LINK expressed in Juels (LINK's equivalent of Wei), so `5000000000000000000`
    * Sender - this is the `UpkeepIDConsumerExample`'s address. In this example it's the calling contract itself.
  4. run `registerAndPredictID()` with the params as per the previous step. It should run successfully.

  5. Verify by going to the [Keepers App](https://keepers.chain.link/goerli) and checking under ""My Upkeeps"" for a new Upkeep that you just programmatically created.

**Cleanup**

  1. In the [Keepers App](https://keepers.chain.link/goerli) note the LINK balance of the Upkeep you just created and funded with the 5 LINK -- it may be a bit less than the 5 LINK you sent it because the keepers network may have already run your Upkeep - we had set the interval for 10 seconds in Step 2 of Prerequisites.
  2. And on Etherscan check whether `UpkeepIDConsumerExample` has any LINK in it (it shouldn't because the 5 LINK you sent from your wallet to this contract, was transferred when you ran `registerAndPredictID()` and sent an amount of 5 LINK

Hope this helps!





:::NEXT DOC:::

Question: (Asked on: 2021-12-08 14:26:10)
Chainlink Keeper not performing upkeep
URL: https://stackoverflow.com/questions/70276632/chainlink-keeper-not-performing-upkeep

Question Body:


I have a contract that is using Chainlink keepers for upkeep but the
checkUpKeep/performUpkeep is not running. I have sufficiently funded the
upkeep to ensure it has a high balance. The code from the contract was
previously deployed, but now contains a minor change (outside the Chainlink
functions), and the previous contract is receiving upkeeps. My code for
checkUpKeep and performUpKeep are below:

    
    
    function **checkUpkeep**(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        if(lottery_state == LOTTERY_STATE.OPEN){
            upkeepNeeded = (block.timestamp - lastTimeStamp) >= duration;
        }
        else{
            upkeepNeeded = false;
        }
      }
    
    function **performUpkeep**(bytes calldata /* performData */) external override {
        require(msg.sender == 0x4Cb093f226983713164A62138C3F718A5b595F73);
        lottery_state = LOTTERY_STATE.DRAWING;
        Random(random).getRandomNumber();
      }
    

As I mentioned earlier, this code is being used in another contract which is
currently receiving upkeep so I am puzzled as to why it is not working in the
new contract.



Answers:
(Answered on: 2021-12-13 23:44:27)


If your upkeeps are not being performed make sure to double-check the next
items:

  * Are Chainlink Keepers currently available on the network you are deploying to?
  * Is your smart contract `KeeperCompatible`?
  * Call `checkUpkeep`. Did it return `true` or `false`?
  * Can you `performUpkeep`?
  * Did you register your contract for upkeeps?
  * Did you fund it?



"
Is there a way in blockchain to get the randomResult?,"No, there is no way to get the randomResult in one transaction. The Chainlink VRF process requires two transactions: one to request the random number and another to retrieve the random number. The `letsgo` function in your code will not work.",{'source': 'https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction'},"There is a way to get the randomResult in blockchain using Chainlink VRF, but it requires a two-transaction process. The first transaction requests the random number, and the second transaction retrieves the random number. It is not possible to get the randomResult in one go. The speed at which the random number is returned depends on the block time of the blockchain being used. It typically takes around 2 * block time, which is about 30 seconds on Ethereum. It is recommended to listen for the event before calling getResult() in order to ensure that the callback to fulfillRandomness has occurred. Additionally, it is important to ensure that the VRF contract is funded with enough LINK tokens to cover the costs of the oracle request. There are different approaches to funding the contract, such as front-running the funding or having the NFT consumer fund it through a conversion from Ether to LINK. The scalability of funding the VRF contract is not well described in the documentation and may require additional considerations. 
","
- https://stackoverflow.com/questions/71242290/function-call-work-fine-in-remix-but-wont-in-js
- https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction
- https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers
- https://stackoverflow.com/questions/67119231/funding-chainlink-vrf-dynamically","Question: (Asked on: 2022-02-23 18:27:36)
Function call work fine in Remix but wont in JS
URL: https://stackoverflow.com/questions/71242290/function-call-work-fine-in-remix-but-wont-in-js

Question Body:


I've been experiencing trouble to link my chainlink VFR mapping to my
Javascript. I've mapped the result of the VRF to the address of the caller so
that the result depends on the caller.

Here is the solidity code:

    
    
    mapping(address => bytes32) private addressToId;
    mapping(bytes32 => uint256) private IdToRandom;
    
    function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            requestId =  requestRandomness(keyHash, fee);
            addressToId[msg.sender] = requestId;
        }
    
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            IdToRandom[requestId] = randomness;
            getResult();
        }
    
        function getResult() public view returns (uint randomnombre) {
            randomnombre = IdToRandom[addressToId[msg.sender]];
        }
    

When I call getResult() in a solidity function to determine if the address won
or not, it works fine on remix but won't work on JS.

Here is my JS call:

    
    
    contract.methods.getResult().call().then(function(bal) { console.log(bal) })
    

It sends me back 0 and I don't know how to handle it...



Answers:
(Answered on: 2022-02-24 13:48:36)


I think you are running into an issue where the `getRandomNumber()` has been
called and that transaction is complete but the callback to
`fulfillRandomness` hasn't occurred yet.

You will need to listen for the event before calling `getResult()`

One of the methods below should accomplish this

web3: <https://web3js.readthedocs.io/en/v1.2.11/web3-eth-
contract.html#contract-events>

ethers: <https://docs.ethers.io/v5/api/providers/provider/#Provider--event-
methods>





:::NEXT DOC:::

Question: (Asked on: 2021-10-05 09:57:27)
Retrieve the random number generated by Chainlink VRF in 1 transaction
URL: https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction

Question Body:


I am trying to get a random number in solidity in 1 transaction with Chainlink
VRF.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    contract RandomNumberConsumer is VRFConsumerBase {
        
        bytes32 internal keyHash;
        uint256 internal fee;
        
        uint256 internal randomResult;
        
        constructor() 
            VRFConsumerBase(
                0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, // VRF Coordinator
                0xa36085F69e2889c224210F603D836748e7dC0088  // LINK Token
            )
        {
            keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
        }
        function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
        function letsGo() public {
            bytes32 requestId;
            requestId = getRandomNumber();
            fulfillRandomness(requestId, 123456);
        }
    }
    

Is there a way in blockchain to get the randomResult?

I'm looking specifically at my `letsGo` function.



Answers:
(Answered on: 2021-10-07 12:29:29)


The chainlink VRF is a 2 transaction process.

The first transaction requests the random number, and the second to have the
random number returned. You can't get the random number in 1 go.

You can read more about the [basic request
model](https://docs.chain.link/docs/architecture-request-model/) in the
documentation.

You're `letsgo` function will not work.





:::NEXT DOC:::

Question: (Asked on: 2021-06-23 23:02:20)
Chain Link VRF takes a long time to get random numbers
URL: https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers

Question Body:


**Description**

Getting a random number takes a really long time. After executing the
getRandomNumber function, a few minutes go by before I can interact with my
random number.

Basically I click getRandomNumber and have to wait 2-3 minutes until the
random number shows up in the randomResult variable.

**Steps to Reproduce**

  1. Head over to the documentation here : <https://docs.chain.link/docs/get-a-random-number/>
  2. Scroll down and click on ""Deploy this contract using Remix"" (blue outline btn)
  3. Click on one of the folders that looks like 536123b61468ad4442cfc4278e8de577 then RandomNumberConsumer.sol
  4. Replace the LINK Token, VRF Coordinator, and Key Hash to be unique to rinkeby <https://docs.chain.link/docs/vrf-contracts/>
  5. Navigation to the Solidity Compiler Tab and click on Compile RandomNumber.sol.
  6. Deploy the contract on Rinkeby
  7. Copy to contract address and send LINK token to fund the contract.
  8. Click on the orange getRandomNumber btn in remix
  9. Click on randomResult and observe how long it takes for the value in randomResult to change. (Keep clicking until it finally changes)

**Additional Information**

I am not sure if this behavior is intentional or if I need to change up the
code. Ideally I would like to have the value of randomResult once the
getRandomNumber function finishes executing. Right now I don't know when the
value of randomResult will show up.



Answers:
(Answered on: 2021-06-23 23:24:42)


Chainlink VRF follows the [request and
receive](https://docs.chain.link/docs/intermediates-tutorial/#1-request--
receive) cycle of getting a number. This means, it has to look outside the
blockchain to get a response.

So, 2 transactions actually take place:

  1. Your requesting transaction
  2. The response transaction

This is necessary to look outside the blockchain like this, otherwise you'll
get a deterministic number as opposed to random. The speed at which the random
number is returned, is dictated by the block time of the blockchain you're
using.

So for Ethereum, the fastest time possible for a Random Number to be returned
is 2 * block time, or about 30ish seconds.

On faster chains like polygon, this is drastically lower.





:::NEXT DOC:::

Question: (Asked on: 2021-04-16 04:47:01)
Funding Chainlink VRF Dynamically
URL: https://stackoverflow.com/questions/67119231/funding-chainlink-vrf-dynamically

Question Body:


I am trying to wrap my head around how Chainlink VRF integrates into Solidity
contracts, such as in this randomly generated NFT tutorial:
<https://blog.chain.link/random-numbers-nft-erc721/>

My question is around the actual funding of the oracle. In the Chainlink VRF
documents, this warning is displayed: ""Requesting randomness will fail unless
your deployed contract has enough LINK to pay for it. Learn how to Acquire
testnet LINK and Fund your contract."" An example is given of how to fund the
VRF contract with metamask and Remix.

However, I'm not really sure how this would work on a large scale. If you have
an NFT ""factory"" that becomes very popular with potentially many requests per
day/hour/minute, are you just expected to front run the funding of this VRF
contract to avoid the aforementioned warning (seems like the costs would be
non-trivial / hard to predict)?

Alternatively, if you wanted your NFT consumer to fund it, would you have to
build in some logic that converts Ether to Link and then sends it to the
oracle contract? (or make them go buy Link token?)

I could be looking at this the wrong way, but the scalability just doesn't
seem well described in the documentation and only looked at from a testing /
test network standpoint. Thank you.



Answers:
(Answered on: 2021-11-08 05:04:46)


My suggestion is, maybe a little awkward, but for the sake of
decentralization, could work.

  * You charge your Contract1 with a sufficient link to get started

  * Charge every minter the equivalent link transaction cost in eth (+ the % that covers the costs of the trade to link and transfer between contracts)

  * As they mint, it is incorporated into the price and the eth is sent to Contract2.

  * In Contract2 simply exists a public callable function to initiate a swap for the link via routerV2 or a similar contract.

  * By placing a call to this function and contract, you can then just let any minter activate the swap contract function

  * The eth in Contract2 will be sent back to Contract1 as a link.

  * You could have a counter go and then call Contract2 every time the link fund is low and refill it automatically.

  * If you build it into the mint, then the inter will cover the fees.


---
(Answered on: 2021-04-16 11:20:22)


You can:

  1. Move the costs directly to the caller

_Require`LINK` payment, or some other form of payment that will cover the
costs of oracle request_

  2. Request the oracle data in a smaller frequency (if your use case allows it)

_Are you receiving some price info from an oracle? Is it sufficient to update
the price info once a day instead of once an hour?_

  3. Change your contract logic to not require (that much) oracle data

_Does your factory really need off-chain random number generation? Wouldn't be
sufficient to generate ""random"" number from the blockhash, difficulty, etc.?_



"
What is a gas lane in chainlink and blockchain?,"A gas lane in chainlink and blockchain is a concept used to set a limit on how much to spend on each request. It is important for setting the ceiling limit of each request, similar to an entry into a bet.",{'source': 'https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain'},,,"# Configuring Chainlink Nodes

  * Overview
  * TOML Configuration
  * Changes to node configuration starting in v1.1.0 nodes
  * Essential environment variables
  * DATABASE_URL
  * General Node Configuration
  * CL_CONFIG
  * CHAIN_TYPE
  * CHAINLINK_DEV
  * EXPLORER_ACCESS_KEY
  * EXPLORER_SECRET
  * EXPLORER_URL
  * ROOT
  * TELEMETRY_INGRESS_UNICONN
  * TELEMETRY_INGRESS_LOGGING
  * TELEMETRY_INGRESS_URL
  * TELEMETRY_INGRESS_SERVER_PUB_KEY
  * TELEMETRY_INGRESS_BUFFER_SIZE
  * TELEMETRY_INGRESS_MAX_BATCH_SIZE
  * TELEMETRY_INGRESS_SEND_INTERVAL
  * TELEMETRY_INGRESS_SEND_TIMEOUT
  * TELEMETRY_INGRESS_USE_BATCH_SEND
  * Chains
  * SOLANA_ENABLED
  * EVM_ENABLED
  * Database Settings
  * MIGRATE_DATABASE
  * ORM_MAX_IDLE_CONNS
  * ORM_MAX_OPEN_CONNS
  * Database Global Lock
  * DATABASE_LOCKING_MODE
  * ADVISORY_LOCK_CHECK_INTERVAL
  * ADVISORY_LOCK_ID
  * LEASE_LOCK_DURATION
  * LEASE_LOCK_REFRESH_INTERVAL
  * Database Automatic Backups
  * DATABASE_BACKUP_FREQUENCY
  * DATABASE_BACKUP_MODE
  * DATABASE_BACKUP_URL
  * DATABASE_BACKUP_DIR
  * Logging
  * JSON_CONSOLE
  * LOG_FILE_DIR
  * LOG_LEVEL
  * LOG_SQL
  * LOG_FILE_MAX_SIZE
  * LOG_FILE_MAX_AGE
  * LOG_FILE_MAX_BACKUPS
  * LOG_UNIX_TS
  * AUDIT_LOGGER_FORWARD_TO_URL
  * AUDIT_LOGGER_HEADERS
  * AUDIT_LOGGER_JSON_WRAPPER_KEY
  * Nurse service (auto-pprof)
  * AUTO_PPROF_ENABLED
  * AUTO_PPROF_PROFILE_ROOT
  * AUTO_PPROF_POLL_INTERVAL
  * AUTO_PPROF_GATHER_DURATION
  * AUTO_PPROF_GATHER_TRACE_DURATION
  * AUTO_PPROF_MAX_PROFILE_SIZE
  * AUTO_PPROF_CPU_PROFILE_RATE
  * AUTO_PPROF_MEM_PROFILE_RATE
  * AUTO_PPROF_BLOCK_PROFILE_RATE
  * AUTO_PPROF_MUTEX_PROFILE_FRACTION
  * AUTO_PPROF_MEM_THRESHOLD
  * AUTO_PPROF_GOROUTINE_THRESHOLD
  * Chainlink Web Server
  * ALLOW_ORIGINS
  * AUTHENTICATED_RATE_LIMIT
  * AUTHENTICATED_RATE_LIMIT_PERIOD
  * BRIDGE_CACHE_TTL
  * BRIDGE_RESPONSE_URL
  * HTTP_SERVER_WRITE_TIMEOUT
  * CHAINLINK_PORT
  * SECURE_COOKIES
  * SESSION_TIMEOUT
  * UNAUTHENTICATED_RATE_LIMIT
  * UNAUTHENTICATED_RATE_LIMIT_PERIOD
  * Web Server MFA
  * MFA_RPID
  * MFA_RPORIGIN
  * Web Server TLS
  * CHAINLINK_TLS_HOST
  * CHAINLINK_TLS_PORT
  * CHAINLINK_TLS_REDIRECT
  * TLS_CERT_PATH
  * TLS_KEY_PATH
  * EVM/Ethereum Legacy Environment Variables
  * ETH_URL
  * ETH_HTTP_URL
  * EVM_NODES
  * ETH_SECONDARY_URLS
  * EVM/Ethereum Global Settings
  * ETH_CHAIN_ID
  * EVM_RPC_ENABLED
  * EVM/Ethereum Chain-specific Overrides
  * BALANCE_MONITOR_ENABLED
  * BLOCK_BACKFILL_DEPTH
  * BLOCK_BACKFILL_SKIP
  * ETH_TX_REAPER_INTERVAL
  * ETH_TX_REAPER_THRESHOLD
  * ETH_TX_RESEND_AFTER_THRESHOLD
  * ETH_FINALITY_DEPTH
  * ETH_HEAD_TRACKER_HISTORY_DEPTH
  * ETH_HEAD_TRACKER_MAX_BUFFER_SIZE
  * ETH_HEAD_TRACKER_SAMPLING_INTERVAL
  * ETH_LOG_BACKFILL_BATCH_SIZE
  * ETH_LOG_POLL_INTERVAL
  * ETH_RPC_DEFAULT_BATCH_SIZE
  * LINK_CONTRACT_ADDRESS
  * MIN_INCOMING_CONFIRMATIONS
  * MIN_OUTGOING_CONFIRMATIONS
  * MINIMUM_CONTRACT_PAYMENT_LINK_JUELS
  * NODE_NO_NEW_HEADS_THRESHOLD
  * NODE_POLL_FAILURE_THRESHOLD
  * NODE_POLL_INTERVAL
  * NODE_SELECTION_MODE
  * NODE_SYNC_THRESHOLD
  * EVM Gas Controls
  * Configuring your ETH node
  * EVM_EIP1559_DYNAMIC_FEES
  * ETH_GAS_BUMP_PERCENT
  * ETH_GAS_BUMP_THRESHOLD
  * ETH_GAS_BUMP_TX_DEPTH
  * ETH_GAS_BUMP_WEI
  * EVM_GAS_FEE_CAP_DEFAULT
  * ETH_GAS_LIMIT_DEFAULT
  * ETH_GAS_LIMIT_MAX
  * ETH_GAS_LIMIT_MULTIPLIER
  * ETH_GAS_LIMIT_TRANSFER
  * ETH_GAS_PRICE_DEFAULT
  * EVM_GAS_TIP_CAP_DEFAULT
  * EVM_GAS_TIP_CAP_MINIMUM
  * ETH_MAX_GAS_PRICE_WEI
  * ETH_MAX_IN_FLIGHT_TRANSACTIONS
  * ETH_MAX_QUEUED_TRANSACTIONS
  * ETH_MIN_GAS_PRICE_WEI
  * ETH_GAS_LIMIT_OCR_JOB_TYPE
  * ETH_GAS_LIMIT_DR_JOB_TYPE
  * ETH_GAS_LIMIT_VRF_JOB_TYPE
  * ETH_GAS_LIMIT_FM_JOB_TYPE
  * ETH_GAS_LIMIT_KEEPER_JOB_TYPE
  * ETH_NONCE_AUTO_SYNC
  * ETH_USE_FORWARDERS
  * EVM/Ethereum Gas Price Estimation
  * GAS_ESTIMATOR_MODE
  * BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE
  * BLOCK_HISTORY_ESTIMATOR_BLOCK_HISTORY_SIZE
  * BLOCK_HISTORY_ESTIMATOR_BLOCK_DELAY
  * BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS
  * BLOCK_HISTORY_ESTIMATOR_TRANSACTION_PERCENTILE
  * EVM/Ethereum Transaction Simulation
  * Job Pipeline and tasks
  * DEFAULT_HTTP_LIMIT
  * DEFAULT_HTTP_TIMEOUT
  * FEATURE_EXTERNAL_INITIATORS
  * JOB_PIPELINE_MAX_RUN_DURATION
  * JOB_PIPELINE_MAX_SUCCESSFUL_RUNS
  * JOB_PIPELINE_REAPER_INTERVAL
  * JOB_PIPELINE_REAPER_THRESHOLD
  * JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH
  * OCR
  * FEATURE_OFFCHAIN_REPORTING
  * OCR_KEY_BUNDLE_ID
  * OCR_MONITORING_ENDPOINT
  * OCR_TRANSMITTER_ADDRESS
  * P2P_NETWORKING_STACK
  * Networking Stack V1
  * Networking Stack V2
  * Keeper
  * KEEPER_GAS_PRICE_BUFFER_PERCENT
  * KEEPER_GAS_TIP_CAP_BUFFER_PERCENT
  * KEEPER_BASE_FEE_BUFFER_PERCENT
  * KEEPER_MAXIMUM_GRACE_PERIOD
  * KEEPER_REGISTRY_CHECK_GAS_OVERHEAD
  * KEEPER_REGISTRY_PERFORM_GAS_OVERHEAD
  * KEEPER_REGISTRY_SYNC_INTERVAL
  * KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE
  * KEEPER_TURN_LOOK_BACK
  * CLI Client
  * ADMIN_CREDENTIALS_FILE
  * CLIENT_NODE_URL
  * INSECURE_SKIP_VERIFY
  * Notes on setting environment variables

Recent versions of the Chainlink node use sensible defaults for most
configuration variables. You do not need to change much to get a standard
deployment working.

Not all environment variables are documented here. Any undocumented
environment variable is subject to change in future releases. In almost all
cases, you should leave any environment variable not listed here to its
default value unless you really understand what you are doing.

To reiterate: _If you have an environment variable set that is not listed
here, and you don't know exactly why you have it set, you should remove it!_

The environment variables listed here are explicitly supported and current as
of Chainlink node v1.3.0.

### TOML Configuration

TOML configuration for Chainlink nodes is stable and recommended for mainnet
deployments. TOML configuration will be the only supported configuration
method starting with `v2.0.0`. Enable TOML configuration by specifying the
`-config <filename>.toml` flag with the path to your TOML file. Alternatively,
you can specify the raw TOML config in the [`CL_CONFIG` environment
variable](/chainlink-nodes/v1/configuration#cl_config). See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/CONFIG.md)
and
[SECRETS.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/SECRETS.md)
on GitHub to learn more.

## Changes to node configuration starting in v1.1.0 nodes

As of Chainlink node v1.1.0 and up, the way nodes manage configuration is
changing. Previously, environment variables exclusively handled all node
configuration. Although this configuration method worked well in the past, it
has its limitations. Notably, it doesn't mesh well with chain-specific
configuration profiles.

For this reason, Chainlink nodes are moving towards a model where you set
variables using the API, CLI, or GUI, and the configuration is saved in the
database. We encourage you to become familiar with this model because it is
likely that nodes will continue to move away from environment variable
configuration in the future.

As of v1.1.0, Chainlink nodes still support environment variables to configure
node settings and chain-specific settings. If the environment variable is set,
it overrides any chain-specific, job-specific, or database configuration
setting. The log displays a warning to indicate when an override happens, so
you know when variables lower in the hierarchy are being ignored.

Your node applies configuration settings using following hierarchy:

  1. Environment variables
  2. Chain-specific variables
  3. Job-specific variables

## Essential environment variables

These are the only environment variables that are _required_ for a Chainlink
node to run.

### DATABASE_URL

**Required**

  * Default: _none_

The PostgreSQL URI to connect to your database. Chainlink nodes require
Postgres versions >= 11. See the [Running a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node) for an example.

## General Node Configuration

### CL_CONFIG

This environment variable is used to set static configuration using TOML
format. Specify the raw TOML config in this environment variable. Unlike the
`-config` flag, it does not accept a path to a TOML file.

See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/CONFIG.md)
and
[SECRETS.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/SECRETS.md)
on GitHub to learn more.

### CHAIN_TYPE

  * Default: _none_

CHAIN_TYPE overrides all chains and forces them to act as a particular chain
type. An up-to-date list of chain types is given in
[`chaintype.go`](https://github.com/smartcontractkit/chainlink/blob/v1.3.0/core/chains/chaintype.go).

This variable enables some chain-specific hacks and optimizations. It is
recommended not to use this environment variable and set the chain-type on a
per-chain basis instead.

### CHAINLINK_DEV

  * Default: `""false""`

Setting `CHAINLINK_DEV` to `true` enables development mode. Do not use this
for production deployments. It can be useful for enabling experimental
features and collecting debug information in test environments.

### EXPLORER_ACCESS_KEY

  * Default: _none_

The access key for authenticating with the explorer. This variable is required
to deliver telemetry.

### EXPLORER_SECRET

  * Default: _none_

The secret for authenticating with the explorer. This variable is required to
deliver telemetry.

### EXPLORER_URL

  * Default: _none_

The explorer websocket URL for the node to push stats to. This variable is
required to deliver telemetry.

### ROOT

  * Default: `""~/.chainlink""`

The Chainlink node's root directory. This is the default directory for
logging, database backups, cookies, and other misc Chainlink node files.
Chainlink nodes will always ensure this directory has `700` permissions
because it might contain sensitive data.

### TELEMETRY_INGRESS_UNICONN

  * Default: `""true""`

Toggles which ws connection style is used.

### TELEMETRY_INGRESS_LOGGING

  * Default: `""false""`

Toggles verbose logging of the raw telemetry messages being sent.

### TELEMETRY_INGRESS_URL

  * Default: _none_

The URL to connect to for sending telemetry.

### TELEMETRY_INGRESS_SERVER_PUB_KEY

  * Default: _none_

The public key of the telemetry server.

### TELEMETRY_INGRESS_BUFFER_SIZE

  * Default: `""100""`

The number of telemetry messages to buffer before dropping new ones.

### TELEMETRY_INGRESS_MAX_BATCH_SIZE

  * Default: `""50""`

The maximum number of messages to batch into one telemetry request.

### TELEMETRY_INGRESS_SEND_INTERVAL

  * Default: `""500ms""`

The interval on which batched telemetry is sent to the ingress server.

### TELEMETRY_INGRESS_SEND_TIMEOUT

  * Default: `""10s""`

The max duration to wait for the request to complete when sending batch
telemetry.

### TELEMETRY_INGRESS_USE_BATCH_SEND

  * Default: `""true""`

Toggles sending telemetry to the ingress server using the batch client.

## Chains

### SOLANA_ENABLED

caution

  * Default: `""false""`

Enables Solana support.

### EVM_ENABLED

  * Default: `""true""`

Enables support for EVM-based chains. By default, this variable is set to
`true` to provide legacy compatibility and ease the upgrade path from older
versions of Chainlink which did not support disabling EVM.

## Database Settings

### MIGRATE_DATABASE

  * Default: `""true""`

This variable controls whether a Chainlink node will attempt to automatically
migrate the database on boot. If you want more control over your database
migration process, set this variable to `false` and manually migrate the
database using the CLI `migrate` command instead.

### ORM_MAX_IDLE_CONNS

  * Default: `""10""`

This setting configures the maximum number of idle database connections that
the Chainlink node will keep open. Think of this as the baseline number of
database connections per Chainlink node instance. Increasing this number can
help to improve performance under database-heavy workloads.

Postgres has connection limits, so you must use cation when increasing this
value. If you are running several instances of a Chainlink node or another
application on a single database server, you might run out of Postgres
connection slots if you raise this value too high.

### ORM_MAX_OPEN_CONNS

  * Default: `""20""`

This setting configures the maximum number of database connections that a
Chainlink node will have open at any one time. Think of this as the maximum
burst upper bound limit of database connections per Chainlink node instance.
Increasing this number can help to improve performance under database-heavy
workloads.

Postgres has connection limits, so you must use cation when increasing this
value. If you are running several instances of a Chainlink node or another
application on a single database server, you might run out of Postgres
connection slots if you raise this value too high.

## Database Global Lock

Chainlink nodes use a database lock to ensure that only one Chainlink node
instance can be run on the database at a time. If you run multiple instances
of a Chainlink node that share a single database at the same time, the node
will encounter strange errors and data integrity failures. Do not allow
multiple nodes to write data to the database at the same time.

### DATABASE_LOCKING_MODE

  * Default: `""dual""`

The `DATABASE_LOCKING_MODE` variable can be set to 'dual', 'advisorylock',
'lease', or 'none'. It controls which mode to use to enforce that only one
Chainlink node can use the database. It is recommended to set this to `lease`.

  * `dual` \- The default: Uses both advisory locks and lease locks for backward and forward compatibility
  * `advisorylock` \- Advisory lock only
  * `lease` \- Lease lock only
  * _none_ \- No locking at all: This option useful for advanced deployment environments when you are sure that only one instance of a Chainlink node will ever be running.

#### Technical details

Ideally, you should use a container orchestration system like
[Kubernetes](https://kubernetes.io/) to ensure that only one Chainlink node
instance can ever use a specific Postgres database. However, some node
operators do not have the technical capacity to do this. Common use cases run
multiple Chainlink node instances in failover mode as recommended by our
official documentation. The first instance takes a lock on the database and
subsequent instances will wait trying to take this lock in case the first
instance fails.

By default, Chainlink nodes use the `dual` setting to provide both advisory
locks and lease locks for backward and forward compatibility. Using advisory
locks alone presents the following problems:

  * If your nodes or applications hold locks open for several hours or days, Postgres is unable to complete internal cleanup tasks. The Postgres maintainers explicitly discourage holding locks open for long periods of time.
  * Advisory locks can silently disappear when you upgrade Postgres, so a new Chainlink node instance can take over even while the old node is still running.
  * Advisory locks do not work well with pooling tools such as [pgbouncer](https://www.pgbouncer.org/).
  * If the Chainlink node crashes, an advisory lock can hang around for up to several hours, which might require you to manually remove it so another instance of the Chainlink node will allow itself to boot.

Because of the complications with advisory locks, Chainlink nodes with v1.1.0
and later support a new `lease` locking mode. This mode might become the
default in future. The `lease` locking mode works using the following process:

  * Node A creates one row in the database with the client ID and updates it once per second.
  * Node B spinlocks and checks periodically to see if the client ID is too old. If the client ID is not updated after a period of time, node B assumes that node A failed and takes over. Node B becomes the owner of the row and updates the client ID once per second.
  * If node A comes back, it attempts to take out a lease, realizes that the database has been leased to another process, and exits the entire application immediately.

### ADVISORY_LOCK_CHECK_INTERVAL

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable advisory
locking.

  * Default: `""1s""`

`ADVISORY_LOCK_CHECK_INTERVAL` controls how often the Chainlink node checks to
make sure it still holds the advisory lock when advisory locking is enabled.
If a node no longer holds the lock, it will try to re-acquire it. If the node
cannot re-acquire the lock, the application will exit.

### ADVISORY_LOCK_ID

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable advisory
locking.

  * Default: `""1027321974924625846""`

`ADVISORY_LOCK_ID` is the application advisory lock ID. This must match all
other Chainlink nodes that might access this database. It is unlikely you will
ever need to change this from the default.

### LEASE_LOCK_DURATION

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable lease
locking.

  * Default: `""30s""`

How long the lease lock will last before expiring.

### LEASE_LOCK_REFRESH_INTERVAL

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable lease
locking.

  * Default: `""1s""`

How often to refresh the lease lock. Also controls how often a standby node
will check to see if it can grab the lease.

## Database Automatic Backups

As a best practice, take regular database backups in case of accidental data
loss. This best practice is especially important when you upgrade your
Chainlink node to a new version. Chainlink nodes support automated database
backups to make this process easier.

NOTE: Dumps can cause high load and massive database latencies, which will
negatively impact the normal functioning of the Chainlink node. For this
reason, it is recommended to set a DATABASE_BACKUP_URL and point it to a read
replica if you enable automatic backups.

### DATABASE_BACKUP_FREQUENCY

  * Default: `""1h""`

If this variable is set to a positive duration and `DATABASE_BACKUP_MODE` is
not _none_ , the node will dump the database at this regular interval.

Set to `0` to disable periodic backups.

### DATABASE_BACKUP_MODE

  * Default: `""none""`

Set the mode for automatic database backups, which can be one of _none_ ,
`lite`, or `full`. If enabled, the Chainlink node will always dump a backup on
every boot before running migrations. Additionally, it will automatically take
database backups that overwrite the backup file for the given version at
regular intervals if `DATABASE_BACKUP_FREQUENCY` is set to a non-zero
interval.

_none_ \- Disables backups. `lite` \- Dumps small tables including
configuration and keys that are essential for the node to function, which
excludes historical data like job runs, transaction history, etc. `full` \-
Dumps the entire database.

It will write to a file like `$ROOT/backup/cl_backup_<VERSION>.dump`. There is
one backup dump file per version of the Chainlink node. If you upgrade the
node, it will keep the backup taken right before the upgrade migration so you
can restore to an older version if necessary.

### DATABASE_BACKUP_URL

If specified, the automatic database backup will pull from this URL rather
than the main `DATABASE_URL`. It is recommended to set this value to a read
replica if you have one to avoid excessive load on the main database.

### DATABASE_BACKUP_DIR

This variable sets the directory to use for saving the backup file. Use this
if you want to save the backup file in a directory other than the default ROOT
directory.

## Logging

### JSON_CONSOLE

  * Default: `""false""`

Set this to true to enable JSON logging. Otherwise, the log is saved in a
human-friendly console format.

### LOG_FILE_DIR

  * Default: `""$ROOT""`

By default, Chainlink nodes write log data to `$ROOT/log.jsonl`. The log
directory can be changed by setting this var. For example,
`LOG_FILE_DIR=/my/log/directory`.

### LOG_LEVEL

  * Default: `""info""`

The `LOG_LEVEL` environment variable determines both what is printed on the
screen and what is written to the log file.

The available options are:

  * `""debug""`: Useful for forensic debugging of issues.
  * `""info""`: High-level informational messages.
  * `""warn""`: A mild error occurred that might require non-urgent action. Check these warnings semi-regularly to see if any of them require attention. These warnings usually happen due to factors outside of the control of the node operator. Examples: Unexpected responses from a remote API or misleading networking errors.
  * `""error""`: An unexpected error occurred during the regular operation of a well-maintained node. Node operators might need to take action to remedy this error. Check these regularly to see if any of them require attention. Examples: Use of deprecated configuration options or incorrectly configured settings that cause a job to fail.
  * `""crit""`: A critical error occurred. The node might be unable to function. Node operators should take immediate action to fix these errors. Examples: The node could not boot because a network socket could not be opened or the database became inaccessible.
  * `""panic""`: An exceptional error occurred that could not be handled. If the node is unresponsive, node operators should try to restart their nodes and notify the Chainlink team of a potential bug.
  * `""fatal""`: The node encountered an unrecoverable problem and had to exit.

### LOG_SQL

  * Default: `""false""`

This setting tells the Chainlink node to log SQL statements made using the
default logger. SQL statements will be logged at `debug` level. Not all
statements can be logged. The best way to get a true log of all SQL statements
is to enable SQL statement logging on Postgres.

### LOG_FILE_MAX_SIZE

  * Default: `""5120mb""`

Determines the log file's max size in megabytes before file rotation. Having
this not set will disable logging to disk. If your disk doesn't have enough
disk space, the logging will pause and the application will log errors until
space is available again.

Values must have suffixes with a unit like: `5120mb` (5,120 megabytes). If no
unit suffix is provided, the value defaults to `b` (bytes). The list of valid
unit suffixes are:

  * b (bytes)
  * kb (kilobytes)
  * mb (megabytes)
  * gb (gigabytes)
  * tb (terabytes)

### LOG_FILE_MAX_AGE

  * Default: `""0""`

Determines the log file's max age in days before file rotation. Keeping this
config with the default value will not remove log files based on age.

### LOG_FILE_MAX_BACKUPS

  * Default: `""1""`

Determines the maximum number of old log files to retain. Keeping this config
with the default value retains all old log files. The `LOG_FILE_MAX_AGE`
variable can still cause them to get deleted.

### LOG_UNIX_TS

  * Default: _none_

Previous versions of Chainlink nodes wrote JSON logs with a unix timestamp. As
of v1.1.0 and up, the default has changed to use ISO8601 timestamps for better
readability. Setting `LOG_UNIX_TS=true` will enable the old behavior.

### AUDIT_LOGGER_FORWARD_TO_URL

  * Default: _none_

When set, this environment variable configures and enables an optional HTTP
logger which is used specifically to send audit log events. Audit logs events
are emitted when specific actions are performed by any of the users through
the node's API. The value of this variable should be a full URL. Log items
will be sent via POST HTTP requests.

There are audit log implemented for the following events:

  * Auth & Sessions (new session, login success, login failed, 2FA enrolled, 2FA failed, password reset, password reset failed, etc.)
  * CRUD actions for all resources (add/create/delete resources such as bridges, nodes, keys)
  * Sensitive actions (keys exported/imported, config changed, log level changed, environment dumped)

A full list of audit log enum types can be found in the source within the
`audit` package
([`audit_types.go`](https://github.com/smartcontractkit/chainlink/blob/develop/core/logger/audit/audit_types.go)).

Log events follow this schema:


    {
        ""eventID"":  EVENT_ID_ENUM,
        ""hostname"": HOSTNAME,
        ""localIP"" : CL_NODE_IP,
        ""env"" : ENVIRONMENT_NAME,
        ""data"": ...
    }

The `AUDIT_LOGGER_*` environment variables configure this optional audit log
HTTP forwarder.

### AUDIT_LOGGER_HEADERS

  * Default: _none_

An optional list of HTTP headers to be added for every optional audit log
event. If the above `AUDIT_LOGGER_FORWARD_TO_URL` is set, audit log events
will be POSTed to that URL, and will include headers specified in this
environment variable. One example use case is auth for example:
`AUDIT_LOGGER_HEADERS=""Authorization||{token}""`

Header keys and values are delimited on `||`, and multiple headers can be
added with a forward slash delimiter (`\`). An example of multiple key value
pairs: `AUDIT_LOGGER_HEADERS=""Authorization||{token}\Some-Other-
Header||{token2}""`

### AUDIT_LOGGER_JSON_WRAPPER_KEY

  * Default: _none_

When the audit log HTTP forwarder is enabled, if there is a value set for this
optional environment variable then the POST body will be wrapped in a
dictionary in a field specified by the value of set variable. This is to help
enable specific logging service integrations that may require the event JSON
in a special shape. For example: `AUDIT_LOGGER_JSON_WRAPPER_KEY=event` will
create the POST body:


    {
      ""event"": {
        ""eventID"":  EVENT_ID_ENUM,
        ""hostname"": HOSTNAME,
        ""localIP"" : CL_NODE_IP,
        ""env"" : ENVIRONMENT_NAME,
        ""data"": ...
      }
    }

## Nurse service (auto-pprof)

The Chainlink node is equipped with an internal ""nurse"" service that can
perform automatic `pprof` profiling when the certain resource thresholds are
exceeded, such as memory and goroutine count. These profiles are saved to disk
to facilitate fine-grained debugging of performance-related issues. In
general, if you notice that your node has begun to accumulate profiles,
forward them to the Chainlink team.

To learn more about these profiles, read the [Profiling Go programs with
pprof](https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/) guide.

### AUTO_PPROF_ENABLED

  * Default: `""false""`

Set to `true` to enable the automatic profiling service.

### AUTO_PPROF_PROFILE_ROOT

Defaults to `$CHAINLINK_ROOT`

The location on disk where pprof profiles will be stored.

### AUTO_PPROF_POLL_INTERVAL

  * Default: `""10s""`

The interval at which the node's resources are checked.

### AUTO_PPROF_GATHER_DURATION

  * Default: `""10s""`

The duration for which profiles are gathered when profiling starts.

### AUTO_PPROF_GATHER_TRACE_DURATION

  * Default: `""5s""`

The duration for which traces are gathered when profiling is kicked off. This
is separately configurable because traces are significantly larger than other
types of profiles.

### AUTO_PPROF_MAX_PROFILE_SIZE

  * Default: `""100mb""`

The maximum amount of disk space that profiles may consume before profiling is
disabled.

### AUTO_PPROF_CPU_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetCPUProfileRate>.

### AUTO_PPROF_MEM_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#pkg-variables>.

### AUTO_PPROF_BLOCK_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetBlockProfileRate>.

### AUTO_PPROF_MUTEX_PROFILE_FRACTION

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetMutexProfileFraction>.

  * Default: `""1""`

### AUTO_PPROF_MEM_THRESHOLD

  * Default: `""4gb""`

The maximum amount of memory the node can actively consume before profiling
begins.

### AUTO_PPROF_GOROUTINE_THRESHOLD

  * Default: `""5000""`

The maximum number of actively-running goroutines the node can spawn before
profiling begins.

## Chainlink Web Server

### ALLOW_ORIGINS

  * Default: `""http://localhost:3000,http://localhost:6688""`

Controls the URLs Chainlink nodes emit in the `Allow-Origins` header of its
API responses. The setting can be a comma-separated list with no spaces. You
might experience CORS issues if this is not set correctly.

You should set this to the external URL that you use to access the Chainlink
UI.

You can set `ALLOW_ORIGINS=*` to allow the UI to work from any URL, but it is
recommended for security reasons to make it explicit instead.

### AUTHENTICATED_RATE_LIMIT

  * Default: `""1000""`

`AUTHENTICATED_RATE_LIMIT` defines the threshold to which authenticated
requests get limited. More than this many authenticated requests per
`AUTHENTICATED_RATE_LIMIT_PERIOD` will be rejected.

### AUTHENTICATED_RATE_LIMIT_PERIOD

  * Default: `""1m""`

`AUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which authenticated
requests get limited.

### BRIDGE_CACHE_TTL

  * Default: 0s

When set to `d` units of time, this variable enables using cached bridge
responses that are at most `d` units old. Caching is disabled by default.

Example `BRIDGE_CACHE_TTL=10s`, `BRIDGE_CACHE_TTL=1m`

### BRIDGE_RESPONSE_URL

  * Default: _none_

`BRIDGE_RESPONSE_URL` defines the URL for bridges to send a response to.

Usually this will be the same as the URL/IP and port you use to connect to the
Chainlink UI, such as `https://my-chainlink-node.example.com:6688`.

### HTTP_SERVER_WRITE_TIMEOUT

**ADVANCED**

Do not change this setting unless you know what you are doing.

  * Default: `""10s""`

`HTTP_SERVER_WRITE_TIMEOUT` controls how long the Chainlink node's API server
can hold a socket open for writing a response to an HTTP request. Sometimes,
this must be increased for pprof.

### CHAINLINK_PORT

  * Default: `""6688""`

Port used for the Chainlink Node API, CLI, and GUI.

### SECURE_COOKIES

  * Default: `""true""`

Requires the use of secure cookies for authentication. Set to false to enable
standard HTTP requests along with `CHAINLINK_TLS_PORT=0`.

### SESSION_TIMEOUT

  * Default: `""15m""`

This value determines the amount of idle time to elapse before session cookies
expire. This signs out GUI users from their sessions.

### UNAUTHENTICATED_RATE_LIMIT

  * Default: `""5""`

`UNAUTHENTICATED_RATE_LIMIT` defines the threshold to which authenticated
requests get limited. More than this many unauthenticated requests per
`UNAUTHENTICATED_RATE_LIMIT_PERIOD` will be rejected.

### UNAUTHENTICATED_RATE_LIMIT_PERIOD

  * Default: `""20s""`

`UNAUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which
unauthenticated requests get limited.

## Web Server MFA

The Operator UI frontend now supports enabling Multi Factor Authentication via
Webauthn per account. When enabled, logging in will require the account
password and a hardware or OS security key such as Yubikey. To enroll, log in
to the operator UI and click the circle purple profile button at the top right
and then click **Register MFA Token**. Tap your hardware security key or use
the OS public key management feature to enroll a key. Next time you log in,
this key will be required to authenticate.

This feature must be enabled by setting the following environment variables:
`MFA_RPID` and `MFA_RPORIGIN`.

### MFA_RPID

  * Default: _none_

The `MFA_RPID` value should be the FQDN of where the Operator UI is served.
When serving locally, the value should be `localhost`.

### MFA_RPORIGIN

  * Default: _none_

The `MFA_RPORIGIN` value should be the origin URL where WebAuthn requests
initiate, including scheme and port. When serving locally, the value should be
`http://localhost:6688/`.

## Web Server TLS

The TLS settings below apply only if you want to enable TLS security on your
Chainlink node.

### CHAINLINK_TLS_HOST

  * Default: _none_

The hostname configured for TLS to be used by the Chainlink node. This is
useful if you configured a domain name specific for your Chainlink node.

### CHAINLINK_TLS_PORT

  * Default: `""6689""`

The port used for HTTPS connections. Set this to `0` to disable HTTPS.
Disabling HTTPS also relieves Chainlink nodes of the requirement for a TLS
certificate.

### CHAINLINK_TLS_REDIRECT

  * Default: `""false""`

Forces TLS redirect for unencrypted connections.

### TLS_CERT_PATH

  * Default: _none_

The location of the TLS certificate file. Example:
`/home/$USER/.chainlink/tls/server.crt`

### TLS_KEY_PATH

  * Default: _none_

The location of the TLS private key file. Example:
`/home/$USER/.chainlink/tls/server.key`

## EVM/Ethereum Legacy Environment Variables

Previous Chainlink node versions supported only one chain. From v1.1.0 and up,
Chainlink nodes support multiple EVM and non-EVM chains, so the way that
chains and nodes are configured has changed.

The preferred way of configuring Chainlink nodes as of v1.1.0 and up is to use
the API, CLI, or UI to set chain-specific configuration and create nodes.

The old way of specifying chains using environment variables is still
supported, but discouraged. It works as follows:

If you set any value for `ETH_URL`, the values of `ETH_CHAIN_ID`, `ETH_URL`,
`ETH_HTTP_URL` and `ETH_SECONDARY_URLS` will be used to create and update
chains and nodes representing these values in the database. If an existing
chain or node is found, it will be overwritten. This mode is used mainly to
ease the process of upgrading. On subsequent runs (once your old settings have
been written to the database) it is recommended to unset `ETH_URL` and use the
API commands exclusively to administer chains and nodes.

In the future, support for the `ETH_URL` and associated environment variables
might be removed, so it is recommended to use the API, CLI, or GUI instead to
setup chains and nodes.

### ETH_URL

Setting this will enable ""legacy eth ENV"" mode, which is not compatible with
multi-chain. It is better to configure settings using the API, CLI, or GUI
instead.

  * Default: _none_

This is the websocket address of the Ethereum client that the Chainlink node
will connect to. All interaction with the Ethereum blockchain will occur
through this connection.

NOTE: It is also required to set `ETH_CHAIN_ID` if you set ETH_URL.

### ETH_HTTP_URL

Only has effect if `ETH_URL` set. Otherwise, it can be set in the API, CLI, or
GUI.

  * Default: _none_

This should be set to the HTTP URL that points to the same ETH node as the
primary. If set, the Chainlink node will automatically use HTTP mode for heavy
requests, which can improve reliability.

### EVM_NODES

caution

Setting this environment variable will **COMPLETELY ERASE** your `evm_nodes`
table on every boot and repopulate from the given data to nullify any runtime
modifications. This is a temporary solution until this configuration can be
defined in a file in the future.

  * Default: _none_

A JSON array of node specifications that allows you to configure multiple
nodes or chains using an environment variable. This is not compatible with
other environment variables that specify the node such as `ETH_URL` or
`ETH_SECONDARY_URLS`. Set this variable using a configuration like the
following example:


    EVM_NODES='
    [
    	{
    		""name"": ""primary_0_1"",
    		""evmChainId"": ""0"",
    		""wsUrl"": ""ws://test1.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""primary_0_2"",
    		""evmChainId"": ""0"",
    		""wsUrl"": ""ws://test2.invalid"",
    		""httpUrl"": ""https://test3.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""primary_1337_1"",
    		""evmChainId"": ""1337"",
    		""wsUrl"": ""ws://test4.invalid"",
    		""httpUrl"": ""http://test5.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""sendonly_1337_1"",
    		""evmChainId"": ""1337"",
    		""httpUrl"": ""http://test6.invalid"",
    		""sendOnly"": true
    	},
    	{
    		""name"": ""sendonly_0_1"",
    		""evmChainId"": ""0"",
    		""httpUrl"": ""http://test7.invalid"",
    		""sendOnly"": true
    	},
    	{
    		""name"": ""primary_42_1"",
    		""evmChainId"": ""42"",
    		""wsUrl"": ""ws://test8.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""sendonly_43_1"",
    		""evmChainId"": ""43"",
    		""httpUrl"": ""http://test9.invalid"",
    		""sendOnly"": true
    	}
    ]
    '

Usage of Docker requires the variable to be formatted as one line with no
whitespaces and quotes wrapping it, as follows in the example:


    EVM_NODES=[{""name"":""primary_0_1"",""evmChainId"":""0"",""wsUrl"":""ws://test1.invalid"",""sendOnly"":false},{""name"":""primary_0_2"",""evmChainId"":""0"",""wsUrl"":""ws://test2.invalid"",""httpUrl"":""https://test3.invalid"",""sendOnly"":false},{""name"":""primary_1337_1"",""evmChainId"":""1337"",""wsUrl"":""ws://test4.invalid"",""httpUrl"":""http://test5.invalid"",""sendOnly"":false}]

### ETH_SECONDARY_URLS

Only has effect if `ETH_URL` set. Otherwise, it can be set in the API, CLI, or
GUI.

  * Default: _none_

If set, transactions will also be broadcast to this secondary Ethereum node.
This allows transaction broadcasting to be more robust in the face of primary
Ethereum node bugs or failures.

It is recommended to set at least one secondary ETH node here that is
different from your primary.

Multiple URLs can be specified as a comma-separated list e.g.

`ETH_SECONDARY_URLS=https://example.com/1,https://example.text/2,...`

## EVM/Ethereum Global Settings

This configuration is specific to EVM/Ethereum chains.

### ETH_CHAIN_ID

  * Default: _none_

This environment variable specifies the default chain ID. Any job spec that
has not explicitly set `EVMChainID` will connect to this default chain. If you
do not have a chain in the database matching this value, any jobs that try to
use it will throw an error.

### EVM_RPC_ENABLED

  * Default: `""true""`

Enables connecting to real EVM RPC nodes. Disabling this can be useful in
certain cases such as spinning up a Chainlink node and adding EVM-based jobs
without having it actually execute anything on-chain, or for debugging to see
what the node _would_ do without actually doing it.

## EVM/Ethereum Chain-specific Overrides

These configuration options act as an override, setting the value for _all_
chains.

This often doesn't make sense, e.g. `ETH_FINALITY_DEPTH` on Avalanche could be
quite different from `ETH_FINALITY_DEPTH` on Ethereum mainnet.

We recommend setting this on a per-chain basis using the API, CLI, or GUI
instead.

In general, Chainlink nodes contain built-in defaults for most of these
settings that should work out of the box on all officially supported chains,
so it is unlikely you must make any changes here.

### BALANCE_MONITOR_ENABLED

  * Default: `""true""`

Enables Balance Monitor feature. This is required to track balances of keys
locally and warn if it drops too low. It also enables displaying balance in
the Chainlink UI and API.

### BLOCK_BACKFILL_DEPTH

  * Default: `""10""`

This variable specifies the number of blocks before the current head that the
log broadcaster will try to re-consume logs from, e.g. after adding a new job.

### BLOCK_BACKFILL_SKIP

  * Default: `""false""`

This variable enables skipping of very long log backfills. For example, this
happens in a situation when the node is started after being offline for a long
time. This might be useful on fast chains and if only recent chain events are
relevant

### ETH_TX_REAPER_INTERVAL

NOTE: This overrides the setting for _all_ chains, you might want to set this
on a per-chain basis using the API, CLI, or GUI instead

  * Default: `""1h""`

Controls how often the ETH transaction reaper should run, used to delete old
confirmed or fatally_errored transaction records from the database. Setting to
`0` disables the reaper.

### ETH_TX_REAPER_THRESHOLD

  * Default: `""24h""`

Represents how long any confirmed or fatally_errored `eth_tx` transactions
will hang around in the database. If the `eth_tx` is confirmed but still below
`ETH_FINALITY_DEPTH`, it will not be deleted even if it was created at a time
older than this value.

EXAMPLE: With: `EthTxReaperThreshold=1h` and `EthFinalityDepth=50` If current
head is 142, any `eth_tx` confirmed in block 91 or below will be reaped as
long as its `created_at` value is older than the value set for
`EthTxReaperThreshold`.

Setting to `0` disables the reaper.

### ETH_TX_RESEND_AFTER_THRESHOLD

NOTE: This overrides the setting for _all_ chains, you might want to set this
on a per-chain basis using the API, CLI, or GUI instead.

  * Default: _automatically set based on Chain ID, typically 1m_

Controls how long the `ethResender` will wait before re-sending the latest
`eth_tx_attempt`. This is designed a as a fallback to protect against the ETH
nodes dropping transactions (which has been anecdotally observed to happen),
networking issues, or transactions being ejected from the mempool.

Setting to `0` disables the resender.

### ETH_FINALITY_DEPTH

  * Default: _automatically set based on Chain ID, typically 50_

The number of blocks after which an Ethereum transaction is considered
""final"".

`ETH_FINALITY_DEPTH` determines how deeply we look back to ensure that
transactions are confirmed onto the longest chain. There is not a large
performance penalty to setting this relatively high (on the order of
hundreds).

It is practically limited by the number of heads we store in the database
(`HEAD_TRACKER_HISTORY_DEPTH`) and should be less than this with a comfortable
margin. If a transaction is mined in a block more than this many blocks ago,
and is reorged out, we will NOT retransmit this transaction and undefined
behavior can occur including gaps in the nonce sequence that require manual
intervention to fix. Therefore, this number represents a number of blocks we
consider large enough that no re-org this deep will ever feasibly happen.

### ETH_HEAD_TRACKER_HISTORY_DEPTH

  * Default: _automatically set based on Chain ID, typically 100_

Tracks the top N block numbers to keep in the `heads` database table. Note
that this can easily result in MORE than N total records since in the case of
re-orgs we keep multiple heads for a particular block height, and it is also
scoped per chain. This number should be at least as large as
`ETH_FINALITY_DEPTH`. There might be a small performance penalty to setting
this to something very large (10,000+)

### ETH_HEAD_TRACKER_MAX_BUFFER_SIZE

  * Default: `""3""`

The maximum number of heads that can be buffered in front of the head tracker
before older heads start to be dropped. Think this setting as the maximum
permitted ""lag"" for the head tracker before the Chainlink node starts dropping
heads to keep up.

### ETH_HEAD_TRACKER_SAMPLING_INTERVAL

  * Default: _automatically set based on Chain ID, typically 1s_

Head tracker sampling was introduced to handle chains with very high
throughput. If this is set, the head tracker will ""gap"" heads and deliver a
maximum of 1 head per this period.

Set to `0` to disable head tracker sampling.

### ETH_LOG_BACKFILL_BATCH_SIZE

  * Default: _automatic based on Chain ID, typically 100_

Controls the batch size for calling FilterLogs when backfilling missing or
recent logs.

### ETH_LOG_POLL_INTERVAL

  * Default: _automatic based on Chain ID_

Defines how frequently to poll for new logs.

### ETH_RPC_DEFAULT_BATCH_SIZE

  * Default: _automatic based on chain ID_

Chainlink nodes use batch mode for certain RPC calls to increase efficiency of
communication with the remote ETH node. In some cases, trying to request too
many items in a single batch will result in an error (e.g. due to bugs in go-
ethereum, third-party provider limitations, limits inherent to the websocket
channel etc). This setting controls the maximum number of items that can be
requested in a single batch. Chainlink nodes use built-in conservative
defaults for different chains that should work out of the box.

If you have enabled HTTP URLs for all of your ETH nodes, you can safely
increase this to a larger value e.g. 100 and see significant RPC performance
improvements.

### LINK_CONTRACT_ADDRESS

  * Default: _automatic based on Chain ID_

The address of the LINK token contract. It is not essential to provide this,
but if given, it is used for displaying the node account's LINK balance. For
supported chains, this is automatically set based on the given chain ID. For
unsupported chains, you must supply it yourself.

This environment variable is a global override. It is recommended instead to
set this on a per-chain basis.

### MIN_INCOMING_CONFIRMATIONS

  * Default: _automatic based on chain ID, typically 3_

The number of block confirmations to wait before kicking off a job run or
proceeding with a task that listens to blockchain and log events. Setting this
to a lower value improves node response time at the expense of occasionally
submitting duplicate transactions in the event of chain re-orgs (duplicate
transactions are harmless but cost some ETH).

You can override this on a per-job basis.

`MIN_INCOMING_CONFIRMATIONS=1` would kick off a job after seeing the
transaction in just one block.

caution

The lowest value allowed here is 1, since setting to 0 would imply that logs
are processed from the mempool before they are even mined into a block, which
isn't possible with Chainlink's current architecture.

### MIN_OUTGOING_CONFIRMATIONS

  * Default: _automatic based on chain ID, typically 12_

The default minimum number of block confirmations that need to be recorded on
an outgoing `ethtx` task before the run can move onto the next task.

This can be overridden on a per-task basis by setting the
`MinRequiredOutgoingConfirmations` parameter.

`MIN_OUTGOING_CONFIRMATIONS=1` considers a transaction as ""done"" once it has
been mined into one block. `MIN_OUTGOING_CONFIRMATIONS=0` would consider a
transaction as ""done"" even before it has been mined.

### MINIMUM_CONTRACT_PAYMENT_LINK_JUELS

note

  * Default: _automatically set based on Chain ID, typically 10000000000000 (0.00001 LINK) on all chains except Ethereum Mainnet and Sepolia where it is 100000000000000000 (0.1 LINK)._

For jobs that use the `EthTx` adapter, this is the minimum payment amount in
order for the node to accept and process the job. Since there are no decimals
on the EVM, the value is represented like wei.

note

Keep in mind, the Chainlink node currently responds with a 500,000 gas limit.
Under pricing your node could mean it spends more in ETH (on gas) than it
earns in LINK.

### NODE_NO_NEW_HEADS_THRESHOLD

  * Default: _automatically set based on Chain ID, typically ""3m"" (3 minutes)_

Controls how long to wait after receiving no new heads before marking the node
as out-of-sync.

Set to zero to disable out-of-sync checking.

### NODE_POLL_FAILURE_THRESHOLD

  * Default: _automatically set based on Chain ID, typically 3_

Indicates how many consecutive polls must fail in order to mark a node as
unreachable.

Set to zero to disable poll checking.

### NODE_POLL_INTERVAL

  * Default: _automatically set based on Chain ID, typically ""10s"" (10 seconds)_

Controls how often to poll the node to check for liveness.

Set to zero to disable poll checking.

### NODE_SELECTION_MODE

  * Default: `""HighestHead""`

Controls node picking strategy. Supported values:

  * `HighestHead` (default) mode picks a node having the highest reported head number among other alive nodes. When several nodes have the same latest head number, the strategy sticks to the last used node. This mode requires `NODE_NO_NEW_HEADS_THRESHOLD` to be configured, otherwise it will always use the first alive node.
  * `RoundRobin` mode simply iterates among available alive nodes. This was the default behavior prior to this release.
  * `TotalDifficulty` mode selects the node with the greatest total difficulty.

### NODE_SYNC_THRESHOLD

  * Default: `5`

SyncThreshold controls how far a node may lag behind the best node before
being marked out-of-sync. Depending on the [`NODE_SELECTION_MODE`
variable](/chainlink-nodes/v1/configuration/#node_selection_mode), this
represents a difference in either the number of blocks (`HighestHead`,
`RoundRobin`), or the total difficulty (`TotalDifficulty`).

Set to `0` to disable this check.

## EVM Gas Controls

These settings allow you to tune your node's gas limits and pricing. In most
cases, leaving these values at their defaults should give good results.

As of Chainlink node v1.1.0, it is recommended to use the API, CLI, or GUI to
configure gas controls because you might want to use different settings for
different chains. Setting the environment variable typically overrides the
setting for all chains.

### Configuring your ETH node

Your ETH node might need some configuration tweaks to make it fully compatible
with Chainlink nodes depending on your configuration.

#### go-ethereum

WARNING: By default, go-ethereum will reject transactions that exceed it's
built-in RPC gas or txfee caps. Chainlink nodes will fatally error
transactions if this happens which means if you ever exceed the caps your node
will miss transactions.

You should at a bare minimum disable the default RPC gas and txfee caps on
your ETH node. This can be done in the TOML file as seen below, or by running
go-ethereum with the command line arguments: `--rpc.gascap=0
--rpc.txfeecap=0`.

It is also recommended to configure go-ethereum properly before increasing
`ETH_MAX_IN_FLIGHT_TRANSACTIONS` to ensure all in-flight transactions are
maintained in the mempool.

Relevant settings for geth and forks (such as BSC).


    [Eth]
    RPCGasCap = 0 # it is recommended to disable both gas and txfee cap
    RPCTxFeeCap = 0.0
    [Eth.TxPool]
    Locals = [""0xYourNodeAddress1"", ""0xYourNodeAddress2""]  # Add your node addresses here
    NoLocals = false # Disabled by default but might as well make sure
    Journal = ""transactions.rlp"" # Make sure you set a journal file
    Rejournal = 3600000000000 # Default 1h, it might make sense to reduce this to e.g. 5m
    PriceBump = 10 # Must be set less than or equal to Chainlink's ETH_GAS_BUMP_PERCENT
    AccountSlots = 16 # Highly recommended to increase this, must be greater than or equal to Chainlink's ETH_MAX_IN_FLIGHT_TRANSACTIONS setting
    GlobalSlots = 4096 # Increase this as necessary
    AccountQueue = 64 # Increase this as necessary
    GlobalQueue = 1024 # Increase this as necessary
    Lifetime = 10800000000000 # Default 3h, this is probably ok, you might even consider reducing it

### EVM_EIP1559_DYNAMIC_FEES

  * Default: _automatic based on chain ID_

Forces EIP-1559 transaction mode for all chains. Enabling EIP-1559 mode can
help reduce gas costs on chains that support it. This is supported only on
official Ethereum mainnet and testnets. It is not recommended to enable this
setting on Polygon because the EIP-1559 fee market appears to be broken on all
Polygon chains and EIP-1559 transactions are less likely to be included than
legacy transactions.

#### Technical details

Chainlink nodes include experimental support for submitting transactions using
type 0x2 (EIP-1559) envelope.

EIP-1559 mode is enabled by default on the Ethereum Mainnet, but can be
enabled on a per-chain basis or globally.

This might help to save gas on spikes. Chainlink nodes should react faster on
the upleg and avoid overpaying on the downleg. It might also be possible to
set `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` to a smaller value such as 12 or even
6 because tip cap should be a more consistent indicator of inclusion time than
total gas price. This would make Chainlink nodes more responsive and should
reduce response time variance. Some experimentation is required to find
optimum settings.

To enable globally, set `EVM_EIP1559_DYNAMIC_FEES=true`. Set with caution, if
you set this on a chain that does not actually support EIP-1559 your node will
be broken.

In EIP-1559 mode, the total price for the transaction is the minimum of base
fee + tip cap and fee cap. More information can be found on the [official
EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).

Chainlink's implementation of EIP-1559 works as follows:

If you are using FixedPriceEstimator:

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and `tipcap=EVM_GAS_TIP_CAP_DEFAULT`
  * With gas bumping enabled, it will submit all transactions initially with `feecap=EVM_GAS_FEE_CAP_DEFAULT` and `tipcap=EVM_GAS_TIP_CAP_DEFAULT`.

If you are using BlockHistoryEstimator (default for most chains):

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and `tipcap=<calculated using past blocks>`
  * With gas bumping enabled (default for most chains) it will submit all transactions initially with `feecap=current block base fee * (1.125 ^ N)` where N is configurable by setting BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS but defaults to `gas bump threshold+1` and `tipcap=<calculated using past blocks>`

Bumping works as follows:

  * Increase tipcap by `max(tipcap * (1 + ETH_GAS_BUMP_PERCENT), tipcap + ETH_GAS_BUMP_WEI)`
  * Increase feecap by `max(feecap * (1 + ETH_GAS_BUMP_PERCENT), feecap + ETH_GAS_BUMP_WEI)`

A quick note on terminology - Chainlink nodes use the same terms used
internally by go-ethereum source code to describe various prices. This is not
the same as the externally used terms. For reference:

  * Base Fee Per Gas = BaseFeePerGas
  * Max Fee Per Gas = FeeCap
  * Max Priority Fee Per Gas = TipCap

In EIP-1559 mode, the following changes occur to how configuration works:

  * All new transactions will be sent as type 0x2 transactions specifying a TipCap and FeeCap. Be aware that existing pending legacy transactions will continue to be gas bumped in legacy mode.
  * `BlockHistoryEstimator` will apply its calculations (gas percentile etc) to the TipCap and this value will be used for new transactions (GasPrice will be ignored)
  * `FixedPriceEstimator` will use `EVM_GAS_TIP_CAP_DEFAULT` instead of `ETH_GAS_PRICE_DEFAULT` for the tip cap
  * `FixedPriceEstimator` will use `EVM_GAS_FEE_CAP_DEFAULT` instaed of `ETH_GAS_PRICE_DEFAULT` for the fee cap
  * `ETH_MIN_GAS_PRICE_WEI` is ignored for new transactions and `EVM_GAS_TIP_CAP_MINIMUM` is used instead (default 0)
  * `ETH_MAX_GAS_PRICE_WEI` still represents that absolute upper limit that Chainlink will ever spend (total) on a single tx
  * `KEEPER_GAS_PRICE_BUFFER_PERCENT` is ignored in EIP-1559 mode and `KEEPER_TIP_CAP_BUFFER_PERCENT` is used instead

### ETH_GAS_BUMP_PERCENT

  * Default: _automatic based on chain ID_

The percentage by which to bump gas on a transaction that has exceeded
`ETH_GAS_BUMP_THRESHOLD`. The larger of `ETH_GAS_BUMP_PERCENT` and
`ETH_GAS_BUMP_WEI` is taken for gas bumps.

### ETH_GAS_BUMP_THRESHOLD

  * Default: _automatic based on chain ID_

Chainlink nodes can be configured to automatically bump gas on transactions
that have been stuck waiting in the mempool for at least this many blocks. Set
to 0 to disable gas bumping completely.

### ETH_GAS_BUMP_TX_DEPTH

  * Default: `""10""`

The number of transactions to gas bump starting from oldest. Set to 0 for no
limit (i.e. bump all).

### ETH_GAS_BUMP_WEI

  * Default: _automatic based on chain ID_

The minimum fixed amount of wei by which gas is bumped on each transaction
attempt.

### EVM_GAS_FEE_CAP_DEFAULT

  * Default: _automatic based on chain ID_

If EIP1559 mode is enabled, and FixedPrice gas estimator is used, this env var
controls the fixed initial fee cap.

### ETH_GAS_LIMIT_DEFAULT

  * Default: _automatically set based on Chain ID, typically 500000_

The default gas limit for outgoing transactions. This should not need to be
changed in most cases. Some job types, such as Keeper jobs, might set their
own gas limit unrelated to this value.

### ETH_GAS_LIMIT_MAX

  * Default: _automatically set based on Chain ID, typically 500000_

The maxium for gas limits estimated by the `Arbitrum` `GAS_ESTIMATOR_MODE`.
This should not need to be changed in most cases.

### ETH_GAS_LIMIT_MULTIPLIER

  * Default: `""1.0""`

A factor by which a transaction's GasLimit is multiplied before transmission.
So if the value is 1.1, and the GasLimit for a transaction is 10, 10% will be
added before transmission.

This factor is always applied, so includes Optimism L2 transactions which uses
a default gas limit of 1 and is also applied to EthGasLimitDefault.

### ETH_GAS_LIMIT_TRANSFER

  * Default: _automatically set based on Chain ID, typically 21000_

The gas limit used for an ordinary ETH transfer.

### ETH_GAS_PRICE_DEFAULT

(Only applies to legacy transactions)

  * Default: _automatic based on chain ID_

The default gas price to use when submitting transactions to the blockchain.
Will be overridden by the built-in `BlockHistoryEstimator` if enabled, and
might be increased if gas bumping is enabled.

Can be used with the `chainlink setgasprice` to be updated while the node is
still running.

### EVM_GAS_TIP_CAP_DEFAULT

(Only applies to EIP-1559 transactions)

  * Default: _automatic based on chain ID_

The default gas tip to use when submitting transactions to the blockchain.
Will be overridden by the built-in `BlockHistoryEstimator` if enabled, and
might be increased if gas bumping is enabled.

### EVM_GAS_TIP_CAP_MINIMUM

(Only applies to EIP-1559 transactions)

  * Default: _automatic based on chain ID_

The minimum gas tip to use when submitting transactions to the blockchain.

### ETH_MAX_GAS_PRICE_WEI

  * Default: _automatic based on chain ID_

Chainlink nodes will never pay more than this for a transaction.

### ETH_MAX_IN_FLIGHT_TRANSACTIONS

  * Default: `""16""`

Controls how many transactions are allowed to be ""in-flight"" i.e. broadcast
but unconfirmed at any one time. You can consider this a form of transaction
throttling.

The default is set conservatively at 16 because this is a pessimistic minimum
that geth will hold without evicting local transactions. If your node is
falling behind and you need higher throughput, you can increase this setting,
but you MUST make sure that your ETH node is configured properly otherwise you
can get nonce gapped and your node will get stuck.

0 value disables the limit. Use with caution.

### ETH_MAX_QUEUED_TRANSACTIONS

  * Default: _automatically set based on Chain ID, typically 250_

The maximum number of unbroadcast transactions per key that are allowed to be
enqueued before jobs will start failing and rejecting send of any further
transactions. This represents a sanity limit and generally indicates a problem
with your ETH node (transactions are not getting mined).

Do NOT blindly increase this value thinking it will fix things if you start
hitting this limit because transactions are not getting mined, you will
instead only make things worse.

In deployments with very high burst rates, or on chains with large re-orgs,
you _may_ consider increasing this.

0 value disables any limit on queue size. Use with caution.

### ETH_MIN_GAS_PRICE_WEI

(Only applies to legacy transactions)

  * Default: _automatic based on chain ID_

Chainlink nodes will never pay less than this for a transaction.

It is possible to force the Chainlink node to use a fixed gas price by setting
a combination of these, e.g.


    EVM_EIP1559_DYNAMIC_FEES=false
    ETH_MAX_GAS_PRICE_WEI=100
    ETH_MIN_GAS_PRICE_WEI=100
    ETH_GAS_PRICE_DEFAULT=100
    ETH_GAS_BUMP_THRESHOLD=0
    GAS_ESTIMATOR_MODE=""FixedPrice""

### ETH_GAS_LIMIT_OCR_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for OCR jobs. This environment variable does
not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_GAS_LIMIT_DR_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for direct request jobs. This environment
variable does not override task-specific or job-specific `gasLimit` parameters
or attributes.

### ETH_GAS_LIMIT_VRF_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for VRF jobs. This environment variable does
not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_GAS_LIMIT_FM_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for Flux Monitor jobs. This environment
variable does not override task-specific or job-specific `gasLimit` parameters
or attributes.

### ETH_GAS_LIMIT_KEEPER_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for Keeper jobs. This environment variable
does not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_NONCE_AUTO_SYNC

  * Default: `""false""`

Chainlink nodes will automatically try to sync its local nonce with the remote
chain on startup and fast forward if necessary. This is almost always safe but
can be disabled in exceptional cases by setting this value to false.

### ETH_USE_FORWARDERS

  * Default: `""false""`

Enables or disables sending transactions through forwarder contracts.

## EVM/Ethereum Gas Price Estimation

These settings allow you to configure how your node calculates gas prices. In
most cases, leaving these values at their defaults should give good results.

As of Chainlink node v1.1.0, it is recommended to use the API, CLI, or GUI to
configure gas controls because you might want to use different settings for
different chains. Setting the environment variable typically overrides the
setting for all chains.

Chainlink nodes decide what gas price to use using an `Estimator`. It ships
with several simple and battle-hardened built-in estimators that should work
well for almost all use-cases. Note that estimators will change their
behaviour slightly depending on if you are in EIP-1559 mode or not.

You can also use your own estimator for gas price by selecting the
`FixedPrice` estimator and using the exposed API to set the price.

An important point to note is that the Chainlink node does _not_ ship with
built-in support for go-ethereum's `estimateGas` call. This is for several
reasons, including security and reliability. We have found empirically that it
is not generally safe to rely on the remote ETH node's idea of what gas price
should be.

### GAS_ESTIMATOR_MODE

  * Default: _automatic, based on chain ID_

Controls what type of gas estimator is used.

  * `FixedPrice` uses static configured values for gas price (can be set via API call).
  * `BlockHistory` dynamically adjusts default gas price based on heuristics from mined blocks.
  * `Optimism2`/`L2Suggested` is a special mode only for use with Optimism and Metis blockchains. This mode will use the gas price suggested by the rpc endpoint via `eth_gasPrice`.
  * `Arbitrum` is a special mode only for use with Arbitrum blockchains. It uses the suggested gas price (up to `ETH_MAX_GAS_PRICE_WEI`, with `1000 gwei` default) as well as an estimated gas limit (up to `ETH_GAS_LIMIT_MAX`, with `1,000,000,000` default).

### BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE

  * Default: _automatic, based on chain ID, typically 4_

Sets the maximum number of blocks to fetch in one batch in the block history
estimator. If the `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` environment variable is
set to 0, it defaults to ETH_RPC_DEFAULT_BATCH_SIZE.

### BLOCK_HISTORY_ESTIMATOR_BLOCK_HISTORY_SIZE

  * Default: _automatic, based on chain ID_

Controls the number of past blocks to keep in memory to use as a basis for
calculating a percentile gas price.

### BLOCK_HISTORY_ESTIMATOR_BLOCK_DELAY

  * Default: _automatic, based on chain ID_

Controls the number of blocks that the block history estimator trails behind
head. For example, if this is set to 3, and we receive block 10, block history
estimator will fetch block 7.

CAUTION: You might be tempted to set this to 0 to use the latest possible
block, but it is possible to receive a head BEFORE that block is actually
available from the connected node via RPC, due to race conditions in the code
of the remote ETH node. In this case you will get false ""zero"" blocks that are
missing transactions.

### BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS

**ADVANCED**

  * Default: _gas bump threshold + 1 block_

If EIP1559 mode is enabled, this optional env var controls the buffer blocks
to add to the current base fee when sending a transaction. By default, the gas
bumping threshold + 1 block is used. It is not recommended to change this
unless you know what you are doing.

### BLOCK_HISTORY_ESTIMATOR_TRANSACTION_PERCENTILE

  * Default: `""60""`

Must be in range 0-100.

Only has an effect if gas updater is enabled. Specifies percentile gas price
to choose. E.g. if the block history contains four transactions with gas
prices `[100, 200, 300, 400]` then picking 25 for this number will give a
value of 200. If the calculated gas price is higher than
`ETH_GAS_PRICE_DEFAULT` then the higher price will be used as the base price
for new transactions.

Think of this number as an indicator of how aggressive you want your node to
price its transactions.

Setting this number higher will cause the Chainlink node to select higher gas
prices.

Setting it lower will tend to set lower gas prices.

## EVM/Ethereum Transaction Simulation

Chainlink nodes support transaction simulation for certain types of job. When
this is enabled, transactions will be simulated using `eth_call` before
initial send. If the transaction would revert, the transaction is marked as an
error without being broadcast, potentially avoiding an expensive on-chain
revert.

This can add a tiny bit of latency with an upper bound of 2s, but generally
much shorter under good conditions. This will add marginally more load to the
ETH client, because it adds an extra call for every transaction sent. However,
it might help to save gas in some cases especially during periods of high
demand by avoiding unnecessary reverts due to outdated round etc.

This option is EXPERIMENTAL and disabled by default.

To enable for FM or OCR:

`FM_SIMULATE_TRANSACTIONs=true` `OCR_SIMULATE_TRANSACTIONS=true`

To enable in the pipeline, use the `simulate=true` option like so:


    submit [type=ethtx to=""0xDeadDeadDeadDeadDeadDeadDeadDead"" data=""0xDead"" simulate=true]

Use at your own risk.

#### FM_SIMULATE_TRANSACTIONS

NOTE: This overrides the setting for _all_ chains, it is not currently
possible to configure this on a per-chain basis.

  * Default: `""false""`

`FM_SIMULATE_TRANSACTIONS` allows to enable transaction simulation for Flux
Monitor.

#### OCR_SIMULATE_TRANSACTIONS

NOTE: This overrides the setting for _all_ chains, it is not currently
possible to configure this on a per-chain basis.

  * Default: `""false""`

`OCR_SIMULATE_TRANSACTIONS` allows to enable transaction simulation for OCR.

## Job Pipeline and tasks

### DEFAULT_HTTP_LIMIT

  * Default: `""32768""`

`DEFAULT_HTTP_LIMIT` defines the maximum number of bytes for HTTP requests and
responses made by `http` and `bridge` adapters.

### DEFAULT_HTTP_TIMEOUT

  * Default: `""15s""`

`DEFAULT_HTTP_TIMEOUT` defines the default timeout for HTTP requests made by
`http` and `bridge` adapters.

### FEATURE_EXTERNAL_INITIATORS

  * Default: `""false""`

Enables the External Initiator feature. If disabled, `webhook` jobs can ONLY
be initiated by a logged-in user. If enabled, `webhook` jobs can be initiated
by a whitelisted external initiator.

### JOB_PIPELINE_MAX_RUN_DURATION

  * Default: `""10m""`

`JOB_PIPELINE_MAX_RUN_DURATION` is the maximum time that a single job run
might take. If it takes longer, it will exit early and be marked errored. If
set to zero, disables the time limit completely.

### JOB_PIPELINE_MAX_SUCCESSFUL_RUNS

This option is not supported as an environment variable. Use
`JobPipeline.MaxSuccessfulRuns` in the config file instead. See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.12.0/docs/CONFIG.md)
reference for details.

### JOB_PIPELINE_REAPER_INTERVAL

  * Default: `""1h""`

In order to keep database size manageable, Chainlink nodes will run a reaper
that deletes completed job runs older than a certain threshold age.
`JOB_PIPELINE_REAPER_INTERVAL` controls how often the job pipeline reaper will
run.

Set to `0` to disable the periodic reaper.

### JOB_PIPELINE_REAPER_THRESHOLD

  * Default: `""24h""`

`JOB_PIPELINE_REAPER_THRESHOLD` determines the age limit for job runs.
Completed job runs older than this will be automatically purged from the
database.

### JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH

  * Default: `""100""`

Some jobs write their results asynchronously for performance reasons such as
OCR. `JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH` controls how many writes will be
buffered before subsequent writes are dropped.

Do not change this setting unless you know what you are doing.

## OCR

This section applies only if you are running off-chain reporting jobs.

### FEATURE_OFFCHAIN_REPORTING

  * Default: `""false""`

Set to `true` to enable OCR jobs.

### OCR_KEY_BUNDLE_ID

  * Default: _none_

`OCR_KEY_BUNDLE_ID` is the default key bundle ID to use for OCR jobs. If you
have an OCR job that does not explicitly specify a key bundle ID, it will fall
back to this value.

### OCR_MONITORING_ENDPOINT

  * Default: _none_

Optional URL of OCR monitoring endpoint.

### OCR_TRANSMITTER_ADDRESS

  * Default: _none_

`OCR_TRANSMITTER_ADDRESS` is the default sending address to use for OCR. If
you have an OCR job that does not explicitly specify a transmitter address, it
will fall back to this value.

### P2P_NETWORKING_STACK

  * Default: `""V1""`

OCR supports multiple networking stacks. `P2P_NETWORKING_STACK` chooses which
stack to use. Possible values are:

  * `V1`
  * `V1V2` \- Runs both stacks simultaneously. For each link with another peer, V2 networking will be preferred. If V2 does not work, the link will automatically fall back to V1. If V2 starts working again later, it will automatically be prefered again. This is useful for migrating networks without downtime. Note that the two networking stacks _must not_ be configured to bind to the same IP/port.
  * `V2`

All nodes in the OCR network should share the same networking stack. The `V1`
stack is deprecated and is being phased out. Do not use it for new
deployments. Expect the default value of this variable to change to `V2` in
the future.

#### P2P_PEER_ID

  * Default: _none_

This environment variable is used for both Networking Stack V1 and V2.

The default peer ID to use for OCR jobs. If unspecified, uses the first
available peer ID. Example:
`P2P_PEER_ID=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U`

### Networking Stack V1

caution

Do not set environment variables for Networking Stack v1 if you are using
Networking Stack V2.

#### P2P_ANNOUNCE_IP

  * Default: _none_

Should be set as the externally reachable IP address of the Chainlink node.
Example: `P2P_ANNOUNCE_IP=1.2.3.4`

#### P2P_ANNOUNCE_PORT

  * Default: _none_

Should be set as the externally reachable port of the Chainlink node. Example:
`P2P_ANNOUNCE_PORT=1337`

#### P2P_BOOTSTRAP_PEERS

  * Default: _none_

Default set of bootstrap peers. Example:
`P2P_BOOTSTRAP_PEERS=/dns4/example.com/tcp/1337/p2p/12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U
/ip4/1.2.3.4/tcp/9999/p2p/12D3KooWLZ9uTC3MrvKfDpGju6RAQubiMDL7CuJcAgDRTYP7fh7R`

#### P2P_LISTEN_IP

  * Default: `""0.0.0.0""`

The default IP address to bind to.

#### P2P_LISTEN_PORT

  * Default: _none_

The port to listen on. If left blank, the node randomly selects a different
port each time it boots. It is highly recommended to set this to a static
value to avoid network instability.

#### P2P_PEER_ID

  * Default: _none_

This environment variable is used for both Networking Stack V1 and V2.

The default peer ID to use for OCR jobs. If unspecified, uses the first
available peer ID. Example:
`P2P_PEER_ID=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U`

### Networking Stack V2

caution

If using the Networking Stack V2, you must unset the following Networking
Stack V1 configuration variables:

  * P2P_ANNOUNCE_IP
  * P2P_ANNOUNCE_PORT
  * P2P_BOOTSTRAP_PEERS
  * P2P_LISTEN_IP
  * P2P_LISTEN_PORT

`P2P_PEER_ID` is used for both Networking Stack V1 and V2.

The Networking Stack V2 uses TCP, any ports mentioned in this section refer to
TCP ports.

#### P2PV2_ANNOUNCE_ADDRESSES

  * Default: _none_

`P2PV2_ANNOUNCE_ADDRESSES` contains the addresses the node will advertise for
peer discovery in host:port form as accepted by the TCP version of Go's
[`net.Dial`](https://pkg.go.dev/net#Dial). The addresses should be reachable
by other nodes on the network. When attempting to connect to another node, a
node will attempt to dial all of the other node's `P2PV2_ANNOUNCE_ADDRESSES`
in round-robin fashion. Example: `P2PV2_ANNOUNCE_ADDRESSES=1.2.3.4:9999
[a52d:0:a88:1274::abcd]:1337`

#### P2PV2_BOOTSTRAPPERS

  * Default: _none_

`P2PV2_BOOTSTRAPPERS` returns the default bootstrapper peers for libocr's v2
networking stack. Example:
`P2PV2_BOOTSTRAPPERS=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U@1.2.3.4:9999
12D3KooWLZ9uTC3MrvKfDpGju6RAQubiMDL7CuJcAgDRTYP7fh7R@[a52d:0:a88:1274::abcd]:1337
12D3KooWM55u5Swtpw9r8aFLQHEtw7HR4t44GdNs654ej5gRs2Dh@example.com:1234`

Oracle nodes typically only know each other's PeerIDs, but not their
hostnames, IP addresses, or ports. Bootstrappers are special nodes that help
other nodes discover each other's `P2PV2_ANNOUNCE_ADDRESSES` so they can
communicate. Nodes continuously attempt to connect to bootstrappers configured
in `P2PV2_BOOTSTRAPPERS`. When a node wants to connect to another node (which
it knows only by PeerID, but not by address), it discovers the other node's
`P2PV2_ANNOUNCE_ADDRESSES` from communications received from its
`P2PV2_BOOTSTRAPPERS` or other discovered nodes. To facilitate discovery,
nodes will regularly broadcast signed announcements containing their PeerID
and `P2PV2_ANNOUNCE_ADDRESSES`.

#### P2PV2_LISTEN_ADDRESSES

  * Default: _none_

`P2PV2_LISTEN_ADDRESSES` contains the addresses the peer will listen to on the
network in `host:port` form as accepted by `net.Listen()`, but the host and
port must be fully specified and cannot be empty. You can specify `0.0.0.0`
(IPv4) or `::` (IPv6) to listen on all interfaces, but that is not
recommended.

Example: `P2PV2_LISTEN_ADDRESSES=1.2.3.4:9999 [a52d:0:a88:1274::abcd]:1337`

## Keeper

These environment variables are used specificly for Chainlink Keepers. For
most Chainlink Nodes, leave these values at their defaults and do not
configure these environment variables.

### KEEPER_GAS_PRICE_BUFFER_PERCENT

caution

  * Default: `""20""`

`KEEPER_GAS_PRICE_BUFFER_PERCENT` adds the specified percentage to the gas
price used for checking whether to perform an upkeep. Only applies in legacy
mode (EIP-1559 off).

### KEEPER_GAS_TIP_CAP_BUFFER_PERCENT

caution

  * Default: `""20""`

`KEEPER_GAS_TIP_CAP_BUFFER_PERCENT` adds the specified percentage to the gas
price used for checking whether to perform an upkeep. Only applies in EIP-1559
mode.

### KEEPER_BASE_FEE_BUFFER_PERCENT

caution

  * Default: `""20""`

Adds the specified percentage to the base fee used for checking whether to
perform an upkeep. Applies only in EIP-1559 mode.

### KEEPER_MAXIMUM_GRACE_PERIOD

caution

  * Default: `""100""`

The maximum number of blocks that a keeper will wait after performing an
upkeep before it resumes checking that upkeep

### KEEPER_REGISTRY_CHECK_GAS_OVERHEAD

caution

  * Default: `""200000""`

The amount of extra gas to provide checkUpkeep() calls to account for the gas
consumed by the keeper registry.

### KEEPER_REGISTRY_PERFORM_GAS_OVERHEAD

caution

  * Default: `""300000""`

The amount of extra gas to provide performUpkeep() calls to account for the
gas consumed by the keeper registry

### KEEPER_REGISTRY_SYNC_INTERVAL

caution

  * Default: `""30m""`

The interval in which the RegistrySynchronizer performs a full sync of the
keeper registry contract it is tracking.

### KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE

caution

  * Default: `""10""`

`KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE` represents the maximum number of
upkeeps that can be synced in parallel.

### KEEPER_TURN_LOOK_BACK

caution

  * Default: `""1000""`

The number of blocks in the past to look back when getting a block for a turn.

## CLI Client

The environment variables in this section apply only when running CLI commands
that connect to a remote running instance of a Chainlink node.

### ADMIN_CREDENTIALS_FILE

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--admin-credentials-file FILE` CLI argument instead.

  * Default: `$ROOT/apicredentials`

`ADMIN_CREDENTIALS_FILE` optionally points to a text file containing admin
credentials for logging in. It is useful for running client CLI commands and
has no effect when passed to a running node.

The file should contain two lines, the first line is the username and second
line is the password. e.g.


    myusername@example.com
    mysecurepassw0rd

### CLIENT_NODE_URL

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--remote-node-url URL` CLI argument instead.

  * Default: `""http://localhost:6688""`

This is the URL that you will use to interact with the node, including the
GUI. Use this URL to connect to the GUI or to run commands remotely using the
Chainlink CLI.

### INSECURE_SKIP_VERIFY

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--insecure-skip-verify` CLI argument instead.

  * Default: `""false""`

`INSECURE_SKIP_VERIFY` disables SSL certificate verification when connection
to a Chainlink node using the remote client. For example, when executing most
remote commands in the CLI. This is mostly useful for people who want to use
TLS on localhost.

It is not recommended to change this unless you know what you are doing.

## Notes on setting environment variables

note

Some environment variables require a duration. A duration string is a possibly
signed sequence of decimal numbers, each with optional fraction and a unit
suffix, such as ""300ms"", ""-1.5h"" or ""2h45m"". Valid time units are ""ns"", ""us""
(or ""µs""), ""ms"", ""s"", ""m"", ""h"". Some examples:

`10ms` `1h15m` `42m30s`

note

Some configuration variables require a file size. A file size string is an
unsigned integer (123) or a float (12.3) followed by a unit suffix. Valid file
size units are ""b"", ""kb"", ""mb"", ""gb"", and ""tb"". If the unit is omitted, it is
assumed to be ""b"" (bytes). Capitalization does not matter. Some examples:

`123gb` `1.2TB` `12345`

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/configuration.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside off-chain.
  * **LP Token Feeds:** These feeds use a decentralized feed for the underlying asset as well as calculations to value the LP tokens.
  * **Wrapped Calculated Feeds:** These feeds are typically pegged 1:1 to the underlying token or asset. Under normal market conditions, these feeds track their underlying value accurately. However, the price is a derivative formed from a calculated method and might not always track value precisely.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⭕ Deprecating

These feeds are being deprecated. To find the deprecation dates for specific
feeds, see the [Feeds Scheduled For Deprecation](/data-feeds/deprecating-feeds) page.

## Risk Mitigation

As a development best practice, design your systems and smart contracts to be
resilient and mitigate risk to your protocol and your users. Ensure that your
systems can tolerate known and unknown exceptions that might occur. Some
examples include but are not limited to volatile market conditions, the
degraded performance of infrastructure, chains, or networks, and any other
upstream outage related to data providers or node operators. You bear
responsibility for any manner in which you use the Chainlink Network, its
software, and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel: <https://discord.gg/Dqy5N9UbsR>

## Chainlink Community Deployments

Chainlink technology is used by many within the blockchain community to
support their use cases. Deployments built and run by community members are
not tracked in the Chainlink documentation. Chainlink's community is
continuously growing, and we believe they play a vital role in developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Fast Gas Reliability

### Liquidity and its Distribution

If your smart contract relies on pricing data for a specific asset, make sure
that the asset has sufficient liquidity in the market to avoid price
manipulation. Assets with low liquidity can be volatile, which might
negatively impact your application and its users. Malicious actors might try
to exploit volatility to take advantage of the logic in a smart contract and
cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather
than from aggregated price tracking services that gather their data from
multiple exchanges. These are marked as such in the docs page for that feed.
Assess the liquidity and reliability of that specific exchange.

_Liquidity migrations_ occur when a project moves its tokens from one
liquidity provider (such as a DEX, a CEX, or a new DeFi application) to
another. When liquidity migrations occur, it can result in low liquidity in
the original pool, making the asset susceptible to market manipulation. If
your project is considering a liquidity migration, you should coordinate with
relevant stakeholders, including liquidity providers, exchanges, oracle node
operators, and users, to ensure prices are accurately reported throughout the
migration.

Feeds for assets with low market liquidity where data providers exhibit an
abnormal price spread may, on occasion, see a price oscillate between two or
more price points within regular intervals. To mitigate risk associated with
such price oscillation, users must regularly monitor & assess the quality of
an asset’s liquidity. Similarly, assets with low market liquidity may
experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk
management measures to protect your assets. For example, create mock tests
that return various oracle responses.

### Single Source Data Providers

Some data providers use a single data source, which might be necessary if only
one source exists off-chain for a specific type of data. Evaluate data
providers to make sure they provide high-quality data that your smart
contracts can rely on. Any error or omission in the provider's data might
negatively impact your application and its users.

### Crypto and Blockchain Actions

Price data quality is subject to crypto actions by the crypto and blockchain
project teams. Crypto actions are similar to [corporate
actions](https://en.wikipedia.org/wiki/Corporate_action) but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on. Periods of
high network congestion might impact the frequency of Chainlink Price Feeds.
It is advised that you configure your applications to detect such chain
performance issues and to respond appropriately.

### Unknown and Known Users

Routine maintenance is carried out on Chainlink Data Feeds, including
decommissioning, on an ad-hoc basis. These maintenance periods might require
users to take action in order to maintain business continuity.

Notifications are sent to inform known users regarding such occurrences, and
it is strongly encouraged for all users, including those users utilizing data
feeds for off-chain purposes, [to provide their contact
information](https://chain.link/contact?ref_id=DataFeed) before utilizing data
feeds. Without providing contact information, users will be unable to receive
notifications regarding important price feed updates.

If you are using Price Feeds but have not provided your contact information,
you can do so [here](https://chain.link/contact?ref_id=DataFeed). Users that
fail to provide notification information do so at their own risk.

## Evaluating Wrapped or Bridged Assets

### Assessing how to Price Wrapped or Bridged Assets

When assessing a Chainlink Price Feed for a wrapped or bridged asset such as
WBTC, users should evaluate the tradeoffs between using a price feed
specifically built for the wrapped or bridged asset or a price feed built for
the underlying asset.

Decisions should be made on a case-by-case basis considering the liquidity,
depth, and trading volatility of the underlying asset compared to its
derivative. In addition, users must consider the security mechanism that is
designed to keep the wrapped or bridged asset coupled to its underlying asset.
Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets

Chainlink Price Feeds are designed to provide the market-wide price of various
assets, as determined by a volume-weighted average across a wide range of
exchanges. On blockchain networks where assets are wrapped and/or bridged from
another environment using a cross-chain token bridge, Chainlink Price Feeds
built for the underlying asset will continue to report the market-wide price
of the underlying asset as opposed to the price of the wrapped/bridged asset.
This methodology reduces risks around market manipulation because
wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price
deviations between the wrapped/bridged asset and its underlying counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible for reviewing the quality of the data that you integrate into your
smart contracts.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/selecting-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-03-09 20:02:05)
What is a gas lane in chainlink and blockchain?
URL: https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain

Question Body:


I do understand the concept of gas in the ethereum blockchain and why gas is
needed to compensate miners for providing computing power to the network.
However, when I was reading up on the chainlink vrf get a random number
documentation it says that the keyhash tells you the gas lane to use. It would
be really helpful if someone could further explain what a gas lane in
blockchain is.

Any help would be appreciated :)



Answers:
(Answered on: 2022-03-10 06:17:54)


So we know that Eth gas is always subject to change and with chainlink vrf
there will be random values with your request, so you need to set a limit to
how much to spend on each request. The reason chainlink uses a Gas lane is
because the lanes are important for setting the ceiling limit of each
request... think of it as your entry into the bet.





:::NEXT DOC:::

Question: (Asked on: 2022-02-25 09:48:01)
Gas estimation error with Chainlink and Remix
URL: https://stackoverflow.com/questions/71263950/gas-estimation-error-with-chainlink-and-remix

Question Body:


I am working on a project that will need to use ChainLink to make external API
calls from the Ethereum blockchain. I was testing out the [demo
code](https://docs.chain.link/docs/make-a-http-get-request/) like so:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
     */
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public volume;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Kovan
         * Oracle: 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 (Chainlink Devrel   
         * Node)
         * Job ID: d5270d1c311941d0b08bead21fea7747
         * Fee: 0.1 LINK
         */
        constructor() {
            setPublicChainlinkToken();
            oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
            jobId = ""d5270d1c311941d0b08bead21fea7747"";
            fee = 0.1 * 10 ** 18; // (Varies by network and job)
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"": xxx.xxx,
            //     }
            //    }
            //   }
            //  }
            request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
            int timesAmount = 10**18;
            request.addInt(""times"", timesAmount);
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId)
        {
            volume = _volume;
        }
    
    
    

However, I am consistently running into a `Gas estimation error` after
deploying and trying to call `requestVolumeData`.

What am I doing wrong?

[Video](https://drive.google.com/file/d/1mCaq8RCxlZPN-
XJcO9kKzghWAiL-j2gW/view?usp=sharing)



Answers:
(Answered on: 2022-02-25 17:05:58)


`Gas estimation error` is a common error meaning that you don't have enough of
""something"" to send your transaction, maybe it's layer 1 (ETH) gas, or an
ERC20 token like LINK (technically, erc677, but I digress...)

Whenever you work with a Chainlink feature that uses the [request and
receive](https://docs.chain.link/docs/architecture-request-model/) method of
using chainlink, you need to [fund the consumer contract with LINK
token](https://docs.chain.link/docs/make-a-http-get-request/).

The issue here is you sent LINK to the oracle address and not the address of
your deployed contract.

[](https://i.stack.imgur.com/1ga4n.png)

If you copy the address of your deployed contract and send the LINK there, it
should work for you.



"
What could be causing the 'File not exist Solc' error when trying to import a data feed into a contract?,One possible cause of the 'File not exist Solc' error is if the yaml file is located in the tests folder instead of the top level directory. Moving the file to the top level directory may resolve the issue.,{'source': 'https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract'},"The 'File not exist Solc' error when trying to import a data feed into a contract could be caused by the file being outside of the allowed directories or the file path being incorrect. It is recommended to check the file path and ensure that it is within the allowed directories. Additionally, updating the solc and chainlink contracts versions, as well as moving the configuration file to the top-level directory, may help resolve the issue.
","
- https://stackoverflow.com/questions/75029401/parsererror-source-chainlink-contracts-src-v0-8-interfaces-aggregatorv3interf
- https://stackoverflow.com/questions/72560937/lesson-7-compiler-version-error-1043-16-full-blockchain-solidity-course
- https://stackoverflow.com/questions/72061609/invalid-blockhash-error-while-deploying-smart-contract
- https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract","Question: (Asked on: 2023-01-06 09:55:44)
ParserError: Source &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot; not found: File outside of allowed directories
URL: https://stackoverflow.com/questions/75029401/parsererror-source-chainlink-contracts-src-v0-8-interfaces-aggregatorv3interf

Question Body:


I'm trying to compile a ""FundMe.sol"" contract: the issue is that when I try to
compile it I keep getting the following Compiler Error:

    
    
    Brownie v1.19.2 - Python development framework for Ethereum
    
    New compatible solc version available: 0.8.0
    Compiling contracts...
      Solc version: 0.8.0
      Optimizer: Enabled  Runs: 200
      EVM Version: Istanbul
    CompilerError: solc returned the following errors:
    
    ParserError: Source ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
      --> contracts/FundMe.sol:15:1:
       |
    15 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    

The contract is included inside of the ""contracts"" folder (initted by
brownie), moreover I have created the ""brownie-config.yaml"" file which should
remap @chainlink - I feel as it might have contain some kind of error aswell.

I'm including all the mentioned files down below:

**Project Folder** : [brownie_fund_me](https://i.stack.imgur.com/HEeeo.png)

**FundMe.sol** :

    
    
    //SPDX-License-Identifier: MIT
    //Last update: 25/12/2022
    
    /* ***** ABI = Application Binary Interface *****
     * Interfaces compile down to an ABI. 
     *
     * ABI tells Solidity and other coding languages
     * how it can interact with other contracts. 
     *
     * Anytime you want to interact with another
     * deployed contract, you will need that contracts' ABI.
     */
    
    pragma solidity >=0.6.0 <0.9.0;
    
    // ***** Imports *****
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";   //The following library is shown below
    /*
     *
     *      interface AggregatorV3Interface 
     *      {
     *       function decimals() external view returns (uint8);
     *
     *       function description() external view returns (string memory);
     *
     *       function version() external view returns (uint256);    <-------------- Version
     *
     *       function getRoundData(uint80 _roundId) external view returns 
     *       (
     *           uint80 roundId,
     *           int256 answer,          
     *           uint256 startedAt,
     *           uint256 updatedAt,
     *           uint80 answeredInRound
     *       );
     *
     *       function latestRoundData() external view returns 
     *       (
     *           uint80 roundId,
     *           int256 answer,             <---------- Value in USD
     *           uint256 startedAt,
     *           uint256 updatedAt,
     *           uint80 answeredInRound
     *       );
     *      }
     *
     */
    
    // ***** FundMe *****
    // The following contract allows the end users to send a minimum amount
    // of ETH without being able to retrive it.
    // This contract is a good example of crowd funding.
    contract FundMe{
        
        // ***** AddressToAmountFunded *****
        // The following mapping allows the user to access the amount funded
        // by somebody, provided the address.
        mapping (address => uint256) public AddressToAmountFunded;
    
        // Array of addresses where the address of each funder will be stored in a temporary way
        // Every time the owner calls the withdraw function, the array is being reset
        address[] public funders;
    
        // Owners' address: this will be the only address being able to withdraw
        address public owner;
    
        // Constructor is called automatically and istantly when the contract is being deployed
        // Such thing allows the deployer of the contract to be the owner
        constructor() public
        {
            owner = msg.sender;     // msg.sender is who calls a function, in the constructor case, who deploys the contract
        }
    
        // ***** onlyOwner *****
        // The following modifier is used in the declaration of functions, such as withdraw, 
        // in order to allow the function, to be called only by the owner.
        modifier onlyOwner
        {
            require(msg.sender == owner);      // Whoever calls the function (msg.sender) must be the owner
            _;                                 // The ""_;"" means that we call the instruction after we check that the address of the caller is equal to owner
        }
    
        // ***** fund *****
        // The following function allows the users to fund the contract with a minimum amount of money ""minimumUSD""
        // to this date (25/12/2022) 50$ = 0,041ETH = 41000000000000000Wei = (41 * 10^15)Wei - to update the value, check the USD/ETH change and convert to Wei here https://eth-converter.com/
        // If the amount funded is <= minimumUSD the transaction will not go through and will lead to an inversion of the
        // transaction
        // ! ! ! ! ! Please notice that the amount funded cannot be retrived in any way ! ! ! ! !
        function fund() public payable
        {
            uint256 minimumUSD = 41 * 10 ** 15;                                                                                        // Minimum amount transferable
            require(msg.value >= minimumUSD, ""The amount of ETH you sent is less then 50$ - Transaction is being inverted"");           // ""msg.value"" is a keyword that stays for the amount of Wei sent
    
            AddressToAmountFunded[msg.sender] += msg.value;             // Given an address, the mapping will return the amount funded by such account - Note that these values will be reset every time withdraw is called
            funders.push(msg.sender);                                   // The funders' address will be added to the funders array - Note that these values will be reset every time withdraw is called
        }
    
        // ***** getVersion *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current version of the contract/library AggregatorV3Interface
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getVersion() public view returns(uint256)
        {      
            return AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e).version();     // .version method is contained inside of AggregatorV3Interface, the address can be find here
            //                                                                                                                                                                                 |
            // The function works also if written like this:                                                                                                                                   |
            // AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);  <--- Address                                                              |
            // return priceFeed.version();                                                                           <--- ABI                                                                 /
            // You can find the Addresses for AggregatorV3Interface here ---> https://docs.chain.link/data-feeds/price-feeds/addresses/ <----------------------------------------------------
        }
    
        // ***** getPrice *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current value of 1ETH in USD, please note that you will get an apporximate value 
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getPrice() public view returns(uint256)
        {
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);    // .latestRoundData method is contained inside of AggregatorV3Interface, the address can be found above
            (,int256 answer,,,) = priceFeed.latestRoundData();                                                      // The method returns 5 different values, we exclude all of them but answer, for further understanding check at AggregatorV3Interface under imports
            return uint256(answer / 10 ** 8);                                                                       // Answer is divided by 10^8 so that the value in USD has no decimals and is easier to read
            
            // Historical:
            // 23/12/2022 - 1,226.67395017
            // 25/12/2022 - 1,220.00000000
        }
    
        // ***** getConvertionRate *****
        // The following function could be considered an extension of getPrice : given
        // the amount of ETH, the function will return the current value of such amount of ETH
        // in USD
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getConvertionRate(uint256 ETH_Amount) public view returns(uint256)
        {
            uint256 ETH_Price = getPrice();                         // Calls getPrice function
            uint256 ETH_AmountInUSD = ETH_Price * ETH_Amount;       // Current ETH pirce * ETH amount
            return ETH_AmountInUSD;                                 // Returns the value of amount ETH in USD
        }
    
        // ***** withdraw *****
        // The following function allows the deployer of the contract (owner) to withdraw
        // the amount of ETH funded to the contract, moreover when the function is called,
        // the funders array will be reset
        function withdraw() payable onlyOwner public                // Check for onlyOwner modifier description at line 77
        {
            payable(msg.sender).transfer(address(this).balance);    // This line of code allows the withdrawal, this refers to the contract
    
            for(uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++)   // The following cycle allows the reset of the money
            {                                                                           // value sent by the funders, accessible through mapping
                address funder = funders[funderIndex];
                AddressToAmountFunded[funder] = 0;
            }
    
            funders = new address[] (0);                            // funders array gets reset, so that it's able to store new values starting from 0
        }
    }
    
    

**brownie-config.yaml** :

    
    
    dependencies:
      # - <organization/repo@version>
      - smartcontractkit/chainlink-brownie-contracts@0.5.1
      
    compiler:
      solc:
        remappings:
          - '@chainlink = smartcontractkit/chainlink-brownie-contracts@0.5.1' 
    

I'm quiet new to ""python-solidity"" coding, but so far I had managed to
overcome all the issues that were popping up. I have spent over 2 days tring
to find a solution to this problem - it's becoming really frustrating. I'm
really thankful to whoever - at least - tries helping me!

**Solutions I tried:**

  * Changing versions of pragma solidity, imports and repo;
  * Adding a .vscode folder --> setting.json containing a path to solidity remappings
  * Updating solc and brownie



Answers:
(Answered on: 2023-01-07 09:23:18)


Can you try `npm install @chainlink/contracts` or `pip3 install
@chainlink/contracts` again and compile it?





:::NEXT DOC:::

Question: (Asked on: 2022-06-09 13:14:15)
Lesson 7: Compiler Version Error -&gt; 10:43.16 (Full blockchain solidity course)
URL: https://stackoverflow.com/questions/72560937/lesson-7-compiler-version-error-1043-16-full-blockchain-solidity-course

Question Body:

    
    
    $ /home/ionmind/hardhat-fundme-fcc/node_modules/.bin/hardhat deploy --network rinkeby
    Error HH606: The project cannot be compiled, see reasons below.
    
    These files import other files that use a different and incompatible version of Solidity:
    
      * contracts/test/MockV3Aggregator.sol (^0.8.12) imports @chainlink/contracts/src/v0.6/tests/MockV3Aggregator.sol (^0.6.0)
    
    To learn more, run the command again with --verbose
    
    Read about compiler configuration at https://hardhat.org/config
    

After getting this error I modified the hardhat.config.js file as instructed
on the video

    
    
    module.exports = {
      //solidity: ""0.8.12"",
      solidity: {
        compilers: [{ version: ""0.8.12"" }, { version: ""0.6.0"" }],
      },
    

But still getting the error, so I also modified the compiler version in
solhint.js file

    
    
    {
      ""extends"": ""solhint:recommended"",
      ""rules"": {
        ""compiler-version"": [""error"", ""^0.8.12"", ""^0.6.0""],
        ""func-visibility"": [""warn"", { ""ignoreConstructors"": true }],
        ""var-name-mixedcase"": ""off"",
        ""avoid-low-level-calls"": ""off""
      }
    }
    

But still getting the error.

I created a separate AggregatorV2V3Interface file in test folder, locally
imported into MockV3Aggregator.sol & also declared solidity version ^0.8.12
for each of the files

    
    
    //SPDX-License-Identifier:MIT
    pragma solidity ^0.8.12;
    
    interface AggregatorInterface {
            //Code Here//
    }
    
    interface AggregatorV3Interface {
           //Code Here//
    }
    
    interface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}
    
    
    
    //SPDX-License-Identifier:MIT
    pragma solidity ^0.8.12;
    
    import ""./AggregatorV2V3Interface.sol"";
    

There are no errors or warnings in the code but I still get the same error
when trying to compile. I don't get why I seem to be the only person having
this compiler issue.Any help is appreciated. Thank you!



Answers:
(Answered on: 2022-06-09 16:11:22)


Update your solidity versions:

    
    
    module.exports = {
      //solidity: ""0.8.12"",
      solidity: {
        compilers: [{ version: ""0.8.12"" }, { version: ""0.6.6"" }],
      },
    





:::NEXT DOC:::

Question: (Asked on: 2022-04-29 17:21:50)
`Invalid blockhash` error while deploying smart contract
URL: https://stackoverflow.com/questions/72061609/invalid-blockhash-error-while-deploying-smart-contract

Question Body:


I am trying to deploy the demo smart contract on solana for chainlink price
feed but getting an error. I followed all the steps from
<https://docs.chain.link/docs/solana/using-data-feeds-solana/>

    
    
    $ anchor deploy --provider.wallet ./id.json --provider.cluster devnet
    
    Deploying workspace: https://api.devnet.solana.com
    Upgrade authority: ./id.json
    Deploying program ""chainlink_solana_demo""...
    Program path: /home/test/solana-starter-kit/target/deploy/chainlink_solana_demo.so...
    =============================================================================
    Recover the intermediate account's ephemeral keypair file with
    `solana-keygen recover` and the following 12-word seed phrase:
    =============================================================================
    until reason almost can clean wish trend buffalo future auto artefact balcony
    =============================================================================
    To resume a deploy, pass the recovered keypair as the
    [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
    Or to recover the account's lamports, pass it as the
    [BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
    =============================================================================
    Error: Custom: Invalid blockhash
    There was a problem deploying: Output { status: ExitStatus(unix_wait_status(256)), stdout: """", stderr: """" }.
    



Answers:
(Answered on: 2022-05-11 14:32:30)


This is just a timeout error message. It happens from time to time depending
on the network availability

Follow these steps and run again. I've also found that you'll want quite a bit
more sol in your wallet than you think you need.

    
    
    To resume a deploy, pass the recovered keypair as the
    [BUFFER_SIGNER] to `solana program deploy` or `solana write-buffer'.
    Or to recover the account's lamports, pass it as the
    [BUFFER_ACCOUNT_ADDRESS] argument to `solana program close`.
    





:::NEXT DOC:::

Question: (Asked on: 2022-03-15 07:39:01)
File not exist Solc error when trying to import data feed into my contract
URL: https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract

Question Body:


[](https://i.stack.imgur.com/fUE5J.png)

[](https://i.stack.imgur.com/lAkYb.png)

[](https://i.stack.imgur.com/b50Pt.png)

I have tried changing different versions of solc, solidity, and chainlink
contracts but it doesn't work.

Error:

    
    
    contracts/Lottery.sol:4:1: ParserError: Source ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    



Answers:
(Answered on: 2022-05-11 18:24:04)


Perhaps the yaml file being in the tests folder is the problem. I would move
that file to live in your top level directory.



"
What command is used to configure user management in Chainlink Node instance?,The admin `chainlink admin users` command is used to configure user management in Chainlink Node instance.,{'source': 'https://docs.chain.link/chainlink-nodes/v1/roles-and-access/'},,,"# Miscellaneous

  * Overview
  * Execute Commands Running Docker
  * Transfer funds from node wallet.
  * Change your API password
  * Multi-user and Role Based Access Control (RBAC)
  * Key management
  * List ETH keys
  * Create a new ETH Key
  * Export an ETH key
  * Delete an ETH key
  * Import an ETH key
  * Full example in detached mode

## Execute Commands Running Docker

In order to interact with the node's CLI commands, you need to be
authenticated. This means that you need to access a shell within the Chainlink
node's running container first. You can obtain the running container's `NAME`
by running:


    docker ps

The output will look similar to:


    CONTAINER ID        IMAGE                     COMMAND                  CREATED             STATUS              PORTS                              NAMES
    436882efd51d        smartcontract/chainlink   ""./chainlink-launche…""   33 minutes ago      Up 21 minutes       6688/tcp, 0.0.0.0:6688->6688/tcp   chainlink

The last item, `chainlink`, is the name of the running container (using
`--name chainlink` in your `docker run` command will give you a common name).
Accessing a shell for this container is accomplished by running:


    docker exec -it chainlink /bin/bash

This changes the prompt to something similar to:


    root@436882efd51d:~#

You can now log in by running:


    chainlink admin login

You will be prompted to enter your API Email and Password, and if successful,
the prompt will simply appear again. You can check that you are authenticated
by running:


    chainlink jobs list

If no jobs have been added, you will receive the following output, otherwise,
the list of added jobs will be returned:


    ╔ Jobs
    ╬════╬════════════╬════════════╬═══════╬
    ║ ID ║ CREATED AT ║ INITIATORS ║ TASKS ║
    ╬════╬════════════╬════════════╬═══════╬

## Transfer funds from node wallet.

Note for Docker

If using Docker, you will first need to follow the Execute Commands Running
Docker guide to enter the running container.

To transfer funds from the node wallet to another address, use the following
CLI command:


    chainlink txs create <amount> <your-cl-node-address> <send-to-address>

This method is the preferred way to interact with your node wallet. Using
other methods to manually interact with the node wallet can cause nonce
issues.

## Change your API password

Note for Docker

If using Docker, you will first need to follow the Execute Commands Running
Docker guide to enter the running container.

In order to change your password, you first need to log into the CLI by
running:


    chainlink admin login

Use your API email and old password in order to authenticate.

Then run the following in order to update the password:


    chainlink admin chpass

It will ask for your old password first, then ask for the new password and a
confirmation.

Once complete, you should see a message ""Password updated.""

## Multi-user and Role Based Access Control (RBAC)

See the [Roles and Access Control](/chainlink-nodes/v1/roles-and-access) page.

## Key management

In this section, ensure you log into the CLI by executing the following
command:


    chainlink admin login

Authenticate using your API email and password.

### List ETH keys

To list available Ethereum accounts along with their ETH & LINK balances,
nonces, and other metadata, execute the following command:


    chainlink keys eth list

Example:


    🔑 ETH keys
    -------------------------------------------------------------------------------------------------
    Address:           0x2d4f5FBD00E5A4fD53D162cE7EDFdb5b7664C542
    EVM Chain ID:      11155111
    Next Nonce:        0
    ETH:               0.000000000000000000
    LINK:              0
    Disabled:          false
    Created:           2023-04-26 08:12:51.340348 +0000 UTC
    Updated:           2023-04-26 08:12:51.340348 +0000 UTC

### Create a new ETH Key

To create a key in the node's keystore alongside the existing keys, run the
following command:


    chainlink keys eth create

Example:


    ETH key created.
    
    🔑 New key
    -------------------------------------------------------------------------------------------------
    Address:           0xd31961E1f62A2FaB824AC3C1A7a332daF8B11eE0
    EVM Chain ID:      11155111
    Next Nonce:        0
    ETH:               0.000000000000000000
    LINK:              0
    Disabled:          false
    Created:           2023-04-26 08:28:36.52974 +0000 UTC
    Updated:           2023-04-26 08:28:36.52974 +0000 UTC
    Max Gas Price Wei: 115792089237316195423570985008687907853269984665640564039457584007913129639935

### Export an ETH key

To export an Ethereum key to a JSON file, run the following command:


    chainlink keys eth export [address] [command options]

where:

  * `address`: The EVM account address for which you want to export the private key.

  * Options:

    * `--newpassword FILE, -p FILE FILE`: A file containing the password to encrypt the key.
    * `--output value, -o value`: The path where the JSON file will be saved.

Example:


    chainlink keys eth export 0xd31961E1f62A2FaB824AC3C1A7a332daF8B11eE0 --newpassword .chainlink/pass --output privatekey.json
    
    🔑 Exported ETH key 0xd31961E1f62A2FaB824AC3C1A7a332daF8B11eE0 to privatekey.json

### Delete an ETH key

To remove an Ethereum key, run the following command:


    chainlink keys eth delete [address] [command options]

where:

  * `address`: The EVM account address that you want to remove.

  * Options:

    * `--yes, -y`: Skip the confirmation prompt.

Example:


    $ chainlink keys eth delete 0xd31961E1f62A2FaB824AC3C1A7a332daF8B11eE0 --yes
    Deleted ETH key: 0xd31961E1f62A2FaB824AC3C1A7a332daF8B11eE0

### Import an ETH key

To import an Ethereum key from a JSON file, run the following command:


    chainlink keys eth import [JSON file] [command options]

where:

  * `JSON file`: The path where the JSON file containing the ETH key is saved.

  * Options:

    * `--oldpassword FILE, -p FILE`: FILE containing the password used to encrypt the key in the JSON file.
    * `--evmChainID value`: Chain ID for the key. If left blank, default chain will be used.

Example:


    $ chainlink keys eth import privatekey.json --oldpassword .chainlink/pass
    🔑 Imported ETH key
    -------------------------------------------------------------
    Address:           0xd31961E1f62A2FaB824AC3C1A7a332daF8B11eE0
    EVM Chain ID:      11155111
    Next Nonce:        0
    ETH:               0.000000000000000000
    LINK:              0
    Disabled:          false
    Created:           2023-04-26 08:51:02.04186 +0000 UTC
    Updated:           2023-04-26 08:51:02.04186 +0000 UTC
    Max Gas Price Wei: <nil>

## Full example in detached mode


    cd ~/.chainlink-sepolia && docker run --restart=always  -p 6688:6688 -d --name sepolia-primary -v ~/.chainlink-sepolia:/chainlink -it --env-file=.env smartcontract/chainlink:1.0.0 node start -p /chainlink/.password

## What's next

  * [› Security and Operation Best Practices](/chainlink-nodes/resources/best-security-practices)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/resources/miscellaneous.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Configuring Chainlink Nodes

  * Overview
  * TOML Configuration
  * Changes to node configuration starting in v1.1.0 nodes
  * Essential environment variables
  * DATABASE_URL
  * General Node Configuration
  * CL_CONFIG
  * CHAIN_TYPE
  * CHAINLINK_DEV
  * EXPLORER_ACCESS_KEY
  * EXPLORER_SECRET
  * EXPLORER_URL
  * ROOT
  * TELEMETRY_INGRESS_UNICONN
  * TELEMETRY_INGRESS_LOGGING
  * TELEMETRY_INGRESS_URL
  * TELEMETRY_INGRESS_SERVER_PUB_KEY
  * TELEMETRY_INGRESS_BUFFER_SIZE
  * TELEMETRY_INGRESS_MAX_BATCH_SIZE
  * TELEMETRY_INGRESS_SEND_INTERVAL
  * TELEMETRY_INGRESS_SEND_TIMEOUT
  * TELEMETRY_INGRESS_USE_BATCH_SEND
  * Chains
  * SOLANA_ENABLED
  * EVM_ENABLED
  * Database Settings
  * MIGRATE_DATABASE
  * ORM_MAX_IDLE_CONNS
  * ORM_MAX_OPEN_CONNS
  * Database Global Lock
  * DATABASE_LOCKING_MODE
  * ADVISORY_LOCK_CHECK_INTERVAL
  * ADVISORY_LOCK_ID
  * LEASE_LOCK_DURATION
  * LEASE_LOCK_REFRESH_INTERVAL
  * Database Automatic Backups
  * DATABASE_BACKUP_FREQUENCY
  * DATABASE_BACKUP_MODE
  * DATABASE_BACKUP_URL
  * DATABASE_BACKUP_DIR
  * Logging
  * JSON_CONSOLE
  * LOG_FILE_DIR
  * LOG_LEVEL
  * LOG_SQL
  * LOG_FILE_MAX_SIZE
  * LOG_FILE_MAX_AGE
  * LOG_FILE_MAX_BACKUPS
  * LOG_UNIX_TS
  * AUDIT_LOGGER_FORWARD_TO_URL
  * AUDIT_LOGGER_HEADERS
  * AUDIT_LOGGER_JSON_WRAPPER_KEY
  * Nurse service (auto-pprof)
  * AUTO_PPROF_ENABLED
  * AUTO_PPROF_PROFILE_ROOT
  * AUTO_PPROF_POLL_INTERVAL
  * AUTO_PPROF_GATHER_DURATION
  * AUTO_PPROF_GATHER_TRACE_DURATION
  * AUTO_PPROF_MAX_PROFILE_SIZE
  * AUTO_PPROF_CPU_PROFILE_RATE
  * AUTO_PPROF_MEM_PROFILE_RATE
  * AUTO_PPROF_BLOCK_PROFILE_RATE
  * AUTO_PPROF_MUTEX_PROFILE_FRACTION
  * AUTO_PPROF_MEM_THRESHOLD
  * AUTO_PPROF_GOROUTINE_THRESHOLD
  * Chainlink Web Server
  * ALLOW_ORIGINS
  * AUTHENTICATED_RATE_LIMIT
  * AUTHENTICATED_RATE_LIMIT_PERIOD
  * BRIDGE_CACHE_TTL
  * BRIDGE_RESPONSE_URL
  * HTTP_SERVER_WRITE_TIMEOUT
  * CHAINLINK_PORT
  * SECURE_COOKIES
  * SESSION_TIMEOUT
  * UNAUTHENTICATED_RATE_LIMIT
  * UNAUTHENTICATED_RATE_LIMIT_PERIOD
  * Web Server MFA
  * MFA_RPID
  * MFA_RPORIGIN
  * Web Server TLS
  * CHAINLINK_TLS_HOST
  * CHAINLINK_TLS_PORT
  * CHAINLINK_TLS_REDIRECT
  * TLS_CERT_PATH
  * TLS_KEY_PATH
  * EVM/Ethereum Legacy Environment Variables
  * ETH_URL
  * ETH_HTTP_URL
  * EVM_NODES
  * ETH_SECONDARY_URLS
  * EVM/Ethereum Global Settings
  * ETH_CHAIN_ID
  * EVM_RPC_ENABLED
  * EVM/Ethereum Chain-specific Overrides
  * BALANCE_MONITOR_ENABLED
  * BLOCK_BACKFILL_DEPTH
  * BLOCK_BACKFILL_SKIP
  * ETH_TX_REAPER_INTERVAL
  * ETH_TX_REAPER_THRESHOLD
  * ETH_TX_RESEND_AFTER_THRESHOLD
  * ETH_FINALITY_DEPTH
  * ETH_HEAD_TRACKER_HISTORY_DEPTH
  * ETH_HEAD_TRACKER_MAX_BUFFER_SIZE
  * ETH_HEAD_TRACKER_SAMPLING_INTERVAL
  * ETH_LOG_BACKFILL_BATCH_SIZE
  * ETH_LOG_POLL_INTERVAL
  * ETH_RPC_DEFAULT_BATCH_SIZE
  * LINK_CONTRACT_ADDRESS
  * MIN_INCOMING_CONFIRMATIONS
  * MIN_OUTGOING_CONFIRMATIONS
  * MINIMUM_CONTRACT_PAYMENT_LINK_JUELS
  * NODE_NO_NEW_HEADS_THRESHOLD
  * NODE_POLL_FAILURE_THRESHOLD
  * NODE_POLL_INTERVAL
  * NODE_SELECTION_MODE
  * NODE_SYNC_THRESHOLD
  * EVM Gas Controls
  * Configuring your ETH node
  * EVM_EIP1559_DYNAMIC_FEES
  * ETH_GAS_BUMP_PERCENT
  * ETH_GAS_BUMP_THRESHOLD
  * ETH_GAS_BUMP_TX_DEPTH
  * ETH_GAS_BUMP_WEI
  * EVM_GAS_FEE_CAP_DEFAULT
  * ETH_GAS_LIMIT_DEFAULT
  * ETH_GAS_LIMIT_MAX
  * ETH_GAS_LIMIT_MULTIPLIER
  * ETH_GAS_LIMIT_TRANSFER
  * ETH_GAS_PRICE_DEFAULT
  * EVM_GAS_TIP_CAP_DEFAULT
  * EVM_GAS_TIP_CAP_MINIMUM
  * ETH_MAX_GAS_PRICE_WEI
  * ETH_MAX_IN_FLIGHT_TRANSACTIONS
  * ETH_MAX_QUEUED_TRANSACTIONS
  * ETH_MIN_GAS_PRICE_WEI
  * ETH_GAS_LIMIT_OCR_JOB_TYPE
  * ETH_GAS_LIMIT_DR_JOB_TYPE
  * ETH_GAS_LIMIT_VRF_JOB_TYPE
  * ETH_GAS_LIMIT_FM_JOB_TYPE
  * ETH_GAS_LIMIT_KEEPER_JOB_TYPE
  * ETH_NONCE_AUTO_SYNC
  * ETH_USE_FORWARDERS
  * EVM/Ethereum Gas Price Estimation
  * GAS_ESTIMATOR_MODE
  * BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE
  * BLOCK_HISTORY_ESTIMATOR_BLOCK_HISTORY_SIZE
  * BLOCK_HISTORY_ESTIMATOR_BLOCK_DELAY
  * BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS
  * BLOCK_HISTORY_ESTIMATOR_TRANSACTION_PERCENTILE
  * EVM/Ethereum Transaction Simulation
  * Job Pipeline and tasks
  * DEFAULT_HTTP_LIMIT
  * DEFAULT_HTTP_TIMEOUT
  * FEATURE_EXTERNAL_INITIATORS
  * JOB_PIPELINE_MAX_RUN_DURATION
  * JOB_PIPELINE_MAX_SUCCESSFUL_RUNS
  * JOB_PIPELINE_REAPER_INTERVAL
  * JOB_PIPELINE_REAPER_THRESHOLD
  * JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH
  * OCR
  * FEATURE_OFFCHAIN_REPORTING
  * OCR_KEY_BUNDLE_ID
  * OCR_MONITORING_ENDPOINT
  * OCR_TRANSMITTER_ADDRESS
  * P2P_NETWORKING_STACK
  * Networking Stack V1
  * Networking Stack V2
  * Keeper
  * KEEPER_GAS_PRICE_BUFFER_PERCENT
  * KEEPER_GAS_TIP_CAP_BUFFER_PERCENT
  * KEEPER_BASE_FEE_BUFFER_PERCENT
  * KEEPER_MAXIMUM_GRACE_PERIOD
  * KEEPER_REGISTRY_CHECK_GAS_OVERHEAD
  * KEEPER_REGISTRY_PERFORM_GAS_OVERHEAD
  * KEEPER_REGISTRY_SYNC_INTERVAL
  * KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE
  * KEEPER_TURN_LOOK_BACK
  * CLI Client
  * ADMIN_CREDENTIALS_FILE
  * CLIENT_NODE_URL
  * INSECURE_SKIP_VERIFY
  * Notes on setting environment variables

Recent versions of the Chainlink node use sensible defaults for most
configuration variables. You do not need to change much to get a standard
deployment working.

Not all environment variables are documented here. Any undocumented
environment variable is subject to change in future releases. In almost all
cases, you should leave any environment variable not listed here to its
default value unless you really understand what you are doing.

To reiterate: _If you have an environment variable set that is not listed
here, and you don't know exactly why you have it set, you should remove it!_

The environment variables listed here are explicitly supported and current as
of Chainlink node v1.3.0.

### TOML Configuration

TOML configuration for Chainlink nodes is stable and recommended for mainnet
deployments. TOML configuration will be the only supported configuration
method starting with `v2.0.0`. Enable TOML configuration by specifying the
`-config <filename>.toml` flag with the path to your TOML file. Alternatively,
you can specify the raw TOML config in the [`CL_CONFIG` environment
variable](/chainlink-nodes/v1/configuration#cl_config). See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/CONFIG.md)
and
[SECRETS.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/SECRETS.md)
on GitHub to learn more.

## Changes to node configuration starting in v1.1.0 nodes

As of Chainlink node v1.1.0 and up, the way nodes manage configuration is
changing. Previously, environment variables exclusively handled all node
configuration. Although this configuration method worked well in the past, it
has its limitations. Notably, it doesn't mesh well with chain-specific
configuration profiles.

For this reason, Chainlink nodes are moving towards a model where you set
variables using the API, CLI, or GUI, and the configuration is saved in the
database. We encourage you to become familiar with this model because it is
likely that nodes will continue to move away from environment variable
configuration in the future.

As of v1.1.0, Chainlink nodes still support environment variables to configure
node settings and chain-specific settings. If the environment variable is set,
it overrides any chain-specific, job-specific, or database configuration
setting. The log displays a warning to indicate when an override happens, so
you know when variables lower in the hierarchy are being ignored.

Your node applies configuration settings using following hierarchy:

  1. Environment variables
  2. Chain-specific variables
  3. Job-specific variables

## Essential environment variables

These are the only environment variables that are _required_ for a Chainlink
node to run.

### DATABASE_URL

**Required**

  * Default: _none_

The PostgreSQL URI to connect to your database. Chainlink nodes require
Postgres versions >= 11. See the [Running a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node) for an example.

## General Node Configuration

### CL_CONFIG

This environment variable is used to set static configuration using TOML
format. Specify the raw TOML config in this environment variable. Unlike the
`-config` flag, it does not accept a path to a TOML file.

See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/CONFIG.md)
and
[SECRETS.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/SECRETS.md)
on GitHub to learn more.

### CHAIN_TYPE

  * Default: _none_

CHAIN_TYPE overrides all chains and forces them to act as a particular chain
type. An up-to-date list of chain types is given in
[`chaintype.go`](https://github.com/smartcontractkit/chainlink/blob/v1.3.0/core/chains/chaintype.go).

This variable enables some chain-specific hacks and optimizations. It is
recommended not to use this environment variable and set the chain-type on a
per-chain basis instead.

### CHAINLINK_DEV

  * Default: `""false""`

Setting `CHAINLINK_DEV` to `true` enables development mode. Do not use this
for production deployments. It can be useful for enabling experimental
features and collecting debug information in test environments.

### EXPLORER_ACCESS_KEY

  * Default: _none_

The access key for authenticating with the explorer. This variable is required
to deliver telemetry.

### EXPLORER_SECRET

  * Default: _none_

The secret for authenticating with the explorer. This variable is required to
deliver telemetry.

### EXPLORER_URL

  * Default: _none_

The explorer websocket URL for the node to push stats to. This variable is
required to deliver telemetry.

### ROOT

  * Default: `""~/.chainlink""`

The Chainlink node's root directory. This is the default directory for
logging, database backups, cookies, and other misc Chainlink node files.
Chainlink nodes will always ensure this directory has `700` permissions
because it might contain sensitive data.

### TELEMETRY_INGRESS_UNICONN

  * Default: `""true""`

Toggles which ws connection style is used.

### TELEMETRY_INGRESS_LOGGING

  * Default: `""false""`

Toggles verbose logging of the raw telemetry messages being sent.

### TELEMETRY_INGRESS_URL

  * Default: _none_

The URL to connect to for sending telemetry.

### TELEMETRY_INGRESS_SERVER_PUB_KEY

  * Default: _none_

The public key of the telemetry server.

### TELEMETRY_INGRESS_BUFFER_SIZE

  * Default: `""100""`

The number of telemetry messages to buffer before dropping new ones.

### TELEMETRY_INGRESS_MAX_BATCH_SIZE

  * Default: `""50""`

The maximum number of messages to batch into one telemetry request.

### TELEMETRY_INGRESS_SEND_INTERVAL

  * Default: `""500ms""`

The interval on which batched telemetry is sent to the ingress server.

### TELEMETRY_INGRESS_SEND_TIMEOUT

  * Default: `""10s""`

The max duration to wait for the request to complete when sending batch
telemetry.

### TELEMETRY_INGRESS_USE_BATCH_SEND

  * Default: `""true""`

Toggles sending telemetry to the ingress server using the batch client.

## Chains

### SOLANA_ENABLED

caution

  * Default: `""false""`

Enables Solana support.

### EVM_ENABLED

  * Default: `""true""`

Enables support for EVM-based chains. By default, this variable is set to
`true` to provide legacy compatibility and ease the upgrade path from older
versions of Chainlink which did not support disabling EVM.

## Database Settings

### MIGRATE_DATABASE

  * Default: `""true""`

This variable controls whether a Chainlink node will attempt to automatically
migrate the database on boot. If you want more control over your database
migration process, set this variable to `false` and manually migrate the
database using the CLI `migrate` command instead.

### ORM_MAX_IDLE_CONNS

  * Default: `""10""`

This setting configures the maximum number of idle database connections that
the Chainlink node will keep open. Think of this as the baseline number of
database connections per Chainlink node instance. Increasing this number can
help to improve performance under database-heavy workloads.

Postgres has connection limits, so you must use cation when increasing this
value. If you are running several instances of a Chainlink node or another
application on a single database server, you might run out of Postgres
connection slots if you raise this value too high.

### ORM_MAX_OPEN_CONNS

  * Default: `""20""`

This setting configures the maximum number of database connections that a
Chainlink node will have open at any one time. Think of this as the maximum
burst upper bound limit of database connections per Chainlink node instance.
Increasing this number can help to improve performance under database-heavy
workloads.

Postgres has connection limits, so you must use cation when increasing this
value. If you are running several instances of a Chainlink node or another
application on a single database server, you might run out of Postgres
connection slots if you raise this value too high.

## Database Global Lock

Chainlink nodes use a database lock to ensure that only one Chainlink node
instance can be run on the database at a time. If you run multiple instances
of a Chainlink node that share a single database at the same time, the node
will encounter strange errors and data integrity failures. Do not allow
multiple nodes to write data to the database at the same time.

### DATABASE_LOCKING_MODE

  * Default: `""dual""`

The `DATABASE_LOCKING_MODE` variable can be set to 'dual', 'advisorylock',
'lease', or 'none'. It controls which mode to use to enforce that only one
Chainlink node can use the database. It is recommended to set this to `lease`.

  * `dual` \- The default: Uses both advisory locks and lease locks for backward and forward compatibility
  * `advisorylock` \- Advisory lock only
  * `lease` \- Lease lock only
  * _none_ \- No locking at all: This option useful for advanced deployment environments when you are sure that only one instance of a Chainlink node will ever be running.

#### Technical details

Ideally, you should use a container orchestration system like
[Kubernetes](https://kubernetes.io/) to ensure that only one Chainlink node
instance can ever use a specific Postgres database. However, some node
operators do not have the technical capacity to do this. Common use cases run
multiple Chainlink node instances in failover mode as recommended by our
official documentation. The first instance takes a lock on the database and
subsequent instances will wait trying to take this lock in case the first
instance fails.

By default, Chainlink nodes use the `dual` setting to provide both advisory
locks and lease locks for backward and forward compatibility. Using advisory
locks alone presents the following problems:

  * If your nodes or applications hold locks open for several hours or days, Postgres is unable to complete internal cleanup tasks. The Postgres maintainers explicitly discourage holding locks open for long periods of time.
  * Advisory locks can silently disappear when you upgrade Postgres, so a new Chainlink node instance can take over even while the old node is still running.
  * Advisory locks do not work well with pooling tools such as [pgbouncer](https://www.pgbouncer.org/).
  * If the Chainlink node crashes, an advisory lock can hang around for up to several hours, which might require you to manually remove it so another instance of the Chainlink node will allow itself to boot.

Because of the complications with advisory locks, Chainlink nodes with v1.1.0
and later support a new `lease` locking mode. This mode might become the
default in future. The `lease` locking mode works using the following process:

  * Node A creates one row in the database with the client ID and updates it once per second.
  * Node B spinlocks and checks periodically to see if the client ID is too old. If the client ID is not updated after a period of time, node B assumes that node A failed and takes over. Node B becomes the owner of the row and updates the client ID once per second.
  * If node A comes back, it attempts to take out a lease, realizes that the database has been leased to another process, and exits the entire application immediately.

### ADVISORY_LOCK_CHECK_INTERVAL

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable advisory
locking.

  * Default: `""1s""`

`ADVISORY_LOCK_CHECK_INTERVAL` controls how often the Chainlink node checks to
make sure it still holds the advisory lock when advisory locking is enabled.
If a node no longer holds the lock, it will try to re-acquire it. If the node
cannot re-acquire the lock, the application will exit.

### ADVISORY_LOCK_ID

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable advisory
locking.

  * Default: `""1027321974924625846""`

`ADVISORY_LOCK_ID` is the application advisory lock ID. This must match all
other Chainlink nodes that might access this database. It is unlikely you will
ever need to change this from the default.

### LEASE_LOCK_DURATION

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable lease
locking.

  * Default: `""30s""`

How long the lease lock will last before expiring.

### LEASE_LOCK_REFRESH_INTERVAL

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable lease
locking.

  * Default: `""1s""`

How often to refresh the lease lock. Also controls how often a standby node
will check to see if it can grab the lease.

## Database Automatic Backups

As a best practice, take regular database backups in case of accidental data
loss. This best practice is especially important when you upgrade your
Chainlink node to a new version. Chainlink nodes support automated database
backups to make this process easier.

NOTE: Dumps can cause high load and massive database latencies, which will
negatively impact the normal functioning of the Chainlink node. For this
reason, it is recommended to set a DATABASE_BACKUP_URL and point it to a read
replica if you enable automatic backups.

### DATABASE_BACKUP_FREQUENCY

  * Default: `""1h""`

If this variable is set to a positive duration and `DATABASE_BACKUP_MODE` is
not _none_ , the node will dump the database at this regular interval.

Set to `0` to disable periodic backups.

### DATABASE_BACKUP_MODE

  * Default: `""none""`

Set the mode for automatic database backups, which can be one of _none_ ,
`lite`, or `full`. If enabled, the Chainlink node will always dump a backup on
every boot before running migrations. Additionally, it will automatically take
database backups that overwrite the backup file for the given version at
regular intervals if `DATABASE_BACKUP_FREQUENCY` is set to a non-zero
interval.

_none_ \- Disables backups. `lite` \- Dumps small tables including
configuration and keys that are essential for the node to function, which
excludes historical data like job runs, transaction history, etc. `full` \-
Dumps the entire database.

It will write to a file like `$ROOT/backup/cl_backup_<VERSION>.dump`. There is
one backup dump file per version of the Chainlink node. If you upgrade the
node, it will keep the backup taken right before the upgrade migration so you
can restore to an older version if necessary.

### DATABASE_BACKUP_URL

If specified, the automatic database backup will pull from this URL rather
than the main `DATABASE_URL`. It is recommended to set this value to a read
replica if you have one to avoid excessive load on the main database.

### DATABASE_BACKUP_DIR

This variable sets the directory to use for saving the backup file. Use this
if you want to save the backup file in a directory other than the default ROOT
directory.

## Logging

### JSON_CONSOLE

  * Default: `""false""`

Set this to true to enable JSON logging. Otherwise, the log is saved in a
human-friendly console format.

### LOG_FILE_DIR

  * Default: `""$ROOT""`

By default, Chainlink nodes write log data to `$ROOT/log.jsonl`. The log
directory can be changed by setting this var. For example,
`LOG_FILE_DIR=/my/log/directory`.

### LOG_LEVEL

  * Default: `""info""`

The `LOG_LEVEL` environment variable determines both what is printed on the
screen and what is written to the log file.

The available options are:

  * `""debug""`: Useful for forensic debugging of issues.
  * `""info""`: High-level informational messages.
  * `""warn""`: A mild error occurred that might require non-urgent action. Check these warnings semi-regularly to see if any of them require attention. These warnings usually happen due to factors outside of the control of the node operator. Examples: Unexpected responses from a remote API or misleading networking errors.
  * `""error""`: An unexpected error occurred during the regular operation of a well-maintained node. Node operators might need to take action to remedy this error. Check these regularly to see if any of them require attention. Examples: Use of deprecated configuration options or incorrectly configured settings that cause a job to fail.
  * `""crit""`: A critical error occurred. The node might be unable to function. Node operators should take immediate action to fix these errors. Examples: The node could not boot because a network socket could not be opened or the database became inaccessible.
  * `""panic""`: An exceptional error occurred that could not be handled. If the node is unresponsive, node operators should try to restart their nodes and notify the Chainlink team of a potential bug.
  * `""fatal""`: The node encountered an unrecoverable problem and had to exit.

### LOG_SQL

  * Default: `""false""`

This setting tells the Chainlink node to log SQL statements made using the
default logger. SQL statements will be logged at `debug` level. Not all
statements can be logged. The best way to get a true log of all SQL statements
is to enable SQL statement logging on Postgres.

### LOG_FILE_MAX_SIZE

  * Default: `""5120mb""`

Determines the log file's max size in megabytes before file rotation. Having
this not set will disable logging to disk. If your disk doesn't have enough
disk space, the logging will pause and the application will log errors until
space is available again.

Values must have suffixes with a unit like: `5120mb` (5,120 megabytes). If no
unit suffix is provided, the value defaults to `b` (bytes). The list of valid
unit suffixes are:

  * b (bytes)
  * kb (kilobytes)
  * mb (megabytes)
  * gb (gigabytes)
  * tb (terabytes)

### LOG_FILE_MAX_AGE

  * Default: `""0""`

Determines the log file's max age in days before file rotation. Keeping this
config with the default value will not remove log files based on age.

### LOG_FILE_MAX_BACKUPS

  * Default: `""1""`

Determines the maximum number of old log files to retain. Keeping this config
with the default value retains all old log files. The `LOG_FILE_MAX_AGE`
variable can still cause them to get deleted.

### LOG_UNIX_TS

  * Default: _none_

Previous versions of Chainlink nodes wrote JSON logs with a unix timestamp. As
of v1.1.0 and up, the default has changed to use ISO8601 timestamps for better
readability. Setting `LOG_UNIX_TS=true` will enable the old behavior.

### AUDIT_LOGGER_FORWARD_TO_URL

  * Default: _none_

When set, this environment variable configures and enables an optional HTTP
logger which is used specifically to send audit log events. Audit logs events
are emitted when specific actions are performed by any of the users through
the node's API. The value of this variable should be a full URL. Log items
will be sent via POST HTTP requests.

There are audit log implemented for the following events:

  * Auth & Sessions (new session, login success, login failed, 2FA enrolled, 2FA failed, password reset, password reset failed, etc.)
  * CRUD actions for all resources (add/create/delete resources such as bridges, nodes, keys)
  * Sensitive actions (keys exported/imported, config changed, log level changed, environment dumped)

A full list of audit log enum types can be found in the source within the
`audit` package
([`audit_types.go`](https://github.com/smartcontractkit/chainlink/blob/develop/core/logger/audit/audit_types.go)).

Log events follow this schema:


    {
        ""eventID"":  EVENT_ID_ENUM,
        ""hostname"": HOSTNAME,
        ""localIP"" : CL_NODE_IP,
        ""env"" : ENVIRONMENT_NAME,
        ""data"": ...
    }

The `AUDIT_LOGGER_*` environment variables configure this optional audit log
HTTP forwarder.

### AUDIT_LOGGER_HEADERS

  * Default: _none_

An optional list of HTTP headers to be added for every optional audit log
event. If the above `AUDIT_LOGGER_FORWARD_TO_URL` is set, audit log events
will be POSTed to that URL, and will include headers specified in this
environment variable. One example use case is auth for example:
`AUDIT_LOGGER_HEADERS=""Authorization||{token}""`

Header keys and values are delimited on `||`, and multiple headers can be
added with a forward slash delimiter (`\`). An example of multiple key value
pairs: `AUDIT_LOGGER_HEADERS=""Authorization||{token}\Some-Other-
Header||{token2}""`

### AUDIT_LOGGER_JSON_WRAPPER_KEY

  * Default: _none_

When the audit log HTTP forwarder is enabled, if there is a value set for this
optional environment variable then the POST body will be wrapped in a
dictionary in a field specified by the value of set variable. This is to help
enable specific logging service integrations that may require the event JSON
in a special shape. For example: `AUDIT_LOGGER_JSON_WRAPPER_KEY=event` will
create the POST body:


    {
      ""event"": {
        ""eventID"":  EVENT_ID_ENUM,
        ""hostname"": HOSTNAME,
        ""localIP"" : CL_NODE_IP,
        ""env"" : ENVIRONMENT_NAME,
        ""data"": ...
      }
    }

## Nurse service (auto-pprof)

The Chainlink node is equipped with an internal ""nurse"" service that can
perform automatic `pprof` profiling when the certain resource thresholds are
exceeded, such as memory and goroutine count. These profiles are saved to disk
to facilitate fine-grained debugging of performance-related issues. In
general, if you notice that your node has begun to accumulate profiles,
forward them to the Chainlink team.

To learn more about these profiles, read the [Profiling Go programs with
pprof](https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/) guide.

### AUTO_PPROF_ENABLED

  * Default: `""false""`

Set to `true` to enable the automatic profiling service.

### AUTO_PPROF_PROFILE_ROOT

Defaults to `$CHAINLINK_ROOT`

The location on disk where pprof profiles will be stored.

### AUTO_PPROF_POLL_INTERVAL

  * Default: `""10s""`

The interval at which the node's resources are checked.

### AUTO_PPROF_GATHER_DURATION

  * Default: `""10s""`

The duration for which profiles are gathered when profiling starts.

### AUTO_PPROF_GATHER_TRACE_DURATION

  * Default: `""5s""`

The duration for which traces are gathered when profiling is kicked off. This
is separately configurable because traces are significantly larger than other
types of profiles.

### AUTO_PPROF_MAX_PROFILE_SIZE

  * Default: `""100mb""`

The maximum amount of disk space that profiles may consume before profiling is
disabled.

### AUTO_PPROF_CPU_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetCPUProfileRate>.

### AUTO_PPROF_MEM_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#pkg-variables>.

### AUTO_PPROF_BLOCK_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetBlockProfileRate>.

### AUTO_PPROF_MUTEX_PROFILE_FRACTION

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetMutexProfileFraction>.

  * Default: `""1""`

### AUTO_PPROF_MEM_THRESHOLD

  * Default: `""4gb""`

The maximum amount of memory the node can actively consume before profiling
begins.

### AUTO_PPROF_GOROUTINE_THRESHOLD

  * Default: `""5000""`

The maximum number of actively-running goroutines the node can spawn before
profiling begins.

## Chainlink Web Server

### ALLOW_ORIGINS

  * Default: `""http://localhost:3000,http://localhost:6688""`

Controls the URLs Chainlink nodes emit in the `Allow-Origins` header of its
API responses. The setting can be a comma-separated list with no spaces. You
might experience CORS issues if this is not set correctly.

You should set this to the external URL that you use to access the Chainlink
UI.

You can set `ALLOW_ORIGINS=*` to allow the UI to work from any URL, but it is
recommended for security reasons to make it explicit instead.

### AUTHENTICATED_RATE_LIMIT

  * Default: `""1000""`

`AUTHENTICATED_RATE_LIMIT` defines the threshold to which authenticated
requests get limited. More than this many authenticated requests per
`AUTHENTICATED_RATE_LIMIT_PERIOD` will be rejected.

### AUTHENTICATED_RATE_LIMIT_PERIOD

  * Default: `""1m""`

`AUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which authenticated
requests get limited.

### BRIDGE_CACHE_TTL

  * Default: 0s

When set to `d` units of time, this variable enables using cached bridge
responses that are at most `d` units old. Caching is disabled by default.

Example `BRIDGE_CACHE_TTL=10s`, `BRIDGE_CACHE_TTL=1m`

### BRIDGE_RESPONSE_URL

  * Default: _none_

`BRIDGE_RESPONSE_URL` defines the URL for bridges to send a response to.

Usually this will be the same as the URL/IP and port you use to connect to the
Chainlink UI, such as `https://my-chainlink-node.example.com:6688`.

### HTTP_SERVER_WRITE_TIMEOUT

**ADVANCED**

Do not change this setting unless you know what you are doing.

  * Default: `""10s""`

`HTTP_SERVER_WRITE_TIMEOUT` controls how long the Chainlink node's API server
can hold a socket open for writing a response to an HTTP request. Sometimes,
this must be increased for pprof.

### CHAINLINK_PORT

  * Default: `""6688""`

Port used for the Chainlink Node API, CLI, and GUI.

### SECURE_COOKIES

  * Default: `""true""`

Requires the use of secure cookies for authentication. Set to false to enable
standard HTTP requests along with `CHAINLINK_TLS_PORT=0`.

### SESSION_TIMEOUT

  * Default: `""15m""`

This value determines the amount of idle time to elapse before session cookies
expire. This signs out GUI users from their sessions.

### UNAUTHENTICATED_RATE_LIMIT

  * Default: `""5""`

`UNAUTHENTICATED_RATE_LIMIT` defines the threshold to which authenticated
requests get limited. More than this many unauthenticated requests per
`UNAUTHENTICATED_RATE_LIMIT_PERIOD` will be rejected.

### UNAUTHENTICATED_RATE_LIMIT_PERIOD

  * Default: `""20s""`

`UNAUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which
unauthenticated requests get limited.

## Web Server MFA

The Operator UI frontend now supports enabling Multi Factor Authentication via
Webauthn per account. When enabled, logging in will require the account
password and a hardware or OS security key such as Yubikey. To enroll, log in
to the operator UI and click the circle purple profile button at the top right
and then click **Register MFA Token**. Tap your hardware security key or use
the OS public key management feature to enroll a key. Next time you log in,
this key will be required to authenticate.

This feature must be enabled by setting the following environment variables:
`MFA_RPID` and `MFA_RPORIGIN`.

### MFA_RPID

  * Default: _none_

The `MFA_RPID` value should be the FQDN of where the Operator UI is served.
When serving locally, the value should be `localhost`.

### MFA_RPORIGIN

  * Default: _none_

The `MFA_RPORIGIN` value should be the origin URL where WebAuthn requests
initiate, including scheme and port. When serving locally, the value should be
`http://localhost:6688/`.

## Web Server TLS

The TLS settings below apply only if you want to enable TLS security on your
Chainlink node.

### CHAINLINK_TLS_HOST

  * Default: _none_

The hostname configured for TLS to be used by the Chainlink node. This is
useful if you configured a domain name specific for your Chainlink node.

### CHAINLINK_TLS_PORT

  * Default: `""6689""`

The port used for HTTPS connections. Set this to `0` to disable HTTPS.
Disabling HTTPS also relieves Chainlink nodes of the requirement for a TLS
certificate.

### CHAINLINK_TLS_REDIRECT

  * Default: `""false""`

Forces TLS redirect for unencrypted connections.

### TLS_CERT_PATH

  * Default: _none_

The location of the TLS certificate file. Example:
`/home/$USER/.chainlink/tls/server.crt`

### TLS_KEY_PATH

  * Default: _none_

The location of the TLS private key file. Example:
`/home/$USER/.chainlink/tls/server.key`

## EVM/Ethereum Legacy Environment Variables

Previous Chainlink node versions supported only one chain. From v1.1.0 and up,
Chainlink nodes support multiple EVM and non-EVM chains, so the way that
chains and nodes are configured has changed.

The preferred way of configuring Chainlink nodes as of v1.1.0 and up is to use
the API, CLI, or UI to set chain-specific configuration and create nodes.

The old way of specifying chains using environment variables is still
supported, but discouraged. It works as follows:

If you set any value for `ETH_URL`, the values of `ETH_CHAIN_ID`, `ETH_URL`,
`ETH_HTTP_URL` and `ETH_SECONDARY_URLS` will be used to create and update
chains and nodes representing these values in the database. If an existing
chain or node is found, it will be overwritten. This mode is used mainly to
ease the process of upgrading. On subsequent runs (once your old settings have
been written to the database) it is recommended to unset `ETH_URL` and use the
API commands exclusively to administer chains and nodes.

In the future, support for the `ETH_URL` and associated environment variables
might be removed, so it is recommended to use the API, CLI, or GUI instead to
setup chains and nodes.

### ETH_URL

Setting this will enable ""legacy eth ENV"" mode, which is not compatible with
multi-chain. It is better to configure settings using the API, CLI, or GUI
instead.

  * Default: _none_

This is the websocket address of the Ethereum client that the Chainlink node
will connect to. All interaction with the Ethereum blockchain will occur
through this connection.

NOTE: It is also required to set `ETH_CHAIN_ID` if you set ETH_URL.

### ETH_HTTP_URL

Only has effect if `ETH_URL` set. Otherwise, it can be set in the API, CLI, or
GUI.

  * Default: _none_

This should be set to the HTTP URL that points to the same ETH node as the
primary. If set, the Chainlink node will automatically use HTTP mode for heavy
requests, which can improve reliability.

### EVM_NODES

caution

Setting this environment variable will **COMPLETELY ERASE** your `evm_nodes`
table on every boot and repopulate from the given data to nullify any runtime
modifications. This is a temporary solution until this configuration can be
defined in a file in the future.

  * Default: _none_

A JSON array of node specifications that allows you to configure multiple
nodes or chains using an environment variable. This is not compatible with
other environment variables that specify the node such as `ETH_URL` or
`ETH_SECONDARY_URLS`. Set this variable using a configuration like the
following example:


    EVM_NODES='
    [
    	{
    		""name"": ""primary_0_1"",
    		""evmChainId"": ""0"",
    		""wsUrl"": ""ws://test1.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""primary_0_2"",
    		""evmChainId"": ""0"",
    		""wsUrl"": ""ws://test2.invalid"",
    		""httpUrl"": ""https://test3.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""primary_1337_1"",
    		""evmChainId"": ""1337"",
    		""wsUrl"": ""ws://test4.invalid"",
    		""httpUrl"": ""http://test5.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""sendonly_1337_1"",
    		""evmChainId"": ""1337"",
    		""httpUrl"": ""http://test6.invalid"",
    		""sendOnly"": true
    	},
    	{
    		""name"": ""sendonly_0_1"",
    		""evmChainId"": ""0"",
    		""httpUrl"": ""http://test7.invalid"",
    		""sendOnly"": true
    	},
    	{
    		""name"": ""primary_42_1"",
    		""evmChainId"": ""42"",
    		""wsUrl"": ""ws://test8.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""sendonly_43_1"",
    		""evmChainId"": ""43"",
    		""httpUrl"": ""http://test9.invalid"",
    		""sendOnly"": true
    	}
    ]
    '

Usage of Docker requires the variable to be formatted as one line with no
whitespaces and quotes wrapping it, as follows in the example:


    EVM_NODES=[{""name"":""primary_0_1"",""evmChainId"":""0"",""wsUrl"":""ws://test1.invalid"",""sendOnly"":false},{""name"":""primary_0_2"",""evmChainId"":""0"",""wsUrl"":""ws://test2.invalid"",""httpUrl"":""https://test3.invalid"",""sendOnly"":false},{""name"":""primary_1337_1"",""evmChainId"":""1337"",""wsUrl"":""ws://test4.invalid"",""httpUrl"":""http://test5.invalid"",""sendOnly"":false}]

### ETH_SECONDARY_URLS

Only has effect if `ETH_URL` set. Otherwise, it can be set in the API, CLI, or
GUI.

  * Default: _none_

If set, transactions will also be broadcast to this secondary Ethereum node.
This allows transaction broadcasting to be more robust in the face of primary
Ethereum node bugs or failures.

It is recommended to set at least one secondary ETH node here that is
different from your primary.

Multiple URLs can be specified as a comma-separated list e.g.

`ETH_SECONDARY_URLS=https://example.com/1,https://example.text/2,...`

## EVM/Ethereum Global Settings

This configuration is specific to EVM/Ethereum chains.

### ETH_CHAIN_ID

  * Default: _none_

This environment variable specifies the default chain ID. Any job spec that
has not explicitly set `EVMChainID` will connect to this default chain. If you
do not have a chain in the database matching this value, any jobs that try to
use it will throw an error.

### EVM_RPC_ENABLED

  * Default: `""true""`

Enables connecting to real EVM RPC nodes. Disabling this can be useful in
certain cases such as spinning up a Chainlink node and adding EVM-based jobs
without having it actually execute anything on-chain, or for debugging to see
what the node _would_ do without actually doing it.

## EVM/Ethereum Chain-specific Overrides

These configuration options act as an override, setting the value for _all_
chains.

This often doesn't make sense, e.g. `ETH_FINALITY_DEPTH` on Avalanche could be
quite different from `ETH_FINALITY_DEPTH` on Ethereum mainnet.

We recommend setting this on a per-chain basis using the API, CLI, or GUI
instead.

In general, Chainlink nodes contain built-in defaults for most of these
settings that should work out of the box on all officially supported chains,
so it is unlikely you must make any changes here.

### BALANCE_MONITOR_ENABLED

  * Default: `""true""`

Enables Balance Monitor feature. This is required to track balances of keys
locally and warn if it drops too low. It also enables displaying balance in
the Chainlink UI and API.

### BLOCK_BACKFILL_DEPTH

  * Default: `""10""`

This variable specifies the number of blocks before the current head that the
log broadcaster will try to re-consume logs from, e.g. after adding a new job.

### BLOCK_BACKFILL_SKIP

  * Default: `""false""`

This variable enables skipping of very long log backfills. For example, this
happens in a situation when the node is started after being offline for a long
time. This might be useful on fast chains and if only recent chain events are
relevant

### ETH_TX_REAPER_INTERVAL

NOTE: This overrides the setting for _all_ chains, you might want to set this
on a per-chain basis using the API, CLI, or GUI instead

  * Default: `""1h""`

Controls how often the ETH transaction reaper should run, used to delete old
confirmed or fatally_errored transaction records from the database. Setting to
`0` disables the reaper.

### ETH_TX_REAPER_THRESHOLD

  * Default: `""24h""`

Represents how long any confirmed or fatally_errored `eth_tx` transactions
will hang around in the database. If the `eth_tx` is confirmed but still below
`ETH_FINALITY_DEPTH`, it will not be deleted even if it was created at a time
older than this value.

EXAMPLE: With: `EthTxReaperThreshold=1h` and `EthFinalityDepth=50` If current
head is 142, any `eth_tx` confirmed in block 91 or below will be reaped as
long as its `created_at` value is older than the value set for
`EthTxReaperThreshold`.

Setting to `0` disables the reaper.

### ETH_TX_RESEND_AFTER_THRESHOLD

NOTE: This overrides the setting for _all_ chains, you might want to set this
on a per-chain basis using the API, CLI, or GUI instead.

  * Default: _automatically set based on Chain ID, typically 1m_

Controls how long the `ethResender` will wait before re-sending the latest
`eth_tx_attempt`. This is designed a as a fallback to protect against the ETH
nodes dropping transactions (which has been anecdotally observed to happen),
networking issues, or transactions being ejected from the mempool.

Setting to `0` disables the resender.

### ETH_FINALITY_DEPTH

  * Default: _automatically set based on Chain ID, typically 50_

The number of blocks after which an Ethereum transaction is considered
""final"".

`ETH_FINALITY_DEPTH` determines how deeply we look back to ensure that
transactions are confirmed onto the longest chain. There is not a large
performance penalty to setting this relatively high (on the order of
hundreds).

It is practically limited by the number of heads we store in the database
(`HEAD_TRACKER_HISTORY_DEPTH`) and should be less than this with a comfortable
margin. If a transaction is mined in a block more than this many blocks ago,
and is reorged out, we will NOT retransmit this transaction and undefined
behavior can occur including gaps in the nonce sequence that require manual
intervention to fix. Therefore, this number represents a number of blocks we
consider large enough that no re-org this deep will ever feasibly happen.

### ETH_HEAD_TRACKER_HISTORY_DEPTH

  * Default: _automatically set based on Chain ID, typically 100_

Tracks the top N block numbers to keep in the `heads` database table. Note
that this can easily result in MORE than N total records since in the case of
re-orgs we keep multiple heads for a particular block height, and it is also
scoped per chain. This number should be at least as large as
`ETH_FINALITY_DEPTH`. There might be a small performance penalty to setting
this to something very large (10,000+)

### ETH_HEAD_TRACKER_MAX_BUFFER_SIZE

  * Default: `""3""`

The maximum number of heads that can be buffered in front of the head tracker
before older heads start to be dropped. Think this setting as the maximum
permitted ""lag"" for the head tracker before the Chainlink node starts dropping
heads to keep up.

### ETH_HEAD_TRACKER_SAMPLING_INTERVAL

  * Default: _automatically set based on Chain ID, typically 1s_

Head tracker sampling was introduced to handle chains with very high
throughput. If this is set, the head tracker will ""gap"" heads and deliver a
maximum of 1 head per this period.

Set to `0` to disable head tracker sampling.

### ETH_LOG_BACKFILL_BATCH_SIZE

  * Default: _automatic based on Chain ID, typically 100_

Controls the batch size for calling FilterLogs when backfilling missing or
recent logs.

### ETH_LOG_POLL_INTERVAL

  * Default: _automatic based on Chain ID_

Defines how frequently to poll for new logs.

### ETH_RPC_DEFAULT_BATCH_SIZE

  * Default: _automatic based on chain ID_

Chainlink nodes use batch mode for certain RPC calls to increase efficiency of
communication with the remote ETH node. In some cases, trying to request too
many items in a single batch will result in an error (e.g. due to bugs in go-
ethereum, third-party provider limitations, limits inherent to the websocket
channel etc). This setting controls the maximum number of items that can be
requested in a single batch. Chainlink nodes use built-in conservative
defaults for different chains that should work out of the box.

If you have enabled HTTP URLs for all of your ETH nodes, you can safely
increase this to a larger value e.g. 100 and see significant RPC performance
improvements.

### LINK_CONTRACT_ADDRESS

  * Default: _automatic based on Chain ID_

The address of the LINK token contract. It is not essential to provide this,
but if given, it is used for displaying the node account's LINK balance. For
supported chains, this is automatically set based on the given chain ID. For
unsupported chains, you must supply it yourself.

This environment variable is a global override. It is recommended instead to
set this on a per-chain basis.

### MIN_INCOMING_CONFIRMATIONS

  * Default: _automatic based on chain ID, typically 3_

The number of block confirmations to wait before kicking off a job run or
proceeding with a task that listens to blockchain and log events. Setting this
to a lower value improves node response time at the expense of occasionally
submitting duplicate transactions in the event of chain re-orgs (duplicate
transactions are harmless but cost some ETH).

You can override this on a per-job basis.

`MIN_INCOMING_CONFIRMATIONS=1` would kick off a job after seeing the
transaction in just one block.

caution

The lowest value allowed here is 1, since setting to 0 would imply that logs
are processed from the mempool before they are even mined into a block, which
isn't possible with Chainlink's current architecture.

### MIN_OUTGOING_CONFIRMATIONS

  * Default: _automatic based on chain ID, typically 12_

The default minimum number of block confirmations that need to be recorded on
an outgoing `ethtx` task before the run can move onto the next task.

This can be overridden on a per-task basis by setting the
`MinRequiredOutgoingConfirmations` parameter.

`MIN_OUTGOING_CONFIRMATIONS=1` considers a transaction as ""done"" once it has
been mined into one block. `MIN_OUTGOING_CONFIRMATIONS=0` would consider a
transaction as ""done"" even before it has been mined.

### MINIMUM_CONTRACT_PAYMENT_LINK_JUELS

note

  * Default: _automatically set based on Chain ID, typically 10000000000000 (0.00001 LINK) on all chains except Ethereum Mainnet and Sepolia where it is 100000000000000000 (0.1 LINK)._

For jobs that use the `EthTx` adapter, this is the minimum payment amount in
order for the node to accept and process the job. Since there are no decimals
on the EVM, the value is represented like wei.

note

Keep in mind, the Chainlink node currently responds with a 500,000 gas limit.
Under pricing your node could mean it spends more in ETH (on gas) than it
earns in LINK.

### NODE_NO_NEW_HEADS_THRESHOLD

  * Default: _automatically set based on Chain ID, typically ""3m"" (3 minutes)_

Controls how long to wait after receiving no new heads before marking the node
as out-of-sync.

Set to zero to disable out-of-sync checking.

### NODE_POLL_FAILURE_THRESHOLD

  * Default: _automatically set based on Chain ID, typically 3_

Indicates how many consecutive polls must fail in order to mark a node as
unreachable.

Set to zero to disable poll checking.

### NODE_POLL_INTERVAL

  * Default: _automatically set based on Chain ID, typically ""10s"" (10 seconds)_

Controls how often to poll the node to check for liveness.

Set to zero to disable poll checking.

### NODE_SELECTION_MODE

  * Default: `""HighestHead""`

Controls node picking strategy. Supported values:

  * `HighestHead` (default) mode picks a node having the highest reported head number among other alive nodes. When several nodes have the same latest head number, the strategy sticks to the last used node. This mode requires `NODE_NO_NEW_HEADS_THRESHOLD` to be configured, otherwise it will always use the first alive node.
  * `RoundRobin` mode simply iterates among available alive nodes. This was the default behavior prior to this release.
  * `TotalDifficulty` mode selects the node with the greatest total difficulty.

### NODE_SYNC_THRESHOLD

  * Default: `5`

SyncThreshold controls how far a node may lag behind the best node before
being marked out-of-sync. Depending on the [`NODE_SELECTION_MODE`
variable](/chainlink-nodes/v1/configuration/#node_selection_mode), this
represents a difference in either the number of blocks (`HighestHead`,
`RoundRobin`), or the total difficulty (`TotalDifficulty`).

Set to `0` to disable this check.

## EVM Gas Controls

These settings allow you to tune your node's gas limits and pricing. In most
cases, leaving these values at their defaults should give good results.

As of Chainlink node v1.1.0, it is recommended to use the API, CLI, or GUI to
configure gas controls because you might want to use different settings for
different chains. Setting the environment variable typically overrides the
setting for all chains.

### Configuring your ETH node

Your ETH node might need some configuration tweaks to make it fully compatible
with Chainlink nodes depending on your configuration.

#### go-ethereum

WARNING: By default, go-ethereum will reject transactions that exceed it's
built-in RPC gas or txfee caps. Chainlink nodes will fatally error
transactions if this happens which means if you ever exceed the caps your node
will miss transactions.

You should at a bare minimum disable the default RPC gas and txfee caps on
your ETH node. This can be done in the TOML file as seen below, or by running
go-ethereum with the command line arguments: `--rpc.gascap=0
--rpc.txfeecap=0`.

It is also recommended to configure go-ethereum properly before increasing
`ETH_MAX_IN_FLIGHT_TRANSACTIONS` to ensure all in-flight transactions are
maintained in the mempool.

Relevant settings for geth and forks (such as BSC).


    [Eth]
    RPCGasCap = 0 # it is recommended to disable both gas and txfee cap
    RPCTxFeeCap = 0.0
    [Eth.TxPool]
    Locals = [""0xYourNodeAddress1"", ""0xYourNodeAddress2""]  # Add your node addresses here
    NoLocals = false # Disabled by default but might as well make sure
    Journal = ""transactions.rlp"" # Make sure you set a journal file
    Rejournal = 3600000000000 # Default 1h, it might make sense to reduce this to e.g. 5m
    PriceBump = 10 # Must be set less than or equal to Chainlink's ETH_GAS_BUMP_PERCENT
    AccountSlots = 16 # Highly recommended to increase this, must be greater than or equal to Chainlink's ETH_MAX_IN_FLIGHT_TRANSACTIONS setting
    GlobalSlots = 4096 # Increase this as necessary
    AccountQueue = 64 # Increase this as necessary
    GlobalQueue = 1024 # Increase this as necessary
    Lifetime = 10800000000000 # Default 3h, this is probably ok, you might even consider reducing it

### EVM_EIP1559_DYNAMIC_FEES

  * Default: _automatic based on chain ID_

Forces EIP-1559 transaction mode for all chains. Enabling EIP-1559 mode can
help reduce gas costs on chains that support it. This is supported only on
official Ethereum mainnet and testnets. It is not recommended to enable this
setting on Polygon because the EIP-1559 fee market appears to be broken on all
Polygon chains and EIP-1559 transactions are less likely to be included than
legacy transactions.

#### Technical details

Chainlink nodes include experimental support for submitting transactions using
type 0x2 (EIP-1559) envelope.

EIP-1559 mode is enabled by default on the Ethereum Mainnet, but can be
enabled on a per-chain basis or globally.

This might help to save gas on spikes. Chainlink nodes should react faster on
the upleg and avoid overpaying on the downleg. It might also be possible to
set `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` to a smaller value such as 12 or even
6 because tip cap should be a more consistent indicator of inclusion time than
total gas price. This would make Chainlink nodes more responsive and should
reduce response time variance. Some experimentation is required to find
optimum settings.

To enable globally, set `EVM_EIP1559_DYNAMIC_FEES=true`. Set with caution, if
you set this on a chain that does not actually support EIP-1559 your node will
be broken.

In EIP-1559 mode, the total price for the transaction is the minimum of base
fee + tip cap and fee cap. More information can be found on the [official
EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).

Chainlink's implementation of EIP-1559 works as follows:

If you are using FixedPriceEstimator:

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and `tipcap=EVM_GAS_TIP_CAP_DEFAULT`
  * With gas bumping enabled, it will submit all transactions initially with `feecap=EVM_GAS_FEE_CAP_DEFAULT` and `tipcap=EVM_GAS_TIP_CAP_DEFAULT`.

If you are using BlockHistoryEstimator (default for most chains):

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and `tipcap=<calculated using past blocks>`
  * With gas bumping enabled (default for most chains) it will submit all transactions initially with `feecap=current block base fee * (1.125 ^ N)` where N is configurable by setting BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS but defaults to `gas bump threshold+1` and `tipcap=<calculated using past blocks>`

Bumping works as follows:

  * Increase tipcap by `max(tipcap * (1 + ETH_GAS_BUMP_PERCENT), tipcap + ETH_GAS_BUMP_WEI)`
  * Increase feecap by `max(feecap * (1 + ETH_GAS_BUMP_PERCENT), feecap + ETH_GAS_BUMP_WEI)`

A quick note on terminology - Chainlink nodes use the same terms used
internally by go-ethereum source code to describe various prices. This is not
the same as the externally used terms. For reference:

  * Base Fee Per Gas = BaseFeePerGas
  * Max Fee Per Gas = FeeCap
  * Max Priority Fee Per Gas = TipCap

In EIP-1559 mode, the following changes occur to how configuration works:

  * All new transactions will be sent as type 0x2 transactions specifying a TipCap and FeeCap. Be aware that existing pending legacy transactions will continue to be gas bumped in legacy mode.
  * `BlockHistoryEstimator` will apply its calculations (gas percentile etc) to the TipCap and this value will be used for new transactions (GasPrice will be ignored)
  * `FixedPriceEstimator` will use `EVM_GAS_TIP_CAP_DEFAULT` instead of `ETH_GAS_PRICE_DEFAULT` for the tip cap
  * `FixedPriceEstimator` will use `EVM_GAS_FEE_CAP_DEFAULT` instaed of `ETH_GAS_PRICE_DEFAULT` for the fee cap
  * `ETH_MIN_GAS_PRICE_WEI` is ignored for new transactions and `EVM_GAS_TIP_CAP_MINIMUM` is used instead (default 0)
  * `ETH_MAX_GAS_PRICE_WEI` still represents that absolute upper limit that Chainlink will ever spend (total) on a single tx
  * `KEEPER_GAS_PRICE_BUFFER_PERCENT` is ignored in EIP-1559 mode and `KEEPER_TIP_CAP_BUFFER_PERCENT` is used instead

### ETH_GAS_BUMP_PERCENT

  * Default: _automatic based on chain ID_

The percentage by which to bump gas on a transaction that has exceeded
`ETH_GAS_BUMP_THRESHOLD`. The larger of `ETH_GAS_BUMP_PERCENT` and
`ETH_GAS_BUMP_WEI` is taken for gas bumps.

### ETH_GAS_BUMP_THRESHOLD

  * Default: _automatic based on chain ID_

Chainlink nodes can be configured to automatically bump gas on transactions
that have been stuck waiting in the mempool for at least this many blocks. Set
to 0 to disable gas bumping completely.

### ETH_GAS_BUMP_TX_DEPTH

  * Default: `""10""`

The number of transactions to gas bump starting from oldest. Set to 0 for no
limit (i.e. bump all).

### ETH_GAS_BUMP_WEI

  * Default: _automatic based on chain ID_

The minimum fixed amount of wei by which gas is bumped on each transaction
attempt.

### EVM_GAS_FEE_CAP_DEFAULT

  * Default: _automatic based on chain ID_

If EIP1559 mode is enabled, and FixedPrice gas estimator is used, this env var
controls the fixed initial fee cap.

### ETH_GAS_LIMIT_DEFAULT

  * Default: _automatically set based on Chain ID, typically 500000_

The default gas limit for outgoing transactions. This should not need to be
changed in most cases. Some job types, such as Keeper jobs, might set their
own gas limit unrelated to this value.

### ETH_GAS_LIMIT_MAX

  * Default: _automatically set based on Chain ID, typically 500000_

The maxium for gas limits estimated by the `Arbitrum` `GAS_ESTIMATOR_MODE`.
This should not need to be changed in most cases.

### ETH_GAS_LIMIT_MULTIPLIER

  * Default: `""1.0""`

A factor by which a transaction's GasLimit is multiplied before transmission.
So if the value is 1.1, and the GasLimit for a transaction is 10, 10% will be
added before transmission.

This factor is always applied, so includes Optimism L2 transactions which uses
a default gas limit of 1 and is also applied to EthGasLimitDefault.

### ETH_GAS_LIMIT_TRANSFER

  * Default: _automatically set based on Chain ID, typically 21000_

The gas limit used for an ordinary ETH transfer.

### ETH_GAS_PRICE_DEFAULT

(Only applies to legacy transactions)

  * Default: _automatic based on chain ID_

The default gas price to use when submitting transactions to the blockchain.
Will be overridden by the built-in `BlockHistoryEstimator` if enabled, and
might be increased if gas bumping is enabled.

Can be used with the `chainlink setgasprice` to be updated while the node is
still running.

### EVM_GAS_TIP_CAP_DEFAULT

(Only applies to EIP-1559 transactions)

  * Default: _automatic based on chain ID_

The default gas tip to use when submitting transactions to the blockchain.
Will be overridden by the built-in `BlockHistoryEstimator` if enabled, and
might be increased if gas bumping is enabled.

### EVM_GAS_TIP_CAP_MINIMUM

(Only applies to EIP-1559 transactions)

  * Default: _automatic based on chain ID_

The minimum gas tip to use when submitting transactions to the blockchain.

### ETH_MAX_GAS_PRICE_WEI

  * Default: _automatic based on chain ID_

Chainlink nodes will never pay more than this for a transaction.

### ETH_MAX_IN_FLIGHT_TRANSACTIONS

  * Default: `""16""`

Controls how many transactions are allowed to be ""in-flight"" i.e. broadcast
but unconfirmed at any one time. You can consider this a form of transaction
throttling.

The default is set conservatively at 16 because this is a pessimistic minimum
that geth will hold without evicting local transactions. If your node is
falling behind and you need higher throughput, you can increase this setting,
but you MUST make sure that your ETH node is configured properly otherwise you
can get nonce gapped and your node will get stuck.

0 value disables the limit. Use with caution.

### ETH_MAX_QUEUED_TRANSACTIONS

  * Default: _automatically set based on Chain ID, typically 250_

The maximum number of unbroadcast transactions per key that are allowed to be
enqueued before jobs will start failing and rejecting send of any further
transactions. This represents a sanity limit and generally indicates a problem
with your ETH node (transactions are not getting mined).

Do NOT blindly increase this value thinking it will fix things if you start
hitting this limit because transactions are not getting mined, you will
instead only make things worse.

In deployments with very high burst rates, or on chains with large re-orgs,
you _may_ consider increasing this.

0 value disables any limit on queue size. Use with caution.

### ETH_MIN_GAS_PRICE_WEI

(Only applies to legacy transactions)

  * Default: _automatic based on chain ID_

Chainlink nodes will never pay less than this for a transaction.

It is possible to force the Chainlink node to use a fixed gas price by setting
a combination of these, e.g.


    EVM_EIP1559_DYNAMIC_FEES=false
    ETH_MAX_GAS_PRICE_WEI=100
    ETH_MIN_GAS_PRICE_WEI=100
    ETH_GAS_PRICE_DEFAULT=100
    ETH_GAS_BUMP_THRESHOLD=0
    GAS_ESTIMATOR_MODE=""FixedPrice""

### ETH_GAS_LIMIT_OCR_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for OCR jobs. This environment variable does
not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_GAS_LIMIT_DR_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for direct request jobs. This environment
variable does not override task-specific or job-specific `gasLimit` parameters
or attributes.

### ETH_GAS_LIMIT_VRF_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for VRF jobs. This environment variable does
not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_GAS_LIMIT_FM_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for Flux Monitor jobs. This environment
variable does not override task-specific or job-specific `gasLimit` parameters
or attributes.

### ETH_GAS_LIMIT_KEEPER_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for Keeper jobs. This environment variable
does not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_NONCE_AUTO_SYNC

  * Default: `""false""`

Chainlink nodes will automatically try to sync its local nonce with the remote
chain on startup and fast forward if necessary. This is almost always safe but
can be disabled in exceptional cases by setting this value to false.

### ETH_USE_FORWARDERS

  * Default: `""false""`

Enables or disables sending transactions through forwarder contracts.

## EVM/Ethereum Gas Price Estimation

These settings allow you to configure how your node calculates gas prices. In
most cases, leaving these values at their defaults should give good results.

As of Chainlink node v1.1.0, it is recommended to use the API, CLI, or GUI to
configure gas controls because you might want to use different settings for
different chains. Setting the environment variable typically overrides the
setting for all chains.

Chainlink nodes decide what gas price to use using an `Estimator`. It ships
with several simple and battle-hardened built-in estimators that should work
well for almost all use-cases. Note that estimators will change their
behaviour slightly depending on if you are in EIP-1559 mode or not.

You can also use your own estimator for gas price by selecting the
`FixedPrice` estimator and using the exposed API to set the price.

An important point to note is that the Chainlink node does _not_ ship with
built-in support for go-ethereum's `estimateGas` call. This is for several
reasons, including security and reliability. We have found empirically that it
is not generally safe to rely on the remote ETH node's idea of what gas price
should be.

### GAS_ESTIMATOR_MODE

  * Default: _automatic, based on chain ID_

Controls what type of gas estimator is used.

  * `FixedPrice` uses static configured values for gas price (can be set via API call).
  * `BlockHistory` dynamically adjusts default gas price based on heuristics from mined blocks.
  * `Optimism2`/`L2Suggested` is a special mode only for use with Optimism and Metis blockchains. This mode will use the gas price suggested by the rpc endpoint via `eth_gasPrice`.
  * `Arbitrum` is a special mode only for use with Arbitrum blockchains. It uses the suggested gas price (up to `ETH_MAX_GAS_PRICE_WEI`, with `1000 gwei` default) as well as an estimated gas limit (up to `ETH_GAS_LIMIT_MAX`, with `1,000,000,000` default).

### BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE

  * Default: _automatic, based on chain ID, typically 4_

Sets the maximum number of blocks to fetch in one batch in the block history
estimator. If the `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` environment variable is
set to 0, it defaults to ETH_RPC_DEFAULT_BATCH_SIZE.

### BLOCK_HISTORY_ESTIMATOR_BLOCK_HISTORY_SIZE

  * Default: _automatic, based on chain ID_

Controls the number of past blocks to keep in memory to use as a basis for
calculating a percentile gas price.

### BLOCK_HISTORY_ESTIMATOR_BLOCK_DELAY

  * Default: _automatic, based on chain ID_

Controls the number of blocks that the block history estimator trails behind
head. For example, if this is set to 3, and we receive block 10, block history
estimator will fetch block 7.

CAUTION: You might be tempted to set this to 0 to use the latest possible
block, but it is possible to receive a head BEFORE that block is actually
available from the connected node via RPC, due to race conditions in the code
of the remote ETH node. In this case you will get false ""zero"" blocks that are
missing transactions.

### BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS

**ADVANCED**

  * Default: _gas bump threshold + 1 block_

If EIP1559 mode is enabled, this optional env var controls the buffer blocks
to add to the current base fee when sending a transaction. By default, the gas
bumping threshold + 1 block is used. It is not recommended to change this
unless you know what you are doing.

### BLOCK_HISTORY_ESTIMATOR_TRANSACTION_PERCENTILE

  * Default: `""60""`

Must be in range 0-100.

Only has an effect if gas updater is enabled. Specifies percentile gas price
to choose. E.g. if the block history contains four transactions with gas
prices `[100, 200, 300, 400]` then picking 25 for this number will give a
value of 200. If the calculated gas price is higher than
`ETH_GAS_PRICE_DEFAULT` then the higher price will be used as the base price
for new transactions.

Think of this number as an indicator of how aggressive you want your node to
price its transactions.

Setting this number higher will cause the Chainlink node to select higher gas
prices.

Setting it lower will tend to set lower gas prices.

## EVM/Ethereum Transaction Simulation

Chainlink nodes support transaction simulation for certain types of job. When
this is enabled, transactions will be simulated using `eth_call` before
initial send. If the transaction would revert, the transaction is marked as an
error without being broadcast, potentially avoiding an expensive on-chain
revert.

This can add a tiny bit of latency with an upper bound of 2s, but generally
much shorter under good conditions. This will add marginally more load to the
ETH client, because it adds an extra call for every transaction sent. However,
it might help to save gas in some cases especially during periods of high
demand by avoiding unnecessary reverts due to outdated round etc.

This option is EXPERIMENTAL and disabled by default.

To enable for FM or OCR:

`FM_SIMULATE_TRANSACTIONs=true` `OCR_SIMULATE_TRANSACTIONS=true`

To enable in the pipeline, use the `simulate=true` option like so:


    submit [type=ethtx to=""0xDeadDeadDeadDeadDeadDeadDeadDead"" data=""0xDead"" simulate=true]

Use at your own risk.

#### FM_SIMULATE_TRANSACTIONS

NOTE: This overrides the setting for _all_ chains, it is not currently
possible to configure this on a per-chain basis.

  * Default: `""false""`

`FM_SIMULATE_TRANSACTIONS` allows to enable transaction simulation for Flux
Monitor.

#### OCR_SIMULATE_TRANSACTIONS

NOTE: This overrides the setting for _all_ chains, it is not currently
possible to configure this on a per-chain basis.

  * Default: `""false""`

`OCR_SIMULATE_TRANSACTIONS` allows to enable transaction simulation for OCR.

## Job Pipeline and tasks

### DEFAULT_HTTP_LIMIT

  * Default: `""32768""`

`DEFAULT_HTTP_LIMIT` defines the maximum number of bytes for HTTP requests and
responses made by `http` and `bridge` adapters.

### DEFAULT_HTTP_TIMEOUT

  * Default: `""15s""`

`DEFAULT_HTTP_TIMEOUT` defines the default timeout for HTTP requests made by
`http` and `bridge` adapters.

### FEATURE_EXTERNAL_INITIATORS

  * Default: `""false""`

Enables the External Initiator feature. If disabled, `webhook` jobs can ONLY
be initiated by a logged-in user. If enabled, `webhook` jobs can be initiated
by a whitelisted external initiator.

### JOB_PIPELINE_MAX_RUN_DURATION

  * Default: `""10m""`

`JOB_PIPELINE_MAX_RUN_DURATION` is the maximum time that a single job run
might take. If it takes longer, it will exit early and be marked errored. If
set to zero, disables the time limit completely.

### JOB_PIPELINE_MAX_SUCCESSFUL_RUNS

This option is not supported as an environment variable. Use
`JobPipeline.MaxSuccessfulRuns` in the config file instead. See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.12.0/docs/CONFIG.md)
reference for details.

### JOB_PIPELINE_REAPER_INTERVAL

  * Default: `""1h""`

In order to keep database size manageable, Chainlink nodes will run a reaper
that deletes completed job runs older than a certain threshold age.
`JOB_PIPELINE_REAPER_INTERVAL` controls how often the job pipeline reaper will
run.

Set to `0` to disable the periodic reaper.

### JOB_PIPELINE_REAPER_THRESHOLD

  * Default: `""24h""`

`JOB_PIPELINE_REAPER_THRESHOLD` determines the age limit for job runs.
Completed job runs older than this will be automatically purged from the
database.

### JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH

  * Default: `""100""`

Some jobs write their results asynchronously for performance reasons such as
OCR. `JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH` controls how many writes will be
buffered before subsequent writes are dropped.

Do not change this setting unless you know what you are doing.

## OCR

This section applies only if you are running off-chain reporting jobs.

### FEATURE_OFFCHAIN_REPORTING

  * Default: `""false""`

Set to `true` to enable OCR jobs.

### OCR_KEY_BUNDLE_ID

  * Default: _none_

`OCR_KEY_BUNDLE_ID` is the default key bundle ID to use for OCR jobs. If you
have an OCR job that does not explicitly specify a key bundle ID, it will fall
back to this value.

### OCR_MONITORING_ENDPOINT

  * Default: _none_

Optional URL of OCR monitoring endpoint.

### OCR_TRANSMITTER_ADDRESS

  * Default: _none_

`OCR_TRANSMITTER_ADDRESS` is the default sending address to use for OCR. If
you have an OCR job that does not explicitly specify a transmitter address, it
will fall back to this value.

### P2P_NETWORKING_STACK

  * Default: `""V1""`

OCR supports multiple networking stacks. `P2P_NETWORKING_STACK` chooses which
stack to use. Possible values are:

  * `V1`
  * `V1V2` \- Runs both stacks simultaneously. For each link with another peer, V2 networking will be preferred. If V2 does not work, the link will automatically fall back to V1. If V2 starts working again later, it will automatically be prefered again. This is useful for migrating networks without downtime. Note that the two networking stacks _must not_ be configured to bind to the same IP/port.
  * `V2`

All nodes in the OCR network should share the same networking stack. The `V1`
stack is deprecated and is being phased out. Do not use it for new
deployments. Expect the default value of this variable to change to `V2` in
the future.

#### P2P_PEER_ID

  * Default: _none_

This environment variable is used for both Networking Stack V1 and V2.

The default peer ID to use for OCR jobs. If unspecified, uses the first
available peer ID. Example:
`P2P_PEER_ID=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U`

### Networking Stack V1

caution

Do not set environment variables for Networking Stack v1 if you are using
Networking Stack V2.

#### P2P_ANNOUNCE_IP

  * Default: _none_

Should be set as the externally reachable IP address of the Chainlink node.
Example: `P2P_ANNOUNCE_IP=1.2.3.4`

#### P2P_ANNOUNCE_PORT

  * Default: _none_

Should be set as the externally reachable port of the Chainlink node. Example:
`P2P_ANNOUNCE_PORT=1337`

#### P2P_BOOTSTRAP_PEERS

  * Default: _none_

Default set of bootstrap peers. Example:
`P2P_BOOTSTRAP_PEERS=/dns4/example.com/tcp/1337/p2p/12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U
/ip4/1.2.3.4/tcp/9999/p2p/12D3KooWLZ9uTC3MrvKfDpGju6RAQubiMDL7CuJcAgDRTYP7fh7R`

#### P2P_LISTEN_IP

  * Default: `""0.0.0.0""`

The default IP address to bind to.

#### P2P_LISTEN_PORT

  * Default: _none_

The port to listen on. If left blank, the node randomly selects a different
port each time it boots. It is highly recommended to set this to a static
value to avoid network instability.

#### P2P_PEER_ID

  * Default: _none_

This environment variable is used for both Networking Stack V1 and V2.

The default peer ID to use for OCR jobs. If unspecified, uses the first
available peer ID. Example:
`P2P_PEER_ID=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U`

### Networking Stack V2

caution

If using the Networking Stack V2, you must unset the following Networking
Stack V1 configuration variables:

  * P2P_ANNOUNCE_IP
  * P2P_ANNOUNCE_PORT
  * P2P_BOOTSTRAP_PEERS
  * P2P_LISTEN_IP
  * P2P_LISTEN_PORT

`P2P_PEER_ID` is used for both Networking Stack V1 and V2.

The Networking Stack V2 uses TCP, any ports mentioned in this section refer to
TCP ports.

#### P2PV2_ANNOUNCE_ADDRESSES

  * Default: _none_

`P2PV2_ANNOUNCE_ADDRESSES` contains the addresses the node will advertise for
peer discovery in host:port form as accepted by the TCP version of Go's
[`net.Dial`](https://pkg.go.dev/net#Dial). The addresses should be reachable
by other nodes on the network. When attempting to connect to another node, a
node will attempt to dial all of the other node's `P2PV2_ANNOUNCE_ADDRESSES`
in round-robin fashion. Example: `P2PV2_ANNOUNCE_ADDRESSES=1.2.3.4:9999
[a52d:0:a88:1274::abcd]:1337`

#### P2PV2_BOOTSTRAPPERS

  * Default: _none_

`P2PV2_BOOTSTRAPPERS` returns the default bootstrapper peers for libocr's v2
networking stack. Example:
`P2PV2_BOOTSTRAPPERS=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U@1.2.3.4:9999
12D3KooWLZ9uTC3MrvKfDpGju6RAQubiMDL7CuJcAgDRTYP7fh7R@[a52d:0:a88:1274::abcd]:1337
12D3KooWM55u5Swtpw9r8aFLQHEtw7HR4t44GdNs654ej5gRs2Dh@example.com:1234`

Oracle nodes typically only know each other's PeerIDs, but not their
hostnames, IP addresses, or ports. Bootstrappers are special nodes that help
other nodes discover each other's `P2PV2_ANNOUNCE_ADDRESSES` so they can
communicate. Nodes continuously attempt to connect to bootstrappers configured
in `P2PV2_BOOTSTRAPPERS`. When a node wants to connect to another node (which
it knows only by PeerID, but not by address), it discovers the other node's
`P2PV2_ANNOUNCE_ADDRESSES` from communications received from its
`P2PV2_BOOTSTRAPPERS` or other discovered nodes. To facilitate discovery,
nodes will regularly broadcast signed announcements containing their PeerID
and `P2PV2_ANNOUNCE_ADDRESSES`.

#### P2PV2_LISTEN_ADDRESSES

  * Default: _none_

`P2PV2_LISTEN_ADDRESSES` contains the addresses the peer will listen to on the
network in `host:port` form as accepted by `net.Listen()`, but the host and
port must be fully specified and cannot be empty. You can specify `0.0.0.0`
(IPv4) or `::` (IPv6) to listen on all interfaces, but that is not
recommended.

Example: `P2PV2_LISTEN_ADDRESSES=1.2.3.4:9999 [a52d:0:a88:1274::abcd]:1337`

## Keeper

These environment variables are used specificly for Chainlink Keepers. For
most Chainlink Nodes, leave these values at their defaults and do not
configure these environment variables.

### KEEPER_GAS_PRICE_BUFFER_PERCENT

caution

  * Default: `""20""`

`KEEPER_GAS_PRICE_BUFFER_PERCENT` adds the specified percentage to the gas
price used for checking whether to perform an upkeep. Only applies in legacy
mode (EIP-1559 off).

### KEEPER_GAS_TIP_CAP_BUFFER_PERCENT

caution

  * Default: `""20""`

`KEEPER_GAS_TIP_CAP_BUFFER_PERCENT` adds the specified percentage to the gas
price used for checking whether to perform an upkeep. Only applies in EIP-1559
mode.

### KEEPER_BASE_FEE_BUFFER_PERCENT

caution

  * Default: `""20""`

Adds the specified percentage to the base fee used for checking whether to
perform an upkeep. Applies only in EIP-1559 mode.

### KEEPER_MAXIMUM_GRACE_PERIOD

caution

  * Default: `""100""`

The maximum number of blocks that a keeper will wait after performing an
upkeep before it resumes checking that upkeep

### KEEPER_REGISTRY_CHECK_GAS_OVERHEAD

caution

  * Default: `""200000""`

The amount of extra gas to provide checkUpkeep() calls to account for the gas
consumed by the keeper registry.

### KEEPER_REGISTRY_PERFORM_GAS_OVERHEAD

caution

  * Default: `""300000""`

The amount of extra gas to provide performUpkeep() calls to account for the
gas consumed by the keeper registry

### KEEPER_REGISTRY_SYNC_INTERVAL

caution

  * Default: `""30m""`

The interval in which the RegistrySynchronizer performs a full sync of the
keeper registry contract it is tracking.

### KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE

caution

  * Default: `""10""`

`KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE` represents the maximum number of
upkeeps that can be synced in parallel.

### KEEPER_TURN_LOOK_BACK

caution

  * Default: `""1000""`

The number of blocks in the past to look back when getting a block for a turn.

## CLI Client

The environment variables in this section apply only when running CLI commands
that connect to a remote running instance of a Chainlink node.

### ADMIN_CREDENTIALS_FILE

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--admin-credentials-file FILE` CLI argument instead.

  * Default: `$ROOT/apicredentials`

`ADMIN_CREDENTIALS_FILE` optionally points to a text file containing admin
credentials for logging in. It is useful for running client CLI commands and
has no effect when passed to a running node.

The file should contain two lines, the first line is the username and second
line is the password. e.g.


    myusername@example.com
    mysecurepassw0rd

### CLIENT_NODE_URL

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--remote-node-url URL` CLI argument instead.

  * Default: `""http://localhost:6688""`

This is the URL that you will use to interact with the node, including the
GUI. Use this URL to connect to the GUI or to run commands remotely using the
Chainlink CLI.

### INSECURE_SKIP_VERIFY

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--insecure-skip-verify` CLI argument instead.

  * Default: `""false""`

`INSECURE_SKIP_VERIFY` disables SSL certificate verification when connection
to a Chainlink node using the remote client. For example, when executing most
remote commands in the CLI. This is mostly useful for people who want to use
TLS on localhost.

It is not recommended to change this unless you know what you are doing.

## Notes on setting environment variables

note

Some environment variables require a duration. A duration string is a possibly
signed sequence of decimal numbers, each with optional fraction and a unit
suffix, such as ""300ms"", ""-1.5h"" or ""2h45m"". Valid time units are ""ns"", ""us""
(or ""µs""), ""ms"", ""s"", ""m"", ""h"". Some examples:

`10ms` `1h15m` `42m30s`

note

Some configuration variables require a file size. A file size string is an
unsigned integer (123) or a float (12.3) followed by a unit suffix. Valid file
size units are ""b"", ""kb"", ""mb"", ""gb"", and ""tb"". If the unit is omitted, it is
assumed to be ""b"" (bytes). Capitalization does not matter. Some examples:

`123gb` `1.2TB` `12345`

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/configuration.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Role-Based Access Control (RBAC)

  * Overview

Chainlink Nodes allow the root admin CLI user and any additional admin users
to create and assign tiers of role-based access to new users. These new API
users can able to log in to the Operator UI independently.

Each user has a specific role assigned to their account. There are four roles:
`admin`, `edit`, `run`, and `view`.

If there are multiple users who need specific access to manage the Chainlink
Node instance, permissions and level of access can be set here.

User management is configured through the use of the admin `chainlink admin
users` command. Run `chainlink admin login` before you set user roles for
other accounts. For example, a read-only user can be created with the
following command:


    chainlink admin users create --email=operator-ui-read-only@test.com --role=view

Specific actions are enabled to check role-based access before they execute.
The following table lists the actions that have role-based access and the role
that is required to run that action:

| Action                                        | Read   | Run   | Edit   | Admin   |
|:----------------------------------------------|:-------|:------|:-------|:--------|
| Update password                               | X      | X     | X      | X       |
| Create self API token                         | X      | X     | X      | X       |
| Delete self API token                         | X      | X     | X      | X       |
| List external initiators                      | X      | X     | X      | X       |
| Create external initiator                     | nan    | nan   | X      | X       |
| Delete external initiator                     | nan    | nan   | X      | X       |
| List bridges                                  | X      | X     | X      | X       |
| View bridge                                   | X      | X     | X      | X       |
| Create bridge                                 | nan    | nan   | X      | X       |
| Edit bridge                                   | nan    | nan   | X      | X       |
| Delete bridge                                 | nan    | nan   | X      | X       |
| View config                                   | X      | X     | X      | X       |
| Update config                                 | nan    | nan   | nan    | X       |
| Dump env/config                               | nan    | nan   | nan    | X       |
| View transaction attempts                     | X      | X     | X      | X       |
| View transaction attempts EVM                 | X      | X     | X      | X       |
| View transactions                             | X      | X     | X      | X       |
| Replay a specific block number                | nan    | X     | X      | X       |
| List keys (CSA,ETH,OCR(2),P2P,Solana,Terra)   | X      | X     | X      | X       |
| Create keys (CSA,ETH,OCR(2),P2P,Solana,Terra) | nan    | nan   | X      | X       |
| Delete keys (CSA,ETH,OCR(2),P2P,Solana,Terra) | nan    | nan   | nan    | X       |
| Import keys (CSA,ETH,OCR(2),P2P,Solana,Terra) | nan    | nan   | nan    | X       |
| Export keys (CSA,ETH,OCR(2),P2P,Solana,Terra) | nan    | nan   | nan    | X       |
| List jobs                                     | X      | X     | X      | X       |
| View job                                      | X      | X     | X      | X       |
| Create job                                    | nan    | nan   | X      | X       |
| Delete job                                    | nan    | nan   | X      | X       |
| List pipeline runs                            | X      | X     | X      | X       |
| View job runs                                 | X      | X     | X      | X       |
| Delete job spec errors                        | nan    | nan   | X      | X       |
| View features                                 | X      | X     | X      | X       |
| View log                                      | X      | X     | X      | X       |
| Update log                                    | nan    | nan   | nan    | X       |
| List chains                                   | X      | X     | X      | X       |
| View chain                                    | X      | X     | X      | X       |
| Create chain                                  | nan    | nan   | X      | X       |
| Update chain                                  | nan    | nan   | X      | X       |
| Delete chain                                  | nan    | nan   | X      | X       |
| View nodes                                    | X      | X     | X      | X       |
| Create node                                   | nan    | nan   | X      | X       |
| Update node                                   | nan    | nan   | X      | X       |
| Delete node                                   | nan    | nan   | X      | X       |
| View forwarders                               | X      | X     | X      | X       |
| Create forwarder                              | nan    | nan   | X      | X       |
| Delete forwarder                              | nan    | nan   | X      | X       |
| Create job run                                | nan    | X     | X      | X       |
| Create Transfer EVM                           | nan    | nan   | nan    | X       |
| Create Transfer Terra                         | nan    | nan   | nan    | X       |
| Create Transfer Solana                        | nan    | nan   | nan    | X       |
| Create user                                   | nan    | nan   | nan    | X       |
| Delete user                                   | nan    | nan   | nan    | X       |
| Edit user                                     | nan    | nan   | nan    | X       |
| List users                                    | nan    | nan   | nan    | X       |
The run command allows for minimal interaction and only enables the ability to
replay a specific block number and kick off a job run.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/roles-and-access.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the 'fulfill' function in this contract?,The 'fulfill' function is used to record the fulfillment of a Chainlink request and update the 'volume' state variable with the provided volume.,{'source': 'https://docs.chain.link/any-api/get-request/examples/single-word-response/'},"To determine the state/country's law that governs the interpretation of the contract, we need to refer to the extracted parts of the document. However, none of the extracted parts provide information about the state/country's law that governs the interpretation of the contract. Therefore, we cannot determine the state/country's law based on the given information.

",None,"# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates with the _Functions Billing Registry_ , which
assigns a unique identifier (aka _Subscription ID_ ).

### Fund Subscription

You must fund your subscription accounts with enough LINK tokens:

  1. Connect your EOA to the _Subscription App_.
  2. Fund your subscription account. The _Subscriptions App_ abstracts the following: 
    1. Call `transferAndCall` on the LINK token contract, transferring LINK tokens along with the _Subscription ID_ in the payload.
    2. The _Functions Billing Registry_ contract implements `onTokenTransfer`: It parses the _Subscription ID_ from the payload and funds the subscription account with the transferred LINK amount.

### Add Consumer

You must allowlist your consumers' contracts on your subscription account
before they can make Chainlink Functions requests. To do so:

  1. Connect your EOA to the _Subscription App_.
  2. Add the address of your consumer contract to your subscription account.
  3. The _Subscription App_ calls the _Functions Billing Registry_ contract to add the consumer contract address to your subscription account.

### Remove Consumer

To remove a consumer contract:

  1. Connect your EOA to the _Subscription App_.
  2. Remove the address of your consumer contract from the allowlist.
  3. The _Subscription App_ calls the _Functions Billing Registry_ contract to remove the consumer contract address from your subscription account.

**Note** : You can still remove consumers from your subscription if there are
in-flight requests. Your consumer contract will still be called back, and your
_Subscription Account_ will be charged.

### Cancel Subscription

To cancel a subscription:

  1. Connect your EOA to the _Subscription App_.
  2. Cancel your subscription, passing the _Subscription Balance_ receiver account address. The _Subscriptions App_ abstracts the following: 
    1. Call the `cancelSubscription` function on the _Functions Billing Registry_ contract, deleting the _Subscription ID_ and removing any existing consumers.
    2. The outstanding _Subscription Balance_ is sent to the receiver account.

**Note** : You cannot cancel a subscription if there are in-flight requests.

### Transferring ownership of a Subscription

Transferring ownership works as follows:

  1. Connect your EOA to the _Subscription App_.
  2. Initiate the ownership transfer by specifying the new owner's address.
  3. The new owner must connect their EOA to the _Subscription App_ and accept the ownership.

## What's next

  * [› Billing](/chainlink-functions/resources/billing)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/architecture.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Local testing using a Mock contract

  * Overview
  * Benefits of local testing
  * Testing logic
  * Prerequisites
  * Testing
  * Open the contracts on RemixIDE
  * Select the correct RemixIDE environment
  * Deploy VRFCoordinatorV2Mock
  * Deploy MockV3Aggregator
  * Deploy LinkToken
  * Deploy VRFV2Wrapper
  * Configure the VRFV2Wrapper
  * Fund the VRFV2Wrapper subscription
  * Deploy the VRF consumer contract
  * Fund your VRF consumer contract
  * Request random words
  * Fulfill the VRF request
  * Check the results
  * Next steps

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to test Chainlink VRF v2 on a [Remix
IDE](https://remix-ide.readthedocs.io/en/latest/run.html#environment) sandbox
blockchain environment. **Note** : You can reuse the same logic on another
development environment, such as Hardhat or Truffle. For example, read the
Hardhat Starter Kit [RandomNumberDirectFundingConsumer unit
tests](https://github.com/smartcontractkit/hardhat-starter-kit/blob/main/test/unit/RandomNumberDirectFundingConsumer.spec.js).

Test on public testnets thoroughly

Even though local testing has several benefits, testing with a VRF mock covers
the bare minimum of use cases. Make sure to test your consumer contract
throughly on public testnets.

## Benefits of local testing

Testing locally using mock contracts saves you time and resources during
development. Some of the key benefits include:

  * Faster feedback loop: Immediate feedback on the functionality and correctness of your smart contracts. This helps you quickly identify and fix issues without waiting for transactions to be mined/validated on a testnet.
  * Saving your native testnet tokens: Deploying and interacting with contracts requires paying gas fees. Although testnet native tokens do not have any value associated with them, their supply is limited by public faucets. Using mock contracts locally allows you to test your contracts freely without incurring any expenses.
  * Controlled environment: Local testing allows you to create a controlled environment where you can manipulate various parameters, such as block time and gas prices, to test your smart contracts' function as expected under different conditions.
  * Isolated testing: You can focus on testing individual parts of your contract, ensuring they work as intended before integrating them with other components.
  * Easier debugging: Because local tests run on your machine, you have better control over the debugging process. You can set breakpoints, inspect variables, and step through your code to identify and fix issues.
  * Comprehensive test coverage: You can create test cases to cover all possible scenarios and edge cases.

## Testing logic

Complete the following tasks to test your VRF v2 consumer locally:

  1. Deploy the [VRFCoordinatorV2Mock](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol). This contract is a mock of the [VRFCoordinatorV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) contract.
  2. Deploy the [MockV3Aggregator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/tests/MockV3Aggregator.sol) contract.
  3. Deploy the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/LinkToken.sol) contract.
  4. Deploy the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) contract.
  5. Call the VRFV2Wrapper [setConfig function](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol#L119) to set wrapper specific parameters.
  6. Fund the VRFv2Wrapper subscription.
  7. Call the the VRFCoordinatorV2Mock [addConsumer function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L229) to add the wrapper contract to your subscription.
  8. Deploy your VRF consumer contract.
  9. Fund your consumer contract with LINK tokens.
  10. Request random words from your consumer contract.
  11. Call the VRFCoordinatorV2Mock [fulfillRandomWords function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L88) to fulfill your consumer contract request.

## Prerequisites

This guide will require you to finetune the gas limit when fulfilling
requests. When writing, manually setting up the gas limits on RemixIDE is not
supported, so you will use RemixIDE in conjunction with
[Metamask](https://metamask.io/). [Ganache](https://trufflesuite.com/ganache/)
lets you quickly fire up a personal Ethereum blockchain. If you still need to
install Ganache, follow the [official
guide](https://trufflesuite.com/docs/ganache/quickstart/).

  1. Once Ganache is installed, click the _QUICKSTART_ button to start a local Ethereum node.

**Note** : Make sure to note the RPC server. In this example, the RPC server
is _<http://127.0.0.1:7545/>_.

  2. Follow the Metamask [official guide](https://support.metamask.io/hc/en-us/articles/360043227612-How-to-add-a-custom-network-RPC#h_01G63GGJ83DGDRCS2ZWXM37CV5) to add a custom network manually.

  3. Import a Ganache account into Metamask.

    1. On Ganache, click on the _key_ symbol of the first account:

    2. Copy the private key:

    3. Follow the Metamask [official guide](https://support.metamask.io/hc/en-us/articles/360015489331-How-to-import-an-account) to import an account using a private key.

    4. Your Metamask is connected to _Ganache_ , and you should have access to the newly imported account.

## Testing

### Open the contracts on RemixIDE

Open _VRFCoordinatorV2Mock_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol"";
    

Open _MockV3Aggregator_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol"";
    

Open _LinkToken_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.4.24;
    
    import ""@chainlink/contracts/src/v0.4/LinkToken.sol"";
    

Open _VRFV2Wrapper_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/VRFV2Wrapper.sol"";
    

Open _RandomNumberDirectFundingConsumerV2_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UNAUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract RandomNumberDirectFundingConsumerV2 is
        VRFV2WrapperConsumerBase,
        ConfirmedOwner
    {
        event RequestSent(uint256 requestId, uint32 numWords, uint256 paid);
        event RequestFulfilled(
            uint256 requestId,
            uint256[] randomWords,
            uint256 payment
        );
        error InsufficientFunds(uint256 balance, uint256 paid);
        error RequestNotFound(uint256 requestId);
        error LinkTransferError(address sender, address receiver, uint256 amount);
    
        struct RequestStatus {
            uint256 paid; // amount paid in link
            bool fulfilled; // whether the request has been successfully fulfilled
            uint256[] randomWords;
        }
        mapping(uint256 => RequestStatus)
            public s_requests; /* requestId --> requestStatus */
    
        // past requests Id.
        uint256[] public requestIds;
        uint256 public lastRequestId;
    
        // configuration: https://docs.chain.link/vrf/v2/direct-funding/supported-networks#configurations
        constructor(
            address _linkAddress,
            address _wrapperAddress
        )
            ConfirmedOwner(msg.sender)
            VRFV2WrapperConsumerBase(_linkAddress, _wrapperAddress)
        {}
    
        // Depends on the number of requested values that you want sent to the
        // fulfillRandomWords() function. Test and adjust
        // this limit based on the network that you select, the size of the request,
        // and the processing of the callback request in the fulfillRandomWords()
        // function.
        // The default is 3, but you can set this higher.
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.
        function requestRandomWords(
            uint32 _callbackGasLimit,
            uint16 _requestConfirmations,
            uint32 _numWords
        ) external onlyOwner returns (uint256 requestId) {
            requestId = requestRandomness(
                _callbackGasLimit,
                _requestConfirmations,
                _numWords
            );
            uint256 paid = VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit);
            uint256 balance = LINK.balanceOf(address(this));
            if (balance < paid) revert InsufficientFunds(balance, paid);
            s_requests[requestId] = RequestStatus({
                paid: paid,
                randomWords: new uint256[](0),
                fulfilled: false
            });
            requestIds.push(requestId);
            lastRequestId = requestId;
            emit RequestSent(requestId, _numWords, paid);
            return requestId;
        }
    
        function fulfillRandomWords(
            uint256 _requestId,
            uint256[] memory _randomWords
        ) internal override {
            RequestStatus storage request = s_requests[_requestId];
            if (request.paid == 0) revert RequestNotFound(_requestId);
            request.fulfilled = true;
            request.randomWords = _randomWords;
            emit RequestFulfilled(_requestId, _randomWords, request.paid);
        }
    
        function getNumberOfRequests() external view returns (uint256) {
            return requestIds.length;
        }
    
        function getRequestStatus(
            uint256 _requestId
        )
            external
            view
            returns (uint256 paid, bool fulfilled, uint256[] memory randomWords)
        {
            RequestStatus memory request = s_requests[_requestId];
            if (request.paid == 0) revert RequestNotFound(_requestId);
            return (request.paid, request.fulfilled, request.randomWords);
        }
    
        /**
         * Allow withdraw of Link tokens from the contract
         */
        function withdrawLink(address _receiver) public onlyOwner {
            bool success = LINK.transfer(_receiver, LINK.balanceOf(address(this)));
            if (!success)
                revert LinkTransferError(
                    msg.sender,
                    _receiver,
                    LINK.balanceOf(address(this))
                );
        }
    }
    

Your RemixIDE file explorer should display the opened contracts:

### Select the correct RemixIDE environment

Under _DEPLOY & RUN TRANSACTIONS_:

  1. Set the Environment to _Injected Provider - Metamask_ :

  2. On Metamask, connect your Ganache account to the Remix IDE.

  3. Click on Connect. The RemixIDE environment should be set to the correct environment, and the account should be the Ganache account.

### Deploy VRFCoordinatorV2Mock

  1. Open _VRFCoordinatorV2Mock.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _VRFCoordinatorV2Mock_.

  3. Under _DEPLOY_ , fill in the `_BASEFEE` and `_GASPRICELINK`. These variables are used in the _VRFCoordinatorV2Mock_ contract to represent the base fee and the gas price (in LINK tokens) for the VRF requests. You can set: `_BASEFEE=100000000000000000` and `_GASPRICELINK=1000000000`.

  4. Click on _transact_ to deploy the _VRFCoordinatorV2Mock_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _VRFCoordinatorV2Mock_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Deploy MockV3Aggregator

The _MockV3Aggregator_ contract is designed for testing purposes, allowing you
to simulate an oracle price feed without interacting with the existing
Chainlink network.

  1. Open _MockV3Aggregator.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _MockV3Aggregator_.

  3. Under _DEPLOY_ , fill in `_DECIMALS` and `_INITIALANSWER`. These variables are used in the _MockV3Aggregator_ contract to represent the number of decimals the aggregator's answer should have and the most recent price feed answer. You can set: `_DECIMALS=18` and `_INITIALANSWER=3000000000000000` (We are considering that `1 LINK = 0.003 native tokens`).

  4. Click on _transact_ to deploy the _MockV3Aggregator_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _MockV3Aggregator_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Deploy LinkToken

The Chainlink VRF v2 direct funding method requires your consumer contract to
pay for VRF requests in LINK. Therefore, you have to deploy the _LinkToken_
contract to your local blockchain.

  1. Open _LinkToken.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _LinkToken_.

  3. Under _DEPLOY_ , click on _transact_ to deploy the _LinkToken_ contract.

  4. A Metamask popup will open. Click on _Confirm_.

  5. Once deployed, you should see the _LinkToken_ contract under _Deployed Contracts_.

  6. Note the address of the deployed contract.

### Deploy VRFV2Wrapper

As the VRF v2 direct funding [end-to-end diagram](/vrf/v2/direct-funding#request-and-receive-data) explains, the _VRFV2Wrapper_ acts as a
wrapper for the coordinator contract.

  1. Open _VRFV2Wrapper.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _VRFV2Wrapper_.

  3. Under _DEPLOY_ , fill in `_LINK` with the _LinkToken_ contract address, `_LINKETHFEED` with the _MockV3Aggregator_ contract address, and `_COORDINATOR` with the _VRFCoordinatorV2Mock_ contract address.

  4. click on _transact_ to deploy the _VRFV2Wrapper_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _VRFV2Wrapper_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Configure the VRFV2Wrapper

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFV2Wrapper_ contract.

  2. Click on `setConfig` and fill in `_wrapperGasOverhead` with `60000`, `_coordinatorGasOverhead` with `52000`, `_wrapperPremiumPercentage` with `10`, `_keyHash` with `0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc`, and `_maxNumWords` with `10`. **Note** on these variables:

    1. `_wrapperGasOverhead`: This variable reflects the gas overhead of the wrapper's fulfillRandomWords function. The cost for this gas is passed to the user.

    2. `_coordinatorGasOverhead`: This variable reflects the gas overhead of the coordinator's `fulfillRandomWords` function. The cost for this gas is billed to the _VRFV2Wrapper_ subscription and must, therefore, be included in the VRF v2 direct funding requests pricing.

    3. `_wrapperPremiumPercentage`: This variable is the premium ratio in percentage. For example, a value of 0 indicates no premium. A value of 15 indicates a 15 percent premium.

    4. `_keyHash`: The gas lane key hash value is the maximum gas price you are willing to pay for a request in wei.

    5. `_maxNumWords`: This variable is the maximum number of words requested in a VRF v2 direct funding request.

  3. click on _transact_.

  4. A Metamask popup will open. Click on _Confirm_.

### Fund the VRFV2Wrapper subscription

When deployed, the _VRFV2Wrapper_ contract creates a new subscription and adds
itself to the newly created subscription. If you started this guide from
scratch, the subscription ID should be 1.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click `fundSubscription` to fund the _VRFV2Wrapper_ subscription. In this example, you can set the `_subid` to `1` (which is your newly created subscription ID) and the `_amount` to `10000000000000000000` (10 LINK).

  3. A Metamask popup will open. Click on _Confirm_.

### Deploy the VRF consumer contract

  1. In the file explorer, open _RandomNumberDirectFundingConsumerV2.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _RandomNumberDirectFundingConsumerV2_.

  3. Under _DEPLOY_ , fill in `_LINKADDRESS_` with the _LinkToken_ contract address, and `_WRAPPERADDRESS_` with the deployed _VRFV2Wrapper_ address.

  4. Click on _transact_ to deploy the _RandomNumberDirectFundingConsumerV2_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _RandomNumberDirectFundingConsumerV2_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Fund your VRF consumer contract

  1. Under _Deployed Contracts_ , open the functions list of your deployed _LinkToken_ contract.

  2. Click on _transfer_ and fill in the `_to` with your consumer contract address and `_value` with LINK tokens amount. For this example, you can set the `_value` to `10000000000000000000` (10 LINK).

  3. Click on _transact_.

  4. A Metamask popup will open. Click on _Confirm_.

### Request random words

Request three random words.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_ contract.

  2. In `requestRandomWords`, fill in `_callbackGasLimit` with `300000`, `_requestConfirmations` with `3` and `_numWords` with `3`.

  3. Click on _transact_.

  4. A Metamask popup will open.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _400,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _400000_ and select **Save**.
Finally, confirm the transaction.

  5. Click on _Confirm_.

  6. In the RemixIDE console, read your transaction logs to find the VRF request ID. In this example, the request ID is _1_.

  7. Note your request ID.

### Fulfill the VRF request

Because you are testing on a local blockchain environment, you must fulfill
the VRF request yourself.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click `fulfillRandomWords` and fill in `_requestId` with your VRF request ID and `_consumer` with the _VRFV2Wrapper_ contract address.

  3. Click on `transact`.

  4. A Metamask popup will open.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _1,000,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _1000000_ and select **Save**.
Finally, confirm the transaction.

  5. Click on _Confirm_.

  6. In the RemixIDE console, read your transaction logs to find the random words.

### Check the results

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberDirectFundingConsumerV2_ contract.

  2. Click on `lastRequestId` to display the last request ID. In this example, the output is _1_.

  3. Click on `getRequestStatus` with `_requestId` equal to `1`:

  4. You will get the amount paid, the status, and the random words.

## Next steps

This guide demonstrated how to test a VRF v2 consumer contract on your local
blockchain. We made the guide on RemixIDE for learning purposes, but you can
reuse the same testing logic on another development environment, such as
Truffle or Hardhat. For example, read the Hardhat Starter Kit
[RandomNumberDirectFundingConsumer unit
tests](https://github.com/smartcontractkit/hardhat-starter-kit/blob/main/test/unit/RandomNumberDirectFundingConsumer.spec.js).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding/examples/test-locally.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-11-09 23:44:03)
Chainlink node external adapter executes successfully, but keeps returning 0
URL: https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0

Question Body:


I'm trying to build an external adapter for a chainlink node to import API
information. On the chainlink node and API, everything seems like it worked,
however when I try to call the stored value from the smart contract, it's
always 0 despite the logs indicating that it ran successfully.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Mimi-Fund-EA""
    externalJobID = ""834d2179-321d-49ac-bf63-140635e3a606""
    forwardingAllowed = false
    maxTaskDuration = ""0s""
    contractAddress = ""0xAf644831B57E5625ac64cDa68248b810bE4D4D01""
    minContractPaymentLinkJuels = ""0""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""mimifund"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""year\\"": $(decode_cbor.year), \\""discount_rate\\"": $(decode_cbor.discount_rate)}}""]
        parse        [type=jsonparse path=""data,result"" data=""$(fetch)""]
        ds_multiply  [type=""multiply"" times=1000000000000000000]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(ds_multiply) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xAf644831B57E5625ac64cDa68248b810bE4D4D01"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> ds_multiply-> encode_data -> encode_tx -> submit_tx
    """"""
    

These are the run logs from the Node. Everything compiled just fine and the
values look good however, they never update in a smart contract, it's always
0.

[](https://i.stack.imgur.com/ZUw17.png)

This is my smart contract for reference.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@openzeppelin/contracts/utils/Strings.sol"";
    
    contract mimifundCO2 is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
        bytes32 private jobId;
        uint256 private fee;
    
        event RequestVolume(bytes32 indexed requestId, uint256 volume);
    
        /**
         * @notice Initialize the link token and target oracle
         *
         * Goerli Testnet details:
         * Link Token: 0x326C977E6efc84E512bB9C30f76E30c160eD06FB
         * Oracle: 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 (Chainlink DevRel)
         * jobId: ca98366cc7314957b8c012c72f05aeeb
         *
         */
        constructor() ConfirmedOwner(msg.sender) {
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            setChainlinkOracle(0xAf644831B57E5625ac64cDa68248b810bE4D4D01);
            jobId = ""834d2179321d49acbf63140635e3a606"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        }
    
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestCO2PricingData(uint256 _year) public returns (bytes32 requestId) {
            Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
            req.add('year', Strings.toString(_year)); // Chainlink nodes 1.0.0 and later support this format
            req.add('discount_rate', '0.0'); // Chainlink nodes 1.0.0 and later support this format
    
            // Sends the request
            return sendChainlinkRequest(req, fee);
        }
    
        /**
         * Receive the response in the form of uint256
         */
        function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
            emit RequestVolume(_requestId, _volume);
            volume = _volume;
        }
    
        /**
         * Allow withdraw of Link tokens from the contract
         */
        function withdrawLink() public onlyOwner {
            LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
            require(link.transfer(msg.sender, link.balanceOf(address(this))), 'Unable to transfer');
        }
    }
    
    

I feel like there is some update to either my fulfill function or submit_tx
that I need to update, but I am out of ideas about what to change.

I've tried changing all the parameters and both the API and chainlink node
accurate update and reflect the correct input. The smart contract seems to
work perfectly, it's just that calling volume in the code always returns 0 and
I've got no clue what the issue is.



Answers:
(Answered on: 2022-11-11 06:51:31)


According to your description, Chainlink node received your request and run
the job successfully, but failed to write the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

Question: (Asked on: 2021-10-08 20:12:22)
How to debug Chainlink job task?
URL: https://stackoverflow.com/questions/69501265/how-to-debug-chainlink-job-task

Question Body:


We are trying to call an API(Deployed on my machine using ngrok for testing)
from Chainlink. We are following the tutorial at
<https://docs.chain.link/docs/advanced-tutorial/> and using Rinkeby network.
The only things we have changed are job id, oracle id and API URL which
returns a simple json. We can see the transaction happening and even a fee of
0.1 LINK is deducted. But the API is not called(We know this because I can see
the realtime logs of the API) and hence the response value is also not fetched
in smart contract.

How to debug this? Is there a way to check logs of the job?

Below is my contract code:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.7.6;
    
    import ""@chainlink/contracts/src/v0.7/ChainlinkClient.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
     */
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public temperature;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        constructor () {
            setPublicChainlinkToken();
            oracle = 0x46cC5EbBe7DA04b45C0e40c061eD2beD20ca7755;
            jobId = ""60803b12c6de4443a99a6078aa59ef79"";
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network and job)
        }
        
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);        
            request.add(""get"", ""http://my-api.com"");
            request.add(""path"", ""temperature"");
    
            // Multiply the result by 1000000000000000000 to remove decimals
            // int timesAmount = 10**18;
            // request.addInt(""times"", timesAmount);
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of int
         */ 
        function fulfill(bytes32 _requestId, uint256 _temperature) public recordChainlinkFulfillment(_requestId) {
            temperature = _temperature;
        }
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    



Answers:
(Answered on: 2021-10-11 16:31:55)


The best way to get started debugging chainlink jobs is to look into the logs.
There are 2 main ways to look into the logs.

  1. If running in a docker container:

Run this command to find the name of the docker container.

    
    
    docker ps
    

Then

    
    
    docker logs <NAME_OF_DOCKER_CONTAINER>
    

  2. Read the `log.jsonl` file. If you created this in your `.chainlink-rinkeby` folder, it'll be in `.chainlink-rinkeby/log.jsonl`

Otherwise you can read the `JSON` of the job that you're debugging.

[](https://i.stack.imgur.com/nhVAp.png)



"
What can you expect to stay up to date on by subscribing to the Chainlink Developer mailing list?,"You can expect to stay up to date on releases, package updates, new features, breaking changes, events, and connecting with other developers.",{'source': 'https://docs.chain.link/resources/developer-communications?parent=anyApi/'},"By subscribing to the Chainlink Developer mailing list, you can expect to stay up to date on releases, package updates, new features, breaking changes, events, and connect with other developers.
",https://docs.chain.link/resources/developer-communications?parent=anyApi/,"# Contributing to Chainlink

  * Overview
  * Contributing to Software and Tooling
  * Raising an Issue
  * Requesting a new Feature
  * Submitting a Pull Request
  * Contributing to the documentation
  * Creating Community Content
  * Becoming a Developer Expert
  * Joining the Chainlink Community Advocate program
  * Running a Chainlink Focused Developer Bootcamp
  * Running an In-Person Meetup or Watch Party
  * Participate in a Hackathon
  * Applying for a Grant

Chainlink is an open-source project licensed [under the MIT
license](https://github.com/smartcontractkit/chainlink/blob/master/LICENSE),
and we encourage contributions from all developers and community members.

# What It Means to Contribute

When you contribute to the Chainlink project, you as a developer or community
member contribute your time and effort to help improve and grow Chainlink.
Your contribution can be from various methods:

  * Building and maintaining the Chainlink software and tools
  * Improving and maintaining the documentation, including translations into other languages
  * Creating Chainlink focused content (blog posts, tutorials, videos etc)
  * Becoming a developer expert
  * Becoming a community advocate
  * Running a Chainlink focused developer Bootcamp (in person or online)
  * Running an in-person meetup or watch party
  * Participate in a hackathon
  * Applying for a grant

# Why Should You Contribute

[Open source software](https://en.wikipedia.org/wiki/Open-source_software) is
a model that brings multiple benefits for both the project and the
contributors. As a developer or community member, contributing to Chainlink
helps you to gain valuable skills and experience, improve the software that
you use, and grow your personal brand in the community which can lead to
future employment opportunities. On top of these awesome things, contributing
to open source is fun. It can give you a sense of community involvement, and
gives you a personal sense of satisfaction knowing that you're part of an
effort to build something that will enable a fairer, more transparent, and
efficient new world.

# Ways to Contribute

## Contributing to Software and Tooling

The most direct way you can contribute to Chainlink is to contribute to the
core code or the various tooling found in our [GitHub
repository](https://github.com/smartcontractkit/). Contributing to code or
code-based tools can generally be split into a few different categories:

  * Raising an issue
  * Requesting a new feature
  * Submitting a Pull Request (PR) for a fix, improvement, or new tool

### Raising an Issue

During the course of using Chainlink software or tools, you might encounter
errors or unexpected behavior that leads you to believe the software isn't
behaving correctly. You can bring this to the attention of the Chainlink Labs
team as well as the wider developer community by raising an issue in the
project’s GitHub repository. The 'Issues' tab lists all of the open issues for
the repository.

After an issue is raised and tagged, the Chainlink Labs team and the wider
community can address it. This gives the issue the visibility required for
someone to investigate it and resolve the issue.

When you first create an issue, you must also categorize it. This prefixes the
issue name to give viewers an indication of what category the issue relates
to:

  * [NODE]: The issue relates to the core node software
  * [DEVEL]: The issue is a result of working on code found in the current repository
  * [FEAT]: The issue relates to a new feature request
  * [SMRT]: The issue related to using Chainlink smart contracts
  * [EXPL]: The issue related to using the Chainlink Explorer
  * [FAUC]: The issue related to using the Chainlink Faucet



After you select a category, enter the details for the issue. Include as much
detail about the issue as possible. Provide a thorough description,
environment, and software version details. Also provide detailed steps that
describe how to reproduce the issue. The more thorough you make your
description, the better the chances are that someone will be able to pick up
the issue and resolve it.

Once a team member acknowledges that the issue has been received, they will
tag it with an appropriate label. You should then monitor the state of the
open issue for any questions or updates.

### Requesting a new Feature

Have you thought of an improvement or an awesome new feature that you think
should be implemented into Chainlink? Request a new feature to bring it to the
attention of the team and the wider community. You can request new features by
creating a new GitHub issue in the correct repository and tagging that issue
with the [FEAT] prefix (Feature request). The process for doing this is
covered in the Raising an Issue section. Provide as much detail as possible in
your feature request, including any benefits, risks, or considerations that
you can think of.

#### Voting on new features

Sometimes a new feature is put to a vote to decide if it's something that the
team and wider community should implement. When a feature is put to a vote,
the issue is tagged with the 'needs votes' label. You can contribute to the
voting process by reacting to the first post in the feature request with a
thumbs up or thumbs down emoji. This will help drive the decision. You can
also contribute your thoughts by replying directly to the feature request with
a new post in the thread.



### Submitting a Pull Request

The best way to contribute to Chainlink is to submit a [pull request
(PR)](https://docs.github.com/en/github/collaborating-with-pull-
requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests). PRs can be submitted for various reasons, such as fixing an
identified issue, adding a feature or improvement to the project, or even
adding an entirely new repository to the Chainlink source code for a new tool
or feature. If you're looking for something to pick up and create a PR for,
you can search through the Chainlink repositories to find open issues, and
approved feature requests.

If you're new to contributing to open-source software or Chainlink, we've
tagged some [good first
issues](https://github.com/smartcontractkit/chainlink/issues?q=is%3Aissue+label%3A%22good+first+issue%22)
against the main node software and smart contracts that you can tackle. Each
major repository in the Chainlink GitHub should also have some good first
issues tagged for developers to be able to take on.

All code changes must follow the [style guide]
(<https://github.com/smartcontractkit/chainlink/wiki/Code-Style-Guide>), All
PRs must be in an appropriately named branch with a format like 'feat/feature-
description' or 'devel/issue-description'. After you submit a PR, you should
get a response by a team member within a day or two acknowledging that the PR
has been received. After that, monitor the PR for any additional questions or
updates that come up while the team and the community review the changes.

## Contributing to the documentation

The [Chainlink documentation](https://docs.chain.link/) is the go-to place for
developers who want to learn how to build applications using Chainlink, and
node operators wanting useful information on running a Chainlink node. The
documentation is [open
source](https://github.com/smartcontractkit/documentation), allowing for other
developers and community members to contribute to adding or improving it. You
can contribute to the Chainlink documentation in various ways:

  * Improving the readability of pages
  * Fixing typos or grammar errors
  * Adding new guides or tutorials that you would find useful
  * Translating the documentation into other languages

The process for contributing to the documentation follows the process defined
earlier in the Submitting a Pull Request section. Each page also has a
'Suggest Edits' link on the top right, and will directly take you to the page
in the [documentation
repository](https://github.com/smartcontractkit/documentation), where you can
create a new PR with the suggested changes. Before you create a PR for the
documentation, read the [contributing
guidelines](https://github.com/smartcontractkit/documentation/blob/main/CONTRIBUTING.md).

If you want to translate the documentation into a new language that is not yet
supported, feel free to [reach out to the
team](mailto:devrel@smartcontract.com) beforehand, so we can make sure you get
the support you need.

## Creating Community Content

Chainlink has a strong and vibrant community of developers and community
advocates. Community members often create Chainlink-focused content in various
forms and publish it for the wider community on various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually hosted](https://blog.chain.link/smart-contract-developer-bootcamp-on-demand/) the first [Chainlink Developer
Bootcamp](http://chain.link/bootcamp). If you're passionate about educating
others about smart contracts and Chainlink, you can contribute by running your
own developer Bootcamp. You can also contribute by translating an existing
Bootcamp and running it in another language. Before you run your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Developer Communications

  * Overview

The Chainlink Developer mailing list is the best place to stay up to date on

  * Releases
  * Package Updates
  * New Features
  * Breaking Changes
  * Events
  * Connecting with other developers

## Subscribe to the latest Chainlink Developer news

### 微信中文开发者社区

### (WeChat Chinese Developer Community)

[
https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE](https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/developer-communications.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the benefit of using Off-Chain Reporting (OCR) for Chainlink oracle networks?,"Submitting only one transaction per round reduces overall network congestion, individual node operators spend less on gas costs, node networks are more scalable, and data feeds can be updated in a more timely manner.",{'source': 'https://docs.chain.link/architecture-overview/off-chain-reporting/'},"The benefit of using Off-Chain Reporting (OCR) for Chainlink oracle networks is that it increases decentralization and scalability. With OCR, all nodes communicate using a peer-to-peer network and a lightweight consensus algorithm is run to aggregate data observations. This allows for a single aggregate transaction to be transmitted, saving a significant amount of gas. OCR also allows for the preservation of trustlessness properties in Chainlink oracle networks. 

","
- https://docs.chain.link/architecture-overview/off-chain-reporting/
- https://stackoverflow.com/questions/69806583/implementation-of-chainlink-feed-aggregator","# Data Feeds Architecture

  * Overview
  * Basic Request Model
  * Decentralized Data Model
  * Off-Chain Reporting

## Basic Request Model

Chainlink connects smart contracts with external data using its decentralized
oracle network. Chainlink API requests are handled 1:1 by an oracle.

The [Basic Request Model](/architecture-overview/architecture-request-model)
describes the on-chain architecture of requesting data from a single oracle
source.

To learn how to make a GET request using a single oracle, see [Make a GET
Request](/any-api/get-request/introduction).

## Decentralized Data Model

For a more robust and trustworthy answer, you can aggregate data from many
oracles. With on-chain aggregation, data is aggregated from a decentralized
network of independent oracle nodes. This architecture is applied to Chainlink
Data Feeds, which can aggregate data such as asset price data.

The [Decentralized Data Model](/architecture-overview/architecture-decentralized-model) describes how data is aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Off-Chain Reporting

  * Overview
  * What is OCR?
  * How does OCR work?

Off-Chain Reporting (OCR) is a significant step towards increasing the
decentralization and scalability of Chainlink networks. See the [OCR Protocol
Paper](https://research.chain.link/ocr.pdf) for a technical deep dive.

For Off-Chain Reporting aggregators, all nodes communicate using a peer to
peer network. During the communication process, a lightweight consensus
algorithm runs where each node reports its data observation and signs it. A
single aggregate transaction is then transmitted, which saves a significant
amount of gas.

The report contained in the aggregate transaction is signed by a quorum of
oracles and contains all oracles' observations. By validating the report on-
chain and checking the quorum's signatures on-chain, we preserve the
trustlessness properties of Chainlink oracle networks.

## What is OCR?

A simple analogy

Imagine ordering 10 items from an online store. Each item is packaged
separately and posted separately, meaning postage and packaging costs must be
applied to each one, and the carrier has to transport 10 different boxes.

OCR, on the other hand, packages all of these items into a single box and
posts that. This saves postage and packaging fees and all effort the carrier
associates with transporting 9 fewer boxes.

The OCR protocol allows nodes to aggregate their observations into a single
report off-chain using a secure P2P network. A single node then submits a
transaction with the aggregated report to the chain. Each report consists of
many nodes' observations and has to be signed by a quorum of nodes. These
signatures are verified on-chain.

Submitting only one transaction per round achieves the following benefits:

  * Overall network congestion from Chainlink oracle networks is reduced dramatically
  * Individual node operators spend far less on gas costs
  * Node networks are more scalable because data feeds can accommodate more nodes
  * Data feeds can be updated in a more timely manner since each round needn't wait for multiple transactions to be confirmed before a price is confirmed on-chain.

## How does OCR work?

Protocol execution happens mostly off-chain over a peer to peer network
between Chainlink nodes. The nodes regularly elect a new leader node that
drives the rest of the protocol.

The leader regularly requests followers to provide freshly signed observations
and aggregates them into a report. It then sends this report back to the
followers and asks them to verify the report's validity. If a quorum of
followers approves the report by sending a signed copy back to the leader, the
leader assembles a final report with the quorum's signatures and broadcasts it
to all followers.

The nodes attempt to transmit the final report to the aggregator contract
according to a randomized schedule. The aggregator verifies that a quorum of
nodes signed the report and exposes the median value to consumers as an answer
with a block timestamp and a round ID.

All nodes watch the blockchain for the final report to remove any single point
of failure during transmission. If the designated node fails to get their
transmission confirmed within a determined period, a round-robin protocol
kicks in so other nodes can also transmit the final report until one of them
is confirmed.

## What's next

  * [› Using Data Feeds](/data-feeds/price-feeds/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/off-chain-reporting.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-11-02 07:13:18)
Implementation of Chainlink Feed Aggregator
URL: https://stackoverflow.com/questions/69806583/implementation-of-chainlink-feed-aggregator

Question Body:


I'm trying to implement chainlink feed aggregator just like it is for ETH and
other price feed provided by chainlink.

I have found this FluxAggregator in version 0.6 but currently chainlink has
version 0.8 and there is no FluxAggregator in 0.8.
<https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/FluxAggregator.sol>

Also I found this FeedRegistry Repo <https://github.com/smartcontractkit/feed-
registry> This repo has FeedRegistry.sol contract which is implementing
'AggregatorV2V3Interface.sol' from version 0.7 of chainlink.

So its all mixed up and I'm not sure what is the right path to look for
implementation of Aggregator



Answers:
(Answered on: 2021-11-02 22:54:01)


The current version of aggregation used is called ""OCR"" or ""Off-Chain
Reporting"". FluxAggregator was the previous aggregation method. The code and
contracts for OCR can be found in this repo:

<https://github.com/smartcontractkit/libocr>

Running your own feeds isn't officially supported _yet_ (this is being worked
on), so there isn't any documentation, but it is possible to run your own feed
using that code if you really need to. You could also aggregate a couple of
""[Chainlink AnyAPI](https://docs.chain.link/docs/make-a-http-get-request/)""
requests in your contract to simulate a feed.

If this is for a hackathon (or just to demo your app) and there's no existing
data feed for the data you need, I'd suggest using the ""AnyAPI"" feature and a
single Chainlink node, so you can focus on your application and not on
building an oracle network. Once it's time to go to production/mainnet, the
Chainlink Labs team can assist you in making a decentralized oracle network.
You can reach them here on the [Chainlink website](https://chain.link/data-
feeds).

Reference: [OCR Announcement Blog](https://blog.chain.link/off-chain-
reporting-live-on-mainnet/)



"
What are external initiators and how do they enable blockchain agnostic cross-chain compatibility?,External initiators allow jobs in a node to be initiated depending on some external condition. The ability to create and add external initiators to Chainlink nodes enables blockchain agnostic cross-chain compatibility.,{'source': 'https://docs.chain.link/chainlink-nodes/external-initiators/external-initiators-introduction/'},"External initiators are a feature in Chainlink nodes that allow jobs to be initiated based on external conditions. They enable blockchain agnostic cross-chain compatibility. External initiators can be created using the remote API or the Chainlink CLI. They require a name and an optional URL for notification purposes. The external initiator can then trigger webhook jobs that have been linked to it. To delete an external initiator, the remote API or the Chainlink CLI can be used. The list of installed external initiators can also be viewed using the remote API or the Chainlink CLI. External initiators are disabled by default and need to be enabled by setting the `FEATURE_EXTERNAL_INITIATORS` environment variable to true. 

","- https://docs.chain.link/chainlink-nodes/external-initiators/external-initiators-in-nodes/
- https://docs.chain.link/chainlink-nodes/external-initiators/external-initiators-introduction/
- https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli","# Adding External Initiators to Nodes

  * Overview
  * Creating an external initiator
  * Deleting an external initiator
  * Listing external initiators

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

## Creating an external initiator

To create an external initiator you must use the remote API. You can do this
yourself, like so:


    POST http://<your chainlink node>/v2/external_initiators -d <PAYLOAD>

where payload is a JSON blob that contains:


    {
      ""name"": <MANDATORY UNIQUE NAME>,
      ""url"": <OPTIONAL EXTERNAL INITIATOR URL>
    }

If a URL is provided, Chainlink will notify this URL of added and deleted jobs
that can be triggered by this external initiator. This allows the external
initiator to program in certain actions e.g. subscribing/unsubscribing to logs
based on the job, etc.

On creation:


    POST <URL> -d {""jobId"": <job external UUID>, ""type"": <name of external initiator>, ""params"": <optional arbitrary JSON specified at job creation time>}

On deletion:


    DELETE <URL>/<job external UUID>

You can use the chainlink client for convenience to access this API.

Enter the [Chainlink nodes CLI](/chainlink-nodes/resources/miscellaneous/#execute-commands-running-docker) and run the
following command


    chainlink initiators create <NAME> <URL>

`NAME`: The name you want to use for your external initiator. `URL`: The URL
of your jobs endpoint. ie: `http://172.17.0.1:8080/jobs`

This will give you the environment variables you need to run your external
initiator. Copy the output. It will look something like this:


    ║ ei_name  ║ http://localhost:8080/jobs ║ a4846e85727e46b48889c6e28b555696 ║ dnNfNhiiCTm1o6l+hGJVfCtRSSuDfZbj1VO4BkZG3E+b96lminE7yQHj2KALMAIk ║ iWt64+Q9benOf5JuGwJtQnbByN9rtHwSlElOVpHVTvGTP5Zb2Guwzy6w3wflwyYt ║ 56m38YkeCymYU0kr4Yg6x3e98CyAu+37y2+kMO2AL9lRMjA3hRA1ejFdG9UfFCAE

Be sure to save these values, since the secrets cannot be shown again.

You now can use `ei_name` as an initiator in your jobspec.

Set a new `.env` file, and add the respective values


    EI_DATABASEURL=postgresql://$USERNAME:$PASSWORD@$SERVER:$PORT/$DATABASE
    EI_CHAINLINKURL=http://localhost:6688
    EI_IC_ACCESSKEY=<INSERT KEY>
    EI_IC_SECRET=<INSERT KEY>
    EI_CI_ACCESSKEY=<INSERT KEY>
    EI_CI_SECRET=<INSERT KEY>

At the time of writing, the output should be in order. For example, in from
the output above, `EI_IC_ACCESSKEY=a4846e85727e46b48889c6e28b555696` and so
on.

Start your EI.

Whatever code you used to run your external initiator, pass it the new headers
created for the access headers, and then start your service. An easy way to do
this is by having it read from the `.env` file you just created. Check out the
[Conflux External initiator](https://github.com/Conflux-Network-Global/demo-cfx-chainlink) for an example.

You'll want to test that your job is running properly. Meeting the criteria of
your EI and then checking to see if a sample job kicks off is the best way to
test this.

To try a real-life example, feel free to follow along with the [Conflux EI
demo](https://www.youtube.com/watch?v=J8oJEp4qz5w).

Additional external initiator reference

note

The External Initiator can only initiate [webhook jobs](/chainlink-nodes/oracle-jobs/job-types/webhook) that have been linked to it. Trying to
initiate a job that is not linked will give an unauthorised error.

## Deleting an external initiator

To delete an external initiator you must use the remote API. You can do this
yourself, like so:


    DELETE http://<your chainlink node>/v2/external_initiators/<external initiator name>

You can alternatively use the chainlink client for convenience:


    chainlink initiators destroy <NAME>

## Listing external initiators

To see your installed external initiators:


    GET http://<your chainlink node>/v2/external_initiators?size=100&page=1

Or, using the chainlink client:


    chainlink initiators list

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-in-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Introduction

  * Overview

External initiators allow jobs in a node to be initiated depending on some
external condition. The ability to create and add external initiators to
Chainlink nodes enables blockchain agnostic cross-chain compatibility.

note

At this time of writing, external initiators do not show up in the bridges
tab. However, they act exactly the same as if they did.

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

Initiator Bridges handle the authentication to and from the External Initiator
and where to send the messages. When creating a Bridge two parameters are
required:

Only the [webhook](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) job
type can be initiated using an External Initiator.

The external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators to
nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes).

## What's next

  * [› Building External Initiators](/chainlink-nodes/external-initiators/building-external-initiators)
  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-09-22 09:33:38)
Can&#39;t create external initiators from chainlink CLI
URL: https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli

Question Body:


We're trying to set external initiators to our chainlink containers deployed
in GKE cluster according to the docs: <https://docs.chain.link/docs/external-
initiators-in-nodes/>

I log into the the pod:

`kubectl exec -it -n chainlink chainlink-75dd5b6bdf-b4kwr -- /bin/bash`

And there I attempt to create external initiators:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink initiators create xxx xxx
    No help topic for 'initiators'
    

I don’t even see initiators in chainlink cli options:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink
    NAME:
       chainlink - CLI for Chainlink
    
    USAGE:
       chainlink [global options] command [command options] [arguments...]
    
    VERSION:
       0.9.10@7cd042c1a94c57219ed826a6eab46752d63fa67a
    
    COMMANDS:
       admin           Commands for remotely taking admin related actions
       attempts, txas  Commands for managing Ethereum Transaction Attempts
       bridges         Commands for Bridges communicating with External Adapters
       config          Commands for the node's configuration
       job_specs       Commands for managing Job Specs (jobs V1)
       jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json, -j     json output as opposed to table
       --help, -h     show help
       --version, -v  print the version
    

Chainlink version 0.9.10.

Could you please clarify what am I doing wrong?



Answers:
(Answered on: 2021-09-28 21:51:21)


You need to make sure you have the `FEATURE_EXTERNAL_INITIATORS` environment
variable set to true in your .env file as such:

`FEATURE_EXTERNAL_INITIATORS=true`

This will open up access to the `initiators` command in the Chainlink CLI and
you can resume the instructions from there.



"
What is the purpose of the GET>bool function in the given text?,"To perform an HTTP GET request to any public API, parse the response, and return a boolean value.",{'source': 'https://docs.chain.link/any-api/testnet-oracles/'},"The purpose of the GET>bool function in the given text is to make an HTTP GET request to any public API and parse the response to return a boolean value. It is used in the context of Chainlink's Any API to retrieve data from external sources for smart contracts. 
",https://docs.chain.link/any-api/introduction/,"# Chainlink Any API Documentation

  * Overview
  * Requesting off-chain data
  * Building external adapters

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=AnyAPI) to talk to an expert
about using Chainlink Any API to get your data on chain.

**Connecting to any API** with Chainlink enables your contracts to access to
_any_ external data source through our decentralized oracle network. We
understand making smart contracts compatible with off-chain data adds to the
complexity of building smart contracts. We created a framework with minimal
requirements, yet unbounded flexibility, so developers can focus more on the
functionality of smart contracts rather than what feeds them. Chainlink’s
decentralized oracle network provides smart contracts with the ability to push
and pull data, facilitating the interoperability between on-chain and off-
chain applications.

Whether your contract requires sports results, the latest weather, or any
other publicly available data, the [Chainlink contract
library](https://github.com/smartcontractkit/chainlink/tree/master/contracts)
provides the tools required for your contract to consume it.

Prerequisites

You should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                                                                                                                                                                                                                                                |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                                                                                                                             |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                                                                             |
| HTTP GET Element in Array Response | This guide explains how to make an HTTP GET request that returns a json array and parse it to retrieve the target element's value.                                                                                                                         |
| HTTP GET Large Reponses            | This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.                                                                                   |
| Existing Job Request               | This guide explains how to call a job that leverages External adapters and returns the relevant data to the smart contract. This allows building succinct smart contracts that do not need to comprehend the URL or the response format of the target API. |
### Building external adapters

To learn more about building external adapters and adding them to nodes, refer
to the [External Adapters](/chainlink-nodes/external-adapters/external-adapters) documentation.

To understand different use cases for using any API, refer to [Other
Tutorials](/getting-started/other-tutorials).

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› API Reference](/any-api/api-reference/)
  * [› Find Existing Jobs](/any-api/find-oracle/)
  * [› Testnet Oracles](/any-api/testnet-oracles/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Testnet Oracles

  * Overview
  * Operator Contracts
  * Jobs
  * Job IDs
  * Examples

The Chainlink Developer Relations team maintains several testnet oracles that
you can use to test your implementation quickly.

Link token address and Faucet details

To retrieve the LINK token address or get faucet details for your testnet of
choice, see the [LINK Token Contracts](/resources/link-token-contracts) page.

## Operator Contracts

Testnet [Operator
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
are deployed and maintained on the following networks:

| Testnet          | Oracle Address                             |
|:-----------------|:-------------------------------------------|
| Ethereum Sepolia | 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD |
| Ethereum Goerli  | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
| Avalanche Fuji   | 0x022EEA14A6010167ca026B32576D6686dD7e85d2 |
| Polygon Mumbai   | 0x40193c8518BB267228Fc409a613bDbD8eC5a97b3 |
| Binance Testnet  | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
| Fantom Testnet   | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
## Jobs

### Job IDs

To make testing simple, jobs are configured with the following properties:

  * Each request on testnets costs 0.1 LINK.
  * Each oracle will wait for 1 confirmation before processing a request.
  * Jobs have the same IDs accross testnets.
  * Parameters are required. See examples for code snippets.

| Purpose                                                                                                                                                            | Tasks                                | Job ID                           | Required Parameters                                                           |
|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------|:---------------------------------|:------------------------------------------------------------------------------|
| GET>bytes: HTTP GET to any public API parse the response return arbitrary-length raw byte data bytes. The job specs can be found here                              | Http JsonParse Ethabiencode          | 7da2702f37fd48e5b1b9a5715e3509b6 | get: stringpath: JSONPath expression with comma(,) delimited string           |
| GET>uint256: HTTP GET to any public API parse the reponse multiply the result by a multiplier return an unsigned integer uint256 . The job specs can be found here | Http JsonParse Multiply Ethabiencode | ca98366cc7314957b8c012c72f05aeeb | get: stringpath: JSONPath expression with comma(,) delimited stringtimes: int |
| GET>int256: HTTP GET to any public API parse the response multiply the result by a multiplier return a signed integer int256. The job specs can be found here      | Http JsonParse Multiply Ethabiencode | fcf4140d696d44b687012232948bdd5d | get: stringpath: JSONPath expression with comma(,) delimited stringtimes: int |
| GET>bool: HTTP GET to any public API parse the response return a boolean bool. The job specs can be found here                                                     | Http JsonParse Ethabiencode          | c1c5e92880894eb6b27d3cae19670aa3 | get: stringpath: JSONPath expression with comma(,) delimited string           |
| GET>string: HTTP GET to any public API parse the response return a sequence of characters string. The job specs can be found here                                  | Http JsonParse Ethabiencode          | 7d80a6386ef543a3abb52817f6707e3b | get: stringpath: JSONPath expression with comma(,) delimited string           |
### Examples

#### Get > bytes

A full example can be found [here](/any-api/get-request/examples/large-responses).

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('7da2702f37fd48e5b1b9a5715e3509b6', address(this), this.fulfill.selector);
      req.add(
          'get',
          'https://ipfs.io/ipfs/QmZgsvrA1o1C8BGCrx6mHTqR1Ui1XqbCrtbMVrRLHtuPVD?filename=big-api-response.json'
      );
      req.add('path', 'image');
      sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
    }

##### Callback method


    bytes public data;
    string public imageUrl;
    function fulfill(bytes32 requestId, bytes memory bytesData) public recordChainlinkFulfillment(requestId) {
        data = bytesData;
        imageUrl = string(data);
    }

#### Get > uint256

A full example can be found [here](/any-api/get-request/examples/single-word-response).

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('ca98366cc7314957b8c012c72f05aeeb', address(this), this.fulfill.selector);
      req.add(
          'get',
          'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD'
      );
      req.add('path', 'RAW,ETH,USD,VOLUME24HOUR');
      req.addInt('times', 10**18); // Multiply by times value to remove decimals. Parameter required so pass '1' if the number returned doesn't have decimals
      sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
    }

##### Callback method


    uint256 public volume;
    function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
      volume = _volume;
    }

#### Get > int256

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('fcf4140d696d44b687012232948bdd5d', address(this), this.fulfill.selector);
      req.add(
          'get',
          'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD'
      );
      req.add('path', 'RAW,ETH,USD,VOLUME24HOUR');
      req.addInt('times', 10**18); // Multiply by times value to remove decimals. Parameter required so pass '1' if the number returned doesn't have decimals
      sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
    }

##### Callback method


    int256 public volume;
    function fulfill(bytes32 _requestId, int256 _volume) public recordChainlinkFulfillment(_requestId) {
      volume = _volume;
    }

#### Get > bool

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('c1c5e92880894eb6b27d3cae19670aa3', address(this), this.fulfill.selector);
      req.add(
          'get',
          'https://app.proofi.com/api/verify/eip155/0xCB5085214B6318aF3dd0FBbb5E74fbF6bf332151?contract=0x2f7f7E44ca1e2Ca1A54db4222cF97ab47EE026F1'
      );
      req.add('path', 'approved');
      sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
    }

##### Callback method


    bool public approved;
    function fulfill(bytes32 _requestId, bool _approved) public recordChainlinkFulfillment(_requestId) {
      approved = _approved;
    }

#### Get > string

A full example can be found [here](/any-api/get-request/examples/array-response).

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('7d80a6386ef543a3abb52817f6707e3b', address(this), this.fulfill.selector);
      req.add(
          'get',
          'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&per_page=10'
      );
      req.add('path', '0,id');
      sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
    }

##### Callback method


    string public id;
    function fulfill(bytes32 _requestId, string memory _id) public recordChainlinkFulfillment(_requestId) {
      id = _id;
    }

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/testnet-oracles.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-10-28 10:04:53)
Chainlink Automation upKeep not working. checkUpKeep is not calling performUpKeep
URL: https://stackoverflow.com/questions/74233765/chainlink-automation-upkeep-not-working-checkupkeep-is-not-calling-performupkee

Question Body:


Our Dapp will have an NFT Auction functionality, which we are trying to
automate 100% using chainlink. The auction winner will get the NFT and the
Previous owner will get the highest Bid, Platform will get a small cut as
well. To do that, we are using CHainlink Keeper/Automation. I've set the
`checkUpKeep` & `performUpKeep`, both are working fine when I'm doing
everything manually. But when I am registering an upKeep for automaton.

When I input the deployed contract's address into the register upkeep box, it
says `Unable to verify if this is an Automation compatible contract`. Why this
warning? How do I make the contract Automation compatible contract?
[](https://i.stack.imgur.com/nykbp.jpg)

`checkUpKeep` is working good: [](https://i.stack.imgur.com/HFmZ5.jpg)

If I pass this `performData` into `performUpKeep` everything will work fine.

Code/Contracts:
<https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8>

Chainlink upKeep:
<https://automation.chain.link/mumbai/21891159634677518530356555981285976030474691922841692133624884405593696766700>

Pls help, Thanks.



Answers:
(Answered on: 2022-10-28 15:46:58)


`Unable to verify if this is an Automation compatible contract` usually stems
from a contract that is not verified on the block explorer. The [contract you
linked](https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8)
is verified and if you create an automation with it everything is good
[](https://i.stack.imgur.com/6eSCb.png)

Your `checkUpKeep` function does return `true` when supplied with the input
you show(`checkData`). However, you have the `checkData` set to `0x` in your
automation. [](https://i.stack.imgur.com/kQaVD.png)

With that input, it returns false.

[](https://i.stack.imgur.com/W8ZYh.png)

You will need to change the `checkData` to match your screenshot.



"
What is the purpose of this contract?,This is an example contract which uses hardcoded values for clarity. It uses un-audited code. Do not use this code in production.,{'source': 'https://docs.chain.link/getting-started/advanced-tutorial/'},"The purpose of this contract is to fulfill a request for data using Chainlink. It includes functions to send a request for data, receive the response, and convert the response into a readable format. The contract is designed to interact with the Chainlink VRF (Verifiable Random Function) system, specifically the VRF Client Contract and the VRF Coordinator Contract. The VRF Client Contract allows the contract to send requests and receive answers from the Chainlink VRF, while the VRF Coordinator Contract manages subscriptions and verifies random numbers. The contract is written in Solidity and utilizes the Chainlink library. 
","
- https://stackoverflow.com/questions/71876570/chainlink-contract-cannot-retrieve-large-response-data-type-from-external-adapt
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-4/course.md","Question: (Asked on: 2022-04-14 19:11:42)
Chainlink: Contract cannot retrieve large-response data type from external adapter
URL: https://stackoverflow.com/questions/71876570/chainlink-contract-cannot-retrieve-large-response-data-type-from-external-adapt

Question Body:


I tried to use the `large-response` type to fulfil the request but somehow it
does not show up in my contract I tried to fulfil the `status` value, and the
job works completely as shown in my chainlink node but it does not change the
`status` value, it stays `0x` as it is. So, I wonder that is my contract or
job spec wrong?

This is my contract

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        bytes public status;
        string public statusString;
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        event RequestFulfilled(bytes32 indexed requestId,bytes indexed data);
        
        /**
         * Network: Kovan
         * Oracle: 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 (Chainlink Devrel   
         * Node)
         * Job ID: d5270d1c311941d0b08bead21fea7747
         * Fee: 0.1 LINK
         */
        constructor() {
            setPublicChainlinkToken();
            oracle = 0xDFE5e6C5C624724384b55719b7da79d3EbB60057;
            fee = 1 * 10 ** 18; // (Varies by network and job)
        }
        
        function requesData(string memory _jobId) public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfill.selector);
            // Set the URL to perform the GET request on
            request.add(""trackingNo"", ""HF123456789DL"");
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, bytes memory bytesData) public recordChainlinkFulfillment(_requestId)
        {
            emit RequestFulfilled(_requestId, bytesData);
            status = bytesData;
            statusString = string(status);
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    
    
        // function getStatus() public view returns (string memory) {
        //     return bytes32ToString(status);
        // }
    
         function bytes32ToString(bytes32 _bytes32)
            public
            pure
            returns (string memory)
        {
            uint8 i = 0;
            while (i < 32 && _bytes32[i] != 0) {
                i++;
            }
            bytes memory bytesArray = new bytes(i);
            for (i = 0; i < 32 && _bytes32[i] != 0; i++) {
                bytesArray[i] = _bytes32[i];
            }
            return string(bytesArray);
        }
    
            function stringToBytes32(string memory source)
            public
            pure
            returns (bytes32 result)
        {
            bytes memory tempEmptyStringTest = bytes(source);
            if (tempEmptyStringTest.length == 0) {
                return 0x0;
            }
    
            assembly {
                // solhint-disable-line no-inline-assembly
                result := mload(add(source, 32))
            }
        }
    
    
    }
    
    

This is my job spec.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Halffin-Data-EA-Create-Tracking8""
    externalJobID = ""3f706a6b-efdd-44ac-8167-f880a6ca63ac""
    maxTaskDuration = ""0s""
    contractAddress = ""0xDFE5e6C5C624724384b55719b7da79d3EbB60057""
    minIncomingConfirmations = 0
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""halffin-data"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""trackingNo\\"": $(decode_cbor.trackingNo)}}""]
    
        parse        [type=jsonparse path=""data,tracking,slug"" data=""$(fetch)""]
    
        encode_data  [type=ethabiencode abi=""(bytes value)"" data=""{ \\""value\\"": $(parse) }""]
    
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xDFE5e6C5C624724384b55719b7da79d3EbB60057"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx
    """"""
    
    

  * These are logs from completed job

fetch

    
    
    ""{\""jobRunID\"":\""3f706a6b-efdd-44ac-8167-f880a6ca63ac\"",\""data\"":{\""tracking\"":{\""id\"":2,\""slug\"":\""halffin-logistics\"",\""tracking_number\"":\""HF123456789DL\""},\""result\"":null},\""result\"":null}""
    
    name: halffin-data
    
    requestData: {""id"": $(jobSpec.externalJobID), ""data"": { ""trackingNo"": $(decode_cbor.trackingNo)}}
    

parse

    
    
    ""halffin-logistics""
    
    path: data,tracking,slug
    
    data: $(fetch)
    

encode_data

    
    
    ""0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001168616c6666696e2d6c6f67697374696373000000000000000000000000000000""
    
    abi: (bytes value)
    
    data: { ""value"": $(parse) }
    

encode_tx

    
    
    ""0x728853aa63b008d8b908b2d431b9ea703268ba10e60ab40603941ec91a2955278f219c1e0000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000136e61cdeae727926aa768574e2f979c724d6cad7c1de7e1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000062586d6800000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001168616c6666696e2d6c6f67697374696373000000000000000000000000000000""
    
    abi: fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data)
    
    data: {""requestId"": $(decode_log.requestId), ""payment"": $(decode_log.payment), ""callbackAddress"": $(decode_log.callbackAddr), ""callbackFunctionId"": $(decode_log.callbackFunctionId), ""expiration"": $(decode_log.cancelExpiration), ""data"": $(encode_data)}
    

submit_tx

    
    
    ""{\""logs\"": [], \""root\"": \""0x\"", \""status\"": \""0x0\"", \""gasUsed\"": \""0x5c49\"", \""blockHash\"": \""0x5b55db677b2776bb637fdb9ba2077e7db21de8e8beba60fb79e1384ae51f39a8\"", \""logsBloom\"": \""0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"", \""blockNumber\"": \""0x1d94cd5\"", \""contractAddress\"": \""0x0000000000000000000000000000000000000000\"", \""transactionHash\"": \""0xc5371c5ce1692b39835e44fb61c47d2deeeb509f71e32fccb0c5d42eec3be443\"", \""transactionIndex\"": \""0x1\"", \""cumulativeGasUsed\"": \""0x39418\""}""
    
    to: 0xDFE5e6C5C624724384b55719b7da79d3EbB60057
    
    data: $(encode_tx)
    

In case, you might wonder why I use the `large-response` data type. I followed
this [link](https://stackoverflow.com/questions/71745260/chainlink-issue-when-
fetching-an-api-in-form-of-bytes32)



Answers:
(Answered on: 2022-05-04 10:35:54)


The `contractAddress` specified in the `(Get > Large bytes)` must be pointed
at `operator.sol` not `oracle.sol`. `(Get > Uint256)` is pointed at
`oracle.sol`. `Oracle.sol` is not meant to handle Large bytes, nor multi-
variable Uint256 output.

Here is the code to deploy the current version of `operator.sol` on remix to
then obtain the correct `contractAddress` to the associated job-spec within
the chainlink node GUI.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.7.0;
    import ""@chainlink/contracts/src/v0.7/Operator.sol"";
    





:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!
"
What is the purpose of OpenSSL in generating self-signed certificates for Chainlink node?,OpenSSL is needed to generate self-signed certificates for Chainlink node.,{'source': 'https://docs.chain.link/chainlink-nodes/resources/enabling-https-connections/'},,,"# Enabling HTTPS Connections

  * Overview

This guide will walk you through how to generate your own self-signed
certificates for use by the Chainlink node. You can also substitute self-
signed certificates with certificates of your own, like those created by
[Let's Encrypt](https://letsencrypt.org/).

TLS

You will need [OpenSSL](https://www.openssl.org) in order to generate your own
self-signed certificates.

Create a directory `tls/` within your local Chainlink directory:


    mkdir ~/.chainlink-sepolia/tls


    mkdir ~/.chainlink-goerli/tls


    mkdir ~/.chainlink/tls

Run this command to create a `server.crt` and `server.key` file in the
previously created directory:


    openssl req -x509 -out  ~/.chainlink-sepolia/tls/server.crt  -keyout ~/.chainlink-sepolia/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink-goerli/tls/server.crt  -keyout ~/.chainlink-goerli/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink/tls/server.crt  -keyout ~/.chainlink/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")

Next, add the `TLS_CERT_PATH` and `TLS_KEY_PATH` environment variables to your
`.env` file.


    echo ""TLS_CERT_PATH=/chainlink/tls/server.crt
    TLS_KEY_PATH=/chainlink/tls/server.key"" >> .env

If `CHAINLINK_TLS_PORT=0` is present in your `.env` file, remove it by
running:


    sed -i '/CHAINLINK_TLS_PORT=0/d' .env

Also remove the line that disables `SECURE_COOKIES` by running:


    code"": ""sed -i '/SECURE_COOKIES=false/d' .env

Finally, update your run command to forward port 6689 to the container instead
of 6688:


    cd ~/.chainlink-sepolia && docker run -p 6689:6689 -v ~/.chainlink-sepolia:/chainlink -it
    --env-file=.env smartcontract/chainlink local n


    cd ~/.chainlink-goerli && docker run -p 6689:6689 -v ~/.chainlink-goerli:/chainlink -it
    --env-file=.env smartcontract/chainlink local n


    cd ~/.chainlink && docker run -p 6689:6689 -v ~/.chainlink:/chainlink -it --env-file=.env
    smartcontract/chainlink local n

Now when running the node, you can access it by navigating to
<https://localhost:6689> if running on the same machine or with a ssh tunnel.

## What's next

  * [› Miscellaneous](/chainlink-nodes/resources/miscellaneous)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/resources/enabling-https-connections.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Configuring Chainlink Nodes

  * Overview
  * TOML Configuration
  * Changes to node configuration starting in v1.1.0 nodes
  * Essential environment variables
  * DATABASE_URL
  * General Node Configuration
  * CL_CONFIG
  * CHAIN_TYPE
  * CHAINLINK_DEV
  * EXPLORER_ACCESS_KEY
  * EXPLORER_SECRET
  * EXPLORER_URL
  * ROOT
  * TELEMETRY_INGRESS_UNICONN
  * TELEMETRY_INGRESS_LOGGING
  * TELEMETRY_INGRESS_URL
  * TELEMETRY_INGRESS_SERVER_PUB_KEY
  * TELEMETRY_INGRESS_BUFFER_SIZE
  * TELEMETRY_INGRESS_MAX_BATCH_SIZE
  * TELEMETRY_INGRESS_SEND_INTERVAL
  * TELEMETRY_INGRESS_SEND_TIMEOUT
  * TELEMETRY_INGRESS_USE_BATCH_SEND
  * Chains
  * SOLANA_ENABLED
  * EVM_ENABLED
  * Database Settings
  * MIGRATE_DATABASE
  * ORM_MAX_IDLE_CONNS
  * ORM_MAX_OPEN_CONNS
  * Database Global Lock
  * DATABASE_LOCKING_MODE
  * ADVISORY_LOCK_CHECK_INTERVAL
  * ADVISORY_LOCK_ID
  * LEASE_LOCK_DURATION
  * LEASE_LOCK_REFRESH_INTERVAL
  * Database Automatic Backups
  * DATABASE_BACKUP_FREQUENCY
  * DATABASE_BACKUP_MODE
  * DATABASE_BACKUP_URL
  * DATABASE_BACKUP_DIR
  * Logging
  * JSON_CONSOLE
  * LOG_FILE_DIR
  * LOG_LEVEL
  * LOG_SQL
  * LOG_FILE_MAX_SIZE
  * LOG_FILE_MAX_AGE
  * LOG_FILE_MAX_BACKUPS
  * LOG_UNIX_TS
  * AUDIT_LOGGER_FORWARD_TO_URL
  * AUDIT_LOGGER_HEADERS
  * AUDIT_LOGGER_JSON_WRAPPER_KEY
  * Nurse service (auto-pprof)
  * AUTO_PPROF_ENABLED
  * AUTO_PPROF_PROFILE_ROOT
  * AUTO_PPROF_POLL_INTERVAL
  * AUTO_PPROF_GATHER_DURATION
  * AUTO_PPROF_GATHER_TRACE_DURATION
  * AUTO_PPROF_MAX_PROFILE_SIZE
  * AUTO_PPROF_CPU_PROFILE_RATE
  * AUTO_PPROF_MEM_PROFILE_RATE
  * AUTO_PPROF_BLOCK_PROFILE_RATE
  * AUTO_PPROF_MUTEX_PROFILE_FRACTION
  * AUTO_PPROF_MEM_THRESHOLD
  * AUTO_PPROF_GOROUTINE_THRESHOLD
  * Chainlink Web Server
  * ALLOW_ORIGINS
  * AUTHENTICATED_RATE_LIMIT
  * AUTHENTICATED_RATE_LIMIT_PERIOD
  * BRIDGE_CACHE_TTL
  * BRIDGE_RESPONSE_URL
  * HTTP_SERVER_WRITE_TIMEOUT
  * CHAINLINK_PORT
  * SECURE_COOKIES
  * SESSION_TIMEOUT
  * UNAUTHENTICATED_RATE_LIMIT
  * UNAUTHENTICATED_RATE_LIMIT_PERIOD
  * Web Server MFA
  * MFA_RPID
  * MFA_RPORIGIN
  * Web Server TLS
  * CHAINLINK_TLS_HOST
  * CHAINLINK_TLS_PORT
  * CHAINLINK_TLS_REDIRECT
  * TLS_CERT_PATH
  * TLS_KEY_PATH
  * EVM/Ethereum Legacy Environment Variables
  * ETH_URL
  * ETH_HTTP_URL
  * EVM_NODES
  * ETH_SECONDARY_URLS
  * EVM/Ethereum Global Settings
  * ETH_CHAIN_ID
  * EVM_RPC_ENABLED
  * EVM/Ethereum Chain-specific Overrides
  * BALANCE_MONITOR_ENABLED
  * BLOCK_BACKFILL_DEPTH
  * BLOCK_BACKFILL_SKIP
  * ETH_TX_REAPER_INTERVAL
  * ETH_TX_REAPER_THRESHOLD
  * ETH_TX_RESEND_AFTER_THRESHOLD
  * ETH_FINALITY_DEPTH
  * ETH_HEAD_TRACKER_HISTORY_DEPTH
  * ETH_HEAD_TRACKER_MAX_BUFFER_SIZE
  * ETH_HEAD_TRACKER_SAMPLING_INTERVAL
  * ETH_LOG_BACKFILL_BATCH_SIZE
  * ETH_LOG_POLL_INTERVAL
  * ETH_RPC_DEFAULT_BATCH_SIZE
  * LINK_CONTRACT_ADDRESS
  * MIN_INCOMING_CONFIRMATIONS
  * MIN_OUTGOING_CONFIRMATIONS
  * MINIMUM_CONTRACT_PAYMENT_LINK_JUELS
  * NODE_NO_NEW_HEADS_THRESHOLD
  * NODE_POLL_FAILURE_THRESHOLD
  * NODE_POLL_INTERVAL
  * NODE_SELECTION_MODE
  * NODE_SYNC_THRESHOLD
  * EVM Gas Controls
  * Configuring your ETH node
  * EVM_EIP1559_DYNAMIC_FEES
  * ETH_GAS_BUMP_PERCENT
  * ETH_GAS_BUMP_THRESHOLD
  * ETH_GAS_BUMP_TX_DEPTH
  * ETH_GAS_BUMP_WEI
  * EVM_GAS_FEE_CAP_DEFAULT
  * ETH_GAS_LIMIT_DEFAULT
  * ETH_GAS_LIMIT_MAX
  * ETH_GAS_LIMIT_MULTIPLIER
  * ETH_GAS_LIMIT_TRANSFER
  * ETH_GAS_PRICE_DEFAULT
  * EVM_GAS_TIP_CAP_DEFAULT
  * EVM_GAS_TIP_CAP_MINIMUM
  * ETH_MAX_GAS_PRICE_WEI
  * ETH_MAX_IN_FLIGHT_TRANSACTIONS
  * ETH_MAX_QUEUED_TRANSACTIONS
  * ETH_MIN_GAS_PRICE_WEI
  * ETH_GAS_LIMIT_OCR_JOB_TYPE
  * ETH_GAS_LIMIT_DR_JOB_TYPE
  * ETH_GAS_LIMIT_VRF_JOB_TYPE
  * ETH_GAS_LIMIT_FM_JOB_TYPE
  * ETH_GAS_LIMIT_KEEPER_JOB_TYPE
  * ETH_NONCE_AUTO_SYNC
  * ETH_USE_FORWARDERS
  * EVM/Ethereum Gas Price Estimation
  * GAS_ESTIMATOR_MODE
  * BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE
  * BLOCK_HISTORY_ESTIMATOR_BLOCK_HISTORY_SIZE
  * BLOCK_HISTORY_ESTIMATOR_BLOCK_DELAY
  * BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS
  * BLOCK_HISTORY_ESTIMATOR_TRANSACTION_PERCENTILE
  * EVM/Ethereum Transaction Simulation
  * Job Pipeline and tasks
  * DEFAULT_HTTP_LIMIT
  * DEFAULT_HTTP_TIMEOUT
  * FEATURE_EXTERNAL_INITIATORS
  * JOB_PIPELINE_MAX_RUN_DURATION
  * JOB_PIPELINE_MAX_SUCCESSFUL_RUNS
  * JOB_PIPELINE_REAPER_INTERVAL
  * JOB_PIPELINE_REAPER_THRESHOLD
  * JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH
  * OCR
  * FEATURE_OFFCHAIN_REPORTING
  * OCR_KEY_BUNDLE_ID
  * OCR_MONITORING_ENDPOINT
  * OCR_TRANSMITTER_ADDRESS
  * P2P_NETWORKING_STACK
  * Networking Stack V1
  * Networking Stack V2
  * Keeper
  * KEEPER_GAS_PRICE_BUFFER_PERCENT
  * KEEPER_GAS_TIP_CAP_BUFFER_PERCENT
  * KEEPER_BASE_FEE_BUFFER_PERCENT
  * KEEPER_MAXIMUM_GRACE_PERIOD
  * KEEPER_REGISTRY_CHECK_GAS_OVERHEAD
  * KEEPER_REGISTRY_PERFORM_GAS_OVERHEAD
  * KEEPER_REGISTRY_SYNC_INTERVAL
  * KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE
  * KEEPER_TURN_LOOK_BACK
  * CLI Client
  * ADMIN_CREDENTIALS_FILE
  * CLIENT_NODE_URL
  * INSECURE_SKIP_VERIFY
  * Notes on setting environment variables

Recent versions of the Chainlink node use sensible defaults for most
configuration variables. You do not need to change much to get a standard
deployment working.

Not all environment variables are documented here. Any undocumented
environment variable is subject to change in future releases. In almost all
cases, you should leave any environment variable not listed here to its
default value unless you really understand what you are doing.

To reiterate: _If you have an environment variable set that is not listed
here, and you don't know exactly why you have it set, you should remove it!_

The environment variables listed here are explicitly supported and current as
of Chainlink node v1.3.0.

### TOML Configuration

TOML configuration for Chainlink nodes is stable and recommended for mainnet
deployments. TOML configuration will be the only supported configuration
method starting with `v2.0.0`. Enable TOML configuration by specifying the
`-config <filename>.toml` flag with the path to your TOML file. Alternatively,
you can specify the raw TOML config in the [`CL_CONFIG` environment
variable](/chainlink-nodes/v1/configuration#cl_config). See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/CONFIG.md)
and
[SECRETS.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/SECRETS.md)
on GitHub to learn more.

## Changes to node configuration starting in v1.1.0 nodes

As of Chainlink node v1.1.0 and up, the way nodes manage configuration is
changing. Previously, environment variables exclusively handled all node
configuration. Although this configuration method worked well in the past, it
has its limitations. Notably, it doesn't mesh well with chain-specific
configuration profiles.

For this reason, Chainlink nodes are moving towards a model where you set
variables using the API, CLI, or GUI, and the configuration is saved in the
database. We encourage you to become familiar with this model because it is
likely that nodes will continue to move away from environment variable
configuration in the future.

As of v1.1.0, Chainlink nodes still support environment variables to configure
node settings and chain-specific settings. If the environment variable is set,
it overrides any chain-specific, job-specific, or database configuration
setting. The log displays a warning to indicate when an override happens, so
you know when variables lower in the hierarchy are being ignored.

Your node applies configuration settings using following hierarchy:

  1. Environment variables
  2. Chain-specific variables
  3. Job-specific variables

## Essential environment variables

These are the only environment variables that are _required_ for a Chainlink
node to run.

### DATABASE_URL

**Required**

  * Default: _none_

The PostgreSQL URI to connect to your database. Chainlink nodes require
Postgres versions >= 11. See the [Running a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node) for an example.

## General Node Configuration

### CL_CONFIG

This environment variable is used to set static configuration using TOML
format. Specify the raw TOML config in this environment variable. Unlike the
`-config` flag, it does not accept a path to a TOML file.

See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/CONFIG.md)
and
[SECRETS.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/SECRETS.md)
on GitHub to learn more.

### CHAIN_TYPE

  * Default: _none_

CHAIN_TYPE overrides all chains and forces them to act as a particular chain
type. An up-to-date list of chain types is given in
[`chaintype.go`](https://github.com/smartcontractkit/chainlink/blob/v1.3.0/core/chains/chaintype.go).

This variable enables some chain-specific hacks and optimizations. It is
recommended not to use this environment variable and set the chain-type on a
per-chain basis instead.

### CHAINLINK_DEV

  * Default: `""false""`

Setting `CHAINLINK_DEV` to `true` enables development mode. Do not use this
for production deployments. It can be useful for enabling experimental
features and collecting debug information in test environments.

### EXPLORER_ACCESS_KEY

  * Default: _none_

The access key for authenticating with the explorer. This variable is required
to deliver telemetry.

### EXPLORER_SECRET

  * Default: _none_

The secret for authenticating with the explorer. This variable is required to
deliver telemetry.

### EXPLORER_URL

  * Default: _none_

The explorer websocket URL for the node to push stats to. This variable is
required to deliver telemetry.

### ROOT

  * Default: `""~/.chainlink""`

The Chainlink node's root directory. This is the default directory for
logging, database backups, cookies, and other misc Chainlink node files.
Chainlink nodes will always ensure this directory has `700` permissions
because it might contain sensitive data.

### TELEMETRY_INGRESS_UNICONN

  * Default: `""true""`

Toggles which ws connection style is used.

### TELEMETRY_INGRESS_LOGGING

  * Default: `""false""`

Toggles verbose logging of the raw telemetry messages being sent.

### TELEMETRY_INGRESS_URL

  * Default: _none_

The URL to connect to for sending telemetry.

### TELEMETRY_INGRESS_SERVER_PUB_KEY

  * Default: _none_

The public key of the telemetry server.

### TELEMETRY_INGRESS_BUFFER_SIZE

  * Default: `""100""`

The number of telemetry messages to buffer before dropping new ones.

### TELEMETRY_INGRESS_MAX_BATCH_SIZE

  * Default: `""50""`

The maximum number of messages to batch into one telemetry request.

### TELEMETRY_INGRESS_SEND_INTERVAL

  * Default: `""500ms""`

The interval on which batched telemetry is sent to the ingress server.

### TELEMETRY_INGRESS_SEND_TIMEOUT

  * Default: `""10s""`

The max duration to wait for the request to complete when sending batch
telemetry.

### TELEMETRY_INGRESS_USE_BATCH_SEND

  * Default: `""true""`

Toggles sending telemetry to the ingress server using the batch client.

## Chains

### SOLANA_ENABLED

caution

  * Default: `""false""`

Enables Solana support.

### EVM_ENABLED

  * Default: `""true""`

Enables support for EVM-based chains. By default, this variable is set to
`true` to provide legacy compatibility and ease the upgrade path from older
versions of Chainlink which did not support disabling EVM.

## Database Settings

### MIGRATE_DATABASE

  * Default: `""true""`

This variable controls whether a Chainlink node will attempt to automatically
migrate the database on boot. If you want more control over your database
migration process, set this variable to `false` and manually migrate the
database using the CLI `migrate` command instead.

### ORM_MAX_IDLE_CONNS

  * Default: `""10""`

This setting configures the maximum number of idle database connections that
the Chainlink node will keep open. Think of this as the baseline number of
database connections per Chainlink node instance. Increasing this number can
help to improve performance under database-heavy workloads.

Postgres has connection limits, so you must use cation when increasing this
value. If you are running several instances of a Chainlink node or another
application on a single database server, you might run out of Postgres
connection slots if you raise this value too high.

### ORM_MAX_OPEN_CONNS

  * Default: `""20""`

This setting configures the maximum number of database connections that a
Chainlink node will have open at any one time. Think of this as the maximum
burst upper bound limit of database connections per Chainlink node instance.
Increasing this number can help to improve performance under database-heavy
workloads.

Postgres has connection limits, so you must use cation when increasing this
value. If you are running several instances of a Chainlink node or another
application on a single database server, you might run out of Postgres
connection slots if you raise this value too high.

## Database Global Lock

Chainlink nodes use a database lock to ensure that only one Chainlink node
instance can be run on the database at a time. If you run multiple instances
of a Chainlink node that share a single database at the same time, the node
will encounter strange errors and data integrity failures. Do not allow
multiple nodes to write data to the database at the same time.

### DATABASE_LOCKING_MODE

  * Default: `""dual""`

The `DATABASE_LOCKING_MODE` variable can be set to 'dual', 'advisorylock',
'lease', or 'none'. It controls which mode to use to enforce that only one
Chainlink node can use the database. It is recommended to set this to `lease`.

  * `dual` \- The default: Uses both advisory locks and lease locks for backward and forward compatibility
  * `advisorylock` \- Advisory lock only
  * `lease` \- Lease lock only
  * _none_ \- No locking at all: This option useful for advanced deployment environments when you are sure that only one instance of a Chainlink node will ever be running.

#### Technical details

Ideally, you should use a container orchestration system like
[Kubernetes](https://kubernetes.io/) to ensure that only one Chainlink node
instance can ever use a specific Postgres database. However, some node
operators do not have the technical capacity to do this. Common use cases run
multiple Chainlink node instances in failover mode as recommended by our
official documentation. The first instance takes a lock on the database and
subsequent instances will wait trying to take this lock in case the first
instance fails.

By default, Chainlink nodes use the `dual` setting to provide both advisory
locks and lease locks for backward and forward compatibility. Using advisory
locks alone presents the following problems:

  * If your nodes or applications hold locks open for several hours or days, Postgres is unable to complete internal cleanup tasks. The Postgres maintainers explicitly discourage holding locks open for long periods of time.
  * Advisory locks can silently disappear when you upgrade Postgres, so a new Chainlink node instance can take over even while the old node is still running.
  * Advisory locks do not work well with pooling tools such as [pgbouncer](https://www.pgbouncer.org/).
  * If the Chainlink node crashes, an advisory lock can hang around for up to several hours, which might require you to manually remove it so another instance of the Chainlink node will allow itself to boot.

Because of the complications with advisory locks, Chainlink nodes with v1.1.0
and later support a new `lease` locking mode. This mode might become the
default in future. The `lease` locking mode works using the following process:

  * Node A creates one row in the database with the client ID and updates it once per second.
  * Node B spinlocks and checks periodically to see if the client ID is too old. If the client ID is not updated after a period of time, node B assumes that node A failed and takes over. Node B becomes the owner of the row and updates the client ID once per second.
  * If node A comes back, it attempts to take out a lease, realizes that the database has been leased to another process, and exits the entire application immediately.

### ADVISORY_LOCK_CHECK_INTERVAL

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable advisory
locking.

  * Default: `""1s""`

`ADVISORY_LOCK_CHECK_INTERVAL` controls how often the Chainlink node checks to
make sure it still holds the advisory lock when advisory locking is enabled.
If a node no longer holds the lock, it will try to re-acquire it. If the node
cannot re-acquire the lock, the application will exit.

### ADVISORY_LOCK_ID

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable advisory
locking.

  * Default: `""1027321974924625846""`

`ADVISORY_LOCK_ID` is the application advisory lock ID. This must match all
other Chainlink nodes that might access this database. It is unlikely you will
ever need to change this from the default.

### LEASE_LOCK_DURATION

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable lease
locking.

  * Default: `""30s""`

How long the lease lock will last before expiring.

### LEASE_LOCK_REFRESH_INTERVAL

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable lease
locking.

  * Default: `""1s""`

How often to refresh the lease lock. Also controls how often a standby node
will check to see if it can grab the lease.

## Database Automatic Backups

As a best practice, take regular database backups in case of accidental data
loss. This best practice is especially important when you upgrade your
Chainlink node to a new version. Chainlink nodes support automated database
backups to make this process easier.

NOTE: Dumps can cause high load and massive database latencies, which will
negatively impact the normal functioning of the Chainlink node. For this
reason, it is recommended to set a DATABASE_BACKUP_URL and point it to a read
replica if you enable automatic backups.

### DATABASE_BACKUP_FREQUENCY

  * Default: `""1h""`

If this variable is set to a positive duration and `DATABASE_BACKUP_MODE` is
not _none_ , the node will dump the database at this regular interval.

Set to `0` to disable periodic backups.

### DATABASE_BACKUP_MODE

  * Default: `""none""`

Set the mode for automatic database backups, which can be one of _none_ ,
`lite`, or `full`. If enabled, the Chainlink node will always dump a backup on
every boot before running migrations. Additionally, it will automatically take
database backups that overwrite the backup file for the given version at
regular intervals if `DATABASE_BACKUP_FREQUENCY` is set to a non-zero
interval.

_none_ \- Disables backups. `lite` \- Dumps small tables including
configuration and keys that are essential for the node to function, which
excludes historical data like job runs, transaction history, etc. `full` \-
Dumps the entire database.

It will write to a file like `$ROOT/backup/cl_backup_<VERSION>.dump`. There is
one backup dump file per version of the Chainlink node. If you upgrade the
node, it will keep the backup taken right before the upgrade migration so you
can restore to an older version if necessary.

### DATABASE_BACKUP_URL

If specified, the automatic database backup will pull from this URL rather
than the main `DATABASE_URL`. It is recommended to set this value to a read
replica if you have one to avoid excessive load on the main database.

### DATABASE_BACKUP_DIR

This variable sets the directory to use for saving the backup file. Use this
if you want to save the backup file in a directory other than the default ROOT
directory.

## Logging

### JSON_CONSOLE

  * Default: `""false""`

Set this to true to enable JSON logging. Otherwise, the log is saved in a
human-friendly console format.

### LOG_FILE_DIR

  * Default: `""$ROOT""`

By default, Chainlink nodes write log data to `$ROOT/log.jsonl`. The log
directory can be changed by setting this var. For example,
`LOG_FILE_DIR=/my/log/directory`.

### LOG_LEVEL

  * Default: `""info""`

The `LOG_LEVEL` environment variable determines both what is printed on the
screen and what is written to the log file.

The available options are:

  * `""debug""`: Useful for forensic debugging of issues.
  * `""info""`: High-level informational messages.
  * `""warn""`: A mild error occurred that might require non-urgent action. Check these warnings semi-regularly to see if any of them require attention. These warnings usually happen due to factors outside of the control of the node operator. Examples: Unexpected responses from a remote API or misleading networking errors.
  * `""error""`: An unexpected error occurred during the regular operation of a well-maintained node. Node operators might need to take action to remedy this error. Check these regularly to see if any of them require attention. Examples: Use of deprecated configuration options or incorrectly configured settings that cause a job to fail.
  * `""crit""`: A critical error occurred. The node might be unable to function. Node operators should take immediate action to fix these errors. Examples: The node could not boot because a network socket could not be opened or the database became inaccessible.
  * `""panic""`: An exceptional error occurred that could not be handled. If the node is unresponsive, node operators should try to restart their nodes and notify the Chainlink team of a potential bug.
  * `""fatal""`: The node encountered an unrecoverable problem and had to exit.

### LOG_SQL

  * Default: `""false""`

This setting tells the Chainlink node to log SQL statements made using the
default logger. SQL statements will be logged at `debug` level. Not all
statements can be logged. The best way to get a true log of all SQL statements
is to enable SQL statement logging on Postgres.

### LOG_FILE_MAX_SIZE

  * Default: `""5120mb""`

Determines the log file's max size in megabytes before file rotation. Having
this not set will disable logging to disk. If your disk doesn't have enough
disk space, the logging will pause and the application will log errors until
space is available again.

Values must have suffixes with a unit like: `5120mb` (5,120 megabytes). If no
unit suffix is provided, the value defaults to `b` (bytes). The list of valid
unit suffixes are:

  * b (bytes)
  * kb (kilobytes)
  * mb (megabytes)
  * gb (gigabytes)
  * tb (terabytes)

### LOG_FILE_MAX_AGE

  * Default: `""0""`

Determines the log file's max age in days before file rotation. Keeping this
config with the default value will not remove log files based on age.

### LOG_FILE_MAX_BACKUPS

  * Default: `""1""`

Determines the maximum number of old log files to retain. Keeping this config
with the default value retains all old log files. The `LOG_FILE_MAX_AGE`
variable can still cause them to get deleted.

### LOG_UNIX_TS

  * Default: _none_

Previous versions of Chainlink nodes wrote JSON logs with a unix timestamp. As
of v1.1.0 and up, the default has changed to use ISO8601 timestamps for better
readability. Setting `LOG_UNIX_TS=true` will enable the old behavior.

### AUDIT_LOGGER_FORWARD_TO_URL

  * Default: _none_

When set, this environment variable configures and enables an optional HTTP
logger which is used specifically to send audit log events. Audit logs events
are emitted when specific actions are performed by any of the users through
the node's API. The value of this variable should be a full URL. Log items
will be sent via POST HTTP requests.

There are audit log implemented for the following events:

  * Auth & Sessions (new session, login success, login failed, 2FA enrolled, 2FA failed, password reset, password reset failed, etc.)
  * CRUD actions for all resources (add/create/delete resources such as bridges, nodes, keys)
  * Sensitive actions (keys exported/imported, config changed, log level changed, environment dumped)

A full list of audit log enum types can be found in the source within the
`audit` package
([`audit_types.go`](https://github.com/smartcontractkit/chainlink/blob/develop/core/logger/audit/audit_types.go)).

Log events follow this schema:


    {
        ""eventID"":  EVENT_ID_ENUM,
        ""hostname"": HOSTNAME,
        ""localIP"" : CL_NODE_IP,
        ""env"" : ENVIRONMENT_NAME,
        ""data"": ...
    }

The `AUDIT_LOGGER_*` environment variables configure this optional audit log
HTTP forwarder.

### AUDIT_LOGGER_HEADERS

  * Default: _none_

An optional list of HTTP headers to be added for every optional audit log
event. If the above `AUDIT_LOGGER_FORWARD_TO_URL` is set, audit log events
will be POSTed to that URL, and will include headers specified in this
environment variable. One example use case is auth for example:
`AUDIT_LOGGER_HEADERS=""Authorization||{token}""`

Header keys and values are delimited on `||`, and multiple headers can be
added with a forward slash delimiter (`\`). An example of multiple key value
pairs: `AUDIT_LOGGER_HEADERS=""Authorization||{token}\Some-Other-
Header||{token2}""`

### AUDIT_LOGGER_JSON_WRAPPER_KEY

  * Default: _none_

When the audit log HTTP forwarder is enabled, if there is a value set for this
optional environment variable then the POST body will be wrapped in a
dictionary in a field specified by the value of set variable. This is to help
enable specific logging service integrations that may require the event JSON
in a special shape. For example: `AUDIT_LOGGER_JSON_WRAPPER_KEY=event` will
create the POST body:


    {
      ""event"": {
        ""eventID"":  EVENT_ID_ENUM,
        ""hostname"": HOSTNAME,
        ""localIP"" : CL_NODE_IP,
        ""env"" : ENVIRONMENT_NAME,
        ""data"": ...
      }
    }

## Nurse service (auto-pprof)

The Chainlink node is equipped with an internal ""nurse"" service that can
perform automatic `pprof` profiling when the certain resource thresholds are
exceeded, such as memory and goroutine count. These profiles are saved to disk
to facilitate fine-grained debugging of performance-related issues. In
general, if you notice that your node has begun to accumulate profiles,
forward them to the Chainlink team.

To learn more about these profiles, read the [Profiling Go programs with
pprof](https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/) guide.

### AUTO_PPROF_ENABLED

  * Default: `""false""`

Set to `true` to enable the automatic profiling service.

### AUTO_PPROF_PROFILE_ROOT

Defaults to `$CHAINLINK_ROOT`

The location on disk where pprof profiles will be stored.

### AUTO_PPROF_POLL_INTERVAL

  * Default: `""10s""`

The interval at which the node's resources are checked.

### AUTO_PPROF_GATHER_DURATION

  * Default: `""10s""`

The duration for which profiles are gathered when profiling starts.

### AUTO_PPROF_GATHER_TRACE_DURATION

  * Default: `""5s""`

The duration for which traces are gathered when profiling is kicked off. This
is separately configurable because traces are significantly larger than other
types of profiles.

### AUTO_PPROF_MAX_PROFILE_SIZE

  * Default: `""100mb""`

The maximum amount of disk space that profiles may consume before profiling is
disabled.

### AUTO_PPROF_CPU_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetCPUProfileRate>.

### AUTO_PPROF_MEM_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#pkg-variables>.

### AUTO_PPROF_BLOCK_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetBlockProfileRate>.

### AUTO_PPROF_MUTEX_PROFILE_FRACTION

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetMutexProfileFraction>.

  * Default: `""1""`

### AUTO_PPROF_MEM_THRESHOLD

  * Default: `""4gb""`

The maximum amount of memory the node can actively consume before profiling
begins.

### AUTO_PPROF_GOROUTINE_THRESHOLD

  * Default: `""5000""`

The maximum number of actively-running goroutines the node can spawn before
profiling begins.

## Chainlink Web Server

### ALLOW_ORIGINS

  * Default: `""http://localhost:3000,http://localhost:6688""`

Controls the URLs Chainlink nodes emit in the `Allow-Origins` header of its
API responses. The setting can be a comma-separated list with no spaces. You
might experience CORS issues if this is not set correctly.

You should set this to the external URL that you use to access the Chainlink
UI.

You can set `ALLOW_ORIGINS=*` to allow the UI to work from any URL, but it is
recommended for security reasons to make it explicit instead.

### AUTHENTICATED_RATE_LIMIT

  * Default: `""1000""`

`AUTHENTICATED_RATE_LIMIT` defines the threshold to which authenticated
requests get limited. More than this many authenticated requests per
`AUTHENTICATED_RATE_LIMIT_PERIOD` will be rejected.

### AUTHENTICATED_RATE_LIMIT_PERIOD

  * Default: `""1m""`

`AUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which authenticated
requests get limited.

### BRIDGE_CACHE_TTL

  * Default: 0s

When set to `d` units of time, this variable enables using cached bridge
responses that are at most `d` units old. Caching is disabled by default.

Example `BRIDGE_CACHE_TTL=10s`, `BRIDGE_CACHE_TTL=1m`

### BRIDGE_RESPONSE_URL

  * Default: _none_

`BRIDGE_RESPONSE_URL` defines the URL for bridges to send a response to.

Usually this will be the same as the URL/IP and port you use to connect to the
Chainlink UI, such as `https://my-chainlink-node.example.com:6688`.

### HTTP_SERVER_WRITE_TIMEOUT

**ADVANCED**

Do not change this setting unless you know what you are doing.

  * Default: `""10s""`

`HTTP_SERVER_WRITE_TIMEOUT` controls how long the Chainlink node's API server
can hold a socket open for writing a response to an HTTP request. Sometimes,
this must be increased for pprof.

### CHAINLINK_PORT

  * Default: `""6688""`

Port used for the Chainlink Node API, CLI, and GUI.

### SECURE_COOKIES

  * Default: `""true""`

Requires the use of secure cookies for authentication. Set to false to enable
standard HTTP requests along with `CHAINLINK_TLS_PORT=0`.

### SESSION_TIMEOUT

  * Default: `""15m""`

This value determines the amount of idle time to elapse before session cookies
expire. This signs out GUI users from their sessions.

### UNAUTHENTICATED_RATE_LIMIT

  * Default: `""5""`

`UNAUTHENTICATED_RATE_LIMIT` defines the threshold to which authenticated
requests get limited. More than this many unauthenticated requests per
`UNAUTHENTICATED_RATE_LIMIT_PERIOD` will be rejected.

### UNAUTHENTICATED_RATE_LIMIT_PERIOD

  * Default: `""20s""`

`UNAUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which
unauthenticated requests get limited.

## Web Server MFA

The Operator UI frontend now supports enabling Multi Factor Authentication via
Webauthn per account. When enabled, logging in will require the account
password and a hardware or OS security key such as Yubikey. To enroll, log in
to the operator UI and click the circle purple profile button at the top right
and then click **Register MFA Token**. Tap your hardware security key or use
the OS public key management feature to enroll a key. Next time you log in,
this key will be required to authenticate.

This feature must be enabled by setting the following environment variables:
`MFA_RPID` and `MFA_RPORIGIN`.

### MFA_RPID

  * Default: _none_

The `MFA_RPID` value should be the FQDN of where the Operator UI is served.
When serving locally, the value should be `localhost`.

### MFA_RPORIGIN

  * Default: _none_

The `MFA_RPORIGIN` value should be the origin URL where WebAuthn requests
initiate, including scheme and port. When serving locally, the value should be
`http://localhost:6688/`.

## Web Server TLS

The TLS settings below apply only if you want to enable TLS security on your
Chainlink node.

### CHAINLINK_TLS_HOST

  * Default: _none_

The hostname configured for TLS to be used by the Chainlink node. This is
useful if you configured a domain name specific for your Chainlink node.

### CHAINLINK_TLS_PORT

  * Default: `""6689""`

The port used for HTTPS connections. Set this to `0` to disable HTTPS.
Disabling HTTPS also relieves Chainlink nodes of the requirement for a TLS
certificate.

### CHAINLINK_TLS_REDIRECT

  * Default: `""false""`

Forces TLS redirect for unencrypted connections.

### TLS_CERT_PATH

  * Default: _none_

The location of the TLS certificate file. Example:
`/home/$USER/.chainlink/tls/server.crt`

### TLS_KEY_PATH

  * Default: _none_

The location of the TLS private key file. Example:
`/home/$USER/.chainlink/tls/server.key`

## EVM/Ethereum Legacy Environment Variables

Previous Chainlink node versions supported only one chain. From v1.1.0 and up,
Chainlink nodes support multiple EVM and non-EVM chains, so the way that
chains and nodes are configured has changed.

The preferred way of configuring Chainlink nodes as of v1.1.0 and up is to use
the API, CLI, or UI to set chain-specific configuration and create nodes.

The old way of specifying chains using environment variables is still
supported, but discouraged. It works as follows:

If you set any value for `ETH_URL`, the values of `ETH_CHAIN_ID`, `ETH_URL`,
`ETH_HTTP_URL` and `ETH_SECONDARY_URLS` will be used to create and update
chains and nodes representing these values in the database. If an existing
chain or node is found, it will be overwritten. This mode is used mainly to
ease the process of upgrading. On subsequent runs (once your old settings have
been written to the database) it is recommended to unset `ETH_URL` and use the
API commands exclusively to administer chains and nodes.

In the future, support for the `ETH_URL` and associated environment variables
might be removed, so it is recommended to use the API, CLI, or GUI instead to
setup chains and nodes.

### ETH_URL

Setting this will enable ""legacy eth ENV"" mode, which is not compatible with
multi-chain. It is better to configure settings using the API, CLI, or GUI
instead.

  * Default: _none_

This is the websocket address of the Ethereum client that the Chainlink node
will connect to. All interaction with the Ethereum blockchain will occur
through this connection.

NOTE: It is also required to set `ETH_CHAIN_ID` if you set ETH_URL.

### ETH_HTTP_URL

Only has effect if `ETH_URL` set. Otherwise, it can be set in the API, CLI, or
GUI.

  * Default: _none_

This should be set to the HTTP URL that points to the same ETH node as the
primary. If set, the Chainlink node will automatically use HTTP mode for heavy
requests, which can improve reliability.

### EVM_NODES

caution

Setting this environment variable will **COMPLETELY ERASE** your `evm_nodes`
table on every boot and repopulate from the given data to nullify any runtime
modifications. This is a temporary solution until this configuration can be
defined in a file in the future.

  * Default: _none_

A JSON array of node specifications that allows you to configure multiple
nodes or chains using an environment variable. This is not compatible with
other environment variables that specify the node such as `ETH_URL` or
`ETH_SECONDARY_URLS`. Set this variable using a configuration like the
following example:


    EVM_NODES='
    [
    	{
    		""name"": ""primary_0_1"",
    		""evmChainId"": ""0"",
    		""wsUrl"": ""ws://test1.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""primary_0_2"",
    		""evmChainId"": ""0"",
    		""wsUrl"": ""ws://test2.invalid"",
    		""httpUrl"": ""https://test3.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""primary_1337_1"",
    		""evmChainId"": ""1337"",
    		""wsUrl"": ""ws://test4.invalid"",
    		""httpUrl"": ""http://test5.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""sendonly_1337_1"",
    		""evmChainId"": ""1337"",
    		""httpUrl"": ""http://test6.invalid"",
    		""sendOnly"": true
    	},
    	{
    		""name"": ""sendonly_0_1"",
    		""evmChainId"": ""0"",
    		""httpUrl"": ""http://test7.invalid"",
    		""sendOnly"": true
    	},
    	{
    		""name"": ""primary_42_1"",
    		""evmChainId"": ""42"",
    		""wsUrl"": ""ws://test8.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""sendonly_43_1"",
    		""evmChainId"": ""43"",
    		""httpUrl"": ""http://test9.invalid"",
    		""sendOnly"": true
    	}
    ]
    '

Usage of Docker requires the variable to be formatted as one line with no
whitespaces and quotes wrapping it, as follows in the example:


    EVM_NODES=[{""name"":""primary_0_1"",""evmChainId"":""0"",""wsUrl"":""ws://test1.invalid"",""sendOnly"":false},{""name"":""primary_0_2"",""evmChainId"":""0"",""wsUrl"":""ws://test2.invalid"",""httpUrl"":""https://test3.invalid"",""sendOnly"":false},{""name"":""primary_1337_1"",""evmChainId"":""1337"",""wsUrl"":""ws://test4.invalid"",""httpUrl"":""http://test5.invalid"",""sendOnly"":false}]

### ETH_SECONDARY_URLS

Only has effect if `ETH_URL` set. Otherwise, it can be set in the API, CLI, or
GUI.

  * Default: _none_

If set, transactions will also be broadcast to this secondary Ethereum node.
This allows transaction broadcasting to be more robust in the face of primary
Ethereum node bugs or failures.

It is recommended to set at least one secondary ETH node here that is
different from your primary.

Multiple URLs can be specified as a comma-separated list e.g.

`ETH_SECONDARY_URLS=https://example.com/1,https://example.text/2,...`

## EVM/Ethereum Global Settings

This configuration is specific to EVM/Ethereum chains.

### ETH_CHAIN_ID

  * Default: _none_

This environment variable specifies the default chain ID. Any job spec that
has not explicitly set `EVMChainID` will connect to this default chain. If you
do not have a chain in the database matching this value, any jobs that try to
use it will throw an error.

### EVM_RPC_ENABLED

  * Default: `""true""`

Enables connecting to real EVM RPC nodes. Disabling this can be useful in
certain cases such as spinning up a Chainlink node and adding EVM-based jobs
without having it actually execute anything on-chain, or for debugging to see
what the node _would_ do without actually doing it.

## EVM/Ethereum Chain-specific Overrides

These configuration options act as an override, setting the value for _all_
chains.

This often doesn't make sense, e.g. `ETH_FINALITY_DEPTH` on Avalanche could be
quite different from `ETH_FINALITY_DEPTH` on Ethereum mainnet.

We recommend setting this on a per-chain basis using the API, CLI, or GUI
instead.

In general, Chainlink nodes contain built-in defaults for most of these
settings that should work out of the box on all officially supported chains,
so it is unlikely you must make any changes here.

### BALANCE_MONITOR_ENABLED

  * Default: `""true""`

Enables Balance Monitor feature. This is required to track balances of keys
locally and warn if it drops too low. It also enables displaying balance in
the Chainlink UI and API.

### BLOCK_BACKFILL_DEPTH

  * Default: `""10""`

This variable specifies the number of blocks before the current head that the
log broadcaster will try to re-consume logs from, e.g. after adding a new job.

### BLOCK_BACKFILL_SKIP

  * Default: `""false""`

This variable enables skipping of very long log backfills. For example, this
happens in a situation when the node is started after being offline for a long
time. This might be useful on fast chains and if only recent chain events are
relevant

### ETH_TX_REAPER_INTERVAL

NOTE: This overrides the setting for _all_ chains, you might want to set this
on a per-chain basis using the API, CLI, or GUI instead

  * Default: `""1h""`

Controls how often the ETH transaction reaper should run, used to delete old
confirmed or fatally_errored transaction records from the database. Setting to
`0` disables the reaper.

### ETH_TX_REAPER_THRESHOLD

  * Default: `""24h""`

Represents how long any confirmed or fatally_errored `eth_tx` transactions
will hang around in the database. If the `eth_tx` is confirmed but still below
`ETH_FINALITY_DEPTH`, it will not be deleted even if it was created at a time
older than this value.

EXAMPLE: With: `EthTxReaperThreshold=1h` and `EthFinalityDepth=50` If current
head is 142, any `eth_tx` confirmed in block 91 or below will be reaped as
long as its `created_at` value is older than the value set for
`EthTxReaperThreshold`.

Setting to `0` disables the reaper.

### ETH_TX_RESEND_AFTER_THRESHOLD

NOTE: This overrides the setting for _all_ chains, you might want to set this
on a per-chain basis using the API, CLI, or GUI instead.

  * Default: _automatically set based on Chain ID, typically 1m_

Controls how long the `ethResender` will wait before re-sending the latest
`eth_tx_attempt`. This is designed a as a fallback to protect against the ETH
nodes dropping transactions (which has been anecdotally observed to happen),
networking issues, or transactions being ejected from the mempool.

Setting to `0` disables the resender.

### ETH_FINALITY_DEPTH

  * Default: _automatically set based on Chain ID, typically 50_

The number of blocks after which an Ethereum transaction is considered
""final"".

`ETH_FINALITY_DEPTH` determines how deeply we look back to ensure that
transactions are confirmed onto the longest chain. There is not a large
performance penalty to setting this relatively high (on the order of
hundreds).

It is practically limited by the number of heads we store in the database
(`HEAD_TRACKER_HISTORY_DEPTH`) and should be less than this with a comfortable
margin. If a transaction is mined in a block more than this many blocks ago,
and is reorged out, we will NOT retransmit this transaction and undefined
behavior can occur including gaps in the nonce sequence that require manual
intervention to fix. Therefore, this number represents a number of blocks we
consider large enough that no re-org this deep will ever feasibly happen.

### ETH_HEAD_TRACKER_HISTORY_DEPTH

  * Default: _automatically set based on Chain ID, typically 100_

Tracks the top N block numbers to keep in the `heads` database table. Note
that this can easily result in MORE than N total records since in the case of
re-orgs we keep multiple heads for a particular block height, and it is also
scoped per chain. This number should be at least as large as
`ETH_FINALITY_DEPTH`. There might be a small performance penalty to setting
this to something very large (10,000+)

### ETH_HEAD_TRACKER_MAX_BUFFER_SIZE

  * Default: `""3""`

The maximum number of heads that can be buffered in front of the head tracker
before older heads start to be dropped. Think this setting as the maximum
permitted ""lag"" for the head tracker before the Chainlink node starts dropping
heads to keep up.

### ETH_HEAD_TRACKER_SAMPLING_INTERVAL

  * Default: _automatically set based on Chain ID, typically 1s_

Head tracker sampling was introduced to handle chains with very high
throughput. If this is set, the head tracker will ""gap"" heads and deliver a
maximum of 1 head per this period.

Set to `0` to disable head tracker sampling.

### ETH_LOG_BACKFILL_BATCH_SIZE

  * Default: _automatic based on Chain ID, typically 100_

Controls the batch size for calling FilterLogs when backfilling missing or
recent logs.

### ETH_LOG_POLL_INTERVAL

  * Default: _automatic based on Chain ID_

Defines how frequently to poll for new logs.

### ETH_RPC_DEFAULT_BATCH_SIZE

  * Default: _automatic based on chain ID_

Chainlink nodes use batch mode for certain RPC calls to increase efficiency of
communication with the remote ETH node. In some cases, trying to request too
many items in a single batch will result in an error (e.g. due to bugs in go-
ethereum, third-party provider limitations, limits inherent to the websocket
channel etc). This setting controls the maximum number of items that can be
requested in a single batch. Chainlink nodes use built-in conservative
defaults for different chains that should work out of the box.

If you have enabled HTTP URLs for all of your ETH nodes, you can safely
increase this to a larger value e.g. 100 and see significant RPC performance
improvements.

### LINK_CONTRACT_ADDRESS

  * Default: _automatic based on Chain ID_

The address of the LINK token contract. It is not essential to provide this,
but if given, it is used for displaying the node account's LINK balance. For
supported chains, this is automatically set based on the given chain ID. For
unsupported chains, you must supply it yourself.

This environment variable is a global override. It is recommended instead to
set this on a per-chain basis.

### MIN_INCOMING_CONFIRMATIONS

  * Default: _automatic based on chain ID, typically 3_

The number of block confirmations to wait before kicking off a job run or
proceeding with a task that listens to blockchain and log events. Setting this
to a lower value improves node response time at the expense of occasionally
submitting duplicate transactions in the event of chain re-orgs (duplicate
transactions are harmless but cost some ETH).

You can override this on a per-job basis.

`MIN_INCOMING_CONFIRMATIONS=1` would kick off a job after seeing the
transaction in just one block.

caution

The lowest value allowed here is 1, since setting to 0 would imply that logs
are processed from the mempool before they are even mined into a block, which
isn't possible with Chainlink's current architecture.

### MIN_OUTGOING_CONFIRMATIONS

  * Default: _automatic based on chain ID, typically 12_

The default minimum number of block confirmations that need to be recorded on
an outgoing `ethtx` task before the run can move onto the next task.

This can be overridden on a per-task basis by setting the
`MinRequiredOutgoingConfirmations` parameter.

`MIN_OUTGOING_CONFIRMATIONS=1` considers a transaction as ""done"" once it has
been mined into one block. `MIN_OUTGOING_CONFIRMATIONS=0` would consider a
transaction as ""done"" even before it has been mined.

### MINIMUM_CONTRACT_PAYMENT_LINK_JUELS

note

  * Default: _automatically set based on Chain ID, typically 10000000000000 (0.00001 LINK) on all chains except Ethereum Mainnet and Sepolia where it is 100000000000000000 (0.1 LINK)._

For jobs that use the `EthTx` adapter, this is the minimum payment amount in
order for the node to accept and process the job. Since there are no decimals
on the EVM, the value is represented like wei.

note

Keep in mind, the Chainlink node currently responds with a 500,000 gas limit.
Under pricing your node could mean it spends more in ETH (on gas) than it
earns in LINK.

### NODE_NO_NEW_HEADS_THRESHOLD

  * Default: _automatically set based on Chain ID, typically ""3m"" (3 minutes)_

Controls how long to wait after receiving no new heads before marking the node
as out-of-sync.

Set to zero to disable out-of-sync checking.

### NODE_POLL_FAILURE_THRESHOLD

  * Default: _automatically set based on Chain ID, typically 3_

Indicates how many consecutive polls must fail in order to mark a node as
unreachable.

Set to zero to disable poll checking.

### NODE_POLL_INTERVAL

  * Default: _automatically set based on Chain ID, typically ""10s"" (10 seconds)_

Controls how often to poll the node to check for liveness.

Set to zero to disable poll checking.

### NODE_SELECTION_MODE

  * Default: `""HighestHead""`

Controls node picking strategy. Supported values:

  * `HighestHead` (default) mode picks a node having the highest reported head number among other alive nodes. When several nodes have the same latest head number, the strategy sticks to the last used node. This mode requires `NODE_NO_NEW_HEADS_THRESHOLD` to be configured, otherwise it will always use the first alive node.
  * `RoundRobin` mode simply iterates among available alive nodes. This was the default behavior prior to this release.
  * `TotalDifficulty` mode selects the node with the greatest total difficulty.

### NODE_SYNC_THRESHOLD

  * Default: `5`

SyncThreshold controls how far a node may lag behind the best node before
being marked out-of-sync. Depending on the [`NODE_SELECTION_MODE`
variable](/chainlink-nodes/v1/configuration/#node_selection_mode), this
represents a difference in either the number of blocks (`HighestHead`,
`RoundRobin`), or the total difficulty (`TotalDifficulty`).

Set to `0` to disable this check.

## EVM Gas Controls

These settings allow you to tune your node's gas limits and pricing. In most
cases, leaving these values at their defaults should give good results.

As of Chainlink node v1.1.0, it is recommended to use the API, CLI, or GUI to
configure gas controls because you might want to use different settings for
different chains. Setting the environment variable typically overrides the
setting for all chains.

### Configuring your ETH node

Your ETH node might need some configuration tweaks to make it fully compatible
with Chainlink nodes depending on your configuration.

#### go-ethereum

WARNING: By default, go-ethereum will reject transactions that exceed it's
built-in RPC gas or txfee caps. Chainlink nodes will fatally error
transactions if this happens which means if you ever exceed the caps your node
will miss transactions.

You should at a bare minimum disable the default RPC gas and txfee caps on
your ETH node. This can be done in the TOML file as seen below, or by running
go-ethereum with the command line arguments: `--rpc.gascap=0
--rpc.txfeecap=0`.

It is also recommended to configure go-ethereum properly before increasing
`ETH_MAX_IN_FLIGHT_TRANSACTIONS` to ensure all in-flight transactions are
maintained in the mempool.

Relevant settings for geth and forks (such as BSC).


    [Eth]
    RPCGasCap = 0 # it is recommended to disable both gas and txfee cap
    RPCTxFeeCap = 0.0
    [Eth.TxPool]
    Locals = [""0xYourNodeAddress1"", ""0xYourNodeAddress2""]  # Add your node addresses here
    NoLocals = false # Disabled by default but might as well make sure
    Journal = ""transactions.rlp"" # Make sure you set a journal file
    Rejournal = 3600000000000 # Default 1h, it might make sense to reduce this to e.g. 5m
    PriceBump = 10 # Must be set less than or equal to Chainlink's ETH_GAS_BUMP_PERCENT
    AccountSlots = 16 # Highly recommended to increase this, must be greater than or equal to Chainlink's ETH_MAX_IN_FLIGHT_TRANSACTIONS setting
    GlobalSlots = 4096 # Increase this as necessary
    AccountQueue = 64 # Increase this as necessary
    GlobalQueue = 1024 # Increase this as necessary
    Lifetime = 10800000000000 # Default 3h, this is probably ok, you might even consider reducing it

### EVM_EIP1559_DYNAMIC_FEES

  * Default: _automatic based on chain ID_

Forces EIP-1559 transaction mode for all chains. Enabling EIP-1559 mode can
help reduce gas costs on chains that support it. This is supported only on
official Ethereum mainnet and testnets. It is not recommended to enable this
setting on Polygon because the EIP-1559 fee market appears to be broken on all
Polygon chains and EIP-1559 transactions are less likely to be included than
legacy transactions.

#### Technical details

Chainlink nodes include experimental support for submitting transactions using
type 0x2 (EIP-1559) envelope.

EIP-1559 mode is enabled by default on the Ethereum Mainnet, but can be
enabled on a per-chain basis or globally.

This might help to save gas on spikes. Chainlink nodes should react faster on
the upleg and avoid overpaying on the downleg. It might also be possible to
set `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` to a smaller value such as 12 or even
6 because tip cap should be a more consistent indicator of inclusion time than
total gas price. This would make Chainlink nodes more responsive and should
reduce response time variance. Some experimentation is required to find
optimum settings.

To enable globally, set `EVM_EIP1559_DYNAMIC_FEES=true`. Set with caution, if
you set this on a chain that does not actually support EIP-1559 your node will
be broken.

In EIP-1559 mode, the total price for the transaction is the minimum of base
fee + tip cap and fee cap. More information can be found on the [official
EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).

Chainlink's implementation of EIP-1559 works as follows:

If you are using FixedPriceEstimator:

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and `tipcap=EVM_GAS_TIP_CAP_DEFAULT`
  * With gas bumping enabled, it will submit all transactions initially with `feecap=EVM_GAS_FEE_CAP_DEFAULT` and `tipcap=EVM_GAS_TIP_CAP_DEFAULT`.

If you are using BlockHistoryEstimator (default for most chains):

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and `tipcap=<calculated using past blocks>`
  * With gas bumping enabled (default for most chains) it will submit all transactions initially with `feecap=current block base fee * (1.125 ^ N)` where N is configurable by setting BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS but defaults to `gas bump threshold+1` and `tipcap=<calculated using past blocks>`

Bumping works as follows:

  * Increase tipcap by `max(tipcap * (1 + ETH_GAS_BUMP_PERCENT), tipcap + ETH_GAS_BUMP_WEI)`
  * Increase feecap by `max(feecap * (1 + ETH_GAS_BUMP_PERCENT), feecap + ETH_GAS_BUMP_WEI)`

A quick note on terminology - Chainlink nodes use the same terms used
internally by go-ethereum source code to describe various prices. This is not
the same as the externally used terms. For reference:

  * Base Fee Per Gas = BaseFeePerGas
  * Max Fee Per Gas = FeeCap
  * Max Priority Fee Per Gas = TipCap

In EIP-1559 mode, the following changes occur to how configuration works:

  * All new transactions will be sent as type 0x2 transactions specifying a TipCap and FeeCap. Be aware that existing pending legacy transactions will continue to be gas bumped in legacy mode.
  * `BlockHistoryEstimator` will apply its calculations (gas percentile etc) to the TipCap and this value will be used for new transactions (GasPrice will be ignored)
  * `FixedPriceEstimator` will use `EVM_GAS_TIP_CAP_DEFAULT` instead of `ETH_GAS_PRICE_DEFAULT` for the tip cap
  * `FixedPriceEstimator` will use `EVM_GAS_FEE_CAP_DEFAULT` instaed of `ETH_GAS_PRICE_DEFAULT` for the fee cap
  * `ETH_MIN_GAS_PRICE_WEI` is ignored for new transactions and `EVM_GAS_TIP_CAP_MINIMUM` is used instead (default 0)
  * `ETH_MAX_GAS_PRICE_WEI` still represents that absolute upper limit that Chainlink will ever spend (total) on a single tx
  * `KEEPER_GAS_PRICE_BUFFER_PERCENT` is ignored in EIP-1559 mode and `KEEPER_TIP_CAP_BUFFER_PERCENT` is used instead

### ETH_GAS_BUMP_PERCENT

  * Default: _automatic based on chain ID_

The percentage by which to bump gas on a transaction that has exceeded
`ETH_GAS_BUMP_THRESHOLD`. The larger of `ETH_GAS_BUMP_PERCENT` and
`ETH_GAS_BUMP_WEI` is taken for gas bumps.

### ETH_GAS_BUMP_THRESHOLD

  * Default: _automatic based on chain ID_

Chainlink nodes can be configured to automatically bump gas on transactions
that have been stuck waiting in the mempool for at least this many blocks. Set
to 0 to disable gas bumping completely.

### ETH_GAS_BUMP_TX_DEPTH

  * Default: `""10""`

The number of transactions to gas bump starting from oldest. Set to 0 for no
limit (i.e. bump all).

### ETH_GAS_BUMP_WEI

  * Default: _automatic based on chain ID_

The minimum fixed amount of wei by which gas is bumped on each transaction
attempt.

### EVM_GAS_FEE_CAP_DEFAULT

  * Default: _automatic based on chain ID_

If EIP1559 mode is enabled, and FixedPrice gas estimator is used, this env var
controls the fixed initial fee cap.

### ETH_GAS_LIMIT_DEFAULT

  * Default: _automatically set based on Chain ID, typically 500000_

The default gas limit for outgoing transactions. This should not need to be
changed in most cases. Some job types, such as Keeper jobs, might set their
own gas limit unrelated to this value.

### ETH_GAS_LIMIT_MAX

  * Default: _automatically set based on Chain ID, typically 500000_

The maxium for gas limits estimated by the `Arbitrum` `GAS_ESTIMATOR_MODE`.
This should not need to be changed in most cases.

### ETH_GAS_LIMIT_MULTIPLIER

  * Default: `""1.0""`

A factor by which a transaction's GasLimit is multiplied before transmission.
So if the value is 1.1, and the GasLimit for a transaction is 10, 10% will be
added before transmission.

This factor is always applied, so includes Optimism L2 transactions which uses
a default gas limit of 1 and is also applied to EthGasLimitDefault.

### ETH_GAS_LIMIT_TRANSFER

  * Default: _automatically set based on Chain ID, typically 21000_

The gas limit used for an ordinary ETH transfer.

### ETH_GAS_PRICE_DEFAULT

(Only applies to legacy transactions)

  * Default: _automatic based on chain ID_

The default gas price to use when submitting transactions to the blockchain.
Will be overridden by the built-in `BlockHistoryEstimator` if enabled, and
might be increased if gas bumping is enabled.

Can be used with the `chainlink setgasprice` to be updated while the node is
still running.

### EVM_GAS_TIP_CAP_DEFAULT

(Only applies to EIP-1559 transactions)

  * Default: _automatic based on chain ID_

The default gas tip to use when submitting transactions to the blockchain.
Will be overridden by the built-in `BlockHistoryEstimator` if enabled, and
might be increased if gas bumping is enabled.

### EVM_GAS_TIP_CAP_MINIMUM

(Only applies to EIP-1559 transactions)

  * Default: _automatic based on chain ID_

The minimum gas tip to use when submitting transactions to the blockchain.

### ETH_MAX_GAS_PRICE_WEI

  * Default: _automatic based on chain ID_

Chainlink nodes will never pay more than this for a transaction.

### ETH_MAX_IN_FLIGHT_TRANSACTIONS

  * Default: `""16""`

Controls how many transactions are allowed to be ""in-flight"" i.e. broadcast
but unconfirmed at any one time. You can consider this a form of transaction
throttling.

The default is set conservatively at 16 because this is a pessimistic minimum
that geth will hold without evicting local transactions. If your node is
falling behind and you need higher throughput, you can increase this setting,
but you MUST make sure that your ETH node is configured properly otherwise you
can get nonce gapped and your node will get stuck.

0 value disables the limit. Use with caution.

### ETH_MAX_QUEUED_TRANSACTIONS

  * Default: _automatically set based on Chain ID, typically 250_

The maximum number of unbroadcast transactions per key that are allowed to be
enqueued before jobs will start failing and rejecting send of any further
transactions. This represents a sanity limit and generally indicates a problem
with your ETH node (transactions are not getting mined).

Do NOT blindly increase this value thinking it will fix things if you start
hitting this limit because transactions are not getting mined, you will
instead only make things worse.

In deployments with very high burst rates, or on chains with large re-orgs,
you _may_ consider increasing this.

0 value disables any limit on queue size. Use with caution.

### ETH_MIN_GAS_PRICE_WEI

(Only applies to legacy transactions)

  * Default: _automatic based on chain ID_

Chainlink nodes will never pay less than this for a transaction.

It is possible to force the Chainlink node to use a fixed gas price by setting
a combination of these, e.g.


    EVM_EIP1559_DYNAMIC_FEES=false
    ETH_MAX_GAS_PRICE_WEI=100
    ETH_MIN_GAS_PRICE_WEI=100
    ETH_GAS_PRICE_DEFAULT=100
    ETH_GAS_BUMP_THRESHOLD=0
    GAS_ESTIMATOR_MODE=""FixedPrice""

### ETH_GAS_LIMIT_OCR_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for OCR jobs. This environment variable does
not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_GAS_LIMIT_DR_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for direct request jobs. This environment
variable does not override task-specific or job-specific `gasLimit` parameters
or attributes.

### ETH_GAS_LIMIT_VRF_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for VRF jobs. This environment variable does
not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_GAS_LIMIT_FM_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for Flux Monitor jobs. This environment
variable does not override task-specific or job-specific `gasLimit` parameters
or attributes.

### ETH_GAS_LIMIT_KEEPER_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for Keeper jobs. This environment variable
does not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_NONCE_AUTO_SYNC

  * Default: `""false""`

Chainlink nodes will automatically try to sync its local nonce with the remote
chain on startup and fast forward if necessary. This is almost always safe but
can be disabled in exceptional cases by setting this value to false.

### ETH_USE_FORWARDERS

  * Default: `""false""`

Enables or disables sending transactions through forwarder contracts.

## EVM/Ethereum Gas Price Estimation

These settings allow you to configure how your node calculates gas prices. In
most cases, leaving these values at their defaults should give good results.

As of Chainlink node v1.1.0, it is recommended to use the API, CLI, or GUI to
configure gas controls because you might want to use different settings for
different chains. Setting the environment variable typically overrides the
setting for all chains.

Chainlink nodes decide what gas price to use using an `Estimator`. It ships
with several simple and battle-hardened built-in estimators that should work
well for almost all use-cases. Note that estimators will change their
behaviour slightly depending on if you are in EIP-1559 mode or not.

You can also use your own estimator for gas price by selecting the
`FixedPrice` estimator and using the exposed API to set the price.

An important point to note is that the Chainlink node does _not_ ship with
built-in support for go-ethereum's `estimateGas` call. This is for several
reasons, including security and reliability. We have found empirically that it
is not generally safe to rely on the remote ETH node's idea of what gas price
should be.

### GAS_ESTIMATOR_MODE

  * Default: _automatic, based on chain ID_

Controls what type of gas estimator is used.

  * `FixedPrice` uses static configured values for gas price (can be set via API call).
  * `BlockHistory` dynamically adjusts default gas price based on heuristics from mined blocks.
  * `Optimism2`/`L2Suggested` is a special mode only for use with Optimism and Metis blockchains. This mode will use the gas price suggested by the rpc endpoint via `eth_gasPrice`.
  * `Arbitrum` is a special mode only for use with Arbitrum blockchains. It uses the suggested gas price (up to `ETH_MAX_GAS_PRICE_WEI`, with `1000 gwei` default) as well as an estimated gas limit (up to `ETH_GAS_LIMIT_MAX`, with `1,000,000,000` default).

### BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE

  * Default: _automatic, based on chain ID, typically 4_

Sets the maximum number of blocks to fetch in one batch in the block history
estimator. If the `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` environment variable is
set to 0, it defaults to ETH_RPC_DEFAULT_BATCH_SIZE.

### BLOCK_HISTORY_ESTIMATOR_BLOCK_HISTORY_SIZE

  * Default: _automatic, based on chain ID_

Controls the number of past blocks to keep in memory to use as a basis for
calculating a percentile gas price.

### BLOCK_HISTORY_ESTIMATOR_BLOCK_DELAY

  * Default: _automatic, based on chain ID_

Controls the number of blocks that the block history estimator trails behind
head. For example, if this is set to 3, and we receive block 10, block history
estimator will fetch block 7.

CAUTION: You might be tempted to set this to 0 to use the latest possible
block, but it is possible to receive a head BEFORE that block is actually
available from the connected node via RPC, due to race conditions in the code
of the remote ETH node. In this case you will get false ""zero"" blocks that are
missing transactions.

### BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS

**ADVANCED**

  * Default: _gas bump threshold + 1 block_

If EIP1559 mode is enabled, this optional env var controls the buffer blocks
to add to the current base fee when sending a transaction. By default, the gas
bumping threshold + 1 block is used. It is not recommended to change this
unless you know what you are doing.

### BLOCK_HISTORY_ESTIMATOR_TRANSACTION_PERCENTILE

  * Default: `""60""`

Must be in range 0-100.

Only has an effect if gas updater is enabled. Specifies percentile gas price
to choose. E.g. if the block history contains four transactions with gas
prices `[100, 200, 300, 400]` then picking 25 for this number will give a
value of 200. If the calculated gas price is higher than
`ETH_GAS_PRICE_DEFAULT` then the higher price will be used as the base price
for new transactions.

Think of this number as an indicator of how aggressive you want your node to
price its transactions.

Setting this number higher will cause the Chainlink node to select higher gas
prices.

Setting it lower will tend to set lower gas prices.

## EVM/Ethereum Transaction Simulation

Chainlink nodes support transaction simulation for certain types of job. When
this is enabled, transactions will be simulated using `eth_call` before
initial send. If the transaction would revert, the transaction is marked as an
error without being broadcast, potentially avoiding an expensive on-chain
revert.

This can add a tiny bit of latency with an upper bound of 2s, but generally
much shorter under good conditions. This will add marginally more load to the
ETH client, because it adds an extra call for every transaction sent. However,
it might help to save gas in some cases especially during periods of high
demand by avoiding unnecessary reverts due to outdated round etc.

This option is EXPERIMENTAL and disabled by default.

To enable for FM or OCR:

`FM_SIMULATE_TRANSACTIONs=true` `OCR_SIMULATE_TRANSACTIONS=true`

To enable in the pipeline, use the `simulate=true` option like so:


    submit [type=ethtx to=""0xDeadDeadDeadDeadDeadDeadDeadDead"" data=""0xDead"" simulate=true]

Use at your own risk.

#### FM_SIMULATE_TRANSACTIONS

NOTE: This overrides the setting for _all_ chains, it is not currently
possible to configure this on a per-chain basis.

  * Default: `""false""`

`FM_SIMULATE_TRANSACTIONS` allows to enable transaction simulation for Flux
Monitor.

#### OCR_SIMULATE_TRANSACTIONS

NOTE: This overrides the setting for _all_ chains, it is not currently
possible to configure this on a per-chain basis.

  * Default: `""false""`

`OCR_SIMULATE_TRANSACTIONS` allows to enable transaction simulation for OCR.

## Job Pipeline and tasks

### DEFAULT_HTTP_LIMIT

  * Default: `""32768""`

`DEFAULT_HTTP_LIMIT` defines the maximum number of bytes for HTTP requests and
responses made by `http` and `bridge` adapters.

### DEFAULT_HTTP_TIMEOUT

  * Default: `""15s""`

`DEFAULT_HTTP_TIMEOUT` defines the default timeout for HTTP requests made by
`http` and `bridge` adapters.

### FEATURE_EXTERNAL_INITIATORS

  * Default: `""false""`

Enables the External Initiator feature. If disabled, `webhook` jobs can ONLY
be initiated by a logged-in user. If enabled, `webhook` jobs can be initiated
by a whitelisted external initiator.

### JOB_PIPELINE_MAX_RUN_DURATION

  * Default: `""10m""`

`JOB_PIPELINE_MAX_RUN_DURATION` is the maximum time that a single job run
might take. If it takes longer, it will exit early and be marked errored. If
set to zero, disables the time limit completely.

### JOB_PIPELINE_MAX_SUCCESSFUL_RUNS

This option is not supported as an environment variable. Use
`JobPipeline.MaxSuccessfulRuns` in the config file instead. See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.12.0/docs/CONFIG.md)
reference for details.

### JOB_PIPELINE_REAPER_INTERVAL

  * Default: `""1h""`

In order to keep database size manageable, Chainlink nodes will run a reaper
that deletes completed job runs older than a certain threshold age.
`JOB_PIPELINE_REAPER_INTERVAL` controls how often the job pipeline reaper will
run.

Set to `0` to disable the periodic reaper.

### JOB_PIPELINE_REAPER_THRESHOLD

  * Default: `""24h""`

`JOB_PIPELINE_REAPER_THRESHOLD` determines the age limit for job runs.
Completed job runs older than this will be automatically purged from the
database.

### JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH

  * Default: `""100""`

Some jobs write their results asynchronously for performance reasons such as
OCR. `JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH` controls how many writes will be
buffered before subsequent writes are dropped.

Do not change this setting unless you know what you are doing.

## OCR

This section applies only if you are running off-chain reporting jobs.

### FEATURE_OFFCHAIN_REPORTING

  * Default: `""false""`

Set to `true` to enable OCR jobs.

### OCR_KEY_BUNDLE_ID

  * Default: _none_

`OCR_KEY_BUNDLE_ID` is the default key bundle ID to use for OCR jobs. If you
have an OCR job that does not explicitly specify a key bundle ID, it will fall
back to this value.

### OCR_MONITORING_ENDPOINT

  * Default: _none_

Optional URL of OCR monitoring endpoint.

### OCR_TRANSMITTER_ADDRESS

  * Default: _none_

`OCR_TRANSMITTER_ADDRESS` is the default sending address to use for OCR. If
you have an OCR job that does not explicitly specify a transmitter address, it
will fall back to this value.

### P2P_NETWORKING_STACK

  * Default: `""V1""`

OCR supports multiple networking stacks. `P2P_NETWORKING_STACK` chooses which
stack to use. Possible values are:

  * `V1`
  * `V1V2` \- Runs both stacks simultaneously. For each link with another peer, V2 networking will be preferred. If V2 does not work, the link will automatically fall back to V1. If V2 starts working again later, it will automatically be prefered again. This is useful for migrating networks without downtime. Note that the two networking stacks _must not_ be configured to bind to the same IP/port.
  * `V2`

All nodes in the OCR network should share the same networking stack. The `V1`
stack is deprecated and is being phased out. Do not use it for new
deployments. Expect the default value of this variable to change to `V2` in
the future.

#### P2P_PEER_ID

  * Default: _none_

This environment variable is used for both Networking Stack V1 and V2.

The default peer ID to use for OCR jobs. If unspecified, uses the first
available peer ID. Example:
`P2P_PEER_ID=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U`

### Networking Stack V1

caution

Do not set environment variables for Networking Stack v1 if you are using
Networking Stack V2.

#### P2P_ANNOUNCE_IP

  * Default: _none_

Should be set as the externally reachable IP address of the Chainlink node.
Example: `P2P_ANNOUNCE_IP=1.2.3.4`

#### P2P_ANNOUNCE_PORT

  * Default: _none_

Should be set as the externally reachable port of the Chainlink node. Example:
`P2P_ANNOUNCE_PORT=1337`

#### P2P_BOOTSTRAP_PEERS

  * Default: _none_

Default set of bootstrap peers. Example:
`P2P_BOOTSTRAP_PEERS=/dns4/example.com/tcp/1337/p2p/12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U
/ip4/1.2.3.4/tcp/9999/p2p/12D3KooWLZ9uTC3MrvKfDpGju6RAQubiMDL7CuJcAgDRTYP7fh7R`

#### P2P_LISTEN_IP

  * Default: `""0.0.0.0""`

The default IP address to bind to.

#### P2P_LISTEN_PORT

  * Default: _none_

The port to listen on. If left blank, the node randomly selects a different
port each time it boots. It is highly recommended to set this to a static
value to avoid network instability.

#### P2P_PEER_ID

  * Default: _none_

This environment variable is used for both Networking Stack V1 and V2.

The default peer ID to use for OCR jobs. If unspecified, uses the first
available peer ID. Example:
`P2P_PEER_ID=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U`

### Networking Stack V2

caution

If using the Networking Stack V2, you must unset the following Networking
Stack V1 configuration variables:

  * P2P_ANNOUNCE_IP
  * P2P_ANNOUNCE_PORT
  * P2P_BOOTSTRAP_PEERS
  * P2P_LISTEN_IP
  * P2P_LISTEN_PORT

`P2P_PEER_ID` is used for both Networking Stack V1 and V2.

The Networking Stack V2 uses TCP, any ports mentioned in this section refer to
TCP ports.

#### P2PV2_ANNOUNCE_ADDRESSES

  * Default: _none_

`P2PV2_ANNOUNCE_ADDRESSES` contains the addresses the node will advertise for
peer discovery in host:port form as accepted by the TCP version of Go's
[`net.Dial`](https://pkg.go.dev/net#Dial). The addresses should be reachable
by other nodes on the network. When attempting to connect to another node, a
node will attempt to dial all of the other node's `P2PV2_ANNOUNCE_ADDRESSES`
in round-robin fashion. Example: `P2PV2_ANNOUNCE_ADDRESSES=1.2.3.4:9999
[a52d:0:a88:1274::abcd]:1337`

#### P2PV2_BOOTSTRAPPERS

  * Default: _none_

`P2PV2_BOOTSTRAPPERS` returns the default bootstrapper peers for libocr's v2
networking stack. Example:
`P2PV2_BOOTSTRAPPERS=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U@1.2.3.4:9999
12D3KooWLZ9uTC3MrvKfDpGju6RAQubiMDL7CuJcAgDRTYP7fh7R@[a52d:0:a88:1274::abcd]:1337
12D3KooWM55u5Swtpw9r8aFLQHEtw7HR4t44GdNs654ej5gRs2Dh@example.com:1234`

Oracle nodes typically only know each other's PeerIDs, but not their
hostnames, IP addresses, or ports. Bootstrappers are special nodes that help
other nodes discover each other's `P2PV2_ANNOUNCE_ADDRESSES` so they can
communicate. Nodes continuously attempt to connect to bootstrappers configured
in `P2PV2_BOOTSTRAPPERS`. When a node wants to connect to another node (which
it knows only by PeerID, but not by address), it discovers the other node's
`P2PV2_ANNOUNCE_ADDRESSES` from communications received from its
`P2PV2_BOOTSTRAPPERS` or other discovered nodes. To facilitate discovery,
nodes will regularly broadcast signed announcements containing their PeerID
and `P2PV2_ANNOUNCE_ADDRESSES`.

#### P2PV2_LISTEN_ADDRESSES

  * Default: _none_

`P2PV2_LISTEN_ADDRESSES` contains the addresses the peer will listen to on the
network in `host:port` form as accepted by `net.Listen()`, but the host and
port must be fully specified and cannot be empty. You can specify `0.0.0.0`
(IPv4) or `::` (IPv6) to listen on all interfaces, but that is not
recommended.

Example: `P2PV2_LISTEN_ADDRESSES=1.2.3.4:9999 [a52d:0:a88:1274::abcd]:1337`

## Keeper

These environment variables are used specificly for Chainlink Keepers. For
most Chainlink Nodes, leave these values at their defaults and do not
configure these environment variables.

### KEEPER_GAS_PRICE_BUFFER_PERCENT

caution

  * Default: `""20""`

`KEEPER_GAS_PRICE_BUFFER_PERCENT` adds the specified percentage to the gas
price used for checking whether to perform an upkeep. Only applies in legacy
mode (EIP-1559 off).

### KEEPER_GAS_TIP_CAP_BUFFER_PERCENT

caution

  * Default: `""20""`

`KEEPER_GAS_TIP_CAP_BUFFER_PERCENT` adds the specified percentage to the gas
price used for checking whether to perform an upkeep. Only applies in EIP-1559
mode.

### KEEPER_BASE_FEE_BUFFER_PERCENT

caution

  * Default: `""20""`

Adds the specified percentage to the base fee used for checking whether to
perform an upkeep. Applies only in EIP-1559 mode.

### KEEPER_MAXIMUM_GRACE_PERIOD

caution

  * Default: `""100""`

The maximum number of blocks that a keeper will wait after performing an
upkeep before it resumes checking that upkeep

### KEEPER_REGISTRY_CHECK_GAS_OVERHEAD

caution

  * Default: `""200000""`

The amount of extra gas to provide checkUpkeep() calls to account for the gas
consumed by the keeper registry.

### KEEPER_REGISTRY_PERFORM_GAS_OVERHEAD

caution

  * Default: `""300000""`

The amount of extra gas to provide performUpkeep() calls to account for the
gas consumed by the keeper registry

### KEEPER_REGISTRY_SYNC_INTERVAL

caution

  * Default: `""30m""`

The interval in which the RegistrySynchronizer performs a full sync of the
keeper registry contract it is tracking.

### KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE

caution

  * Default: `""10""`

`KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE` represents the maximum number of
upkeeps that can be synced in parallel.

### KEEPER_TURN_LOOK_BACK

caution

  * Default: `""1000""`

The number of blocks in the past to look back when getting a block for a turn.

## CLI Client

The environment variables in this section apply only when running CLI commands
that connect to a remote running instance of a Chainlink node.

### ADMIN_CREDENTIALS_FILE

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--admin-credentials-file FILE` CLI argument instead.

  * Default: `$ROOT/apicredentials`

`ADMIN_CREDENTIALS_FILE` optionally points to a text file containing admin
credentials for logging in. It is useful for running client CLI commands and
has no effect when passed to a running node.

The file should contain two lines, the first line is the username and second
line is the password. e.g.


    myusername@example.com
    mysecurepassw0rd

### CLIENT_NODE_URL

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--remote-node-url URL` CLI argument instead.

  * Default: `""http://localhost:6688""`

This is the URL that you will use to interact with the node, including the
GUI. Use this URL to connect to the GUI or to run commands remotely using the
Chainlink CLI.

### INSECURE_SKIP_VERIFY

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--insecure-skip-verify` CLI argument instead.

  * Default: `""false""`

`INSECURE_SKIP_VERIFY` disables SSL certificate verification when connection
to a Chainlink node using the remote client. For example, when executing most
remote commands in the CLI. This is mostly useful for people who want to use
TLS on localhost.

It is not recommended to change this unless you know what you are doing.

## Notes on setting environment variables

note

Some environment variables require a duration. A duration string is a possibly
signed sequence of decimal numbers, each with optional fraction and a unit
suffix, such as ""300ms"", ""-1.5h"" or ""2h45m"". Valid time units are ""ns"", ""us""
(or ""µs""), ""ms"", ""s"", ""m"", ""h"". Some examples:

`10ms` `1h15m` `42m30s`

note

Some configuration variables require a file size. A file size string is an
unsigned integer (123) or a float (12.3) followed by a unit suffix. Valid file
size units are ""b"", ""kb"", ""mb"", ""gb"", and ""tb"". If the unit is omitted, it is
assumed to be ""b"" (bytes). Capitalization does not matter. Some examples:

`123gb` `1.2TB` `12345`

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/configuration.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.
"
What are some improvements and changes introduced in Chainlink VRF v2?,"Chainlink VRF v2 includes improvements such as subscription management, variable callback gas limit, more configuration capability, multiple random outputs in a single request, and unified billing.",{'source': 'https://docs.chain.link/vrf/v2/subscription/migration-from-v1/'},"Some improvements and changes introduced in Chainlink VRF v2 include:

1. Variable Callback Gas Limit: VRF v2 allows for adjusting the callback gas limit, allowing consuming contracts to execute more complex logic in the callback request function that receives the random values. The new gas limits are higher than VRF v1. (Source: https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/)

2. More configuration capability: VRF v2 allows for defining how many block confirmations must pass before verifiable randomness is generated and delivered on-chain. The range is from 3 to 200 blocks, providing flexibility in balancing block re-organizations and low latency. (Source: https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/)

3. Multiple Random Outputs in a Single Request: VRF v2 allows for requesting multiple random numbers in a single on-chain transaction, reducing gas costs and response latency. (Source: https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/)

These are just a few of the improvements and changes introduced in Chainlink VRF v2. For more details, please refer to the provided sources.

","- https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/
- https://docs.chain.link/vrf/v2/subscription/migration-from-v1/","# Migrating from VRF v1

  * Overview
  * Comparison between VRF v1 and VRF v2 (Direct funding method)
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparison between VRF v1 and VRF v2 (Direct funding method)

The main similarity between VRF v1 and VRF v2 Direct funding method is that
consuming contracts must be funded with LINK to pay for requests. However,
Chainlink VRF v2 includes several improvements.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper contracts](/vrf/v2/direct-funding/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

## Updating your applications to use VRF v2

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) guide for an example.

  1. Import and inherit the new [`VRFV2WrapperConsumerBase.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  2. Add a `VRFV2WrapperConsumerBase` constructor as shown in the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) example and use the correct VRF v2 Direct funding configuration.

  3. You can still call the `requestRandomness` function. However, the v2 `requestRandomness` function requires several different parameters (`callbackGasLimit` , `requestConfirmations` , `numWords`). See the [Supported networks](/vrf/v2/direct-funding/supported-networks) page to adjust them for your own needs.

  4. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  2. Import the new [`VRFConsumerBaseV2.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  3. Import the [`VRFCoordinatorV2Interface.sol` interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol). This interface includes the new `requestRandomWords` function.

  4. Add a `VRFConsumerBaseV2` constructor as shown in the [Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number) example.

  5. Change `requestRandomness` function calls to `requestRandomWords`. The `requestRandomWords` function requires several additional parameters.

  6. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are some improvements in Chainlink VRF v2 compared to VRF v1 Direct funding method?,"Chainlink VRF v2 includes improvements such as variable callback gas limit, more configuration capability, and multiple random outputs in a single request.",{'source': 'https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/'},"Some improvements in Chainlink VRF v2 compared to VRF v1 Direct funding method include:

1. Variable Callback Gas Limit: VRF v2 allows for adjusting the callback gas limit, allowing consuming contracts to execute more complex logic in the callback request function.

2. More configuration capability: VRF v2 allows for defining the number of block confirmations required before verifiable randomness is generated and delivered on-chain.

3. Multiple Random Outputs in a Single Request: VRF v2 allows for requesting multiple random numbers in a single on-chain transaction, reducing gas costs and response latency.

","
- https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/
- https://docs.chain.link/vrf/v2/subscription/migration-from-v1/","# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                                                                                                          | Suitable for infrequent one-off requests                                                                                                                                                                    |
| Supports multiple VRF consuming contracts connected to one subscription account                                                                                        | Each VRF consuming contract directly pays for its requests                                                                                                                                                  |
| VRF costs are calculated after requests are fulfilled and then deducted from the subscription balance. Learn how VRF costs are calculated for the subscription method. | VRF costs are estimated and charged at request time, which may make it easier to transfer the cost of VRF to the end user. Learn how VRF costs are calculated for the direct funding method.                |
| Reduced gas overhead and more control over the maximum gas price for requests                                                                                          | Higher gas overhead than the subscription method                                                                                                                                                            |
| More random values returned per single request. See the maximum random values per request for the Subscription supported networks.                                     | Fewer random values returned per single request than the subscription method, due to higher overhead. See the maximum random values per request and gas overhead for the Direct funding supported networks. |
| You don't have to estimate costs precisely for each request. Ensure that the subscription account has enough funds.                                                    | You must estimate transaction costs carefully for each request to ensure the consuming contract has enough funds to pay for the request.                                                                    |
| Requires a subscription account                                                                                                                                        | No subscription account required                                                                                                                                                                            |
| Supported on Arbitrum                                                                                                                                                  | Not yet supported on Arbitrum                                                                                                                                                                               |
| VRF costs are billed to your subscription account. Manage and monitor your balance                                                                                     | No refunds for overpayment after requests are completed                                                                                                                                                     |
| Flexible funding method first introduced in VRF v2. Compare the VRF v2 subscription method to VRF v1.                                                                  | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparison between VRF v1 and VRF v2 (Direct funding method)
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparison between VRF v1 and VRF v2 (Direct funding method)

The main similarity between VRF v1 and VRF v2 Direct funding method is that
consuming contracts must be funded with LINK to pay for requests. However,
Chainlink VRF v2 includes several improvements.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper contracts](/vrf/v2/direct-funding/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

## Updating your applications to use VRF v2

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) guide for an example.

  1. Import and inherit the new [`VRFV2WrapperConsumerBase.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  2. Add a `VRFV2WrapperConsumerBase` constructor as shown in the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) example and use the correct VRF v2 Direct funding configuration.

  3. You can still call the `requestRandomness` function. However, the v2 `requestRandomness` function requires several different parameters (`callbackGasLimit` , `requestConfirmations` , `numWords`). See the [Supported networks](/vrf/v2/direct-funding/supported-networks) page to adjust them for your own needs.

  4. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  2. Import the new [`VRFConsumerBaseV2.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  3. Import the [`VRFCoordinatorV2Interface.sol` interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol). This interface includes the new `requestRandomWords` function.

  4. Add a `VRFConsumerBaseV2` constructor as shown in the [Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number) example.

  5. Change `requestRandomness` function calls to `requestRandomWords`. The `requestRandomWords` function requires several additional parameters.

  6. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is Chainlink Functions and what are some use cases for it?,"Chainlink Functions is a platform that enables users to connect to public data sources, transform data, connect to password-protected data sources, connect to external decentralized databases, and fetch data from almost any Web2 system. Some use cases for it include connecting smart contracts to weather statistics for parametric insurance, calculating Twitter sentiment, and fetching data from AWS S3, Firebase, or Google Cloud Storage.",{'source': 'https://docs.chain.link/chainlink-functions/'},"Chainlink Functions is a platform that provides smart contracts with access to a trust-minimized compute infrastructure. It allows smart contracts to send code to a Decentralized Oracle Network (DON), where the code is run by multiple oracles in a serverless environment. The DON aggregates the results and returns the final result to the smart contract. Chainlink Functions can be used for various purposes, such as connecting to public data sources, transforming data before consumption, accessing password-protected data sources, connecting to decentralized databases, fetching data from Web2 applications, and more. It provides off-chain computation without the need to run and configure a Chainlink Node. Chainlink Functions is currently available on testnet as a limited BETA preview. (Source: https://docs.chain.link/chainlink-functions/)

Some use cases for Chainlink Functions include connecting smart contracts to public data sources like weather statistics or real-time sports results, transforming public data before consumption (e.g., calculating Twitter sentiment or deriving asset prices), connecting to password-protected data sources like IoT devices or enterprise resource planning systems, connecting to external decentralized databases like IPFS, connecting to Web2 applications and building complex hybrid smart contracts, and fetching data from various Web2 systems like AWS S3, Firebase, or Google Cloud Storage. (Source: https://docs.chain.link/chainlink-functions/)",,"# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature improvements
along with interface and contract changes. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and add your EVM account address to the allow list.

## Supported networks

See the [Supported Networks](/chainlink-functions/supported-networks) page to
find a list of supported networks and contract addresses.

## What's next

  * [› Learn the basics in the Getting Started guide.](/chainlink-functions/getting-started)
  * [› Learn how to use more advanced capabilities in one of the Tutorials.](/chainlink-functions/tutorials)
  * [› Learn about core concepts, the Chainlink Functions architecture, and billing.](/chainlink-functions/resources)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 5:

# The Smart Contract Connectivity Problem

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     NFTs are a part of Web 3.0 so why not take truly advantage of this new primitive and make your NFT change depending on some conditions on the outside world? We call these changing NFTs <i>Dynamic NFT</i> or <i>dNFTs</i>. But how will you connect your dynamic NFT to outside data?  
    </div>
  </div>
</ContentWrapp>

Blockchains and smart contracts are unaware of any conditions or logic that occur outside of the blockchain itself; they cannot connect to outside resources. This is due to the distributed and deterministic nature of blockchains. All of the distributed nodes (nodes are computers running the blockchain software) in the blockchain must come to a consensus on what the blockchain is and any changes to it. If the blockchain just connected to a data source, the nodes could query the data at different times and get other answers, breaking the ability for the nodes to reach consensus. Even worse, if that data source changed locations or is down, the whole blockchain would break.

This means developers can program smart contracts as long as their logic doesn’t require any outside data. This may sound highly limiting, but there is a system in place that sits in between blockchains and the outside world (a concept aptly called “middleware”). This middleware system is called an Oracle. The name <ColorWord>Oracle</ColorWord> comes from the Greek concept of an Oracle since it needs to determine what is <i>true</i> in outside systems.

<Spacer>

## Centralized Oracles

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So an Oracle is the type of system you want to make a dNFT but it is important that the entire NFT remains decentralized so your art work can truly live on forever. You'll also want the NFT to be have the most accurate up-to-date data.
    </div>
  </div>
</ContentWrapp>

To create functional smart contracts we need a middleware system called an <ColorWord>Oracle</ColorWord>, but how will we make this Oracle? Well, we are trying to get price data into our smart contract for NFTs. My friend Jim (trust me, he is good!) is an expert in cryptocurrency prices, and he even has a server set up that we can access for price data. Awesome, we'll make Jim our oracle and he will provide price data to our NFT smart contract.

But wait….didn’t all the great properties of smart contracts and blockchains come from their decentralized nature? What if Jim wanted to maliciously send our smart contract bad price data so he could manipulate it in his favor? What if his server goes offline when the NFT needs to update and thus can’t? What if Jim isn’t even malicious but gets hacked by a malicious actor? This single oracle solution isn’t solving much of the oracle problem because it isn’t <i>decentralized</i>, and thus provides a weak link that ruins all of those awesome smart contract properties. You need to trust that Jim, and my word on Jim, that he is a great person and will act in the best interest of everyone. But what if we had a decentralized middleware solution, one where Jim doesn’t control everything (sorry Jim), so we didn’t have to trust him?

Finally we are here…...enter Chainlink!

<Spacer>

## Chainlink and Decentralized Oracles

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Using a Chainlink Decentralized Oracle Network (DON) as the Oracle for your dNFT can give you strong guarantees that your artwork will truly update with the latest, most acurate data and remain decentralized. 
    </div>
  </div>
</ContentWrapp>

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform. Finally, with Chainlink, developers can build smart contracts that can interact with the outside world to preserve the decentralized nature of smart contracts.

<Spacer>

## How Chainlink Works

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      Curious how Chainlink works? Read below! With Chainlink, any type of data the exists can be brought on chain, and the conditions on which that data is delivered can be customized! 
    </div>
  </div>
</ContentWrapp>

Chainlink allows developers to build and customize DONs. Chainlink allows DONs to work and assures that node operators are incentivized not to collude or act maliciously.

<p><ColorWord>How does Chainlink Work?</ColorWord></p>

<div>
  <p>Developers can customize several main areas of Chainlink DONs. These include:</p>
  <ul>
    <li>
      <p>Specifying what data DONs need to provide</p>
    </li>
    <li>
      <p>How DONs retrieve data </p>
    </li>
    <li>
      <p>When DONs provide data</p>
    </li>
    <li>
      <p>How agreement (also known as consensus) is achieved among the nodes to achieve a single source of truth for the specified data.</p>
    </li>
  </ul>
</div>

###Each step is outlined in more detail below:

<br><br>
<b>Specifying what data DONs need to provide</b>

Due to the proliferation of Decentralized Finance (DeFi), a popular use case of Chainlink DONs is relating them with price data. However, any type of data that is available in a digital format can be accessed. This includes but is not limited to weather data, YouTube views, sensor data, or even data from other blockchains. For the NFT we’re just going to stick to price data for now, specifically the ETH/USD price, but you can imagine all the possibilities of cool smart contracts we can make with all of the digital data available today!

<br>
<b>When DONS Provide Data</b>

Some applications require a DON that updates the data once a day. Others need updates once every five minutes or only when the data itself changes by a certain amount. The term <ColorWord>heartbeat</ColorWord> is used to describe the max amount of time that can elapse before a DON updates it's data feed The term <ColorWord>deviation threshold</ColorWord> is used to describe how much variation is allowed in the data before it is posted on-chain, regardless of how much time has elasped. For example, if the ETH/USD deviation threshold is set to 1%, then the DON will update the data feed if it senses the price of ETH versus USD fluctuates more than 1%.

<br>
<b>How DONs Provide Data</b>

Ideally, nodes should retrieve data from multiple sources and <i>aggregate</i>, or combine, the data to return the most accurate price they can. Developers can use external adapters to customize the sources that nodes use to aggregate data. <ColorWord>External adapters</ColorWord> are custom built software packages that can be added to the nodes. These can be built in any programming language and perform any operations developers may find useful. These operations can be as simple as basic arithmetic but can span to being complex machine learning algorithms.

<br>
<b>How Consensus is Reached Among Nodes</b>

All of the different nodes in the DON have their own version of the price. Using this information, developers customize the aggregation method of Chainlink DONs to determine one value for the true price. This is another level of aggregation beyond the aggregation completed at the individual node level. Having multiple levels of aggregation ensures the highest level of data quality. This <i>aggregation method</i> can consist of any type of operation including median, mean, weighted mean, mode, or other calculations. In our dynamic NFT will make use of a data feed that takes the median of all the node’s price data, since the median is more resistant to outliers than the mean.
"
What is the purpose of the AggregatorV3Interface contract?,"The AggregatorV3Interface contract is used to get data from a specific round or the latest round of an aggregator, and to get the number of decimals and description of the aggregator.",{'source': 'https://docs.chain.link/data-feeds/api-reference/'},"The purpose of the AggregatorV3Interface contract is to provide an interface for smart contracts to interact with data feeds. It allows smart contracts to retrieve data from a specific round, get the latest round data, and access other information about the aggregator. The contract also includes functions to get the number of decimals in the response, the description of the aggregator, and the version of the aggregator. The contract is used to connect smart contracts to data feeds and retrieve data from them.
","30-pl, 34-pl","# Data Feeds API Reference

  * Overview
  * AggregatorV3Interface
  * Functions in AggregatorV3Interface
  * AccessControlledOffchainAggregator
  * Variables and functions in AccessControlledOffchainAggregator

When you use data feeds, retrieve the feeds through the
`AggregatorV3Interface` and the proxy address. Optionally, you can call
variables and functions in the `AccessControlledOffchainAggregator` contract
to get information about the aggregator behind the proxy.

## AggregatorV3Interface

Import this interface to your contract and use it to run functions in the
proxy contract. Create the interface object by pointing to the proxy address.
For example, on Sepolia you could create the interface object in the
constructor of your contract using the following example:


    /**
     * Network: Sepolia
     * Data Feed: ETH/USD
     * Address: 0x694AA1769357215DE4FAC081bf1f309aDC325306
     */
    constructor() {
      priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
    }
    

To see examples for how to use this interface, read the [Using Data
Feeds](/data-feeds/price-feeds) guide.

You can see the code for the [`AggregatorV3Interface`
contract](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
on GitHub.

### Functions in AggregatorV3Interface

| Name            | Description                                                          |
|:----------------|:---------------------------------------------------------------------|
| decimals        | The number of decimals in the response.                              |
| description     | The description of the aggregator that the proxy points to.          |
| getRoundData    | Get data from a specific round.                                      |
| latestRoundData | Get data from the latest round.                                      |
| version         | The version representing the type of aggregator the proxy points to. |
#### decimals

Get the number of decimals present in the response value.


    function decimals() external view returns (uint8);

  * `RETURN`: The number of decimals.

#### description

Get the description of the underlying aggregator that the proxy points to.


    function description() external view returns (string memory);

  * `RETURN`: The description of the underlying aggregator.

#### getRoundData

Get data about a specific round, using the `roundId`.


    function getRoundData(
      uint80 _roundId
    ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);

**Parameters:**

  * `_roundId`: The round ID

**Return values:**

  * `roundId`: The round ID
  * `answer`: The answer for this round
  * `startedAt`: Timestamp of when the round started
  * `updatedAt`: Timestamp of when the round was updated
  * `answeredInRound`: The round ID in which the answer was computed

#### latestRoundData

Get the data from the latest round.


    function latestRoundData() external view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )

**Return values:**

  * `roundId`: The round ID.
  * `answer`: The data that this specific feed provides. Depending on the feed you selected, this answer provides asset prices, reserves, NFT floor prices, and other types of data.
  * `startedAt`: Timestamp of when the round started.
  * `updatedAt`: Timestamp of when the round was updated.
  * `answeredInRound`: The round ID of the round in which the answer was computed.

#### version

The version representing the type of aggregator the proxy points to.


    function version() external view returns (uint256)

  * `RETURN`: The version number.

## AccessControlledOffchainAggregator

This is the contract for the aggregator. You can call functions on the
aggregator directly, but it is a best practice to use the
AggregatorV3Interface to run functions on the proxy instead so that changes to
the aggregator do not affect your application. Read the aggregator contract
only if you need functions that are not available in the proxy.

The aggregator contract has several variables and functions that might be
useful for your application. Although aggregator contracts are similar for
each data feed, some aggregators have different variables. Use the
`typeAndVersion()` function on the aggregator to identify what type of
aggregator it is and what version it is running.

Always check the contract source code and configuration to understand how
specific data feeds operate. For example, the [aggregator contract for BTC/USD
on
Arbitrum](https://arbiscan.io/address/0x942d00008d658dbb40745bbec89a93c253f9b882#code)
is different from the aggregators on other networks.

For examples of the contracts that are typically used in aggregator
deployments, see the [libocr
repository](https://github.com/smartcontractkit/libocr/blob/master/contract/)
on GitHub.

### Variables and functions in AccessControlledOffchainAggregator

This contract imports `OffchainAggregator` and `SimpleReadAccessController`,
which also include their own imports. The variables and functions lists
include the publicly accessible items from these imported contracts.

A simple way to read the variables or functions is to get the ABI from a
blockchain explorer and point the ABI to the aggregator address. To do this in
Remix, follow the [Using the ABI with AtAddress](https://remix-ide.readthedocs.io/en/latest/run.html#using-the-abi-with-ataddress) guide in
the Remix documentation. As an example, you can find the ABI for the BTC/USD
aggregator by viewing the [contract code in
Etherscan](https://etherscan.io/address/0xae74faa92cb67a95ebcab07358bc222e33a34da7#code).

**Variables:**

| Name                    | Description                                                                                                                      |
|:------------------------|:---------------------------------------------------------------------------------------------------------------------------------|
| LINK                    | The address for the LINK token contract on a specific network.                                                                   |
| billingAccessController | The address for the billingAccessController, which limits access to the billing configuration for the aggregator.                |
| checkEnabled            | A boolean that indicates if access is limited to addresses on the internal access list.                                          |
| maxAnswer               | The highest median answer that the aggregator will accept. This prevents the aggregator from accepting extreme erroneous values. |
| minAnswer               | The lowest median answer that the aggregator will accept. This prevents the aggregator from accepting extreme erroneous values.  |
| owner                   | The address that owns this aggregator contract. This controls which address can execute specific functions.                      |
**Functions:**

| Name                      | Description                                                                                                                                                                                                                             |
|:--------------------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| decimals                  | Return the number of digits of precision for the stored answer. Answers are stored in fixed-point format.                                                                                                                               |
| description               | Return a description for this data feed. This is different depending on which feed you select.                                                                                                                                          |
| getAnswer                 | (Deprecated - Do not use this function.)                                                                                                                                                                                                |
| getBilling                | Retrieve the current billing configuration.                                                                                                                                                                                             |
| getRoundData              | Get the full information for a specific aggregator round including the answer and update timestamps. Use this to get the full historical data for a round.                                                                              |
| getTimestamp              | (Deprecated - Do not use this function.)                                                                                                                                                                                                |
| hasAccess                 | Check if an address has internal access.                                                                                                                                                                                                |
| latestAnswer              | (Deprecated - Do not use this function.)                                                                                                                                                                                                |
| latestConfigDetails       | Return information about the current off-chain reporting protocol configuration.                                                                                                                                                        |
| latestRound               | (Deprecated - Do not use this function.)                                                                                                                                                                                                |
| latestRoundData           | Get the full information for the most recent round including the answer and update timestamps.                                                                                                                                          |
| latestTimestamp           | (Deprecated - Do not use this function.)                                                                                                                                                                                                |
| latestTransmissionDetails | Get information about the most recent answer.                                                                                                                                                                                           |
| linkAvailableForPayment   | Get the amount of LINK on this contract that is available to make payments to oracles. This value can be negative if there are outstanding payment obligations.                                                                         |
| oracleObservationCount    | Returns the number of observations that oracle is due to be reimbursed for.                                                                                                                                                             |
| owedPayment               | Returns how much LINK an oracle is owed for its observations.                                                                                                                                                                           |
| requesterAccessController | Returns the address for the access controller contract.                                                                                                                                                                                 |
| transmitters              | The oracle addresses that can report answers to this aggregator.                                                                                                                                                                        |
| typeAndVersion            | Returns the aggregator type and version. Many aggregators are AccessControlledOffchainAggregator 3.0.0, but there are other variants in production. The version is for the type of aggregator, and different from the contract version. |
| validatorConfig           | Returns the address and the gas limit for the validator contract.                                                                                                                                                                       |
| version                   | Returns the contract version. This is different from the typeAndVersion for the aggregator.                                                                                                                                             |
#### decimals

Return the number of digits of precision for the stored answer. Answers are
stored in fixed-point format.


    function decimals() external view returns (uint8 decimalPlaces);
    

#### description

Return a description for this data feed. Usually this is an asset pair for a
price feed.


    function description() public view override checkAccess returns (string memory) {
      return super.description();
    }
    

#### getAnswer

caution

#### getBilling

Retrieve the current billing configuration.


    function getBilling()
      external
      view
      returns (
        uint32 maximumGasPrice,
        uint32 reasonableGasPrice,
        uint32 microLinkPerEth,
        uint32 linkGweiPerObservation,
        uint32 linkGweiPerTransmission
      )
    {
      Billing memory billing = s_billing;
      return (
        billing.maximumGasPrice,
        billing.reasonableGasPrice,
        billing.microLinkPerEth,
        billing.linkGweiPerObservation,
        billing.linkGweiPerTransmission
      );
    }
    

#### getRoundData

Get the full information for a specific aggregator round including the answer
and update timestamps. Use this to get the full historical data for a round.


    function getRoundData(
      uint80 _roundId
    )
      public
      view
      override
      checkAccess
      returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
    {
      return super.getRoundData(_roundId);
    }
    

#### getTimestamp

:::caution[ This function is deprecated. Do not use this function.]

:::

#### hasAccess

Check if an address has internal access.


    function hasAccess(address _user, bytes memory _calldata) public view virtual override returns (bool) {
      return super.hasAccess(_user, _calldata) || _user == tx.origin;
    }
    

#### latestAnswer

:::caution[ This function is deprecated. Do not use this function.]

:::

#### latestConfigDetails

Return information about the current off-chain reporting protocol
configuration.


    function latestConfigDetails() external view returns (uint32 configCount, uint32 blockNumber, bytes16 configDigest) {
      return (s_configCount, s_latestConfigBlockNumber, s_hotVars.latestConfigDigest);
    }
    

#### latestRound

:::caution[ This function is deprecated. Do not use this function.]

:::

#### latestRoundData

Get the full information for the most recent round including the answer and
update timestamps.


    function latestRoundData()
      public
      view
      override
      checkAccess
      returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
    {
      return super.latestRoundData();
    }
    

#### latestTimestamp

:::caution[ This function is deprecated. Do not use this function.]

:::

#### latestTransmissionDetails

Get information about the most recent answer.


    function latestTransmissionDetails()
      external
      view
      returns (bytes16 configDigest, uint32 epoch, uint8 round, int192 latestAnswer, uint64 latestTimestamp)
    {
      require(msg.sender == tx.origin, ""Only callable by EOA"");
      return (
        s_hotVars.latestConfigDigest,
        uint32(s_hotVars.latestEpochAndRound >> 8),
        uint8(s_hotVars.latestEpochAndRound),
        s_transmissions[s_hotVars.latestAggregatorRoundId].answer,
        s_transmissions[s_hotVars.latestAggregatorRoundId].timestamp
      );
    }
    

#### linkAvailableForPayment

Get the amount of LINK on this contract that is available to make payments to
oracles. This value can be negative if there are outstanding payment
obligations.


    function linkAvailableForPayment() external view returns (int256 availableBalance) {
      // there are at most one billion LINK, so this cast is safe
      int256 balance = int256(LINK.balanceOf(address(this)));
      // according to the argument in the definition of totalLINKDue,
      // totalLINKDue is never greater than 2**172, so this cast is safe
      int256 due = int256(totalLINKDue());
      // safe from overflow according to above sizes
      return int256(balance) - int256(due);
    }
    

#### oracleObservationCount

Returns the number of observations that oracle is due to be reimbursed for.


    function oracleObservationCount(address _signerOrTransmitter) external view returns (uint16) {
      Oracle memory oracle = s_oracles[_signerOrTransmitter];
      if (oracle.role == Role.Unset) {
        return 0;
      }
      return s_oracleObservationsCounts[oracle.index] - 1;
    }
    

#### owedPayment

Returns how much LINK an oracle is owed for its observations.


    function owedPayment(address _transmitter) public view returns (uint256) {
      Oracle memory oracle = s_oracles[_transmitter];
      if (oracle.role == Role.Unset) {
        return 0;
      }
      Billing memory billing = s_billing;
      uint256 linkWeiAmount = uint256(s_oracleObservationsCounts[oracle.index] - 1) *
        uint256(billing.linkGweiPerObservation) *
        (1 gwei);
      linkWeiAmount += s_gasReimbursementsLinkWei[oracle.index] - 1;
      return linkWeiAmount;
    }
    

#### requesterAccessController

Returns the address for the access controller contract.


    function requesterAccessController() external view returns (AccessControllerInterface) {
      return s_requesterAccessController;
    }
    

#### transmitters

The oracle addresses that can report answers to this aggregator.


    function transmitters() external view returns (address[] memory) {
      return s_transmitters;
    }
    

#### typeAndVersion

Returns the aggregator type and version. Many aggregators are
`AccessControlledOffchainAggregator 2.0.0`, but there are other variants in
production. The version is for the type of aggregator, and different from the
contract `version`.


    function typeAndVersion() external pure virtual override returns (string memory) {
      return ""AccessControlledOffchainAggregator 2.0.0"";
    }
    

#### validatorConfig

Returns the address and the gas limit for the validator contract.


    function validatorConfig() external view returns (AggregatorValidatorInterface validator, uint32 gasLimit) {
      ValidatorConfig memory vc = s_validatorConfig;
      return (vc.validator, vc.gasLimit);
    }
    

#### version

Returns the contract version. This is different from the `typeAndVersion` for
the aggregator.


    function version() external view returns (uint256);
    

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/api-reference.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 6:

# Chainlink Data Feeds

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now that you understood how to connect the off-chain world you can utilize this knowledge now for your NFT. Imagine a NFT that reacts to the price of Ethereum. It could rain when the price falls and it could be sunny when the price rises.
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson, Chainlink gives developers the ability to create extremely powerful DON’s that provide smart contracts with the highest quality data from outside the blockchain. As a smart contract developer, how can you take advantage of these DONs in your own smart contracts? Chainlink is open source so there’s always the option of making your own DON, but creating a DON is a complex and nuanced process. Instead, in the spirit of the old developer adage “Never build something twice”, use existing DONs if possible.

Luckily, many of the largest and highest quality node operators in the blockchain industry have already combined their knowledge and prowess to create DONs that serve the most in-demand data for smart contract developers to take advantage of. These data serving DONs are called <ColorWord>Chainlink Data Feeds</ColorWord>. Currently most of the data feeds provide data on various currency and cryptocurrency pairs, as that was initially what smart contract developers needed, but data feeds can be used to retrieve any type of data.

You can see these data feeds updating in real time at data.chain.link. There you can select different blockchains Chainlink DONs are posting data to, as well view the details of each DON that compose a particular data feed. For instance if you click on the ETH/USD data feed you will see all the nodes involved in the DON, what price each individual node posted, and the final aggregated price of the asset. Some important terms you may notice are:

<p><ColorWord>Rounds</ColorWord>DONs update data feeds in rounds. When a new round is initiated the nodes in a DON retrieve the latest data point from data providers, aggregate the data at the individual node level and finally aggregate the between the nodes. Once the final aggregated data point, along with each individual nodes observation, is posted on-chain the round is considered complete.</p>
<p><ColorWord>Heartbeat</ColorWord>The maximum amount of time that is allowed to pass before the DON automatically starts a new round and updates the data.</p>
<p><ColorWord>Deviation Threshold</ColorWord>If a node within the DON senses the data fluctuates by a certain percentage, they will automatically start a new round forcing the DON to update the data feed regardless of how much time has elapsed.</p>

<MissionContainer>
  <div className=""title"">Quizzes:</div>
  <ol className=""mission-goals"">
    <li>
      What is the heartbeat for the ETH/USD data feed on Ethereum mainnet?
    </li>
    <li>
      What is the deviation threshold for the BTC/USD data feed on Binance Smart Chain mainnet?
    </li>
  </ol>
</MissionContainer>

## Programming with Chainlink Data Feeds

Now that we understand how Chainlink data feeds work, lets use them within a smart contract. To use a Chainlink data feed within a smart contract you only have to complete three simple steps:

<div>
  <ul>
    <li>
      <p>Import the AggregatorV3Interface into your smart contract</p>
    </li>
    <li>
      <p>Point the interface to the desired data feed</p>
    </li>
    <li>
      <p>Access the latest data!</p>
    </li>
  </ul>
</div>
"
What is the purpose of the HTTPGet adapter?,The HTTPGet adapter is used to make a GET request to a specified URL and return the response body.,{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/'},"The purpose of the HTTPGet adapter is to make an HTTP GET request and retrieve data from an external API. It can be used to fetch single word responses, multiple variable responses, elements in an array response, or large responses containing raw byte data. The adapter allows smart contracts to access off-chain data sources through Chainlink's decentralized oracle network. It provides flexibility and interoperability between on-chain and off-chain applications. 
",https://docs.chain.link/any-api/introduction/,"# Chainlink Any API Documentation

  * Overview
  * Requesting off-chain data
  * Building external adapters

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=AnyAPI) to talk to an expert
about using Chainlink Any API to get your data on chain.

**Connecting to any API** with Chainlink enables your contracts to access to
_any_ external data source through our decentralized oracle network. We
understand making smart contracts compatible with off-chain data adds to the
complexity of building smart contracts. We created a framework with minimal
requirements, yet unbounded flexibility, so developers can focus more on the
functionality of smart contracts rather than what feeds them. Chainlink’s
decentralized oracle network provides smart contracts with the ability to push
and pull data, facilitating the interoperability between on-chain and off-
chain applications.

Whether your contract requires sports results, the latest weather, or any
other publicly available data, the [Chainlink contract
library](https://github.com/smartcontractkit/chainlink/tree/master/contracts)
provides the tools required for your contract to consume it.

Prerequisites

You should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                                                                                                                                                                                                                                                |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                                                                                                                             |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                                                                             |
| HTTP GET Element in Array Response | This guide explains how to make an HTTP GET request that returns a json array and parse it to retrieve the target element's value.                                                                                                                         |
| HTTP GET Large Reponses            | This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.                                                                                   |
| Existing Job Request               | This guide explains how to call a job that leverages External adapters and returns the relevant data to the smart contract. This allows building succinct smart contracts that do not need to comprehend the URL or the response format of the target API. |
### Building external adapters

To learn more about building external adapters and adding them to nodes, refer
to the [External Adapters](/chainlink-nodes/external-adapters/external-adapters) documentation.

To understand different use cases for using any API, refer to [Other
Tutorials](/getting-started/other-tutorials).

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› API Reference](/any-api/api-reference/)
  * [› Find Existing Jobs](/any-api/find-oracle/)
  * [› Testnet Oracles](/any-api/testnet-oracles/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Job Specifications [v1]

  * Overview
  * What is a job?

# REMOVED

v1 Jobs are removed

The v1 job spec or JSON spec removed for Chainlink nodes running version 1.0.0
and later. If you are still running this type of job, migrate them to v2
specs.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

## What is a job?

Job specifications, or specs, contain the sequential tasks that the node must
perform to produce a final result. Chainlink jobs are divided into 2 segments.

  * [Initiators](/chainlink-nodes/oracle-jobs/v1/initiators)
  * [Adapters](/chainlink-nodes/oracle-jobs/v1/adapters) (also known as tasks)

A job must contain at least one of each.

**Initiators** define _when_ a job will run. **Adapters** define _how_ a job
will run.

Specs are defined using standard JSON so that they are human-readable and can
be easily parsed by the Chainlink node.

Here is an example of a spec:


    {
      ""initiators"": [
        {
          ""type"": ""RunLog"",
          ""params"": { ""address"": ""0x51DE85B0cD5B3684865ECfEedfBAF12777cd0Ff8"" }
        }
      ],
      ""tasks"": [
        {
          ""type"": ""HTTPGet"",
          ""confirmations"": 0,
          ""params"": { ""get"": ""https://bitstamp.net/api/ticker/"" }
        },
        {
          ""type"": ""JSONParse"",
          ""params"": { ""path"": [""last""] }
        },
        {
          ""type"": ""Multiply"",
          ""params"": { ""times"": 100 }
        },
        { ""type"": ""EthUint256"" },
        { ""type"": ""EthTx"" }
      ],
      ""startAt"": ""2020-02-09T15:13:03Z"",
      ""endAt"": null,
      ""minPayment"": ""1000000000000000000""
    }

This example shows the two main components of a spec: initiators and tasks.
[Initiators](/resources/glossary/#initiator) determine how the spec will
start. [Tasks](/resources/glossary/#task-spec) are the individual steps that
the Chainlink node follows to process data in order to produce a result.

In the example above, we see that the only initiator is a RunLog. This means
that the spec can only be started when a specific event log is emitted from a
specified address. The specified address will be the address of the oracle
contract on Ropsten, which manages requests from contracts and responses from
Chainlink nodes.

The five tasks (referred to as [core adapters](/chainlink-nodes/oracle-jobs/v1/adapters)) in the example above follow a common pattern for requesting
data from the Chainlink network, and returning a single result. Each task
takes three fields: `type`, `confirmations`, and `params`. The `type` is the
adapter or [bridge](/resources/glossary/#bridge) name and is required.
`confirmations` is optional, and will default to 0. `params` is also optional,
and will default to an empty object if not specified. See the [core
adapters](/chainlink-nodes/oracle-jobs/v1/adapters) page for a complete list
of `params` for each adapter.

  1. The **HTTPGet** adapter uses the value in the `get` field to perform a standard HTTP GET request at the value specified. The body of that result is passed on to the next task, JSONParse.
  2. The **JSONParse** adapter takes a dot-delimited string or an array of strings, and will walk the given path to store the value at the end. In this case, there is only one field to save, ""last"". JSONParse will then pass the value stored in the ""last"" field to the Multiply adapter.
  3. The **Multiply** adapter will, as its name describes, multiply the given value by the value of the `times` field, in this case, 100.
  4. The multiplied value will be passed to the **EthUint256** adapter, which will format it specifically for the `uint256` data type on Ethereum. Notice there are no parameters supplied to the EthUint256 adapter, as it does not accept any.
  5. Finally, that formatted value is written to the blockchain with the **EthTx** adapter. The parameters for the EthTx adapter are given by the oracle contract when the run is initiated through the RunLog initiator.

Note: If specifying multiple adapters of the same type, the parameters can be
specified in the job spec itself if the key values need to be different. The
requester can also use run parameters for these requests, but shared keys will
be the same for any adapter that uses them.

Additional parameters may be specified on the job as well. These include:

  * **startAt** : The beginning date at which the job can be executed, specified in ISO 8601 standard. Jobs can not be ran before this date. Defaults to null if unspecified.
  * **endAt** : The ending date at which the job can be executed, specified in ISO 8601 standard. Jobs can not be ran after this date. Defaults to null if unspecified.
  * **minPayment** : The payment amount for this job, specified in LINK to the 18th decimal. If supplied, this will override the global `MIN_CONTRACT_PAYMENT` configuration set on the node, regardless if the value is lower or higher.

## What's next

  * [› Core Adapters](/chainlink-nodes/oracle-jobs/v1/adapters)
  * [› Initiators](/chainlink-nodes/oracle-jobs/v1/initiators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/job-specifications.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-11-01 10:37:01)
Getting individual array elements from the data returned by a chainlink external adapter
URL: https://stackoverflow.com/questions/69795720/getting-individual-array-elements-from-the-data-returned-by-a-chainlink-external

Question Body:


In the job I'm adding for my external adapter, I'm looking to get results for
the first 3 elements in the `Results` array one at a time.(see the data
returned from my external adapter below)

So I'm adding ""position"" to my chainlink request in the consumer contract and
wanting to use that in the `jsonparse` like below, rather than pass it to the
external adapter. However, I get this error `JSONParse task error:
$(decode_cbor.position) is not a valid array index`

    
    
    parse        [type=jsonparse path=""data,MRData,RaceTable,Races,0,Results,$(decode_cbor.position),number"" data=""$(fetch)""]```
    

in my consumer contract

    
    
    Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    request.add(""position"", ""1"");
    

The data returned from the external adapter looks like this.

    
    
    {
        ""MRData"": {
            ""xmlns"": ""http://ergast.com/mrd/1.4"",
            ""series"": ""f1"",
            ""url"": ""http://ergast.com/api/f1/current/last/results.json"",
            ""limit"": ""30"",
            ""offset"": ""0"",
            ""total"": ""20"",
                    
            ""RaceTable"": {
                ""season"": ""2021"",
                ""round"": ""17"",
            
              ""Races"": [{
                    ""season"": ""2021"",
                    ""round"": ""17"",
                    ""url"": ""http://en.wikipedia.org/wiki/2021_United_States_Grand_Prix"",
                    ""raceName"": ""United States Grand Prix"",
                    ""Circuit"": {
                        ""circuitId"": ""americas"",
                        ""url"": ""http://en.wikipedia.org/wiki/Circuit_of_the_Americas"",
                        ""circuitName"": ""Circuit of the Americas"",
                        ""Location"": {
                            ""lat"": ""30.1328"",
                            ""long"": ""-97.6411"",
                            ""locality"": ""Austin"",
                            ""country"": ""USA""
                        }
                    },
                    ""date"": ""2021-10-24"",
                    ""time"": ""19:00:00Z"",
            
                    ""Results"": [{
                        ""number"": ""33"",
                        ""position"": ""1"",
                        ""positionText"": ""1"",
                        ""points"": ""25"",
                        ""Driver"": {
                            ""driverId"": ""max_verstappen"",
                            ""permanentNumber"": ""33"",
                            ""code"": ""VER"",
                            ""url"": ""http://en.wikipedia.org/wiki/Max_Verstappen"",
                            ""givenName"": ""Max"",
                            ""familyName"": ""Verstappen"",
                            ""dateOfBirth"": ""1997-09-30"",
                            ""nationality"": ""Dutch""
                        },.....
    

The full results can be found here.
<http://ergast.com/api/f1/current/last/results.json>

Should I be able to do something like this? Is there a better way to go about
this? Should I edit the adapter instead?

    
    
    schemaVersion = 1
    name = ""f1latestresults2""
    contractAddress = ""0x765aCc258f3a7b2D8d103D1A9310fc51b07D5425""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
    
        fetch        [type=bridge name=""raceresults"" requestData=""{\\""id\\"":$(jobSpec.externalJobID),\\""data\\"":{\\""position\\"":\\""0\\""}}""]
        
    
        parse        [type=jsonparse path=""data,MRData,RaceTable,Races,0,Results,$(decode_cbor.position),number"" data=""$(fetch)""]
    
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(parse) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0x765aCc258f3a7b2D8d103D1A9310fc51b07D5425"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx
    """"""
    externalJobID = ""cfa059b4-a31d-4c30-99e4-3a2fd4c57739""
    



Answers:
(Answered on: 2021-11-02 01:06:23)


The syntax you are using looks correct to me, so I'm not 100% sure if the TOML
jobs can support having a parameter like that within a string yet?

If the rest of the JSON path is static, suggest just having it as a built up
string in your consuming contract, and just sending it as a full string in the
request, then using that in your TOML spec, similar to the example [in the
docs](https://docs.chain.link/docs/fulfilling-requests/)

    
    
    req.add(""path"", ""data,MRData,RaceTable,Races,0,Results,0"");
    

Then in your TOML job spec:

    
    
    parse        [type=jsonparse path=""$(decode_cbor.path)"" data=""$(fetch)""]
    



"
What is the purpose of the `oracleRequest` function in the `AuthorizedReceiver` contract?,The `oracleRequest` function creates a Chainlink request and assumes that the `callbackAddress` is the same as the request sender.,{'source': 'https://docs.chain.link/chainlink-nodes/contracts/operator/'},"The purpose of the `oracleRequest` function in the `AuthorizedReceiver` contract is to create a Chainlink request. It is a backwards compatible API with the `Oracle.sol` contract, but the behavior changes because `callbackAddress` is assumed to be the same as the request sender. The function takes several parameters including the sender of the request, the payment amount, the Job Specification ID, the callback address, the callback function ID, the nonce, the data version, and the extra request parameters. This function is used to send a request to the off-chain oracle node for data retrieval. 
",30-pl,"# Operator

  * Overview
  * Features
  * Multi-word Response
  * Factory deployment
  * Distributing funds to multiple addresses
  * Flexibility and security
  * API Reference
  * Methods
  * Events

Oracles must deploy an on-chain contract to handle requests made through the
LINK token (Read [Basic Request Model](/architecture-overview/architecture-request-model) to learn more).

When the _Basic Request_ model was introduced, node operators had to deploy
[Oracle
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol).
However, these come with some limitations, and soon, we introduced [operator
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).

note

In addition to replacing oracle contracts, operator contracts come with
additional features that add more security and flexibility for node operators.

## Features

### Multi-word Response

In the EVM architecture, a word is made up of 32 bytes. One limitation of the
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
contract is that it limits responses to requests to 32 bytes.

[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
doesn't have the same limitation as it supports a response made of multiple
EVM words.

### Factory deployment

To deploy an _Oracle_ contract, each node operator has to manually compile and
deploy
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol).
The vast number of Solidity versions and steps involved in verifying the
contract made it difficult for a client to verify that the deployed contract
had not been tampered with. To fix this, node operators can use a
[factory](/chainlink-nodes/contracts/operatorfactory) to deploy an instance of
the _operator_ contract. Moreover, the factory exposes a getter for clients to
check if it deployed a specific _operator_ contract address.

### Distributing funds to multiple addresses

A common pain point of node operators is keeping their addresses funded.
_Operator_ 's `distributeFunds` method allows node operators to fund multiple
addresses in a single transaction.

### Flexibility and security

By using multiple externally-owned accounts (EOAs) on Chainlink nodes and
[forwarder](/chainlink-nodes/contracts/forwarder) contracts, node operators
can set up different transaction-sending strategies.

note

As discussed in the [forwarder](/chainlink-nodes/contracts/forwarder)
contracts page:

  * Chainlink nodes' EOAs are hot wallets that fulfill requests.
  * These EOAs can be associated with one or multiple [forwarder](/chainlink-nodes/contracts/forwarder) contracts. The forwarder's owner must whitelist them to call the [forward](/chainlink-nodes/contracts/forwarder#forward) function. One operator contract owns one or multiple forwarder contracts.
  * Node operators manage their forwarder contracts through operator contracts. They use a secure wallet such as hardware or a multisig wallet as the operator's owner account.

## API Reference

The operator contract inherits
[AuthorizedReceiver](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/AuthorizedReceiver.sol)
and
[ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/edit/develop/contracts/src/v0.7/ConfirmedOwnerWithProposal.sol).
Read [AuthorizedReceiver](/chainlink-nodes/contracts/receiver) and
[ConfirmedOwnerWithProposal](/chainlink-nodes/contracts/ownership) API
references.

### Methods

#### oracleRequest

Legacy

Use `operatorRequest` function instead.


    function oracleRequest(address sender, uint256 payment, bytes32 specId, address callbackAddress, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. This is backwards compatible API with
[Oracle.sol
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol),
but the behavior changes because `callbackAddress` is assumed to be the same
as the request sender.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackAddress    | address | The consumer of the request                    |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### operatorRequest


    function operatorRequest(address sender, uint256 payment, bytes32 specId, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. Stores the hash of the params as the on-chain
commitment for the request. Emits OracleRequest event for the Chainlink node
to detect.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### fulfillOracleRequest

Legacy

Use `fulfillOracleRequest2` function instead.


    function fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data) external returns (bool)

Called by the Chainlink node to fulfill requests. Given params must hash back
to the commitment stored from `oracleRequest`. Will call the callback address'
callback function without bubbling up error checking in a `require` so that
the node can get paid. Emits OracleResponse event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes32 | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### fulfillOracleRequest2


    function fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data) external returns (bool)

Called by the Chainlink node to fulfill requests with multi-word support.
Given params must hash back to the commitment stored from `oracleRequest`.
Will call the callback address' callback function without bubbling up error
checking in a `require` so that the node can get paid. Emits OracleResponse
event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes   | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### transferOwnableContracts


    function transferOwnableContracts(address[] ownable, address newOwner) external

Transfer the ownership of ownable contracts. This is primarily intended for
authorized forwarders but could possibly be extended to work with future
contracts.

##### Parameters

| Name     | Type      | Description                      |
|:---------|:----------|:---------------------------------|
| ownable  | address[] | list of addresses to transfer    |
| newOwner | address   | address to transfer ownership to |
#### acceptOwnableContracts


    function acceptOwnableContracts(address[] ownable) public

Accept the ownership of an ownable contract. This is primarily intended for
authorized forwarders but could possibly be extended to work with future
contracts. Emits OwnableContractAccepted event.

_Must be the pending owner on the contract_

##### Parameters

| Name    | Type      | Description                                      |
|:--------|:----------|:-------------------------------------------------|
| ownable | address[] | list of addresses of Ownable contracts to accept |
#### setAuthorizedSendersOn


    function setAuthorizedSendersOn(address[] targets, address[] senders) public

Sets the fulfillment permission for `senders` on `targets`. Emits
TargetsUpdatedAuthorizedSenders event.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| targets | address[] | The addresses to set permissions on            |
| senders | address[] | The addresses that are allowed to send updates |
#### acceptAuthorizedReceivers


    function acceptAuthorizedReceivers(address[] targets, address[] senders) external

Accepts ownership of ownable contracts and then immediately sets the
authorized sender list on each of the newly owned contracts. This is primarily
intended for authorized forwarders but could possibly be extended to work with
future contracts.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| targets | address[] | The addresses to set permissions on            |
| senders | address[] | The addresses that are allowed to send updates |
#### withdraw


    function withdraw(address recipient, uint256 amount) external

Allows the node operator to withdraw earned LINK to a given address
`recipient`.

_The owner of the contract can be another wallet and does not have to be a
Chainlink node_

##### Parameters

| Name      | Type    | Description                           |
|:----------|:--------|:--------------------------------------|
| recipient | address | The address to send the LINK token to |
| amount    | uint256 | The amount to send (specified in wei) |
#### withdrawable


    function withdrawable() external view returns (uint256)

Displays the amount of LINK that is available for the node operator to
withdraw.

_We use`1` in place of 0 in storage_

##### Return values

|   Name | Type    | Description                                     |
|-------:|:--------|:------------------------------------------------|
|    nan | uint256 | The amount of withdrawable LINK on the contract |
#### ownerForward


    function ownerForward(address to, bytes data) external

Forward a call to another contract.

_Only callable by the owner_

##### Parameters

| Name   | Type    | Description   |
|:-------|:--------|:--------------|
| to     | address | address       |
| data   | bytes   | to forward    |
#### ownerTransferAndCall


    function ownerTransferAndCall(address to, uint256 value, bytes data) external returns (bool success)

Interact with other LinkTokenReceiver contracts by calling transferAndCall.

##### Parameters

| Name   | Type    | Description                                            |
|:-------|:--------|:-------------------------------------------------------|
| to     | address | The address to transfer to.                            |
| value  | uint256 | The amount to be transferred.                          |
| data   | bytes   | The extra data to be passed to the receiving contract. |
##### Return values

| Name    | Type   | Description   |
|:--------|:-------|:--------------|
| success | bool   | bool          |
#### distributeFunds


    function distributeFunds(address payable[] receivers, uint256[] amounts) external payable

Distribute funds to multiple addresses using ETH sent to this payable
function.

Array length must be equal, ETH sent must equal the sum of amounts. A
malicious receiver could cause the distribution to revert, in which case it is
expected that the address is removed from the list.

##### Parameters

| Name      | Type              | Description       |
|:----------|:------------------|:------------------|
| receivers | address payable[] | list of addresses |
| amounts   | uint256[]         | list of amounts   |
#### cancelOracleRequest


    function cancelOracleRequest(bytes32 requestId, uint256 payment, bytes4 callbackFunc, uint256 expiration) external

Allows recipient to cancel requests sent to this oracle contract. Will
transfer the LINK sent for the request back to the recipient address. Given
params must hash to a commitment stored on the contract in order for the
request to be valid. Emits CancelOracleRequest event.

##### Parameters

| Name         | Type    | Description                                          |
|:-------------|:--------|:-----------------------------------------------------|
| requestId    | bytes32 | The request ID                                       |
| payment      | uint256 | The amount of payment given (specified in wei)       |
| callbackFunc | bytes4  | The requester's specified callback function selector |
| expiration   | uint256 | The time of the expiration for the request           |
#### cancelOracleRequestByRequester


    function cancelOracleRequestByRequester(uint256 nonce, uint256 payment, bytes4 callbackFunc, uint256 expiration) external

Allows requester to cancel requests sent to this oracle contract. Will
transfer the LINK sent for the request back to the recipient address. Given
params must hash to a commitment stored on the contract in order for the
request to be valid. Emits CancelOracleRequest event.

##### Parameters

| Name         | Type    | Description                                          |
|:-------------|:--------|:-----------------------------------------------------|
| nonce        | uint256 | The nonce used to generate the request ID            |
| payment      | uint256 | The amount of payment given (specified in wei)       |
| callbackFunc | bytes4  | The requester's specified callback function selector |
| expiration   | uint256 | The time of the expiration for the request           |
#### getChainlinkToken


    function getChainlinkToken() public view returns (address)

Returns the address of the LINK token

This is the public implementation for chainlinkTokenAddress, which is an
internal method of the ChainlinkClient contract.

### Events

#### OracleRequest


    event OracleRequest(bytes32 specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)

#### CancelOracleRequest


    event CancelOracleRequest(bytes32 requestId)

#### OracleResponse


    event OracleResponse(bytes32 requestId)

#### OwnableContractAccepted


    event OwnableContractAccepted(address acceptedContract)

#### TargetsUpdatedAuthorizedSenders


    event TargetsUpdatedAuthorizedSenders(address[] targets, address[] senders, address changedBy)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/contracts/operator.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-12-16 18:52:48)
Testing Chainlink API calls using Hardhat
URL: https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat

Question Body:


I am having trouble testing Chainlink API calls locally. I have a contract
which calls my API consumer contract to make an API call. However, when I try
to do that, the MockOracle (mocked oracle for local testing, from chainlink)
contract reverts (VM exception) saying ""Must use whitelisted functions"". I am
making an API call for a bytes32 get request.

This is the function modifier (inside of LinkTokenReceiver) where the
MockOracle reverts (it gets called by the MockOracle when receiving LINK
tokens):

    
    
    /**
       * @dev Reverts if the given data does not begin with the `oracleRequest` function selector
       * @param _data The data payload of the request
       */
      modifier permittedFunctionsForLINK(bytes memory _data) {
        bytes4 funcSelector;
        assembly {
          // solhint-disable-next-line avoid-low-level-calls
          funcSelector := mload(add(_data, 32))
        }
        require(funcSelector == ORACLE_REQUEST_SELECTOR, ""Must use whitelisted functions"");
        _;
      }
    

The ApiConsumer is properly funded, and the LINK token is a local deployment
of the chainlink Token. So, what am I doing wrong? Or what is the best way to
test Chainlink API calls (bytes32 get request) locally using hardhat?



Answers:
(Answered on: 2023-03-04 12:21:04)


If you are testing locally the chainlink node will not be able to detect any
requests.  
You have a few options:

  1. Deploy your APIConsumer contract to a testnet and make use of an already deployed operator contract. A list can be found on chainlinks website [https://docs.chain.link/any-api/testnet-oracles/]. Then select a jobId for a node job that can provide the API data you need e.g. bytes32, Int, multi words etc. The jobId can be specified in your APIConsumer contract.
  2. Deploy your own operator contract, setup your own node (chainlink has an option for setting up temporary development nodes), and then create a custom job for your API. You will then need to put you node address as an authorised sender in your operator contract to permit data to be returned from your node.
  3. For local testing you will need to write a function in your test script that sends a mock response to your mock operator contract. Make sure you setAuthorisedSenders for the account you use to send the fulfillOracleRequest transaction, to test properly I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:

    
    
      modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata _data) {
        require(_data.length >= 32, ""Response must be > 32 bytes""); 
        bytes memory firstDataWord = new bytes(32);
        for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript snippet for test script 
    //If local network - Set Authorised senders on Mock Oracle to account[1]
        const [owner, mockNode] = await ethers.getSigners();
        const mockNodeAccount = mockNode.address
        await mockOracle.setAuthorizedSenders([mockNodeAccount])
        
        
        const transaction: ContractTransaction = await apiConsumer.requestWithWords(ANY_ARGS_FOR_API)
        const transactionReceipt: ContractReceipt = await transaction.wait(1)
        const requestId = transactionReceipt.events[0].topics[1]
    
        const apiFilter = apiConsumer.filters.ChainlinkRequested()
        const apiEvents = await apiConsumer.queryFilter(apiFilter)
        console.log(apiEvents)
    
        const filter = mockOracle.filters.OracleRequest()
        const events = await mockOracle.queryFilter(filter)
        const {specId, requester, requestIdEvent, payment, callbackAddr, callbackFunctionId, cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
    
        const encodeRequestId = web3.eth.abi.encodeParameters(
            ['bytes32'],
            [requestId])
            
        await mockOracle.connect(mockNode).fulfillOracleRequest2(requestIdfirst, payment, callbackAddr, callbackFunctionId, cancelExpiration, encodeMwr)

To improve on this you could then look to add an API http GET call into your
test script for getting the rest of the callback data for fulfillOracleRequest
or fulfillOracleRequest2 function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I am guessing you are currently using the `oracle.sol` and
`ChainlinkClient.sol` in version v0.6. In version v0.6, AFAIK, ChainlinkClient
doesn't not help users to add function selector `oracleRequest` in the users'
Chainlink request, which means you will get the error if you doesn't manually
add the function selector in your request. In v0.7, ChainlinkClient helps you
add the selector in the request. Just check the function
`sendChainlinkRequestTo` in [ChainlinkClient
v0.6](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/ChainlinkClient.sol)
and [ChainlinkClient
v0.7](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/ChainlinkClient.sol)
by yourself.

Solutions:

  1. Use the v0.7 ChainlinkClient and [operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)(smart contract oracle.sol is renamed as operator.sol in v0.7) for your test. The document can be found [here](https://docs.chain.link/any-api/get-request/examples/single-word-response).
  2. There is a repo called [hardhat-starter-kit](https://github.com/smartcontractkit/hardhat-starter-kit) in Chainlink official github, there are sample codes you can try. Or you can directly use starterkit to test AnyApi and any other services.





:::NEXT DOC:::

Question: (Asked on: 2021-12-25 10:24:04)
Can chainlink external adapters be made so they can only called by a specific smart contract?
URL: https://stackoverflow.com/questions/70479339/can-chainlink-external-adapters-be-made-so-they-can-only-called-by-a-specific-sm

Question Body:


I want to make an external adapter which can only be called by a specific
function in a smart contract so that I can assure that the caller is an
authorized address. Is anyone able to make a call to an external adapter or
can I restrict it to a certain smart contract? If anyone is able to make a
call, is there a way for me to ensure that the caller is from the smart
contract?

What I am trying to do is to have a smart contract which can provide a
decryption key for a file. Essentially, the smart contract would store a
decryption key encrypted to the adapter's public key. Then, when an event in
the smart contract occurs where someone should gain access to the file, the
smart contract makes a call to the adapter. The adapter would then take the
encrypted decryption key, decrypt it, and return the decryption key encrypted
to the recipient's public key. The smart contract would then receive the
decryption key encrypted to the recipient's public key and store this so that
the recipient could use this to decrypt the file. Is something like this
possible with an external adapter?



Answers:
(Answered on: 2022-06-23 04:07:05)


If whitelisting addresses doesn't do the trick, I believe you can do the
following to the oracle contract:

    
    
        /**
         * @notice Creates the Chainlink request. This is a backwards compatible API
         * with the Oracle.sol contract, but the behavior changes because
         * callbackAddress is assumed to be the same as the request sender.
         * @param callbackAddress The consumer of the request
         * @param payment The amount of payment given (specified in wei)
         * @param specId The Job Specification ID
         * @param callbackAddress The address the oracle data will be sent to
         * @param callbackFunctionId The callback function ID for the response
         * @param nonce The nonce sent by the requester
         * @param dataVersion The specified data version
         * @param data The extra request parameters
         */
        function oracleRequest(
            address sender,
            uint256 payment,
            bytes32 specId,
            address callbackAddress,
            bytes4 callbackFunctionId,
            uint256 nonce,
            uint256 dataVersion,
            bytes calldata data
        ) external override validateFromLINK validateIsAuthorizedConsumer(sender) {
            revert(""use the operatorRequest only"");
        }
    
        /**
         * @notice Creates the Chainlink request
         * @dev Stores the hash of the params as the on-chain commitment for the request.
         * Emits OracleRequest event for the Chainlink node to detect.
         * @param sender The sender of the request
         * @param payment The amount of payment given (specified in wei)
         * @param specId The Job Specification ID
         * @param callbackFunctionId The callback function ID for the response
         * @param nonce The nonce sent by the requester
         * @param dataVersion The specified data version
         * @param data The extra request parameters
         */
        function operatorRequest(
            address sender,
            uint256 payment,
            bytes32 specId,
            bytes4 callbackFunctionId,
            uint256 nonce,
            uint256 dataVersion,
            bytes calldata data
        ) external override validateIsAuthorizedConsumer(sender) validateFromLINK {
            (
                bytes32 requestId,
                uint256 expiration
            ) = _verifyAndProcessOracleRequest(
                    sender,
                    payment,
                    sender,
                    callbackFunctionId,
                    nonce,
                    dataVersion
                );
            emit OracleRequest(
                specId,
                sender,
                requestId,
                payment,
                sender,
                callbackFunctionId,
                expiration,
                dataVersion,
                data
            );
        }
    
    

I removed the `oracleRequest()` function because it exceeds stack size by
adding more modifiers to it and since I can use `operatorRequest()` to fulfill
both multi-word and single-word requests I will make that method deprecated by
reverting everytime it's called.

The modifier that sets the authorized consumer is basically the following:

    
    
        /**
         * @dev function used to change the authorized consumer. Can only be set once
         */
        function setAuthorizedConsumer(address _consumer) public onlyOwner {
            require(
                authorizedConsumer == address(0),
                ""authorized consumer is already set""
            );
            authorizedConsumer = _consumer;
        }
    
        /**
         * @notice validates the consumer is an authorized consumer
         */
        function _validateIsAuthorizedConsumer(address _consumer) internal view {
            require(_consumer == authorizedConsumer, ""Not authorized sender"");
        }
    
        /**
         * @notice prevents non-authorized addresses from calling this method
         */
        modifier validateIsAuthorizedConsumer(address _consumer) {
            _validateIsAuthorizedConsumer(_consumer);
            _;
        }
    
    
    


---
(Answered on: 2021-12-29 08:59:47)


You can restrict the access by adding whitelisted requesters (authorized smart
contract addresses) to the database of the Chainlink node that is picking up
your requests and running the job calling your external adapter.

We wrote a short guide on how to do this:
<https://github.com/Linkriver/Chainlink-node-whitelisting>



"
What is the Chainlink Solana Crate and how can it be used?,The Chainlink Solana Crate is a library that can be imported into an existing project to read Chainlink Data Feed data on-chain. It can be used to query price data by specifying the feed account and the Chainlink Data Feeds OCR2 Program for the network.,{'source': 'https://docs.chain.link/data-feeds/solana/using-data-feeds-solana/'},"The Chainlink Solana Crate is a Rust crate that allows developers to read Chainlink Data Feed data on-chain in their Solana projects. It provides functions for querying price data from data feeds on the Solana network. The crate uses the Chainlink Data Feeds OCR2 Program to retrieve data from data providers. Developers can import the Chainlink Solana Crate into their projects and use its functions to make calls to the Chainlink Data Feeds on Solana.

The Chainlink Solana Crate can be used by adding it as a dependency in the project's `Cargo.toml` file and using its functions to query price data from the Chainlink Data Feeds on Solana. The crate provides functions such as `latest_round_data`, `description`, and `decimals` to retrieve different information from the data feeds. Developers can use these functions to access price data and other information from the Chainlink Data Feeds on Solana.

","- https://docs.chain.link/data-feeds/solana/
- https://docs.chain.link/data-feeds/solana/using-data-feeds-solana/","# Data Feeds on Solana

  * Overview
  * Chainlink products and Solana clusters
  * Languages, tools, and frameworks
  * Solana Wallets

Chainlink provides data feeds on the [Solana](https://solana.com/) network.
Chainlink data feeds on Solana employ [Off-Chain Reporting
(OCR)](/architecture-overview/off-chain-reporting?parent=dataFeeds) to
aggregate data from data providers who pull from both centralized and
decentralized exchanges. Chainlink’s Solana deployment has no dependencies on
external blockchain networks such as Ethereum. In Solana, storage and smart
contract logic are separate. Programs store all the logic similar to an EVM
(Ethereum) smart contract. The accounts store all the data. Compared to
Solidity, the combination of an account and a program is equivalent to a smart
contract on an EVM chain. State and logic are separate in Solana.

Solana programs are stateless, so you don't always need to deploy your program
to the network to test it. You can deploy and test your programs on a [Solana
Test Validator](https://docs.solana.com/developing/test-validator). However,
to use Chainlink products on Solana, you must deploy your contract on-chain to
one of the supported Solana clusters.

Note

Please note that Price Feeds performance relies on the chains they are
deployed on. Periods of high network congestion may impact the frequency of
Chainlink Price Feeds. Subscribe to [Solana
status](https://status.solana.com/) notifications to stay updated on system
performance.

To learn how to mitigate risk to your applications, read the [Selecting
Quality Data Feeds](/data-feeds/selecting-data-feeds) page.

## Chainlink products and Solana clusters

[Price Feeds](/data-feeds/price-feeds/addresses?network=solana) are available
on the following Solana clusters:

  * [Solana Mainnet](https://solscan.io/)
  * [Solana Devnet](https://solscan.io/?cluster=devnet)

Solana provides a [Testnet cluster](https://docs.solana.com/clusters#testnet)
that runs newer [Solana releases](https://github.com/solana-labs/solana/releases), but Chainlink Data Feeds are not available on this
cluster.

See the [Solana Data Feeds](/data-feeds/price-feeds/addresses?network=solana)
page for a full list of Chainlink data feeds that are available on Solana.

To learn when more Chainlink services become available, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=dataFeeds).

## Languages, tools, and frameworks

The examples in the Chainlink documentation use the following languages,
tools, and frameworks:

  * [Node.js 14 or higher](https://nodejs.org/en/download/): Used to run client code
  * [Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust): A general-purpose programming language designed for performance and memory safety
  * [Anchor](https://project-serum.github.io/anchor/getting-started/introduction.html): A framework for the [Solana Sealevel runtime](https://github.com/solana-labs/sealevel) that provides several developer tools
  * [Chainlink Solana Starter Kit](https://github.com/smartcontractkit/solana-starter-kit): An Anchor based program and client that shows developers how to use and interact with Chainlink Data Feeds on Solana
  * [Solana CLI](https://docs.solana.com/cli): The Solana command line interface
  * [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git): Used to clone the example code repository

When developing applications to use Chainlink products on Solana, always use a
[Mainnet release](https://github.com/solana-labs/solana/releases) version of
the Solana CLI that is equal to or greater than the version currently running
on your target cluster. Use `solana --version` and `solana cluster-version` to
check CLI and cluster versions:


    solana --version
    solana-cli 1.9.28 (src:b576e9cc; feat:320703611)
    
    solana cluster-version --url devnet
    1.9.25
    
    solana cluster-version --url mainnet-beta
    1.9.28

The examples in this documentation use Solana programs in
[Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust),
but you can also write Solana programs in
[C](https://docs.solana.com/developing/on-chain-programs/developing-c). To
learn more about the Solana programming model, see the [Solana
Documentation](https://docs.solana.com/developing/programming-model/overview).

## Solana Wallets

When you use Chainlink on Solana, you need a [Solana
wallet](https://docs.solana.com/wallet-guide/). The Chainlink documentation
uses [file system wallets](https://docs.solana.com/wallet-guide/file-system-wallet) and free Devnet SOL tokens to demonstrate examples. When you deploy
your programs to the Solana Mainnet, you must use wallets with mainnet
lamports.

If you have existing wallets that you want to use for the guides in the
Chainlink documentation, find your wallet keypair and make it available in
your development environment as a file. You can point
[Anchor](https://project-serum.github.io/anchor/getting-started/introduction.html) and the [Solana CLI](https://docs.solana.com/cli)
to a specific keypair when you deploy or manage your Solana programs.


    anchor build
    ⋮
    
    anchor deploy --provider.wallet ~/.config/solana/id.json --provider.cluster devnet
    ⋮
    
    solana program show --programs --keypair ~/.config/solana/id.json --url devnet
    
    Program Id                                   | Slot      | Authority                                    | Balance
    6U4suTp55kiJRKqV7HGAQvFgcLaStLnUA4myg5DRqsKw | 109609728 | E6gKKToCJPgf4zEL1GRLL6T99g2WcfAzJAMvtma1KijT | 2.57751768 SOL

When you build your production applications and deploy Solana programs to the
Mainnet cluster, always follow the security best practices in the [Solana
Wallet Guide](https://docs.solana.com/wallet-guide) for managing your wallets
and keypairs.

## What's next

  * [› Use data feeds off-chain](/data-feeds/solana/using-data-feeds-off-chain)
  * [› Use data feeds on-chain](/data-feeds/solana/using-data-feeds-solana)
  * [› See the available data feeds on Solana](/data-feeds/price-feeds/addresses?network=solana)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/solana/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds On-Chain (Solana)

  * Overview
  * The Chainlink Data Feeds OCR2 Program
  * Adding Data Feeds On-Chain In An Existing Project
  * Using the Solana Starter Kit
  * Install the required tools
  * Deploy the example program
  * Call the deployed program
  * Clean up

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world market prices of assets. This guide demonstrates how to deploy
a program to the Solana Devnet cluster and access Data Feeds on-chain using
the [Chainlink Solana Starter Kit](https://github.com/smartcontractkit/solana-starter-kit). To learn how to read price feed data using off-chain
applications, see the [Using Data Feeds Off-Chain](/solana/using-data-feeds-off-chain) guide.

To get the full list of available Chainlink Data Feeds on Solana, see the
[Solana Feeds](/data-feeds/price-feeds/addresses?network=solana) page. View
the program that owns the Chainlink Data Feeds in the [Solana Devnet
Explorer](https://solscan.io/account/HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny?cluster=devnet),
or the [Solana Mainnet
Explorer](https://solscan.io/account/HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny).

Select quality data feeds

Be aware of the quality of the data that you use. [Learn more about making
responsible data quality decisions](/data-feeds/selecting-data-feeds).

## The Chainlink Data Feeds OCR2 Program

The program that owns the data feeds on both Devnet and Mainnet is
[HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny](https://solscan.io/account/HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny?cluster=devnet).
This is the program ID that you use to retrieve Chainlink Price Data on-chain
in your program. The source code for this program is available in the
[smartcontractkit/chainlink-
solana](https://github.com/smartcontractkit/chainlink-solana/tree/develop/contracts/programs/ocr2) repository on GitHub.

You can add data feeds to an existing project or use the Solana Starter Kit.

## Adding Data Feeds On-Chain In An Existing Project

You can read Chainlink Data Feed data on-chain in your existing project using
the [Chainlink Solana Crate](https://crates.io/crates/chainlink_solana).

Reading feed data

Although you can directly query the data feed accounts, you should not rely on
the memory layout always being the same as it currently is. Based on this, the
recommendation is to always use the consumer library queries below.

Import the Chainlink Solana Crate into your project and use the code sample to
make function calls.

  1. Add the Chainlink Solana Crate as an entry in your `Cargo.toml` file dependencies section, as shown in the [starter kit Cargo.toml example](https://github.com/smartcontractkit/solana-starter-kit/blob/main/programs/chainlink_solana_demo/Cargo.toml).
    
        [dependencies]
    chainlink_solana = ""1.0.0""

  2. Use the following code sample to query price data. Each function call to the Chainlink Solana library takes two parameters:

    * The [feed account](/data-feeds/price-feeds/addresses?network=solana) that you want to query.
    * The Chainlink Data Feeds OCR2 Program for the network. This is a static value that never changes.

The code sample has the following components:

    * `latest_round_data`: Returns the latest round information for the specified price pair including the latest price
    * `description`: Returns a price pair description such as SOL/USD
    * `decimals`: Returns the precision of the price, as in how many numbers the price is padded out to
    * `Display`: A helper function that formats the padded out price data into a human-readable price
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    use chainlink_solana as chainlink;
    
    use solana_program::{
        account_info::{next_account_info, AccountInfo},
        entrypoint,
        entrypoint::ProgramResult,
        msg,
        pubkey::Pubkey,
    };
    
    struct Decimal {
        pub value: i128,
        pub decimals: u32,
    }
    
    impl Decimal {
        pub fn new(value: i128, decimals: u32) -> Self {
            Decimal { value, decimals }
        }
    }
    
    impl std::fmt::Display for Decimal {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut scaled_val = self.value.to_string();
            if scaled_val.len() <= self.decimals as usize {
                scaled_val.insert_str(
                    0,
                    &vec![""0""; self.decimals as usize - scaled_val.len()].join(""""),
                );
                scaled_val.insert_str(0, ""0."");
            } else {
                scaled_val.insert(scaled_val.len() - self.decimals as usize, '.');
            }
            f.write_str(&scaled_val)
        }
    }
    
    // Declare and export the program's entrypoint
    entrypoint!(process_instruction);
    
    // Program entrypoint's implementation
    pub fn process_instruction(
        _program_id: &Pubkey, // Ignored
        accounts: &[AccountInfo],
        _instruction_data: &[u8], // Ignored
    ) -> ProgramResult {
        msg!(""Chainlink Price Feed Consumer entrypoint"");
    
        let accounts_iter = &mut accounts.iter();
    
        // This is the account of the price feed data to read from
        let feed_account = next_account_info(accounts_iter)?;
        // This is the chainlink solana program ID
        let chainlink_program = next_account_info(accounts_iter)?;
    
        let round = chainlink::latest_round_data(
            chainlink_program.clone(),
            feed_account.clone(),
        )?;
    
        let description = chainlink::description(
            chainlink_program.clone(),
            feed_account.clone(),
        )?;
    
        let decimals = chainlink::decimals(
            chainlink_program.clone(),
            feed_account.clone(),
        )?;
    
        let decimal_print = Decimal::new(round.answer, u32::from(decimals));
        msg!(""{} price is {}"", description, decimal_print);
    
        Ok(())
    }
    
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    use anchor_lang::prelude::*;
    use chainlink_solana as chainlink;
    
    //Program ID required by Anchor. Replace with your unique program ID once you build your project
    declare_id!(""HPuUpM1bKbaqx7yY2EJ4hGBaA3QsfP5cofHHK99daz85"");
    
    #[account]
    pub struct Decimal {
        pub value: i128,
        pub decimals: u32,
    }
    
    impl Decimal {
        pub fn new(value: i128, decimals: u32) -> Self {
            Decimal { value, decimals }
        }
    }
    
    impl std::fmt::Display for Decimal {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut scaled_val = self.value.to_string();
            if scaled_val.len() <= self.decimals as usize {
                scaled_val.insert_str(
                    0,
                    &vec![""0""; self.decimals as usize - scaled_val.len()].join(""""),
                );
                scaled_val.insert_str(0, ""0."");
            } else {
                scaled_val.insert(scaled_val.len() - self.decimals as usize, '.');
            }
            f.write_str(&scaled_val)
        }
    }
    
    #[program]
    pub mod chainlink_solana_demo {
        use super::*;
            pub fn execute(ctx: Context<Execute>) -> Result<()>  {
            let round = chainlink::latest_round_data(
                ctx.accounts.chainlink_program.to_account_info(),
                ctx.accounts.chainlink_feed.to_account_info(),
            )?;
    
            let description = chainlink::description(
                ctx.accounts.chainlink_program.to_account_info(),
                ctx.accounts.chainlink_feed.to_account_info(),
            )?;
    
            let decimals = chainlink::decimals(
                ctx.accounts.chainlink_program.to_account_info(),
                ctx.accounts.chainlink_feed.to_account_info(),
            )?;
            // write the latest price to the program output
            let decimal_print = Decimal::new(round.answer, u32::from(decimals));
            msg!(""{} price is {}"", description, decimal_print);
            Ok(())
        }
    }
    
    #[derive(Accounts)]
    pub struct Execute<'info> {
        /// CHECK: We're reading data from this chainlink feed account
        pub chainlink_feed: AccountInfo<'info>,
        /// CHECK: This is the Chainlink program library
        pub chainlink_program: AccountInfo<'info>
    }
    

Program Transaction logs:


    > Program logged: ""Chainlink Price Feed Consumer entrypoint"" > Program logged: ""SOL / USD price is
    83.99000000""
    > Program consumed: 95953 of 1400000 compute units > Program return:
    HNYSbr77Jc9LhHeb9tx53SrWbWfNBnQzQrM4b3BB3PCR CA==


    Fetching transaction logs... [ 'Program HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny
    consumed 1826 of 1306895 compute units', 'Program return: HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny CA==',
    'Program HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny success', 'Program log: SOL / USD price is 93.76988029', ]

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://project-serum.github.io/anchor/).

## Using the Solana Starter Kit

This guide demonstrates the following tasks:

  * Write and deploy programs to the [Solana Devnet](https://solscan.io/?cluster=devnet) cluster using Anchor.
  * Retrieve price data data using the [Solana Web3 JavaScript API](https://www.npmjs.com/package/@solana/web3.js) with Node.js.

This example shows a full end to end example of using Chainlink Price Feeds on
Solana. It includes an on-chain program written in rust, as well as an off-
chain client written in JavaScript. The client passes in an account to the
program, the program then looks up the latest price of the specified price
feed account, and then stores the result in the passed in account. The off-
chain client then reads the value stored in the account.

### Install the required tools

Before you begin, set up your environment for development on Solana:

  1. Install [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if it is not already configured on your system.

  2. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  3. Install [Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to simplify package management and run code samples.

  4. Install a C compiler such as the one included in [GCC](https://gcc.gnu.org/install/). Some of the dependencies require a C compiler.

  5. Install [Rust](https://www.rust-lang.org/tools/install):
    
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh &&
    source $HOME/.cargo/env

  6. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  7. [Install Anchor](https://book.anchor-lang.com/getting_started/installation.html). On some operating systems, you might need to build and install Anchor locally. See the [Anchor documentation](https://book.anchor-lang.com/getting_started/installation.html#build-from-source-for-other-operating-systems-without-avm) for instructions.

After you install the required tools, build and deploy the example program
from the [solana-starter-kit](https://github.com/smartcontractkit/solana-starter-kit) repository.

### Deploy the example program

This example includes a contract written in Rust. Deploy the contract to the
Solana Devnet cluster.

  1. In a terminal, clone the [solana-starter-kit](https://github.com/smartcontractkit/solana-starter-kit) repository and change to the `solana-starter-kit` directory:
    
        git clone https://github.com/smartcontractkit/solana-starter-kit &&
    cd ./solana-starter-kit

You can see the complete code for the example on
[GitHub](https://github.com/smartcontractkit/solana-starter-kit/).

  2. In the `./solana-starter-kit` directory, install Node.js dependencies defined in the `package.json` file:
    
        yarn install

  3. Create a temporary Solana wallet to use for this example. Use a temporary wallet to isolate development from your other wallets and prevent you from unintentionally using lamports on the Solana Mainnet. Alternatively, if you have an existing wallet that you want to use, locate the path to your [keypair](https://docs.solana.com/terminology#keypair) file and use it as the keypair for the rest of this guide.
    
        solana-keygen new --outfile ./id.json

When you build your production applications and deploy Solana programs to the
Mainnet cluster, always follow the security best practices in the [Solana
Wallet Guide](https://docs.solana.com/wallet-guide) for managing your wallets
and keypairs.

  4. Fund your Solana wallet. On Devnet, use `solana airdrop` to add tokens to your account. The contract requires at least 4 SOL to deploy and the faucet limits each request to 2 SOL, so you must make two requests to get a total of 4 SOL on your wallet:
    
        solana airdrop 2 --keypair ./id.json --url devnet &&
    solana airdrop 2 --keypair ./id.json --url devnet

    * If the command line faucet does not work, run `solana address` on the temporary wallet to print the public key value for the wallet and request tokens from [SolFaucet](https://solfaucet.com/):
        
                solana address -k ./id.json

  5. Run `anchor build` to build the example program. If you receive the `no such subcommand: 'build-bpf'` error, restart your terminal session and run `anchor build` again:
    
        anchor build

  6. The build process generates the keypair for your program's account. Before you deploy your program, you must add this public key to the `lib.rs` file:

    1. Get the keypair from the `./target/deploy/chainlink_solana_demo-keypair.json` file that Anchor generated:
        
                solana address -k ./target/deploy/chainlink_solana_demo-keypair.json

    2. Edit the `./programs/chainlink_solana_demo/src/lib.rs` file and replace the keypair in the `declare_id!()` definition:
        
                vi ./programs/chainlink_solana_demo/src/lib.rs
        
                declare_id!(""JC16qi56dgcLoaTVe4BvnCoDL6FhH5NtahA7jmWZFdqm"");

  7. With the new program ID added, run `anchor build` again. This recreates the necessary program files with the correct program ID:
    
        anchor build

  8. Run `anchor deploy` to deploy the program to the Solana Devnet. Remember to specify the keypair file for your wallet and override the default. This wallet is the [account owner](https://docs.solana.com/terminology#account-owner) (authority) for the program:
    
        anchor deploy --provider.wallet ./id.json --provider.cluster devnet

  9. To confirm that the program deployed correctly, run `solana program show --programs` to get a list of deployed programs that your wallet owns. For this example, check the list of deployed programs for the `id.json` wallet on the Solana Devnet:
    
        solana program show --programs --keypair ./id.json --url devnet

The command prints the program ID, slot number, the wallet address that owns
the program, and the program balance:

    
        Program Id                                   | Slot      | Authority                                    | Balance
    GRt21UnJFHZvcaWLbcUrXaTCFMREewDrm1DweDYBak3Z | 110801571 | FsQPnANKDhqpoayxCL3oDHFCBmrhP34NrfbDR34qbQUt | 3.07874904 SOL

To see additional details of your deployed program, copy the program ID and
look it up in the [Solana Devnet
Explorer](https://solscan.io/?cluster=devnet).

Now that the program is on-chain, you can call it using the [Anchor Web3
module](https://project-serum.github.io/anchor/ts/modules/web3.html).

### Call the deployed program

Use your deployed program to retrieve price data from a Chainlink data feed on
Solana Devnet. For this example, call your deployed program using the [Anchor
Web3 module](https://project-serum.github.io/anchor/ts/modules/web3.html) and
the [`client.js` example](https://github.com/smartcontractkit/solana-starter-kit/blob/main/client.js) code.

  1. Set the [Anchor environment variables](https://www.twilio.com/blog/2017/01/how-to-set-environment-variables.html). Anchor uses these to determine which wallet to use and Solana cluster to use.
    
        export ANCHOR_PROVIDER_URL=https://api.devnet.solana.com &&
    export ANCHOR_WALLET=./id.json

  2. Run the `client.js` example and pass the program address in using the `--program` flag:
    
        node client.js --program $(solana address -k ./target/deploy/chainlink_solana_demo-keypair.json)

If the script executes correctly, you will see output with the current price
of SOL / USD.

    
        ⋮
    Price Is: 96.79778375
    Success
    ⋮

  3. Each request costs an amount of SOL that is subtracted from the `id.json` wallet. Run `solana balance` to check the remaining balance for your temporary wallet on Devnet.
    
        solana balance --keypair ./id.json --url devnet

  4. To get prices for a different asset pair, run `client.js` again and add the `--feed` flag with one of the available [Chainlink data feeds](/data-feeds/price-feeds/addresses?network=solana). For example, to get the price of BTC / USD on Devnet, use the following command:
    
        node client.js \
    --program $(solana address -k ./target/deploy/chainlink_solana_demo-keypair.json) \
    --feed CzZQBrJCLqjXRfMjRN3fhbxur2QYHUzkpaRwkWsiPqbz
    
        Price Is: 12.4215826
    Success

The program that owns the data feeds is
[HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny](https://solscan.io/account/HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny?cluster=devnet),
which you can see defined for `const CHAINLINK_PROGRAM_ID` in the `client.js`
file.

### Clean up

After you are done with your deployed contract and no longer need it, it is
nice to close the program and withdraw the Devnet SOL tokens for future use.
In a production environment, you will want to withdraw unused SOL tokens from
any Solana program that you no longer plan to use, so it is good to practice
the process when you are done with programs on Devnet.

  1. Run `solana program show` to see the list of deployed programs that your wallet owns and the balances for each of those programs:
    
        solana program show --programs --keypair ./id.json --url devnet
    
        Program Id                                   | Slot      | Authority                                    | Balance
    GRt21UnJFHZvcaWLbcUrXaTCFMREewDrm1DweDYBak3Z | 110801571 | FsQPnANKDhqpoayxCL3oDHFCBmrhP34NrfbDR34qbQUt | 3.07874904 SOL

  2. Run `solana program close` and specify the program that you want to close:
    
        solana program close [YOUR_PROGRAM_ID] --keypair ./id.json --url devnet

The program closes and the remaining SOL is transferred to your temporary
wallet.

  3. If you have deployments that failed, they might still be in the buffer holding SOL tokens. Run `solana program show` again with the `--buffers` flag:
    
        solana program show --buffers --keypair ./id.json --url devnet

If you have open buffers, they will appear in the list.

    
        Buffer Address                               | Authority                                    | Balance
    CSc9hnBqYJoYtBgsryJAmrjAE6vZ918qaFhL6N6BdEmB | FsQPnANKDhqpoayxCL3oDHFCBmrhP34NrfbDR34qbQUt | 1.28936088 SOL

  4. If you have any buffers that you do not plan to finish deploying, run the same `solana program close` command to close them and retrieve the unused SOL tokens:
    
        solana program close [YOUR_PROGRAM_ID] --keypair ./id.json --url devnet

  5. Check the balance on your temporary wallet.
    
        solana balance --keypair ./id.json --url devnet

  6. If you are done using this wallet for examples and testing, you can use [`solana transfer`](https://docs.solana.com/cli/transfer-tokens) to send the remaining SOL tokens to your default wallet or another Solana wallet that you use. For example, if your default wallet keypair is at `~/.config/solana/id.json`, you can send `ALL` of the temporary wallet's balance with the following command:
    
        solana transfer ~/.config/solana/id.json ALL --keypair ./id.json --url devnet

Alternatively, you can send the remaining balance to a web wallet. Specify the
public key for your wallet instead of the path the default wallet keypair. Now
you can use those Devnet funds for other examples and development.

To learn more about Solana and Anchor, see the [Solana
Documentation](https://docs.solana.com/) and the [Anchor
Documentation](https://project-serum.github.io/anchor/).

## What's next

  * [› Use data feeds off-chain](/data-feeds/solana/using-data-feeds-off-chain)
  * [› See the available data feeds on Solana](/data-feeds/price-feeds/addresses?network=solana)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/solana/using-data-feeds-solana.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Why is it important to assess the liquidity and reliability of a specific exchange when obtaining pricing data for a smart contract?,Assessing the liquidity and reliability of a specific exchange is important to avoid price manipulation and ensure that prices are accurately reported throughout a liquidity migration.,{'source': 'https://docs.chain.link/data-feeds/selecting-data-feeds/'},"It is important to assess the liquidity and reliability of a specific exchange when obtaining pricing data for a smart contract because assets with low liquidity can be volatile and susceptible to price manipulation. By evaluating the liquidity and reliability of the exchange, you can ensure that the pricing data used in your smart contract is accurate and trustworthy. Additionally, assessing the liquidity and distribution of the asset can help mitigate risks associated with extreme events, market failures, and periods of high network congestion. It is also important to consider the risks associated with single source data providers and evaluate the quality of their data. By considering these factors, you can make informed decisions about the data feeds used in your smart contract and protect your application and its users.

",https://docs.chain.link/data-feeds/selecting-data-feeds/,"# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside off-chain.
  * **LP Token Feeds:** These feeds use a decentralized feed for the underlying asset as well as calculations to value the LP tokens.
  * **Wrapped Calculated Feeds:** These feeds are typically pegged 1:1 to the underlying token or asset. Under normal market conditions, these feeds track their underlying value accurately. However, the price is a derivative formed from a calculated method and might not always track value precisely.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⭕ Deprecating

These feeds are being deprecated. To find the deprecation dates for specific
feeds, see the [Feeds Scheduled For Deprecation](/data-feeds/deprecating-feeds) page.

## Risk Mitigation

As a development best practice, design your systems and smart contracts to be
resilient and mitigate risk to your protocol and your users. Ensure that your
systems can tolerate known and unknown exceptions that might occur. Some
examples include but are not limited to volatile market conditions, the
degraded performance of infrastructure, chains, or networks, and any other
upstream outage related to data providers or node operators. You bear
responsibility for any manner in which you use the Chainlink Network, its
software, and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel: <https://discord.gg/Dqy5N9UbsR>

## Chainlink Community Deployments

Chainlink technology is used by many within the blockchain community to
support their use cases. Deployments built and run by community members are
not tracked in the Chainlink documentation. Chainlink's community is
continuously growing, and we believe they play a vital role in developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Fast Gas Reliability

### Liquidity and its Distribution

If your smart contract relies on pricing data for a specific asset, make sure
that the asset has sufficient liquidity in the market to avoid price
manipulation. Assets with low liquidity can be volatile, which might
negatively impact your application and its users. Malicious actors might try
to exploit volatility to take advantage of the logic in a smart contract and
cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather
than from aggregated price tracking services that gather their data from
multiple exchanges. These are marked as such in the docs page for that feed.
Assess the liquidity and reliability of that specific exchange.

_Liquidity migrations_ occur when a project moves its tokens from one
liquidity provider (such as a DEX, a CEX, or a new DeFi application) to
another. When liquidity migrations occur, it can result in low liquidity in
the original pool, making the asset susceptible to market manipulation. If
your project is considering a liquidity migration, you should coordinate with
relevant stakeholders, including liquidity providers, exchanges, oracle node
operators, and users, to ensure prices are accurately reported throughout the
migration.

Feeds for assets with low market liquidity where data providers exhibit an
abnormal price spread may, on occasion, see a price oscillate between two or
more price points within regular intervals. To mitigate risk associated with
such price oscillation, users must regularly monitor & assess the quality of
an asset’s liquidity. Similarly, assets with low market liquidity may
experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk
management measures to protect your assets. For example, create mock tests
that return various oracle responses.

### Single Source Data Providers

Some data providers use a single data source, which might be necessary if only
one source exists off-chain for a specific type of data. Evaluate data
providers to make sure they provide high-quality data that your smart
contracts can rely on. Any error or omission in the provider's data might
negatively impact your application and its users.

### Crypto and Blockchain Actions

Price data quality is subject to crypto actions by the crypto and blockchain
project teams. Crypto actions are similar to [corporate
actions](https://en.wikipedia.org/wiki/Corporate_action) but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on. Periods of
high network congestion might impact the frequency of Chainlink Price Feeds.
It is advised that you configure your applications to detect such chain
performance issues and to respond appropriately.

### Unknown and Known Users

Routine maintenance is carried out on Chainlink Data Feeds, including
decommissioning, on an ad-hoc basis. These maintenance periods might require
users to take action in order to maintain business continuity.

Notifications are sent to inform known users regarding such occurrences, and
it is strongly encouraged for all users, including those users utilizing data
feeds for off-chain purposes, [to provide their contact
information](https://chain.link/contact?ref_id=DataFeed) before utilizing data
feeds. Without providing contact information, users will be unable to receive
notifications regarding important price feed updates.

If you are using Price Feeds but have not provided your contact information,
you can do so [here](https://chain.link/contact?ref_id=DataFeed). Users that
fail to provide notification information do so at their own risk.

## Evaluating Wrapped or Bridged Assets

### Assessing how to Price Wrapped or Bridged Assets

When assessing a Chainlink Price Feed for a wrapped or bridged asset such as
WBTC, users should evaluate the tradeoffs between using a price feed
specifically built for the wrapped or bridged asset or a price feed built for
the underlying asset.

Decisions should be made on a case-by-case basis considering the liquidity,
depth, and trading volatility of the underlying asset compared to its
derivative. In addition, users must consider the security mechanism that is
designed to keep the wrapped or bridged asset coupled to its underlying asset.
Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets

Chainlink Price Feeds are designed to provide the market-wide price of various
assets, as determined by a volume-weighted average across a wide range of
exchanges. On blockchain networks where assets are wrapped and/or bridged from
another environment using a cross-chain token bridge, Chainlink Price Feeds
built for the underlying asset will continue to report the market-wide price
of the underlying asset as opposed to the price of the wrapped/bridged asset.
This methodology reduces risks around market manipulation because
wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price
deviations between the wrapped/bridged asset and its underlying counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible for reviewing the quality of the data that you integrate into your
smart contracts.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/selecting-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the VRFv2SubscriptionManager contract?,The VRFv2SubscriptionManager contract is an example contract that uses hardcoded values for clarity and uses un-audited code. It should not be used in production.,{'source': 'https://docs.chain.link/vrf/v2/subscription/examples/programmatic-subscription/'},"To fund your contract with LINK for VRF v2 subscription, you can use the `topUpSubscription` function in the `VRFv2SubscriptionManager` contract. This function allows you to transfer LINK tokens from your Metamask wallet to the subscription account. You need to specify the amount of LINK tokens you want to transfer as a parameter when calling this function.

Here is an example of how to use the `topUpSubscription` function in a Python script using the Brownie framework:

```python
from brownie import VRFv2SubscriptionManager, network, config

def fund_contract_with_link(contract_address, amount):
    # Connect to the network
    network.connect(config[""networks""][""rinkeby""][""name""])

    # Get the contract instance
    contract = VRFv2SubscriptionManager.at(contract_address)

    # Transfer LINK tokens to the contract
    contract.topUpSubscription(amount, {""from"": accounts[0]})

    print(""Funded contract with LINK tokens"")

# Replace CONTRACT_ADDRESS with the actual address of your deployed contract
fund_contract_with_link(CONTRACT_ADDRESS, 1000000000000000000)  # Transfer 1 LINK token
```

Make sure to replace `CONTRACT_ADDRESS` with the actual address of your deployed `VRFv2SubscriptionManager` contract. Also, adjust the `amount` parameter to the desired number of LINK tokens you want to transfer.

Note: Before running the script, make sure you have configured your Brownie project with the correct network and have sufficient LINK tokens in your Metamask wallet.

","- [Stack Overflow: How to fund your contract with LINKs for VRF v2 subscription?](https://stackoverflow.com/questions/72168793/how-to-fund-your-contract-with-links-for-vrf-v2-subscription)
- [Chainlink VRF Documentation: VRF v2 Subscription](https://docs.chain.link/vrf/v2/subscription/)","# Subscription Method

  * Overview
  * Subscriptions
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits
  * Subscription limits
  * Coordinator contract limits

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This section explains how to generate random numbers using the subscription
method.

## Subscriptions

VRF v2 requests receive funding from subscription accounts. The [Subscription
Manager](/vrf/v2/subscription/ui) lets you create an account and pre-pay for
VRF v2, so you don't provide funding each time your application requests
randomness. This reduces the total gas cost to use VRF v2. It also provides a
simple way to fund your use of Chainlink products from a single location, so
you don't have to manage multiple wallets across several different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends on current network conditions. The callback gas depends
on your callback function, and the number of random values in your request.
The cost of each request is final only after the transaction is complete, but
you define the limits you are willing to spend for the request with the
following variables:

  * **Gas lane:** The maximum gas price you are willing to pay for a request in wei. Define this limit by specifying the appropriate `keyHash` in your request. The limits of each gas lane are important for handling gas price spikes when Chainlink VRF bumps the gas price to fulfill your request quickly.

  * **Callback gas limit:** Specifies the maximum amount of gas you are willing to spend on the callback request. Define this limit by specifying the `callbackGasLimit` value in your request.

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF subscription
request, and registering a smart contract with a VRF subscription account:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can only be initiated by EOAs.
  * Smart contract: A contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFConsumerBaseV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol).

  2. Your contract must implement the implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling `requestRandomWords` of the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol). Include the following parameters in your request:

    * `keyHash`: Identifier that maps to a job and a private key on the VRF service and that represents a specified gas lane. If your request is urgent, specify a gas lane with a higher gas price limit. The configuration for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).
    * `s_subscriptionId`: The subscription ID that the consuming contract is registered to. LINK funds are deducted from this subscription.
    * `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).
    * `callbackGasLimit`: The maximum amount of gas a user is willing to pay for completing the callback VRF function. Note that you cannot put a value larger than maxGasLimit of the VRF Coordinator contract (read coordinator contract limits for more details).
    * `numWords`: The number of random numbers to request. The maximum random values that can be requested for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).

### How VRF processes your request

After you submit your request, it is processed using the Request & Receive
Data cycle. The VRF coordinator processes the request and determines the final
charge to your subscription using the following steps:

  1. The VRF coordinator emits an event.

  2. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

  3. The VRF coordinator verifies the proof on-chain, then it calls back the consuming contract `fulfillRandomWords` function.

## Limits

Chainlink VRF v2 has some subscription limits and coordinator contract limits.

### Subscription limits

Subscriptions are required to maintain a minimum balance, and they can support
a limited number of consuming contracts.

#### Minimum subscription balance

Each subscription must maintain a minimum balance to fund requests from
consuming contracts. This minimum balance requirement serves as a buffer
against gas volatility by ensuring that all your requests have more than
enough funding to go through. If your balance is below the minimum, your
requests remain pending for up to 24 hours before they expire. After you add
sufficient LINK to a subscription, pending requests automatically process as
long as they have not expired.

In the Subscription Manager, the minimum subscription balance is displayed as
the **Max Cost** , and it indicates the amount of LINK you need to add for a
pending request to process. After the request is processed, only the amount
actually consumed by the request is deducted from your balance. For example,
if your minimum balance is 10 LINK, but your subscription balance is 5 LINK,
you need to add at least 5 more LINK for your request to process. This does
not mean that your request will ultimately cost 10 LINK. If the request
ultimately costs 3 LINK after it has processed, then 3 LINK is deducted from
your subscription balance.

The minimum subscription balance must be sufficient for each new consuming
contract that you add to a subscription. For example, the minimum balance for
a subscription that supports 20 consuming contracts needs to cover all the
requests for all 20 contracts, while a subscription with one consuming
contract only needs to cover that one contract.

For one request, the required size of the minimum balance depends on the gas
lane and the size of the request. For example, a consuming contract that
requests one random value will require a smaller minimum balance than a
consuming contract that requests 50 random values. In general, you can
estimate the required minimum LINK balance using the following formula where
max verification gas is always 200,000 gwei.


    (((Gas lane maximum * (Max verification gas + Callback gas limit)) / (1,000,000,000 Gwei/ETH)) / (ETH/LINK price)) + LINK premium = Minimum LINK

Here is the same formula, broken out into steps:


    Gas lane maximum * (Max verification gas + Callback gas limit) = Total estimated gas (Gwei)
    Total estimated gas (Gwei) / 1,000,000,000 Gwei/ETH = Total estimated gas (ETH)
    Total estimated gas (ETH) / (ETH/LINK price) = Total estimated gas (LINK)
    Total estimated gas (LINK) + LINK premium = Minimum subscription balance (LINK)

#### Maximum consuming contracts

Each subscription supports up to 100 consuming contracts. If you need more
than 100 consuming contracts, create multiple subscriptions.

### Coordinator contract limits

You can see the configuration for each network on the [Supported
networks](/vrf/v2/subscription/supported-networks) page. You can also view the
full configuration for each coordinator contract directly in Etherscan. As an
example, view the [Ethereum Mainnet VRF v2 coordinator
contract](https://etherscan.io/token/0x271682DEB8C4E0901D1a1550aD2e64D568E69909#readContract)
configuration.

  * Each coordinator has a `MAX_NUM_WORDS` parameter that limits the maximum number of random values you can receive in each request.
  * Each coordinator has a `maxGasLimit` parameter, which is the maximum allowed `callbackGasLimit` value for your requests. You must specify a sufficient `callbackGasLimit` to fund the callback request to your consuming contract. This depends on the number of random values you request and how you process them in your `fulfillRandomWords()` function. If your `callbackGasLimit` is not sufficient, the callback fails but your subscription is still charged for the work done to generate your requested random values.

## What's next

  * [› Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Programmatic Subscription

  * Overview
  * Modifying subscriptions and configurations
  * Subscription manager contract
  * Funding and requesting simultaneously

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

How you manage the subscription depends on your randomness needs. You can
configure your subscriptions using the [Subscription
Manager](/vrf/v2/subscription/ui), but these examples demonstrate how to
create your subscription and add your consumer contracts programmatically. For
these examples, the contract owns and manages the subscription. Any wallet can
provide funding to those subscriptions.

You can view and monitor your subscriptions in the [Subscription
Manager](/vrf/v2/subscription/ui) even if you create them programmatically. Go
to [vrf.chain.link](https://vrf.chain.link) to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    * `acceptSubscriptionOwnerTransfer(uint64 subId)`.
  * View the subscription with `getSubscription(uint64 subId)`.
  * Cancel the subscription with `cancelSubscription(uint64 subId)`.

To send LINK to the subscription balance, use the LINK token interface with
`LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(subId))`.
Any wallet can fund a subscription.

See the example in the Subscription manager contract section to learn how to
create a contract that can change your subscription configuration.

## Subscription manager contract

In this example, the contract operates as a subscription owner and can run
functions to add consuming contracts to the subscription. The consuming
contracts must include the `requestRandomWords()` function with the correct
coordinator parameters and the correct subscription ID to request random
values and use the subscription balance. The consuming contracts must also
include the `fulfillRandomWords()` function to receive the random values.

Subscription owners and consumers do not have to be separate. This contract
not only allows adding consumers with `addConsumer(address consumerAddress)`
but can also act as a consumer by running its own `requestRandomWords()`
function. This example contract includes a `createNewSubscription()` function
in the `constructor()` that creates the subscription and adds itself as a
consumer automatically when you deploy it.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that also owns and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Sepolia coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    
        // Sepolia LINK token contract. For other networks, see
        // https://docs.chain.link/docs/vrf-contracts/#configurations
        address link_token_contract = 0x779877A7B0D9E8603169DdbD7836e478b4624789;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 keyHash =
            0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;
    
        // A reasonable default is 100000, but this value could be different
        // on other networks.
        uint32 callbackGasLimit = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 requestConfirmations = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
        uint32 numWords = 2;
    
        // Storage parameters
        uint256[] public s_randomWords;
        uint256 public s_requestId;
        uint64 public s_subscriptionId;
        address s_owner;
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            LINKTOKEN = LinkTokenInterface(link_token_contract);
            s_owner = msg.sender;
            //Create a new subscription when you deploy the contract.
            createNewSubscription();
        }
    
        // Assumes the subscription is funded sufficiently.
        function requestRandomWords() external onlyOwner {
            // Will revert if subscription is not set and funded.
            s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
        }
    
        function fulfillRandomWords(
            uint256 /* requestId */,
            uint256[] memory randomWords
        ) internal override {
            s_randomWords = randomWords;
        }
    
        // Create a new subscription when the contract is initially deployed.
        function createNewSubscription() private onlyOwner {
            s_subscriptionId = COORDINATOR.createSubscription();
            // Add this contract as a consumer of its own subscription.
            COORDINATOR.addConsumer(s_subscriptionId, address(this));
        }
    
        // Assumes this contract owns link.
        // 1000000000000000000 = 1 LINK
        function topUpSubscription(uint256 amount) external onlyOwner {
            LINKTOKEN.transferAndCall(
                address(COORDINATOR),
                amount,
                abi.encode(s_subscriptionId)
            );
        }
    
        function addConsumer(address consumerAddress) external onlyOwner {
            // Add a consumer contract to the subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
        }
    
        function removeConsumer(address consumerAddress) external onlyOwner {
            // Remove a consumer contract from the subscription.
            COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
        }
    
        function cancelSubscription(address receivingWallet) external onlyOwner {
            // Cancel the subscription and send the remaining LINK to a wallet address.
            COORDINATOR.cancelSubscription(s_subscriptionId, receivingWallet);
            s_subscriptionId = 0;
        }
    
        // Transfer this contract's funds to an address.
        // 1000000000000000000 = 1 LINK
        function withdraw(uint256 amount, address to) external onlyOwner {
            LINKTOKEN.transfer(to, amount);
        }
    
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }
    

To use this contract, compile and deploy it in Remix.

  1. Open the contract in [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol).

  2. Compile and deploy the contract using the Injected Provider environment. The contract includes all of the configuration variables that you need, but you can edit them if necessary. For a full list of available configuration variables, see the [Supported Networks](/vrf/v2/subscription/supported-networks) page.

This contract automatically creates a new subscription when you deploy it.
Read the `s_subscriptionId` variable to find your subscription ID. You can use
this value to find the subscription at
[vrf.chain.link](https://vrf.chain.link).

  3. In this example, the `topUpSubscription()` function sends LINK from your contract to the subscription. Fund your contract with at least three testnet LINK. Alternatively, you can send LINK directly to the subscription at [vrf.chain.link](https://vrf.chain.link). Any address can provide funding to a subscription balance. If you need testnet LINK, you can get it from [faucets.chain.link](https://faucets.chain.link/sepolia/).

  4. Run the `topUpSubscription()` function to send LINK from your contract to your subscription balance. For this example, specify a value of `3000000000000000000`, which is equivalent to three LINK.

  5. Run the `requestRandomWords()` function. The request might take several minutes to process. Track the pending request status at [vrf.chain.link](https://vrf.chain.link).

  6. You can also add and test consumer contracts using the same programmatic subscription process:

    1. Create and deploy a consumer contract that includes the following components:

      * The `requestRandomWords()` function and the required variables and your subscription ID.
      * The `fulfillRandomWords()` callback function.

You can use the example from the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number/#analyzing-the-contract) guide.

    2. After you deploy the consumer contract, add it to the subscription as an approved consumer using the `addConsumer()` function on your subscription manager contract. Specify the address of your consumer contract.

    3. On the consumer contract, run the `requestRandomWords()` function to request and receive random values. The request might take several minutes to process. Track the pending request status at [vrf.chain.link](https://vrf.chain.link).

The consumer contract can continue to make requests until your subscription
balance runs out. The subscription manager contract must maintain sufficient
balance in the subscription so that the consumers can continue to operate.

    4. If you need to remove consumer contracts from the subscription, use the `removeConsumer()` function. Specify the address of the consumer contract to be removed.

  7. When you are done with your contracts and the subscription, run the `cancelSubscription()` function to close the subscription and send the remaining LINK to your wallet address. Specify the address of the receiving wallet.

## Funding and requesting simultaneously

You can fund a subscription and request randomness in a single transaction.
You must estimate how much the transaction might cost and determine the amount
of funding to send to the subscription yourself. See the [Subscription
billing](/vrf/v2/subscription/#subscription-limits) page to learn how to
estimate request costs.


    // Assumes this contract owns link
    // You must estimate LINK cost yourself based on the gas lane and limits.
    // 1_000_000_000_000_000_000 = 1 LINK
    function fundAndRequestRandomWords(uint256 amount) external onlyOwner {
        LINKTOKEN.transferAndCall(
            address(COORDINATOR),
            amount,
            abi.encode(s_subscriptionId)
        );
        // Will revert if subscription is not set and funded.
        s_requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
    }
    

Add this function to your contracts if you need to provide funding
simultaneously with your requests. The `transferAndCall()` function sends LINK
from your contract to the subscription, and the `requestRandomWords()`
function requests the random words. Your contract still needs the
`fulfillRandomWords()` callback function to receive the random values.

## What's next

  * [› Subscription Manager UI](/vrf/v2/subscription/ui)
  * [› Security Considerations](/vrf/v2/security)
  * [› Best Practices](/vrf/v2/best-practices)
  * [› Migrating from VRF v1 to v2](/vrf/v2/subscription/migration-from-v1)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/examples/programmatic-subscription.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-05-09 08:07:14)
How to fund your contract with LINKs for VRF v2 subscription?
URL: https://stackoverflow.com/questions/72168793/how-to-fund-your-contract-with-links-for-vrf-v2-subscription

Question Body:


I've been learning solidity with brownie framework and python. I'm trying to
write a very simple contract which will generate a random number using
**ChainLink VRF v2**.

Here's the link of their sample **Subscription Manager Contract** :
<https://docs.chain.link/docs/chainlink-vrf/example-contracts/>

I've copied this exact same code in my **VRFv2SubscriptionManager.sol** file :

    
    
    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that also owns and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Rinkeby coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
    
        // Rinkeby LINK token contract. For other networks, see
        // https://docs.chain.link/docs/vrf-contracts/#configurations
        address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 keyHash =
            0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
    
        // A reasonable default is 100000, but this value could be different
        // on other networks.
        uint32 callbackGasLimit = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 requestConfirmations = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
        uint32 numWords = 2;
    
        // Storage parameters
        uint256[] public s_randomWords;
        uint256 public s_requestId;
        uint64 public s_subscriptionId;
        address public s_owner;
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            LINKTOKEN = LinkTokenInterface(link_token_contract);
            s_owner = msg.sender;
            //Create a new subscription when you deploy the contract.
            createNewSubscription();
        }
    
        // Assumes the subscription is funded sufficiently.
        function requestRandomWords() external onlyOwner {
            // Will revert if subscription is not set and funded.
            s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
        }
    
        function fulfillRandomWords(
            uint256, /* requestId */
            uint256[] memory randomWords
        ) internal override {
            s_randomWords = randomWords;
        }
    
        // Create a new subscription when the contract is initially deployed.
        function createNewSubscription() private onlyOwner {
            // Create a subscription with a new subscription ID.
            address[] memory consumers = new address[](1);
            consumers[0] = address(this);
            s_subscriptionId = COORDINATOR.createSubscription();
            // Add this contract as a consumer of its own subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumers[0]);
        }
    
        // Assumes this contract owns link.
        // 1000000000000000000 = 1 LINK
        function topUpSubscription(uint256 amount) external onlyOwner {
            LINKTOKEN.transferAndCall(
                address(COORDINATOR),
                amount,
                abi.encode(s_subscriptionId)
            );
        }
    
        function addConsumer(address consumerAddress) external onlyOwner {
            // Add a consumer contract to the subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
        }
    
        function removeConsumer(address consumerAddress) external onlyOwner {
            // Remove a consumer contract from the subscription.
            COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
        }
    
        function cancelSubscription(address receivingWallet) external onlyOwner {
            // Cancel the subscription and send the remaining LINK to a wallet address.
            COORDINATOR.cancelSubscription(s_subscriptionId, receivingWallet);
            s_subscriptionId = 0;
        }
    
        // Transfer this contract's funds to an address.
        // 1000000000000000000 = 1 LINK
        function withdraw(uint256 amount, address to) external onlyOwner {
            LINKTOKEN.transfer(to, amount);
        }
    
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }
    

This is my **deploy_first.py** :

    
    
    from brownie import VRFv2SubscriptionManager
    from scripts.helpful_scripts import get_account
    import time
    
    
    def deploy_random_number():
        account = get_account()
        random_number = VRFv2SubscriptionManager.deploy({""from"": account})
    
        print(""Deployed Random Number!!!"")
    
        owner = random_number.s_owner()
        print(""owner : "", owner)
    
        sub_id = random_number.s_subscriptionId()
        print(""sub_id : "", sub_id)
    
        random_number.topUpSubscription(9000000000000000000)
        print(""after the top up"")
        random_number.requestRandomWords()
        # time.sleep(60)
        print(""array : "", random_number.s_randomWords())
    
        return random_number
    
    
    def main():
        deploy_random_number()
    

I'm running this contract on Rinkeby TestNet and the account through which I'm
running this contract, has enough ETHER and LINK because I've tried
chainlink's official guide to generate the random number on **REMIX** and I
was able to generate it.

Here's the link of remix implementation of code :
<https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol>

**The Process on Remix :**

The new release of chainlink VRF v2 works this way from what I've understood
by implementing on **REMIX** :

  1. Inject web3, connect your Metamask (Rinkeby testnet) account to deploy the contract

  2. You deploy the contract and the contract creates a subscription for you in the constructor using **COORDINATOR.createSubscription();** where COOORDINATOR is **VRFCoordinatorV2Interface**

  3. Your Metamask account -- owns --> deployed contract

  4. Your deployed contract -- owns --> created subscription

  5. Consumers under a subscription account are allowed to use LINKs of that account and we are assigning our contract as the first consumer in the constructor

  6. To make calls to oracle our subscription account pays in LINKs, to send my subscription account LINKs I transferred LINKs from my metamask account to the address of the deployed contract, then used the function :
    
         // Assumes this contract owns link.
     // 1000000000000000000 = 1 LINK
     function topUpSubscription(uint256 amount) external onlyOwner {
         LINKTOKEN.transferAndCall(
             address(COORDINATOR),
             amount,
             abi.encode(s_subscriptionId)
         );
     }
    

to send LINKs from my contract to the subscription account.

  7. This worked completely fine in **REMIX** and I was able to generate the random number

**The Problem :**

Funding subscription and contracts is easy with Metamask wallet and Remix but
not scalable so I've got 2 main problems :

  1. How do I transfer LINKs from my Metamask (Rinkeby testnet) account (basically the **first msg.sender** i.e. **owner of the contract** ) to the contract that has been in deployed using my **VRFv2SubscriptionManager.sol** and **python_first.py**? Is there a way to do this using **web3.py**? (basically automate the process of funding the subscription account with LINKs while deploying the contract and creating subscription in the code only)

  2. In this example the **deployed contract** \-- owns --> **subscription account** after deploying the contract and creating a subscription using following functions :
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        LINKTOKEN = LinkTokenInterface(link_token_contract);
        s_owner = msg.sender;
        //Create a new subscription when you deploy the contract.
        createNewSubscription();
    }
    
    
        // Create a new subscription when the contract is initially deployed.
    function createNewSubscription() private onlyOwner {
        // Create a subscription with a new subscription ID.
        address[] memory consumers = new address[](1);
        consumers[0] = address(this);
        s_subscriptionId = COORDINATOR.createSubscription();
        // Add this contract as a consumer of its own subscription.
        COORDINATOR.addConsumer(s_subscriptionId, consumers[0]);
    }
    

Is there any way to create subscription, programatically, so that
**msg.sender** i.e. my Metamask (Rinkeby Testnet) account is the owner of
subscription account so that I don't have to transfer the LINKs to contract
first and can directly send it to the subscription account? On browser you can
do it easily here : <https://vrf.chain.link/>

  1. Link you Metamask wallet to the website
  2. Create a subscription account using you Metamask (Rinkeby Testnet) account
  3. Fund it with LINKs directly and in consumers you can add your deployed previously contracts using their addresses for them to use the LINKs to interact with VRF

I've tried changing the Gas Limit pre set in the contract, doublechecked my
values that I'm sending but I'm getting following error when python compiler
reaches the line : `random_number.topUpSubscription(9000000000000000000)` in
my **python_first.py**

**error :**

    
    
    Deployed Random Number!!!
    owner :  0xD8154fBD7cf816CdFde8cBC397b7cF5C604d7154
    sub_id :  4091
      File ""brownie/_cli/run.py"", line 51, in main
        return_value, frame = run(
      File ""brownie/project/scripts.py"", line 103, in run
        return_value = f_locals[method_name](*args, **kwargs)
      File ""./scripts/deploy_first.py"", line 28, in main
        deploy_random_number()
      File ""./scripts/deploy_first.py"", line 18, in deploy_random_number
        random_number.topUpSubscription(9000000000000000000)
      File ""brownie/network/contract.py"", line 1710, in __call__
        return self.transact(*args)
      File ""brownie/network/contract.py"", line 1583, in transact
        return tx[""from""].transfer(
      File ""brownie/network/account.py"", line 644, in transfer
        receipt, exc = self._make_transaction(
      File ""brownie/network/account.py"", line 727, in _make_transaction
        raise VirtualMachineError(e) from None
      File ""brownie/exceptions.py"", line 93, in __init__
        raise ValueError(str(exc)) from None
    ValueError: Gas estimation failed: 'execution reverted'. This transaction will likely revert. If you wish to broadcast, you must set the gas limit manually.
    

I assume this is because my contract doesn't have any LINK or ETHER i don't
know, I need more clarity on this error too.

I've been stuck on this problem for a day now. Please help. Thanks in advance.



Answers:
(Answered on: 2022-05-09 20:10:29)


As you said, the easiest way is to go to the
[vrf.chain.link](https://vrf.chain.link/), connect your wallet, and manage
your subscription(s). The initial flow is:

  * connect your wallet and select the proper network
  * create a new subscription, save your subscription id
  * fund your subscription
  * deploy VRF consumer smart contract
  * add it as a subscription consumer

[The Subscription Manager page](https://vrf.chain.link/) allows us to easily
manage subscription funds, add/remove multiple consumer contracts to/from one
subscription, and so much more.

Since you want to automate this process from the brownie CLI in a way that
your smart contract is not the owner of a subscription (and doesn't need to
worry about the funds), I suggest you move ""subscription logic"" from the smart
contract to python scripts, as described [in Chainlink Brownie Starter
Kit](https://github.com/smartcontractkit/chainlink-
mix/tree/main/scripts/vrf_scripts).

  1. To transfer LINKs from your Metamask (Rinkeby testnet) account to the contract that has been deployed, just perform the regular ERC20 transfer, but add your contract's address as the receiver/destination address. More examples [here](https://stackoverflow.com/questions/50764686/send-erc20-token-with-web3-py-using-a-local-private-key) and [here](https://web3py.readthedocs.io/en/stable/examples.html#sending-tokens).
  2. Probably because of that, try to set gas manually, as described in previous URLs, to some high value to confirm





:::NEXT DOC:::

#####Chapter 5: VRF Subscriptions

# Subscription Manager Contract

Now that we learned more about the theoretical background, let’s get practical. We want to create and manage a subscription contract. We will use the example contract that you can find here on [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js). It shows an example implementation of a VRF v2 Subscription manager for the Goerli network. But you can also adjust it to work with other networks by changing the code's hardcoded addresses. You can find a complete list of available networks [here](https://docs.chain.link/docs/vrf-contracts/#configurations).

Hint: This course assumes you are already familiar with the Architecture of Chainlink VRF from [VRFv2 Introduction Chapter 4](https://www.chainlink.education/vrfIntroduction/chapter-4).

Generally, consumer contracts must implement the requestRandomWords() function providing coordinator parameters and subscription ID. This function is used to create random values. A second function, fulfillRandomWords(), must be implemented to receive the random values. Learn about how to implement the basics of such a contract in [chapters 6-12](https://www.chainlink.education/vrfIntroduction/chapter-6) from the introduction course.

We want to focus on the mentioned functions here and show how to manage subscriptions in this contract. So let’s start by creating a new subscription:

<Highlight class=""language-javascript"">
uint64 public s_subscriptionId;
 function createNewSubscription() private onlyOwner {
   s_subscriptionId = COORDINATOR.createSubscription();
   COORDINATOR.addConsumer(s_subscriptionId, address(this));
 }
</Highlight>

We shall call this function when the contract is initially deployed using the constructor. The COORDINATOR is set to the COORDINATOR address in your network of choice. It is used to call the createSubscription() function. This returns an ID which is then used to add a new consumer using the same COORDINATOR contract. That’s already all you need to create a subscription and add a consumer. Now we can expand this and add or remove consumers using the corresponding functions (addConsumer, removeConsumer) to generate random numbers.

<Highlight class=""language-javascript"">
 function addConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
 }
 
 function removeConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
 }
</Highlight>

This was pretty straight forward. Before we implement the mandatory functions mentioned in the beginning, we will also add a function to topup the subscription with LINK tokens. That means we pre-fund the subscription so it can then be used to request random numbers without paying again, like in VRF v1.

<Highlight class=""language-javascript"">
 function topUpSubscription(uint256 amount) external onlyOwner {
   LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subscriptionId));
 }
</Highlight>

We assume that the contract itself has Link that we can use here. LINKTOKEN is the Link token contract. Now that we have the ability to manage consumers and funding, we will implement a simple function to request random words and received a request ID that we can use to get the random words. If the subscription is not set and funded it will revert. Note that the request might take several minutes to process.

<Highlight class=""language-javascript"">
function requestRandomWords() external onlyOwner {
   s_requestId = COORDINATOR.requestRandomWords(
     keyHash,
     s_subscriptionId,
     requestConfirmations,
     callbackGasLimit,
     numWords
   );
 }
</Highlight>

You can see that we don’t need to provide any parameters here though the COORDINATOR expects 5 of them. We have hard coded these values in the contract, but you could also ask the caller of the function to provide these values depending on your implementation. Let’s look into each parameter.

- **keyHash** defines which gas lane to use, which specifies the maximum gas price
- **s_subscriptionId** is set when the contract is deployed and a new subscription is created.
- **requestConfirmations** is three by default but you can set it higher.
- **callbackGasLimit** allows to set the the limit so more complex contracts can be developed using a single transaction to get verifiable randomness to their contract.
- **numWords** defines the number of random values which we want to get in one request.

So now that we have a function to request random words, we still need to implement a function to actually get the random words. This function is then called as a callback by the COORDINATOR to set the random values.

<Highlight class=""language-javascript"">
 uint256[] public s_randomWords;
 function fulfillRandomWords(
   uint256, /* requestId */
   uint256[] memory randomWords
 ) internal override {
   s_randomWords = randomWords;
 }
</Highlight>

The results are stored as a uint256 array. It can now be used by other functions or applications for further processing. If you wanted to have a random number between 0 and 10 you would simply use modulo: s_randomWords[0] % 10.
"
What are the two methods offered by Chainlink VRF v2 for requesting randomness?,Chainlink VRF v2 offers two methods for requesting randomness: Subscription and Direct funding.,{'source': 'https://docs.chain.link/vrf/'},"Chainlink VRF v2 offers two methods for requesting randomness: the Subscription method and the Direct funding method. The Subscription method involves creating a subscription account and funding its balance with LINK tokens, allowing multiple VRF consuming contracts to connect to the subscription account. The Direct funding method requires each VRF consuming contract to directly pay with LINK when requesting random values. The choice between the two methods depends on factors such as the frequency of requests, the number of consuming contracts, gas overhead, and funding flexibility. 

","
- https://docs.chain.link/vrf/v2/subscription
- https://docs.chain.link/vrf/v2/direct-funding","# Random Numbers: Using Chainlink VRF

  * Overview
  * How is randomness generated on blockchains? What is Chainlink VRF?
  * What is the Request and Receive cycle?
  * What is the payment process for generating a random number?
  * How can I use Chainlink VRF?
  * Create and fund a subscription
  * Importing VRFConsumerBaseV2 and VRFCoordinatorV2Interface
  * Contract variables
  * Initializing the contract
  * rollDice function
  * fulfillRandomWords function
  * house function
  * How do I deploy to testnet?
  * How do I add my contract to my subscription account?
  * How do I test rollDice?
  * Further Reading

Requirements

This guide assumes that you have basic knowledge about writing and deploying
smart contracts. If you are new to smart contract development, read the
[Consuming Data Feeds](/getting-started/consuming-data-feeds) guide before you
begin.

VRF v2 - Developer Walkthrough

In this guide, you will learn about generating randomness on blockchains. This
includes learning how to implement a Request and Receive cycle with Chainlink
oracles and how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation of Chainlink VRF, see [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number). In this section,
you will create an application that uses Chainlink VRF to generate randomness.
The contract used in this application has a [_Game of
Thrones_](https://en.wikipedia.org/wiki/Game_of_Thrones) theme.

After the contract requests randomness from Chainlink VRF, the result of the
randomness will transform into a number between 1 and 20, mimicking the
rolling of a 20 sided die. Each number represents a _Game of Thrones_ house.
If the dice land on the value 1, the user is assigned house Targaryan, 2 for
Lannister, and so on. A full list of houses can be found
[here](https://gameofthrones.fandom.com/wiki/Great_House).

When rolling the dice, it uses an `address` variable to track which address is
assigned to each house.

The contract has the following functions:

  * `rollDice`: This submits a randomness request to Chainlink VRF
  * `fulfillRandomWords`: The function that the Oracle uses to send the result back
  * `house`: To see the assigned house of an address

**Note** : to jump straight to the entire implementation, you can [open the
VRFD20.sol
contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFD20.sol)
in remix.

### Create and fund a subscription

Chainlink VRF requests receive funding from subscription accounts. The
[Subscription Manager](https://vrf.chain.link) lets you create an account and
pre-pay your use of Chainlink VRF requests. For this example, create a new
subscription on the Sepolia testnet as explained
[here](/vrf/v2/subscription/examples/get-a-random-number/#create-and-fund-a-subscription).

### Importing `VRFConsumerBaseV2` and `VRFCoordinatorV2Interface`

Chainlink maintains a [library of
contracts](https://github.com/smartcontractkit/chainlink/tree/master/contracts)
that make consuming data from oracles easier. For Chainlink VRF, you will use:

  * [`VRFConsumerBaseV2`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/VRFConsumerBaseV2.sol) that must be imported and extended from the contract that you create.
  * [`VRFCoordinatorV2Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol) that must be imported to communicate with the VRF coordinator.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
    
    }

### Contract variables

This example is adapted for [Sepolia testnet](/vrf/v2/subscription/supported-networks/#sepolia-testnet) but you can change the configuration and make it
run for any [supported network](/vrf/v2/subscription/supported-networks/#configurations).


    uint64 s_subscriptionId;
    address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
    bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
    uint32 callbackGasLimit = 40000;
    uint16 requestConfirmations = 3;
    uint32 numWords =  1;

  * `uint64 s_subscriptionId`: The subscription ID that this contract uses for funding requests. Initialized in the `constructor`.
  * `address vrfCoordinator`: The address of the Chainlink VRF Coordinator contract.
  * `bytes32 s_keyHash`: The gas lane key hash value, which is the maximum gas price you are willing to pay for a request in wei. It functions as an ID of the off-chain VRF job that runs in response to requests.
  * `uint32 callbackGasLimit`: The limit for how much gas to use for the callback request to your contract's `fulfillRandomWords` function. It must be less than the `maxGasLimit` on the coordinator contract. Adjust this value for larger requests depending on how your `fulfillRandomWords` function processes and stores the received random values. If your `callbackGasLimit` is not sufficient, the callback will fail and your subscription is still charged for the work done to generate your requested random values.
  * `uint16 requestConfirmations`: How many confirmations the Chainlink node should wait before responding. The longer the node waits, the more secure the random value is. It must be greater than the `minimumRequestBlockConfirmations` limit on the coordinator contract.
  * `uint32 numWords`: How many random values to request. If you can use several random values in a single callback, you can reduce the amount of gas that you spend per random value. In this example, each transaction requests one random value.

To keep track of addresses that roll the dice, the contract uses mappings.
[Mappings](https://medium.com/upstate-interactive/mappings-in-solidity-explained-in-under-two-minutes-ecba88aff96e) are unique key-value pair data
structures similar to hash tables in Java.


    mapping(uint256 => address) private s_rollers;
    mapping(address => uint256) private s_results;

  * `s_rollers` stores a mapping between the `requestID` (returned when a request is made), and the address of the roller. This is so the contract can keep track of who to assign the result to when it comes back.
  * `s_results` stores the roller and the result of the dice roll.

### Initializing the contract

The coordinator and subscription id must be initialized in the `constructor`
of the contract. To use `VRFConsumerBaseV2` properly, you must also pass the
VRF coordinator address into its constructor. The address that creates the
smart contract is the owner of the contract. the modifier `onlyOwner()` checks
that only the owner is allowed to do some tasks.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // variables
        // ...
    
        // constructor
        constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            s_owner = msg.sender;
            s_subscriptionId = subscriptionId;
        }
    
        //...
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }

### `rollDice` function

The `rollDice` function will complete the following tasks:

  1. Check if the roller has already rolled since each roller can only ever be assigned to a single house.
  2. Request randomness by calling the VRF coordinator.
  3. Store the `requestId` and roller address.
  4. Emit an event to signal that the dice is rolling.

You must add a `ROLL_IN_PROGRESS` constant to signify that the dice has been
rolled but the result is not yet returned. Also add a `DiceRolled` event to
the contract.

Only the owner of the contract can execute the `rollDice` function.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // variables
        uint256 private constant ROLL_IN_PROGRESS = 42;
        // ...
    
        // events
        event DiceRolled(uint256 indexed requestId, address indexed roller);
        // ...
    
        // ...
        // { constructor }
        // ...
    
        // rollDice function
        function rollDice(address roller) public onlyOwner returns (uint256 requestId) {
            require(s_results[roller] == 0, ""Already rolled"");
            // Will revert if subscription is not set and funded.
            requestId = COORDINATOR.requestRandomWords(
            s_keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
           );
    
            s_rollers[requestId] = roller;
            s_results[roller] = ROLL_IN_PROGRESS;
            emit DiceRolled(requestId, roller);
        }
    }

### `fulfillRandomWords` function

`fulfillRandomWords` is a special function defined within the
`VRFConsumerBaseV2` contract that our contract extends from. The coordinator
sends the result of our generated `randomWords` back to `fulfillRandomWords`.
You will implement some functionality here to deal with the result:

  1. Change the result to a number between 1 and 20 inclusively. Note that `randomWords` is an array that could contain several random values. In this example, request 1 random value.
  2. Assign the transformed value to the address in the `s_results` mapping variable.
  3. Emit a `DiceLanded` event.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // ...
        // { variables }
        // ...
    
        // events
        // ...
        event DiceLanded(uint256 indexed requestId, uint256 indexed result);
    
        // ...
        // { constructor }
        // ...
    
        // ...
        // { rollDice function }
        // ...
    
        // fulfillRandomWords function
        function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {
    
            // transform the result to a number between 1 and 20 inclusively
            uint256 d20Value = (randomWords[0] % 20) + 1;
    
            // assign the transformed value to the address in the s_results mapping variable
            s_results[s_rollers[requestId]] = d20Value;
    
            // emitting event to signal that dice landed
            emit DiceLanded(requestId, d20Value);
        }
    }

### `house` function

Finally, the `house` function returns the house of an address.

To have a list of the house's names, create the `getHouseName` function that
is called in the `house` function.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // ...
        // { variables }
        // ...
    
        // ...
        // { events }
        // ...
    
        // ...
        // { constructor }
        // ...
    
        // ...
        // { rollDice function }
        // ...
    
        // ...
        // { fulfillRandomWords function }
        // ...
    
        // house function
        function house(address player) public view returns (string memory) {
            // dice has not yet been rolled to this address
            require(s_results[player] != 0, ""Dice not rolled"");
    
            // not waiting for the result of a thrown dice
            require(s_results[player] != ROLL_IN_PROGRESS, ""Roll in progress"");
    
            // returns the house name from the name list function
            return getHouseName(s_results[player]);
        }
    
        // getHouseName function
        function getHouseName(uint256 id) private pure returns (string memory) {
            // array storing the list of house's names
            string[20] memory houseNames = [
                ""Targaryen"",
                ""Lannister"",
                ""Stark"",
                ""Tyrell"",
                ""Baratheon"",
                ""Martell"",
                ""Tully"",
                ""Bolton"",
                ""Greyjoy"",
                ""Arryn"",
                ""Frey"",
                ""Mormont"",
                ""Tarley"",
                ""Dayne"",
                ""Umber"",
                ""Valeryon"",
                ""Manderly"",
                ""Clegane"",
                ""Glover"",
                ""Karstark""
            ];
    
            // returns the house name given an index
            return houseNames[id - 1];
        }
    }

You have now completed all necessary functions to generate randomness and
assign the user a _Game of Thrones_ house. We've added a few helper functions
in there to make using the contract easier and more flexible. You can deploy
and interact with the complete contract in Remix.

## How do I deploy to testnet?

You will deploy this contract on the Sepolia test network. You need to [have
some Sepolia ETH](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) in your MetaMask account to pay for the gas.

This deployment is slightly different than the example in the [Deploy Your
First Contract](/getting-started/deploy-your-first-contract) guide. In this
case, you pass in parameters to the constructor upon deployment.

Once compiled, you'll see a dropdown menu that looks like this in the deploy
pane:



Select the `VRFD20` contract or the name that you gave to your contract.

Click the caret arrow on the right hand side of **Deploy** to expand the
parameter fields, and paste your subscription ID.



Then click the `Deploy` button and use your MetaMask account to confirm the
transaction.

Address, Key Hashes and more

For a full reference of the addresses, key hashes and fees for each network,
see [VRF Supported Networks](/vrf/v2/subscription/supported-networks/#configurations).

At this point, your contract should be successfully deployed. However, it
can't request anything because it is not yet approved to use the LINK balance
in your subscription. If you click `rollDice`, the transaction will revert.

## How do I add my contract to my subscription account?

After you deploy your contract, you must add it as an approved consumer
contract so it can use the subscription balance when requesting for
randomness. Go to the [Subscription Manager](https://vrf.chain.link) and add
your deployed contract address to the list of consumers. Find your contract
address in Remix under **Deployed Contracts** on the bottom left.



## How do I test `rollDice`?

After you open the deployed contract tab in the bottom left, the function
buttons are available. Find `rollDice` and click the caret to expand the
parameter fields. Enter an Ethereum address to specify a ""dice roller"", and
click 'rollDice'.

It takes a few minutes for the transaction to confirm and the response to be
sent back. You can get your house by clicking the `house` function button with
the address passed in `rollDice`. After the response is sent back, you'll be
assigned a _Game of Thrones_ house!

## Further Reading

To read more about generating random numbers in Solidity, read our blog posts:

  * [35+ Blockchain RNG Use Cases Enabled by Chainlink VRF](https://blog.chain.link/blockchain-rng-use-cases-enabled-by-chainlink-vrf/)
  * [How to Build Dynamic NFTs on Polygon](https://blog.chain.link/how-to-build-dynamic-nfts-on-polygon/)
  * [Chainlink VRF v2 Now Live on Ethereum Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/)

## What's next

  * [› Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number)
  * [› Programmatic Subscription](/vrf/v2/subscription/examples/programmatic-subscription)
  * [› Security Considerations](/vrf/v2/security)
  * [› Best Practices](/vrf/v2/best-practices)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/intermediates-tutorial.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                                                                                                          | Suitable for infrequent one-off requests                                                                                                                                                                    |
| Supports multiple VRF consuming contracts connected to one subscription account                                                                                        | Each VRF consuming contract directly pays for its requests                                                                                                                                                  |
| VRF costs are calculated after requests are fulfilled and then deducted from the subscription balance. Learn how VRF costs are calculated for the subscription method. | VRF costs are estimated and charged at request time, which may make it easier to transfer the cost of VRF to the end user. Learn how VRF costs are calculated for the direct funding method.                |
| Reduced gas overhead and more control over the maximum gas price for requests                                                                                          | Higher gas overhead than the subscription method                                                                                                                                                            |
| More random values returned per single request. See the maximum random values per request for the Subscription supported networks.                                     | Fewer random values returned per single request than the subscription method, due to higher overhead. See the maximum random values per request and gas overhead for the Direct funding supported networks. |
| You don't have to estimate costs precisely for each request. Ensure that the subscription account has enough funds.                                                    | You must estimate transaction costs carefully for each request to ensure the consuming contract has enough funds to pay for the request.                                                                    |
| Requires a subscription account                                                                                                                                        | No subscription account required                                                                                                                                                                            |
| Supported on Arbitrum                                                                                                                                                  | Not yet supported on Arbitrum                                                                                                                                                                               |
| VRF costs are billed to your subscription account. Manage and monitor your balance                                                                                     | No refunds for overpayment after requests are completed                                                                                                                                                     |
| Flexible funding method first introduced in VRF v2. Compare the VRF v2 subscription method to VRF v1.                                                                  | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.
"
What is the purpose of the `functions-simulate` command in the Chainlink Functions hardhat starter kit?,"The `functions-simulate` command executes your code in a local runtime environment and simulates an end-to-end fulfillment, helping you fix any issues before submitting your functions to a Decentralized Oracle Network.",{'source': 'https://docs.chain.link/chainlink-functions/tutorials/simple-computation/'},,,"# Return Custom Data Types

  * Overview
  * Before you begin
  * Tutorial
  * Simulation
  * Request
  * Explanation
  * FunctionsConsumer.sol
  * config.js
  * source.js

In this tutorial, you send a request to a Decentralized Oracle Network to call
the [Cryptocompare GET /data/pricemultifull API](https://min-api.cryptocompare.com/documentation?key=Price&cat=multipleSymbolsFullPriceEndpoint).
After [OCR](/chainlink-functions/resources/concepts) completes off-chain
computation and aggregation, it returns several responses to your smart
contract. The response includes an asset price, daily volume, and market name
to your smart contract. The example uses query parameters to specify the
ETH/USD asset pair, but you can configure HTTP query parameters to make
requests for different assets.

Maximum response size

You can return any number of responses as long as they are encoded in a
`bytes` response. The maximum response size that you can return is 256 bytes.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  3. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/3-custom-response_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/3-custom-response).
    
        git checkout tutorials

## Tutorial

This tutorial is configured to get the `ETH/USD`, daily volume, and market in
a single request. For a detailed explanation of the code example, read the
Explanation section.

  * Open `config.js`. Note the `args` value is `[""ETH"", ""USD""]`: We want to fetch the current `ETH/USD` price and daily volume. You can adapt `args` to get the list of supported symbols. Read the [API docs](https://min-api.cryptocompare.com/documentation?key=Price&cat=multipleSymbolsFullPriceEndpoint) to learn more about these configuration variables. For a more detailed explanation about the configuration in this example, read the request config explanation section.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation section for a more detailed explanation of how the source file is written.

### Simulation

The [Chainlink Functions hardhat starter
kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command will execute your code in a local runtime
environment and simulate an end-to-end fulfillment. Simulation can help you to
fix any issues before you submit your requests to the Decentralized Oracle
Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `Functions-request-source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/3-custom-response/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    HTTP GET Request to https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD
    ETH price is: 1810.29 USD. 24h Volume is 113255.87 USD. Market: Coinbase
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x7b227072696365223a22313831302e3239222c22766f6c756d65223a223131333235352e3837222c226c6173744d61726b6574223a22436f696e62617365227d
    Decoded as a string: {""price"":""1810.29"",""volume"":""113255.87"",""lastMarket"":""Coinbase""}
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x7b227072696365223a22313831302e3239222c22766f6c756d65223a223131333235352e3837222c226c6173744d61726b6574223a22436f696e62617365227d
    Decoded as a string: {""price"":""1810.29"",""volume"":""113255.87"",""lastMarket"":""Coinbase""}
    
    Gas used by sendRequest: 376604
    Gas used by client callback function: 98391

Reading the output of the example above, you can see that the `ETH/USD` price
is _1810.29 USD_ , volume is _113255.87_ , and the market is _Coinbase_.
Because the final result is a JSON object, the example converts it to a string
and returns the `bytes` encoded value
`0x7b227072696365223a22313831302e3239222c22766f6c756d65223a223131333235352e3837222c226c6173744d61726b6574223a22436f696e62617365227d`
in the callback. Read the source code explanation for a more detailed
explanation.

### Request

Reminder

Before you can make a successful request, you must complete the setup steps in
the Before you begin section. Each tutorial is in a separate Git branch and
some require unique entries in your `.env.enc` file.

Send a request to the Decentralized Oracle Network to fetch the asset price.
Run the `functions-request` task with the `subid` (subscription ID) and
`contract` parameters. This task passes the JavaScript source code, arguments,
and secrets when you call the `executeRequest` function in your deployed
`FunctionsConsumer` contract. Read the functionsConsumer section for a more
detailed explanation.


    npx hardhat functions-request --subid REPLACE_SUBSCRIPTION_ID --contract REPLACE_CONSUMER_CONTRACT_ADDRESS --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-request --subid 443 --contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea --network polygonMumbai --configpath tutorials/3-custom-response/config.js
    secp256k1 unavailable, reverting to browser version
    Estimating cost if the current gas price remains the same...
    
    The transaction to initiate this request will charge the wallet (0x9d087fC03ae39b088326b67fA3C788236645b717):
    0.00050942400509424 MATIC, which (using mainnet value) is $0.0005628062918760629
    
    If the request's callback uses all 100,000 gas, this request will charge the subscription:
    0.200148583233223418 LINK
    
    Continue? Enter (y) Yes / (n) No
    y
    Simulating Functions request locally...
    
    __Console log messages from sandboxed code__
    HTTP GET Request to https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD
    ETH price is: 1811.08 USD. 24h Volume is 113909.01 USD. Market: Bitfinex
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x7b227072696365223a22313831312e3038222c22766f6c756d65223a223131333930392e3031222c226c6173744d61726b6574223a2242697466696e6578227d
    Decoded as a string: {""price"":""1811.08"",""volume"":""113909.01"",""lastMarket"":""Bitfinex""}
    
    
    ⣾ Request 0x51d3aa3be08c71c49a37d586de07eb85e87a403e35a73521c5c914c430e2de2d has been initiated. Waiting for fulfillment from the Decentralized Oracle Network...
    
    ℹ Transaction confirmed, see https://mumbai.polygonscan.com/tx/0xd0140c40e65fdf51ea1b4396258915438693b61cfacb6d28a368bdd4f94b0443 for more details.
    
    ✔ Request 0x51d3aa3be08c71c49a37d586de07eb85e87a403e35a73521c5c914c430e2de2d fulfilled! Data has been written on-chain.
    
    Response returned to client contract represented as a hex string: 0x7b227072696365223a22313831312e3139222c22766f6c756d65223a223131333931302e3933222c226c6173744d61726b6574223a2242697466696e6578227d
    Decoded as a string: {""price"":""1811.19"",""volume"":""113910.93"",""lastMarket"":""Bitfinex""}
    
    Actual amount billed to subscription #443:
    ┌──────────────────────┬─────────────────────────────┐
    │         Type         │           Amount            │
    ├──────────────────────┼─────────────────────────────┤
    │  Transmission cost:  │  0.000071836060128269 LINK  │
    │      Base fee:       │          0.2 LINK           │
    │                      │                             │
    │     Total cost:      │  0.200071836060128269 LINK  │
    └──────────────────────┴─────────────────────────────┘
    

The output of the example above gives you the following information:

  * The `executeRequest` function was successfully called in the `FunctionsConsumer` contract. The transaction in this example is [0xd0140c40e65fdf51ea1b4396258915438693b61cfacb6d28a368bdd4f94b0443](https://mumbai.polygonscan.com/tx/0xd0140c40e65fdf51ea1b4396258915438693b61cfacb6d28a368bdd4f94b0443).
  * The request ID is `0x51d3aa3be08c71c49a37d586de07eb85e87a403e35a73521c5c914c430e2de2d`.
  * The DON successfully fulfilled your request. The total cost was: `0.200071836060128269 LINK`.
  * The consumer contract received a response in `bytes` with a value of `0x7b227072696365223a22313831312e3038222c22766f6c756d65223a223131333930392e3031222c226c6173744d61726b6574223a2242697466696e6578227d`. Decoding it off-chain to `string` gives you the following result: `{""price"":""1811.19"",""volume"":""113910.93"",""lastMarket"":""Bitfinex""}`.

At any time, you can run the `functions-read` task with the `contract`
parameter to read the latest received response.


    npx hardhat functions-read  --contract REPLACE_CONSUMER_CONTRACT_ADDRESS --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-read  --contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea  --network polygonMumbai --configpath tutorials/3-custom-response/config.js
    secp256k1 unavailable, reverting to browser version
    Reading data from Functions client contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea on network mumbai
    
    On-chain response represented as a hex string: 0x7b227072696365223a22313831312e3139222c22766f6c756d65223a223131333931302e3933222c226c6173744d61726b6574223a2242697466696e6578227d
    Decoded as a string: {""price"":""1811.19"",""volume"":""113910.93"",""lastMarket"":""Bitfinex""}

Decoding
`0x7b227072696365223a22313831312e3139222c22766f6c756d65223a223131333931302e3933222c226c6173744d61726b6574223a2242697466696e6578227d`
from `bytes` to `string` gives you
`{""price"":""1811.19"",""volume"":""113910.93"",""lastMarket"":""Bitfinex""}`. Off-chain,
you can use [JSON.parse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse) to convert the
JSON string to a JSON object.

## Explanation

### FunctionsConsumer.sol

  * To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol). You can read the API reference: [FunctionsClient](/chainlink-functions/api-reference/FunctionsClient).

This contract is not available in an NPM package, so you must download and
import it from within your project.

    
        import {Functions, FunctionsClient} from ""./dev/functions/FunctionsClient.sol"";

  * Use the [Functions.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/Functions.sol) library to get all the functions needed for building a Chainlink Functions request. You can read the API reference: [Functions](/chainlink-functions/api-reference/Functions).
    
        using Functions for Functions.Request;
    

  * The latest request id, latest received response, and latest received error (if any) are defined as state variables. Note `latestResponse` and `latestError` are encoded as dynamically sized byte array `bytes`, so you will still need to decode them to read the response or error:
    
        bytes32 public latestRequestId;
    bytes public latestResponse;
    bytes public latestError;

  * We define the `OCRResponse` event that your smart contract will emit during the callback
    
        event OCRResponse(bytes32 indexed requestId, bytes result, bytes err);

  * Pass the oracle address for your network when you deploy the contract:
    
        constructor(address oracle) FunctionsClient(oracle)

  * At any time, you can change the oracle address by calling the `updateOracleAddress` function.

  * The two remaining functions are:

    * `executeRequest` for sending a request. It receives the JavaScript source code, encrypted secrets, list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

      * It uses the `Functions`library to initialize the request and add any passed encrypted secrets or arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/Functions/#initializerequest), [adding secrets](/chainlink-functions/api-reference/Functions/#addinlinesecrets), and [adding arguments](/chainlink-functions/api-reference/Functions/#addargs).
            
                        Functions.Request memory req;
            req.initializeRequest(Functions.Location.Inline, Functions.CodeLanguage.JavaScript, source);
            if (secrets.length > 0) {
              req.addRemoteSecrets(secrets);
            }
            if (args.length > 0) req.addArgs(args);

      * It sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Finally, it stores the request id in `latestRequestId`.
            
                        bytes32 assignedReqID = sendRequest(req, subscriptionId, gasLimit);
            latestRequestId = assignedReqID;

    * `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `latestResponse` and `latestError` before emitting the `OCRResponse` event.
        
                latestResponse = response;
        latestError = err;
        emit OCRResponse(requestId, response, err);

### config.js

Read the [Request
Configuration](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) section for a detailed description of each setting.
This example uses the following settings:

  * `codeLocation: Location.Inline`: The JavaScript code is provided within the request.
  * `codeLanguage: CodeLanguage.JavaScript`: The source code is developed in the JavaScript language.
  * `source: fs.readFileSync(path.resolve(__dirname, ""source.js"")).toString()`: The source code must be a script object. This example uses `fs.readFileSync` to read `source.js` and calls `toString()` to get the content as a `string` object.
  * `args: [""ETH"", ""USD""]`: These arguments are passed to the source code. This example requests the `ETH/USD` price and daily volume.
  * `expectedReturnType: ReturnType.string`: The response received by the DON is encoded in `bytes`. Because the price, daily volume and market are put in a JSON string, define `ReturnType.string` to inform users how to decode the response received by the DON. Read source code explanation for more information.

### source.js

You can check the expected API response. Directly paste the following URL in
your browser `https://min-
api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD` or run a `curl`
command in your terminal:


    curl -X 'GET' \
      'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD' \
      -H 'accept: application/json'

The response should be similar to the following example:


    {
      ""RAW"": {
        ""ETH"": {
          ""USD"": {
            ""TYPE"": ""5"",
            ""MARKET"": ""CCCAGG"",
            ""FROMSYMBOL"": ""ETH"",
            ""TOSYMBOL"": ""USD"",
            ""FLAGS"": ""2049"",
            ""PRICE"": 2867.04,
            ""LASTUPDATE"": 1650896942,
            ""MEDIAN"": 2866.2,
            ""LASTVOLUME"": 0.16533939,
            ""LASTVOLUMETO"": 474.375243849,
            ""LASTTRADEID"": ""1072154517"",
            ""VOLUMEDAY"": 195241.78281014622,
            ""VOLUMEDAYTO"": 556240560.4621655,
            ""VOLUME24HOUR"": 236248.94641103,
            ...
    }

The price is located at `RAW,ETH,USD,PRICE`, the volume is at
`RAW,ETH,USD,VOLUME24HOUR`, and the market is at `RAW,ETH,USD,LASTMARKET`.

Read the [JavaScript code](https://github.com/smartcontractkit/functions-hardhat-starter-kit#javascript-code) section for a detailed explanation of how
to write compatible JavaScript source code. This JavaScript source code uses
[Functions.makeHttpRequest](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) to make HTTP requests. To request the
`ETH/USD` price, the source code calls this URL: `https://min-
api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD` If you read the
documentation for
[Functions.makeHttpRequest](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library), you see you must provide the following
parameters:

  * `url`: `https://min-api.cryptocompare.com/data/pricemultifull`

  * `params`: The query parameters object:
    
        {
      fsyms: fromSymbol,
      tsyms: toSymbol
    }

Note `fromSymbol` and `toSymbol` are fetched from `args` (see request config).

The code is self-explanatory and has comments to help you understand all the
steps. The main steps are:

  * Construct the HTTP object `cryptoCompareRequest` using `Functions.makeHttpRequest`.

  * Run the HTTP request.

  * Read the asset price, daily volume, and market from the response.

  * Construct a JSON object.
    
        const result = {
      price: price.toFixed(2),
      volume: volume.toFixed(2),
      lastMarket,
    }

  * Convert the JSON object to a JSON string using `JSON.stringify(result)`. This step is mandatory before encoding `string` to `bytes`.

  * Return the result as a [buffer](https://nodejs.org/api/buffer.html#buffer) using the `Functions.string` helper function. **Note** : Read this [article](https://www.freecodecamp.org/news/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8/) if you are new to Javascript Buffers and want to understand why they are important.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/tutorials/api-custom-response.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Call an API with HTTP Query Parameters

  * Overview
  * Before you begin
  * Tutorial
  * Simulation
  * Request
  * Explanation
  * FunctionsConsumer.sol
  * config.js
  * source.js

This tutorial shows you how to send a request to a Decentralized Oracle
Network to call the [Cryptocompare GET /data/pricemultifull API](https://min-api.cryptocompare.com/documentation?key=Price&cat=multipleSymbolsFullPriceEndpoint).
After [OCR](/chainlink-functions/resources/concepts) completes off-chain
computation and aggregation, it returns the asset price for ETH/USD to your
smart contract. This guide also shows you how to configure HTTP query
parameters to request different asset prices.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  3. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/2-call-api_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/2-call-api).
    
        git checkout tutorials

## Tutorial

This tutorial is configured to get the `ETH/USD` price. For a detailed
explanation of the code example, read the Explanation section.

  * Open `config.js`. The `args` value is `[""ETH"", ""USD""]`, which fetches the current `ETH/USD` price. You can adapt `args` to fetch another asset price. See the [CryptoCompare API docs](https://min-api.cryptocompare.com/documentation?key=Price&cat=multipleSymbolsFullPriceEndpoint) to get the list of supported symbols. Read the request config explanation for a more detailed explanation about the request config file.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation.

### Simulation

The [Chainlink Functions Hardhat Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command executes your code in a local runtime environment
and simulates an end-to-end fulfillment. This helps you to fix any issues
before you submit your functions to a Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/2-call-api/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    HTTP GET Request to https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD
    ETH price is: 1813.50 USD
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x000000000000000000000000000000000000000000000000000000000002c466
    Decoded as a uint256: 181350
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x000000000000000000000000000000000000000000000000000000000002c466
    Decoded as a uint256: 181350
    
    Gas used by sendRequest: 367881
    Gas used by client callback function: 75029

Reading the output of the example above, you can see that the `ETH/USD` price
is: _1813.50 USD_. Because Solidity does not support decimals, we move the
decimal point so that the value looks like an integer `181350` before
returning the `bytes` encoded value
`0x000000000000000000000000000000000000000000000000000000000002c466` in the
callback. Read the source code explanation for more information about the
source code.

### Request

Reminder

Before you can make a successful request, you must complete the setup steps in
the Before you begin section. Each tutorial is in a separate Git branch and
some require unique entries in your `.env.enc` file.

Send a request to the Decentralized Oracle Network to fetch the asset price.
Run the `functions-request` task with the `subid` (subscription ID) and
`contract` parameters. This task passes the functions JavaScript source code,
arguments, and secrets to the `executeRequest` function in your deployed
`FunctionsConsumer` contract. Read the functionsConsumer section for more
information about the consumer contract.


    npx hardhat functions-request --subid REPLACE_SUBSCRIPTION_ID --contract REPLACE_CONSUMER_CONTRACT_ADDRESS --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-request --subid 443 --contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea --network polygonMumbai --configpath tutorials/2-call-api/config.js
    secp256k1 unavailable, reverting to browser version
    Estimating cost if the current gas price remains the same...
    
    The transaction to initiate this request will charge the wallet (0x9d087fC03ae39b088326b67fA3C788236645b717):
    0.000496339505294288 MATIC, which (using mainnet value) is $0.0005516547067031669
    
    If the request's callback uses all 100,000 gas, this request will charge the subscription:
    0.200148503810857266 LINK
    
    Continue? Enter (y) Yes / (n) No
    y
    Simulating Functions request locally...
    
    __Console log messages from sandboxed code__
    HTTP GET Request to https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD
    ETH price is: 1813.96 USD
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x000000000000000000000000000000000000000000000000000000000002c494
    Decoded as a uint256: 181396
    
    ⣾ Request 0x5e89f3e84cbf80d65de53de816052d1b79c50c1f1f9f283aadc3ad36d33d41aa has been initiated. Waiting for fulfillment from the Decentralized Oracle Network...
    
    ℹ Transaction confirmed, see https://mumbai.polygonscan.com/tx/0x36029c2e49d0d890d00a1b554e4bea564444e48c5449f9d5deaed5d42114d91e for more details.
    
    ✔ Request 0x5e89f3e84cbf80d65de53de816052d1b79c50c1f1f9f283aadc3ad36d33d41aa fulfilled! Data has been written on-chain.
    
    Response returned to client contract represented as a hex string: 0x000000000000000000000000000000000000000000000000000000000002c48b
    Decoded as a uint256: 181387
    
    Actual amount billed to subscription #443:
    ┌──────────────────────┬─────────────────────────────┐
    │         Type         │           Amount            │
    ├──────────────────────┼─────────────────────────────┤
    │  Transmission cost:  │  0.000063268449037502 LINK  │
    │      Base fee:       │          0.2 LINK           │
    │                      │                             │
    │     Total cost:      │  0.200063268449037502 LINK  │
    └──────────────────────┴─────────────────────────────┘
    

The output of the example above gives you the following information:

  * The `executeRequest` function was successfully called in the `FunctionsConsumer` contract. The transaction in this example is [0x36029c2e49d0d890d00a1b554e4bea564444e48c5449f9d5deaed5d42114d91e](https://mumbai.polygonscan.com/tx/0x36029c2e49d0d890d00a1b554e4bea564444e48c5449f9d5deaed5d42114d91e).
  * The request ID is `0x5e89f3e84cbf80d65de53de816052d1b79c50c1f1f9f283aadc3ad36d33d41aa`.
  * The DON successfully fulfilled your request. The total cost was: `0.200063268449037502 LINK`.
  * The consumer contract received a response in `bytes` with a value of `0x000000000000000000000000000000000000000000000000000000000002c48b`. Decoding it off-chain to a `uint256` gives you a result: `181387`.

At any time, you can run the `functions-read` task again with the `contract`
parameter to read the latest received response.


    npx hardhat functions-read  --contract REPLACE_CONSUMER_CONTRACT_ADDRESS --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-read  --contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea  --network polygonMumbai --configpath tutorials/2-call-api/config.js
    secp256k1 unavailable, reverting to browser version
    Reading data from Functions client contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea on network mumbai
    
    On-chain response represented as a hex string: 0x000000000000000000000000000000000000000000000000000000000002c48b
    Decoded as a uint256: 181387

## Explanation

### FunctionsConsumer.sol

  * To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol). You can read the API reference: [FunctionsClient](/chainlink-functions/api-reference/FunctionsClient).

This contract is not available in an NPM package, so you must download and
import it from within your project.

    
        import {Functions, FunctionsClient} from ""./dev/functions/FunctionsClient.sol"";

  * Use the [Functions.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/Functions.sol) library to get all the functions needed for building a Chainlink Functions request. You can read the API reference: [Functions](/chainlink-functions/api-reference/Functions).
    
        using Functions for Functions.Request;
    

  * The latest request id, latest received response, and latest received error (if any) are defined as state variables. Note `latestResponse` and `latestError` are encoded as dynamically sized byte array `bytes`, so you will still need to decode them to read the response or error:
    
        bytes32 public latestRequestId;
    bytes public latestResponse;
    bytes public latestError;

  * We define the `OCRResponse` event that your smart contract will emit during the callback
    
        event OCRResponse(bytes32 indexed requestId, bytes result, bytes err);

  * Pass the oracle address for your network when you deploy the contract:
    
        constructor(address oracle) FunctionsClient(oracle)

  * At any time, you can change the oracle address by calling the `updateOracleAddress` function.

  * The two remaining functions are:

    * `executeRequest` for sending a request. It receives the JavaScript source code, encrypted secrets, list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

      * It uses the `Functions`library to initialize the request and add any passed encrypted secrets or arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/Functions/#initializerequest), [adding secrets](/chainlink-functions/api-reference/Functions/#addinlinesecrets), and [adding arguments](/chainlink-functions/api-reference/Functions/#addargs).
            
                        Functions.Request memory req;
            req.initializeRequest(Functions.Location.Inline, Functions.CodeLanguage.JavaScript, source);
            if (secrets.length > 0) {
              req.addRemoteSecrets(secrets);
            }
            if (args.length > 0) req.addArgs(args);

      * It sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Finally, it stores the request id in `latestRequestId`.
            
                        bytes32 assignedReqID = sendRequest(req, subscriptionId, gasLimit);
            latestRequestId = assignedReqID;

    * `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `latestResponse` and `latestError` before emitting the `OCRResponse` event.
        
                latestResponse = response;
        latestError = err;
        emit OCRResponse(requestId, response, err);

### config.js

Read the [Request
Configuration](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) section for a detailed description of each setting. In
this example, the settings are the following:

  * `codeLocation: Location.Inline`: The JavaScript code is provided within the request.
  * `codeLanguage: CodeLanguage.JavaScript`: The source code is developed in the JavaScript language.
  * `source: fs.readFileSync(path.resolve(__dirname, ""source.js"")).toString()`: The source code must be a script object. This example uses `fs.readFileSync` to read `source.js` and calls `toString()` to get the content as a `string` object.
  * `args: [""ETH"", ""USD""]`: These arguments are passed to the source code. This example requests the `ETH/USD` price.
  * `expectedReturnType: ReturnType.uint256`: The response received by the DON is encoded in `bytes`. Because the asset price is a `uint256`, define `ReturnType.uint256` to inform users how to decode the response received by the DON.

### source.js

To check the expected API response, you can directly paste the following URL
in your browser `https://min-
api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD` or run the
`curl` command in your terminal:


    curl -X 'GET' \
      'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD' \
      -H 'accept: application/json'

The response should be similar to the following example:


    {
      ""RAW"": {
        ""ETH"": {
          ""USD"": {
            ""TYPE"": ""5"",
            ""MARKET"": ""CCCAGG"",
            ""FROMSYMBOL"": ""ETH"",
            ""TOSYMBOL"": ""USD"",
            ""FLAGS"": ""2049"",
            ""PRICE"": 2867.04,
            ""LASTUPDATE"": 1650896942,
            ""MEDIAN"": 2866.2,
            ""LASTVOLUME"": 0.16533939,
            ""LASTVOLUMETO"": 474.375243849,
            ""LASTTRADEID"": ""1072154517"",
            ""VOLUMEDAY"": 195241.78281014622,
            ""VOLUMEDAYTO"": 556240560.4621655,
            ""VOLUME24HOUR"": 236248.94641103,
            ...
    }

The price is located at `RAW,ETH,USD,PRICE`.

Read the [JavaScript code](https://github.com/smartcontractkit/functions-hardhat-starter-kit#javascript-code) section for a detailed explanation of how
to write a compatible JavaScript source code. This JavaScript source code uses
[Functions.makeHttpRequest](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) to make HTTP requests. To request the
`ETH/USD` price, the source code calls the `https://min-
api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD` URL. If you
read the
[Functions.makeHttpRequest](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) documentation, you see that you must
provide the following parameters:

  * `url`: `https://min-api.cryptocompare.com/data/pricemultifull`

  * `params`: The query parameters object:
    
        {
      fsyms: fromSymbol,
      tsyms: toSymbol
    }

The `fromSymbol` and `toSymbol` values are fetched from `args`. See the
request config section for more details.

The code is self-explanatory and has comments to help you understand all the
steps. The main steps are:

  * Construct the HTTP object `cryptoCompareRequest` using `Functions.makeHttpRequest`.
  * Make the HTTP call.
  * Read the asset price from the response.
  * Return the result as a [buffer](https://nodejs.org/api/buffer.html#buffer) using the `Functions.encodeUint256` helper function. Because solidity doesn't support decimals, multiply the result by `100` and round the result to the nearest integer. **Note** : Read this [article](https://www.freecodecamp.org/news/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8/) if you are new to Javascript Buffers and want to understand why they are important.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/tutorials/api-query-parameters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Off-chain Secrets in Requests

  * Overview
  * Before you begin
  * Tutorial
  * Build Off-chain Secrets
  * Simulation
  * Request
  * Explanation
  * FunctionsConsumer.sol
  * config.js
  * source.js

As explained in the [Using Secrets in Requests guide](/chainlink-functions/tutorials/api-use-secrets), the Chainlink Functions starter kit
shares encrypted secrets off-chain with a Decentralized Oracle Network (DON)
using [gists](https://docs.github.com/en/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists). This tutorial
shows you how to share encrypted secrets off-chain with a Decentralized Oracle
Network (DON) using another storage platform such as AWS S3, Google Drive,
IPFS, or any other service where the DON can fetch secrets via HTTP.

Read the [API multiple calls](/chainlink-functions/tutorials/api-multiple-calls) tutorial before you follow the steps in this example. This tutorial
uses the same example, but with a slightly different process:

  1. Instead of relying on the default off-chain option(gists), you will host your encrypted secrets on AWS S3.
  2. Include the encrypted secrets in an `offchain-secrets.json` file.
  3. Host the secrets file off-chain (AWS S3).
  4. Include the HTTP URL to the file in your Chainlink Functions request.

The `functions-build-offchain-secrets` task encrypts the secrets and creates
the secrets file for you. For reference, you can find the public key for the
DON by running the `getDONPublicKey` function on the [Functions Oracle Proxy
contract](https://mumbai.polygonscan.com/address/0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4#readProxyContract#F5).
See the [Supported Networks](https://docs.chain.link/chainlink-functions/supported-networks#contract-addresses) page to find the Functions
Oracle Proxy contract for each supported network.

caution

Chainlink Functions is still in BETA. Please utilize credentials that are
assigned for your testing purposes only and that do not secure sensitive data
or real value. The use of secrets in your requests is an experimental feature
that may not operate as expected and is subject to change. Use of this feature
is at your own risk and may result in unexpected errors, possible revealing of
the secret as new versions are released, or other issues.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure to understand the [API multiple calls](/chainlink-functions/tutorials/api-multiple-calls) guide.

  3. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  4. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/7-offchain-secrets_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/7-offchain-secrets).
    
        git checkout tutorials

  5. Get a free API key from [CoinMarketCap](https://coinmarketcap.com/api/).

  6. Run `npx env-enc set` to add an encrypted `COINMARKETCAP_API_KEY` to your `.env.enc` file.
    
        npx env-enc set

  7. Prepare the store for your encrypted secrets file.

    1. Create a [AWS free tier account](https://aws.amazon.com/free/).
    2. Follow [these steps](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html) to create a AWS S3 bucket. Choose a name for your bucket, set _ACLs enabled_ , and turn off _Block all public access_.

## Tutorial

Set up your environment variables

This tutorial has some unique `.env.enc` setup steps. Make sure that you
configured your `.env.enc` file with the necessary variables in the Before you
begin section.

This tutorial is configured to get the median `BTC/USD` price from multiple
data sources. For a detailed explanation of the code example, read the
Explanation section.

  * Open `config.js`. Note the `args` value is `[""1"", ""bitcoin"", ""btc-bitcoin""]`. These arguments are BTC IDs at CoinMarketCap, CoinGecko, and Coinpaprika. You can adapt `args` to fetch other asset prices. See the API docs for [CoinMarketCap](https://coinmarketcap.com/api/documentation/v1/), [CoinGecko](https://www.coingecko.com/en/api/documentation), and [CoinPaprika](https://api.coinpaprika.com/) for details. For more information about the request, read the request config section.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation of the request source file.

### Build Off-chain Secrets

Before you make a request, prepare the secrets file and host it off-chain:

  1. Encrypt the secrets with the public key of the DON and store them in the `offchain-secrets.json` file. The `--network` flag is required because each network has a unique DON with a different public key.
    
        npx hardhat functions-build-offchain-secrets --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:

    
        $ npx hardhat functions-build-offchain-secrets --network polygonMumbai --configpath tutorials/7-offchain-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    Using public keys from FunctionsOracle contract 0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4 on network mumbai
    
    Wrote offchain secrets file to offchain-secrets.json

  2. Follow these [steps](https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-an-object-bucket.html) to upload the file `offchain-secrets.json` to your AWS S3 bucket.

  3. To make the file publically accessible without authentication:

    1. Find the file in the bucket list, and click on it to open the object overview.
    2. Click on the _Permissions_ tab to display the _Access control list (ACL)_.
    3. Click on _Edit_.
    4. Set _Everyone (public access)_ Objects read, then confirm. This action makes the object readable by anyone on the internet.
    5. Note the object URL.
    6. To verify that the URL is publicly readable without authentication, open a new browser tab and copy/paste the object URL in the browser location bar. After you hit _Enter_ , the browser will display the content of your encrypted secrets file.
  4. Open `config.js`. Fill in the `secretsURLs` variable. For example: `secretsURLs: [""https://clfunctions.s3.eu-north-1.amazonaws.com/offchain-secrets.json""]`. **Note** : When you make requests, any URLs in `secretsURL` are encrypted so no third party can view them.

### Simulation

The [Chainlink Functions Hardhat Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command executes your code in a local runtime environment
and simulates an end-to-end fulfillment. This helps you to fix issues before
you submit functions to the Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/7-offchain-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    Median Bitcoin price: $28148.36
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002af374
    Decoded as a uint256: 2814836
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002af374
    Decoded as a uint256: 2814836
    
    Gas used by sendRequest: 411773
    Gas used by client callback function: 75029

Reading the output of the example above, you can note that the `BTC/USD`
median price is: _28148.36 USD_. Because Solidity does not support decimals,
we move the decimal point so that the value looks like the integer `2814836`
before returning the `bytes` encoded value
`0x00000000000000000000000000000000000000000000000000000000002af374` in the
callback. Read the source code explanation for a more detailed explanation.

### Request

Reminder

Before you can make a successful request, you must complete the setup steps in
the Before you begin section. Each tutorial is in a separate Git branch and
some require unique entries in your `.env.enc` file.

Send a request to the Decentralized Oracle Network to fetch the asset price.
Run the `functions-request` task with the `subid` (subscription ID) and
`contract` parameters. This task passes the functions JavaScript source code
and any arguments and secrets when calling the `executeRequest` function in
your deployed `FunctionsConsumer` contract. Read the functionsConsumer section
for a more detailed explanation about the consumer contract.


    npx hardhat functions-request --subid REPLACE_SUBSCRIPTION_ID --contract REPLACE_CONSUMER_CONTRACT_ADDRESS --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example (You will see several compile warnings, but no errors):


    $ npx hardhat functions-request --subid 443 --contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea --network polygonMumbai --configpath tutorials/7-offchain-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    Estimating cost if the current gas price remains the same...
    
    The transaction to initiate this request will charge the wallet (0x9d087fC03ae39b088326b67fA3C788236645b717):
    0.000561571505990096 MATIC, which (using mainnet value) is $0.0006155385277157443
    
    If the request's callback uses all 100,000 gas, this request will charge the subscription:
    0.200148071812467286 LINK
    
    Continue? Enter (y) Yes / (n) No
    y
    Simulating Functions request locally...
    
    __Console log messages from sandboxed code__
    Median Bitcoin price: $28148.36
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002af374
    Decoded as a uint256: 2814836
    
    WARNING: No secrets found for node 0xca46169b34e00cadabb8ecbffa34ae4d1f7050e4.  That node will use default secrets specified by the ""0x0"" entry.
    WARNING: No secrets found for node 0x7a0fd7a68d0257139c9a90c130fb732e6d997c4b.  That node will use default secrets specified by the ""0x0"" entry.
    WARNING: No secrets found for node 0x4225387e43e066598300e6ef18af183060b4145b.  That node will use default secrets specified by the ""0x0"" entry.
    WARNING: No secrets found for node 0x42918d83b9298113274420350fd901d9ac382b89.  That node will use default secrets specified by the ""0x0"" entry.
    
    ⣾ Request 0x1d4affdb139f35980da5200db0ef22df1f408ce6e68835b7665dce36e9dec784 has been initiated. Waiting for fulfillment from the Decentralized Oracle Network...
    
    
    ℹ Transaction confirmed, see https://mumbai.polygonscan.com/tx/0x0d321a8fbe9fb44be1409f08039a0ddaaa114b612afa00a2fc8c17c4367aa81c for more details.
    
    Actual amount billed to subscription #443:
    ┌──────────────────────┬─────────────────────────────┐
    │         Type         │           Amount            │
    ├──────────────────────┼─────────────────────────────┤
    │  Transmission cost:  │  0.000101970932120464 LINK  │
    │      Base fee:       │          0.2 LINK           │
    │                      │                             │
    │     Total cost:      │  0.200101970932120464 LINK  │
    └──────────────────────┴─────────────────────────────┘
    
    
    ✔ Request 0x1d4affdb139f35980da5200db0ef22df1f408ce6e68835b7665dce36e9dec784 fulfilled! Data has been written on-chain.
    
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002af47c
    Decoded as a uint256: 2815100

The output of the example above gives you the following information:

  * The `executeRequest` function was successfully called in the `FunctionsConsumer` contract. The transaction in this example is [0x0d321a8fbe9fb44be1409f08039a0ddaaa114b612afa00a2fc8c17c4367aa81c](https://mumbai.polygonscan.com/tx/0x0d321a8fbe9fb44be1409f08039a0ddaaa114b612afa00a2fc8c17c4367aa81c).
  * The request ID is `0x1d4affdb139f35980da5200db0ef22df1f408ce6e68835b7665dce36e9dec784`.
  * The DON successfully fulfilled your request. The total cost was: `0.200101970932120464 LINK`.
  * The consumer contract received a response in `bytes` with a value of `0x00000000000000000000000000000000000000000000000000000000002af47c`. Decoding the response off-chain to `uint256` gives you a result of `2815100`.

At any time, you can run the `functions-read` task with the `contract`
parameter to read the latest received response.


    npx hardhat functions-read  --contract REPLACE_CONSUMER_CONTRACT_ADDRESS --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-read  --contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea  --network polygonMumbai --configpath tutorials/7-offchain-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    Reading data from Functions client contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea on network mumbai
    
    On-chain response represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002af47c
    Decoded as a uint256: 2815100

## Explanation

### FunctionsConsumer.sol

  * To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol). You can read the API reference: [FunctionsClient](/chainlink-functions/api-reference/FunctionsClient).

This contract is not available in an NPM package, so you must download and
import it from within your project.

    
        import {Functions, FunctionsClient} from ""./dev/functions/FunctionsClient.sol"";

  * Use the [Functions.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/Functions.sol) library to get all the functions needed for building a Chainlink Functions request. You can read the API reference: [Functions](/chainlink-functions/api-reference/Functions).
    
        using Functions for Functions.Request;
    

  * The latest request id, latest received response, and latest received error (if any) are defined as state variables. Note `latestResponse` and `latestError` are encoded as dynamically sized byte array `bytes`, so you will still need to decode them to read the response or error:
    
        bytes32 public latestRequestId;
    bytes public latestResponse;
    bytes public latestError;

  * We define the `OCRResponse` event that your smart contract will emit during the callback
    
        event OCRResponse(bytes32 indexed requestId, bytes result, bytes err);

  * Pass the oracle address for your network when you deploy the contract:
    
        constructor(address oracle) FunctionsClient(oracle)

  * At any time, you can change the oracle address by calling the `updateOracleAddress` function.

  * The two remaining functions are:

    * `executeRequest` for sending a request. It receives the JavaScript source code, encrypted secrets, list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

      * It uses the `Functions`library to initialize the request and add any passed encrypted secrets or arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/Functions/#initializerequest), [adding secrets](/chainlink-functions/api-reference/Functions/#addinlinesecrets), and [adding arguments](/chainlink-functions/api-reference/Functions/#addargs).
            
                        Functions.Request memory req;
            req.initializeRequest(Functions.Location.Inline, Functions.CodeLanguage.JavaScript, source);
            if (secrets.length > 0) {
              req.addRemoteSecrets(secrets);
            }
            if (args.length > 0) req.addArgs(args);

      * It sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Finally, it stores the request id in `latestRequestId`.
            
                        bytes32 assignedReqID = sendRequest(req, subscriptionId, gasLimit);
            latestRequestId = assignedReqID;

    * `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `latestResponse` and `latestError` before emitting the `OCRResponse` event.
        
                latestResponse = response;
        latestError = err;
        emit OCRResponse(requestId, response, err);

### config.js

Read the [Request
Configuration](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) section for a detailed description of each setting. In
this example, the settings are the following:

  * `codeLocation: Location.Inline`: The JavaScript code is provided within the request.
  * `codeLanguage: CodeLanguage.JavaScript`: The source code is developed in the JavaScript language.
  * `source: fs.readFileSync(path.resolve(__dirname, ""source.js"")).toString()`: The source code must be a script object. This example uses `fs.readFileSync` to read `source.js` and calls `toString()` to get the content as a `string` object.
  * `secrets: { apiKey: process.env.COINMARKETCAP_API_KEY }`: JavaScript object which contains secret values. These secrets are encrypted using the DON public key. The `process.env.COINMARKETCAP_API_KEY` setting means `COINMARKETCAP_API_KEY` is fetched from the environment variables. **Note** : `secrets` is limited to a key-value map that can only contain strings. It cannot include any other types or nested parameters.
  * `secretsURLs: [""YOUR_HTTP_URL""]`: This is an array that contains the URLs of encrypted secrets.
  * `walletPrivateKey: process.env[""PRIVATE_KEY""]`: This is your EVM account private key. It is used to generate a signature for the encrypted secrets such that an unauthorized third party cannot reuse them.
  * `args: [""1"", ""bitcoin"", ""btc-bitcoin""]`: These arguments are passed to the source code. This example requests the `BTC/USD` price. These arguments are BTC IDs at CoinMarketCap, CoinGecko, and Coinpaprika. You can adapt `args` to fetch other asset prices. See the API docs for [CoinMarketCap](https://coinmarketcap.com/api/documentation/v1/), [CoinGecko](https://www.coingecko.com/en/api/documentation), and [CoinPaprika](https://api.coinpaprika.com/) for details.
  * `expectedReturnType: ReturnType.uint256`: The response received by the DON is encoded in `bytes`. Because the asset price is `uint256`, you must define `ReturnType.uint256` to inform users how to decode the response received by the DON.

### source.js

To check the expected API responses, run these commands in your terminal:

  * CoinMarketCap:
    
        curl -X 'GET' \
    'https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?id=1&convert=USD' \
    -H 'accept: application/json' \
    -H 'X-CMC_PRO_API_KEY: REPLACE_WITH_YOUR_API_KEY'

  * CoinGecko:
    
        curl -X 'GET' \
    'https://api.coingecko.com/api/v3/simple/price?vs_currencies=USD&ids=bitcoin' \
    -H 'accept: application/json'

  * Coinpaprika:
    
        curl -X 'GET' \
    'https://api.coinpaprika.com/v1/tickers/btc-bitcoin' \
    -H 'accept: application/json'

The price is located at:

  * CoinMarketCap: `data,1,quote,USD,price`
  * CoinGecko: `bitcoin,usd`
  * Coinpaprika: `quotes,USD,price`

Read the [JavaScript code](https://github.com/smartcontractkit/functions-hardhat-starter-kit#javascript-code) section for a detailed explanation of how
to write a compatible JavaScript source code. This JavaScript source code uses
[Functions.makeHttpRequest](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) to make HTTP requests.

The code is self-explanatory and has comments to help you understand all the
steps. The main steps are:

  * Construct the HTTP objects `coinMarketCapRequest`, `coinGeckoRequest`, and `coinPaprikaRequest` using `Functions.makeHttpRequest`. The values for `coinMarketCapCoinId`, `coinGeckoCoinId`, and `coinPaprikaCoinId` are fetched from the `args`. See the request config section for details.
  * Make the HTTP calls.
  * Read the asset price from each response.
  * Calculate the median of all the prices.
  * Return the result as a [buffer](https://nodejs.org/api/buffer.html#buffer) using the `Functions.encodeUint256` helper function. Because solidity doesn't support decimals, multiply the result by `100` and round the result to the nearest integer. **Note** : Read this [article](https://www.freecodecamp.org/news/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8/) if you are new to Javascript Buffers and want to understand why they are important.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/tutorials/api-use-secrets-offchain.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Secrets in Requests

  * Overview
  * Before you begin
  * Tutorial
  * Simulation
  * Request
  * Explanation
  * FunctionsConsumer.sol
  * config.js
  * source.js

This tutorial shows you how to send a request to a Decentralized Oracle
Network to call the [Coinmarketcap
API](https://coinmarketcap.com/api/documentation/v1/). After [OCR](/chainlink-functions/resources/concepts) completes off-chain computation and aggregation,
it returns the `BTC/USD` asset price to your smart contract. Because the API
requires you to provide an API key, this guide will also show you how to
encrypt, sign your API key, and share it off-chain with a Decentralized Oracle
Network (DON).

The Chainlink Functions starter kit creates
[gists](https://docs.github.com/en/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists) containing encrypted secrets on
your behalf. Then, it shares the gist URL with the DON. This method comes with
a security benefit:

  * The encrypted secrets are never stored on-chain. The secrets are encrypted with the DON's public key so that only an oracle node in the DON can decrypt them using the DON's private key. After the DON fulfills a request, the starter kit deletes the gist. This revokes the credentials after the DON has fulfilled the request.

caution

Chainlink Functions is still in BETA. Please utilize credentials that are
assigned for your testing purposes only and that do not secure sensitive data
or real value. The use of secrets in your requests is an experimental feature
that may not operate as expected and is subject to change. Use of this feature
is at your own risk and may result in unexpected errors, possible revealing of
the secret as new versions are released, or other issues.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  3. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/5-use-secrets_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/5-use-secrets).
    
        git checkout tutorials

  4. Get a free API key from [CoinMarketCap](https://coinmarketcap.com/api/) and note your API key.

  5. The starter kit store encrypted secrets as [gists](https://docs.github.com/en/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists) to share them off-chain with the Decentralized Oracle Network. To allow the starter kit to write gists on your behalf, create a [github fine-grained personal access token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token#creating-a-fine-grained-personal-access-token).

    1. Visit [Github tokens settings page](https://github.com/settings/tokens?type=beta).
    2. Click on _Generate new token_.
    3. Provide a name to your token and define the expiration date.
    4. Under `Account permissions`, enable _Read and write_ for Gists. **Note** : Do not enable additional settings.
    5. Click on _Generate token_ and copy your fine-grained personal access token.
  6. Run `npx env-enc set` to add an encrypted `GITHUB_API_TOKEN` and `COINMARKETCAP_API_KEY` to your `.env.enc` file.
    
        npx env-enc set

## Tutorial

Set up your environment variables

This tutorial has some unique `.env.enc` setup steps. Make sure that you
configured your `.env.enc` file with the necessary variables in the Before you
begin section.

This tutorial is configured to get the `BTC/USD` price with a request that
requires API keys. For a detailed explanation of the code example, read the
Explanation section.

  * Open `config.js`. The `args` value is `[""1"", ""USD""]`, which fetches the current `BTC/USD` price. The value of `""1""` is the BTC CoinMarketCap ID. You can change `args` to fetch other asset prices. See the [CoinMarketCap API documentation](https://coinmarketcap.com/api/documentation/v1/) to learn about the available values. Read the request config section for more details about the request config file.
  * Open `source.js` to analyze the JavaScript source code. Read the source code section for more details about the source code file.

### Simulation

The [Chainlink Functions Hardhat Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test Functions code on your local machine. The
`functions-simulate` command executes your code in a local runtime environment
and simulate an end-to-end fulfillment. This helps you fix issues before you
submit functions to a Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/5-use-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    Price: 28272.77 USD
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b240d
    Decoded as a uint256: 2827277
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b240d
    Decoded as a uint256: 2827277
    
    Gas used by sendRequest: 355760
    Gas used by client callback function: 75029

Reading the output of the example above, you can note that the `BTC/USD` price
is _28272.77 USD_. Because Solidity does not support decimals, move the
decimal point so that the value looks like an integer `2827277` before
returning the `bytes` encoded value
`0x00000000000000000000000000000000000000000000000000000000002b240d` in the
callback. Read the source code section for a more details.

### Request

Reminder

Before you can make a successful request, you must complete the setup steps in
the Before you begin section. Each tutorial is in a separate Git branch and
some require unique entries in your `.env.enc` file.

Send a request to the Decentralized Oracle Network to fetch the asset price.
Run the `functions-request` task with the `subid` (subscription ID) and
`contract` parameters. This task passes the functions JavaScript source code,
arguments, and secrets to the `executeRequest` function in your deployed
`FunctionsConsumer` contract. Read the functionsConsumer section for more
details about the consumer contract.


    npx hardhat functions-request --subid REPLACE_SUBSCRIPTION_ID --contract REPLACE_CONSUMER_CONTRACT_ADDRESS --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-request --subid 443 --contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea --network polygonMumbai --configpath tutorials/5-use-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    Estimating cost if the current gas price remains the same...
    
    The transaction to initiate this request will charge the wallet (0x9d087fC03ae39b088326b67fA3C788236645b717):
    0.00049769700497697 MATIC, which (using mainnet value) is $0.0005508427833382278
    
    If the request's callback uses all 100,000 gas, this request will charge the subscription:
    0.200148068209448658 LINK
    
    Continue? Enter (y) Yes / (n) No
    y
    Simulating Functions request locally...
    
    __Console log messages from sandboxed code__
    Price: 28264.75 USD
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b20eb
    Decoded as a uint256: 2826475
    
    Successfully created encrypted secrets Gist: https://gist.github.com/aelmanaa/677f0b039b5036d9ab9f09caa7d3ecd5
    
    ⣾ Request 0x958c7b88f2edb0d827e9ca8b5d5e63ee373527a409099983e18a69c16ebc4a24 has been initiated. Waiting for fulfillment from the Decentralized Oracle Network...
    ℹ Transaction confirmed, see https://mumbai.polygonscan.com/tx/0x1cd9edfb6ee3dc6c45038d93a2b146217fd104eb92fe82a1c9203d4f83ced5d6 for more details.
    
    ✔ Request 0x958c7b88f2edb0d827e9ca8b5d5e63ee373527a409099983e18a69c16ebc4a24 fulfilled! Data has been written on-chain.
    
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b20eb
    Decoded as a uint256: 2826475
    
    Actual amount billed to subscription #443:
    ┌──────────────────────┬─────────────────────────────┐
    │         Type         │           Amount            │
    ├──────────────────────┼─────────────────────────────┤
    │  Transmission cost:  │  0.000066649973244399 LINK  │
    │      Base fee:       │          0.2 LINK           │
    │                      │                             │
    │     Total cost:      │  0.200066649973244399 LINK  │
    └──────────────────────┴─────────────────────────────┘
    
    
    Off-chain secrets Gist https://gist.github.com/aelmanaa/677f0b039b5036d9ab9f09caa7d3ecd5 deleted successfully

The example output tells you the following information:

  * The `executeRequest` function was successfully called in the `FunctionsConsumer` contract. The transaction in this example is [0x1cd9edfb6ee3dc6c45038d93a2b146217fd104eb92fe82a1c9203d4f83ced5d6](https://mumbai.polygonscan.com/tx/0x1cd9edfb6ee3dc6c45038d93a2b146217fd104eb92fe82a1c9203d4f83ced5d6).
  * The request ID is `0x958c7b88f2edb0d827e9ca8b5d5e63ee373527a409099983e18a69c16ebc4a24`.
  * The DON successfully fulfilled your request. The total cost was: `0.200066649973244399 LINK`.
  * The consumer contract received a response in `bytes` with a value of `0x00000000000000000000000000000000000000000000000000000000002b20eb`. Decoding it off-chain to `uint256` give you a result: `2826475`.
  * The starter kit created a gist `https://gist.github.com/aelmanaa/677f0b039b5036d9ab9f09caa7d3ecd5` containing the encrypted secrets. This gist is shared with the DON when making the request.
  * After request fulfillment, the starter kit deleted the gist `https://gist.github.com/aelmanaa/677f0b039b5036d9ab9f09caa7d3ecd5`.

At any time, you can run the `functions-read` task with the `contract`
parameter to read the latest received response.


    npx hardhat functions-read  --contract REPLACE_CONSUMER_CONTRACT_ADDRESS --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-read  --contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea  --network polygonMumbai --configpath tutorials/5-use-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    Reading data from Functions client contract 0x4B4BA2Fd6b93aDF8d6b6002E10540E58394388Ea on network mumbai
    
    On-chain response represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b20eb
    Decoded as a uint256: 2826475

## Explanation

### FunctionsConsumer.sol

  * To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol). You can read the API reference: [FunctionsClient](/chainlink-functions/api-reference/FunctionsClient).

This contract is not available in an NPM package, so you must download and
import it from within your project.

    
        import {Functions, FunctionsClient} from ""./dev/functions/FunctionsClient.sol"";

  * Use the [Functions.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/Functions.sol) library to get all the functions needed for building a Chainlink Functions request. You can read the API reference: [Functions](/chainlink-functions/api-reference/Functions).
    
        using Functions for Functions.Request;
    

  * The latest request id, latest received response, and latest received error (if any) are defined as state variables. Note `latestResponse` and `latestError` are encoded as dynamically sized byte array `bytes`, so you will still need to decode them to read the response or error:
    
        bytes32 public latestRequestId;
    bytes public latestResponse;
    bytes public latestError;

  * We define the `OCRResponse` event that your smart contract will emit during the callback
    
        event OCRResponse(bytes32 indexed requestId, bytes result, bytes err);

  * Pass the oracle address for your network when you deploy the contract:
    
        constructor(address oracle) FunctionsClient(oracle)

  * At any time, you can change the oracle address by calling the `updateOracleAddress` function.

  * The two remaining functions are:

    * `executeRequest` for sending a request. It receives the JavaScript source code, encrypted secrets, list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

      * It uses the `Functions`library to initialize the request and add any passed encrypted secrets or arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/Functions/#initializerequest), [adding secrets](/chainlink-functions/api-reference/Functions/#addinlinesecrets), and [adding arguments](/chainlink-functions/api-reference/Functions/#addargs).
            
                        Functions.Request memory req;
            req.initializeRequest(Functions.Location.Inline, Functions.CodeLanguage.JavaScript, source);
            if (secrets.length > 0) {
              req.addRemoteSecrets(secrets);
            }
            if (args.length > 0) req.addArgs(args);

      * It sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Finally, it stores the request id in `latestRequestId`.
            
                        bytes32 assignedReqID = sendRequest(req, subscriptionId, gasLimit);
            latestRequestId = assignedReqID;

    * `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `latestResponse` and `latestError` before emitting the `OCRResponse` event.
        
                latestResponse = response;
        latestError = err;
        emit OCRResponse(requestId, response, err);

### config.js

Read the [Request
Configuration](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) section for a detailed description of each setting. In
this example, the settings are the following:

  * `codeLocation: Location.Inline`: The JavaScript code is provided within the request.
  * `codeLanguage: CodeLanguage.JavaScript`: The source code is developed in the JavaScript language.
  * `source: fs.readFileSync(path.resolve(__dirname, ""source.js"")).toString()`: The source code must be a script object. This example uses `fs.readFileSync` to read `source.js` and calls `toString()` to get the content as a `string` object.
  * `secrets: { apiKey: process.env.COINMARKETCAP_API_KEY }`: JavaScript object which contains secret values. These secrets are encrypted using the DON public key. The `process.env.COINMARKETCAP_API_KEY` setting means `COINMARKETCAP_API_KEY` is fetched from the environment variables. **Note** : `secrets` is limited to a key-value map that can only contain strings. It cannot include any other types or nested parameters.
  * `walletPrivateKey: process.env[""PRIVATE_KEY""]`: This is your EVM account private key. It is used to generate a signature for the encrypted secrets such that an unauthorized third party cannot reuse them.
  * `args: [""1"", ""USD""]`: These arguments are passed to the source code. In this example, request the `BTC/USD` price. The value of `""1""` is the BTC ID for CoinMarketCap. You can adapt `args` to fetch other asset prices. Read the [CoinMarketCap API documentation](https://coinmarketcap.com/api/documentation/v1/) to see what options are available.
  * `expectedReturnType: ReturnType.uint256`: The response received by the DON is encoded in `bytes`. Because the asset price is a `uint256`, define `ReturnType.uint256` to inform users how to decode the response received by the DON.

### source.js

To check the expected API response, run the `curl` command in your terminal:


    curl -X 'GET' \
      'https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?id=1&convert=USD' \
      -H 'accept: application/json' \
      -H 'X-CMC_PRO_API_KEY: REPLACE_WITH_YOUR_API_KEY'

The response should be similar to the following example:


    {
      ...,
      ""data"": {
        ""1"": {
          ""id"": 1,
          ""name"": ""Bitcoin"",
          ""symbol"": ""BTC"",
          ""slug"": ""bitcoin"",
          ...,
          ""quote"": {
            ""USD"": {
              ""price"": 23036.068560170934,
              ""volume_24h"": 33185308895.694683,
              ""volume_change_24h"": 24.8581,
              ""percent_change_1h"": 0.07027098,
              ""percent_change_24h"": 1.79073805,
              ""percent_change_7d"": 10.29859656,
              ""percent_change_30d"": 38.10735851,
              ""percent_change_60d"": 39.26624921,
              ""percent_change_90d"": 11.59835416,
              ""market_cap"": 443982488416.99316,
              ""market_cap_dominance"": 42.385,
              ""fully_diluted_market_cap"": 483757439763.59,
              ""tvl"": null,
              ""last_updated"": ""2023-01-26T18:27:00.000Z""
            }
          }
        }
      }
    }

The price is located at `data,1,quote,USD,price`.

Read the [JavaScript code](https://github.com/smartcontractkit/functions-hardhat-starter-kit#javascript-code) section for a detailed explanation of how
to write a compatible JavaScript source code. This JavaScript source code uses
[Functions.makeHttpRequest](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) to make HTTP requests. If you read the
[Functions.makeHttpRequest](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-library) documentation, you can see the
following required parameters:

  * `url`: `https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest`

  * `headers`: This is an HTTP headers object set to `{ ""X-CMC_PRO_API_KEY"": secrets.apiKey }`. The `apiKey` is defined in the request config file.

  * `params`: The query parameters object:
    
        {
      convert: currencyCode,
      id: coinMarketCapCoinId
    }

Note `currencyCode` and `coinMarketCapCoinId` are fetched from `args` (see
request config).

The code is self-explanatory and has comments to help you understand all the
steps. The main steps are:

  * Construct the HTTP object `coinMarketCapRequest` using `Functions.makeHttpRequest`.
  * Make the HTTP call.
  * Read the asset price from the response.
  * Return the result as a [buffer](https://nodejs.org/api/buffer.html#buffer) using the helper function: `Functions.encodeUint256`. Note: Because solidity doesn't support decimals, we multiply the result by `100` and round the result to the nearest integer. **Note** : Read this [article](https://www.freecodecamp.org/news/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8/) if you are new to Javascript Buffers and want to understand why they are important.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/tutorials/api-use-secrets.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of disallowing local network and multicast IPs by default in HTTPGet?,"For security, because the URL can come from an untrusted source, HTTPGet imposes some restrictions on which IPs may be fetched. Local network and multicast IPs are disallowed by default and attempting to connect will result in an error.",{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/'},"The purpose of disallowing local network and multicast IPs by default in HTTPGet is for security reasons. It is to prevent connections to local/private and multicast networks, which could present a security risk. However, it is possible to enable these connections by modifying the configuration, specifically by setting the ""allowUnrestrictedNetworkAccess"" flag to true in the HTTP task. This flag permits the task to access a URL at localhost. Please refer to the Chainlink documentation for more information on configuring the HTTP task. 
","
- https://stackoverflow.com/questions/70022029/how-to-enable-local-bridge-httpget-task-api-connection-to-chainlink-node","Question: (Asked on: 2022-12-16 18:52:48)
Testing Chainlink API calls using Hardhat
URL: https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat

Question Body:


I am having trouble testing Chainlink API calls locally. I have a contract
which calls my API consumer contract to make an API call. However, when I try
to do that, the MockOracle (mocked oracle for local testing, from chainlink)
contract reverts (VM exception) saying ""Must use whitelisted functions"". I am
making an API call for a bytes32 get request.

This is the function modifier (inside of LinkTokenReceiver) where the
MockOracle reverts (it gets called by the MockOracle when receiving LINK
tokens):

    
    
    /**
       * @dev Reverts if the given data does not begin with the `oracleRequest` function selector
       * @param _data The data payload of the request
       */
      modifier permittedFunctionsForLINK(bytes memory _data) {
        bytes4 funcSelector;
        assembly {
          // solhint-disable-next-line avoid-low-level-calls
          funcSelector := mload(add(_data, 32))
        }
        require(funcSelector == ORACLE_REQUEST_SELECTOR, ""Must use whitelisted functions"");
        _;
      }
    

The ApiConsumer is properly funded, and the LINK token is a local deployment
of the chainlink Token. So, what am I doing wrong? Or what is the best way to
test Chainlink API calls (bytes32 get request) locally using hardhat?



Answers:
(Answered on: 2023-03-04 12:21:04)


If you are testing locally the chainlink node will not be able to detect any
requests.  
You have a few options:

  1. Deploy your APIConsumer contract to a testnet and make use of an already deployed operator contract. A list can be found on chainlinks website [https://docs.chain.link/any-api/testnet-oracles/]. Then select a jobId for a node job that can provide the API data you need e.g. bytes32, Int, multi words etc. The jobId can be specified in your APIConsumer contract.
  2. Deploy your own operator contract, setup your own node (chainlink has an option for setting up temporary development nodes), and then create a custom job for your API. You will then need to put you node address as an authorised sender in your operator contract to permit data to be returned from your node.
  3. For local testing you will need to write a function in your test script that sends a mock response to your mock operator contract. Make sure you setAuthorisedSenders for the account you use to send the fulfillOracleRequest transaction, to test properly I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:

    
    
      modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata _data) {
        require(_data.length >= 32, ""Response must be > 32 bytes""); 
        bytes memory firstDataWord = new bytes(32);
        for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript snippet for test script 
    //If local network - Set Authorised senders on Mock Oracle to account[1]
        const [owner, mockNode] = await ethers.getSigners();
        const mockNodeAccount = mockNode.address
        await mockOracle.setAuthorizedSenders([mockNodeAccount])
        
        
        const transaction: ContractTransaction = await apiConsumer.requestWithWords(ANY_ARGS_FOR_API)
        const transactionReceipt: ContractReceipt = await transaction.wait(1)
        const requestId = transactionReceipt.events[0].topics[1]
    
        const apiFilter = apiConsumer.filters.ChainlinkRequested()
        const apiEvents = await apiConsumer.queryFilter(apiFilter)
        console.log(apiEvents)
    
        const filter = mockOracle.filters.OracleRequest()
        const events = await mockOracle.queryFilter(filter)
        const {specId, requester, requestIdEvent, payment, callbackAddr, callbackFunctionId, cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
    
        const encodeRequestId = web3.eth.abi.encodeParameters(
            ['bytes32'],
            [requestId])
            
        await mockOracle.connect(mockNode).fulfillOracleRequest2(requestIdfirst, payment, callbackAddr, callbackFunctionId, cancelExpiration, encodeMwr)

To improve on this you could then look to add an API http GET call into your
test script for getting the rest of the callback data for fulfillOracleRequest
or fulfillOracleRequest2 function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I am guessing you are currently using the `oracle.sol` and
`ChainlinkClient.sol` in version v0.6. In version v0.6, AFAIK, ChainlinkClient
doesn't not help users to add function selector `oracleRequest` in the users'
Chainlink request, which means you will get the error if you doesn't manually
add the function selector in your request. In v0.7, ChainlinkClient helps you
add the selector in the request. Just check the function
`sendChainlinkRequestTo` in [ChainlinkClient
v0.6](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/ChainlinkClient.sol)
and [ChainlinkClient
v0.7](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/ChainlinkClient.sol)
by yourself.

Solutions:

  1. Use the v0.7 ChainlinkClient and [operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)(smart contract oracle.sol is renamed as operator.sol in v0.7) for your test. The document can be found [here](https://docs.chain.link/any-api/get-request/examples/single-word-response).
  2. There is a repo called [hardhat-starter-kit](https://github.com/smartcontractkit/hardhat-starter-kit) in Chainlink official github, there are sample codes you can try. Or you can directly use starterkit to test AnyApi and any other services.





:::NEXT DOC:::

Question: (Asked on: 2022-01-02 16:18:48)
Ethereum Chainlink HTTP Get not pinging my HTTP endpoint
URL: https://stackoverflow.com/questions/70557627/ethereum-chainlink-http-get-not-pinging-my-http-endpoint

Question Body:


I am attempting to have my Ethereum smart contract connect to an external HTTP
endpoint using Chainlink. Following along with Chainlink's documentation
(<https://docs.chain.link/docs/advanced-tutorial/>) I deployed this contract
onto the Rinkeby testnet.

    
    
    pragma solidity ^0.8.7;
    
    import ""github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ChainlinkClient.sol"";
    
    // MyContract inherits the ChainlinkClient contract to gain the
    // functionality of creating Chainlink requests
    
    
    contract getHTTP is ChainlinkClient {
      using Chainlink for Chainlink.Request;
    
      bytes32 private thisDoesNotWork;
      address private owner;
      address private ORACLE_ADDRESS = 0x718Cc73722a2621De5F2f0Cb47A5180875f62D60;
      bytes32 private JOBID = stringToBytes32(""86b489ec4d84439c96181a8df7b22223"");
      string private url = ""<myHTTPAddressAsString>""; 
    
    // This endpoint URL is hard coded in my contract, and stored as a string (as in the example code). 
    // I control it and can have it reply with whatever I want, which might be an issue, returning data in a format that the oracle rejects
    
      uint256 constant private ORACLE_PAYMENT = 100000000000000000;
    
      constructor() public {
        // Set the address for the LINK token for the network
        setPublicChainlinkToken();
        owner = msg.sender;
      }
    
      function requestBytes() 
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(JOBID, address(this), this.fulfill.selector);
        req.add(""get"", url);
        sendChainlinkRequestTo(ORACLE_ADDRESS, req, ORACLE_PAYMENT);
      }
    
      function fulfill(bytes32 _requestId, bytes32 recVal)
        public
        recordChainlinkFulfillment(_requestId)
      {
        thisDoesNotWork = recVal;
      }
      function cancelRequest(
        bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunctionId,
        uint256 _expiration
      )
        public
        onlyOwner
      {
        cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);
      }
    
      
      // withdrawLink allows the owner to withdraw any extra LINK on the contract
      function withdrawLink()
        public
        onlyOwner
      {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
      }
      
      modifier onlyOwner() {
        require(msg.sender == owner);
        _;
      }
      
       // A helper funciton to make the string a bytes32
      function stringToBytes32(string memory source) private pure returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
          return 0x0;
        }
        assembly { // solhint-disable-line no-inline-assembly
          result := mload(add(source, 32))
        }
      }
    }
    

I found a node on the Chainlink market
(<https://market.link/jobs/529c7194-c665-4b30-8d25-5321ea49d9cc>) that is
currently active on rinkeby (according to Etherscan it has been active within
the past 3 days and presumably still working).

I deploy the contract and fund the contract with LINK. I call the
requestBytes() function through remix and everything works as expected.
Metamask pays the gas, the LINK is removed from my contract, I get a
transaction hash, and no errors.

However, my endpoint never logs a request attempt, the oracle never lists a
transaction on its Etherscan page, and my data is not present.

I have attempted to use other jobs from the Chainlink market with similar
outcomes.

I have also attempted to use other HTTP endpoints, like the ones from the
Chainlink examples, with similar outcomes, however I doubt this is the issue,
since it appears the HTTP request is never even getting called (as referenced
by the fact that my HTTP endpoint does not log the request)

Without an error message, and being new to Web3 dev, I am not sure where to
start debugging. I found this comment on Github:
<https://github.com/smartcontractkit/documentation/issues/513> and implemented
the suggestion here without luck.

I also found this: [Chainlink - Job not being
fulfilled](https://stackoverflow.com/questions/67880818/chainlink-job-not-
being-fulfilled) but this was not helpful either.

My current considerations for where the error might be:

  1. The oracles are whitelisted and reject my request outright. Have considered creating my own node but want to avoid if possible at this stage.

  2. I have an type error in how I am formatting the request in my contract, like the example in the GitHub exchange I found and referenced above.

EDIT: I am also open to other options beyond Chainlink to connect my contract
to an HTTP GET endpoint, if anyone has any suggestions. Thanks!



Answers:
(Answered on: 2022-01-08 05:31:43)


I've been working on something similar recently and would suggest you try
using the kovan network and the oracle that chainlink has there. Even more
specifically, I think it would be a good idea to confirm you can get it
working using the api, oracle, and jobid listed in the example on that page
you are following... here:

<https://docs.chain.link/docs/advanced-tutorial/#contract-example>

Once you get that example working, then you can modify it for your usage. The
jobid in that tutorial is for returning a (multiplied) uint256... which, for
your API, I think is not what you want as you are wanting bytes32 it sounds
like... so when you try to use it with your API that returns bytes32 the jobid
would be: 7401f318127148a894c00c292e486ffd as seen here:

<https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/>

Another thing that might be your issue, is your api. You say you control what
it returns... I think it might have to return a response in bytes format, like
Patrick says in his response (and his comments on his response) here:

[Get a string from any API using Chainlink Large Response
Example](https://stackoverflow.com/questions/69474890/get-a-string-from-any-
api-using-chainlink-large-response-example)

Hope this is helpful. If you cannot get the example in the chainlink docs to
work, let me know.





:::NEXT DOC:::

Question: (Asked on: 2021-12-06 12:19:59)
How do I extend the context deadline?
URL: https://stackoverflow.com/questions/70245412/how-do-i-extend-the-context-deadline

Question Body:


I am running a job which fetches data from an API. Sometimes the request fails
with

`error making http request: Get
""http://XXX/0xFA103c21ea2DF71DFb92B0652F8B1D795e51cdEf"": context deadline
exceeded`

[Error Screenshot](https://i.stack.imgur.com/IrGMz.png)

Is there a way I could extend the deadline? I tried adding `maxTaskDuration`
and `timeout`, that doesn't seem to be working either. This is the part of my
job description fetching requests -

    
    
    schemaVersion = 1
    name = ""score multiple""
    contractAddress = ""0x502B4BadDe549E5338676bF9caF9C415463A4c74""
    maxTaskDuration = ""5m0s""
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=""cborparse"" data=""$(decode_log.data)""]
        fetch        [type=""http"" method=GET url=""$(decode_cbor.get)"" timeout=""300s""]
    



Answers:
(Answered on: 2021-12-06 13:37:41)


Solved by updating `DEFAULT_HTTP_TIMEOUT` in `.env`

refrence: <https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

Question: (Asked on: 2021-11-18 14:56:42)
how to enable local bridge/httpget/task api connection to chainlink node?
URL: https://stackoverflow.com/questions/70022029/how-to-enable-local-bridge-httpget-task-api-connection-to-chainlink-node

Question Body:


I have a custom API running on <http://127.0.0.1:8080> and I have my own
chainlink node running on <http://127.0.0.1:6688>. I get the error saying
""Connections to local/private and multicast networks are disabled by default
for security reasons: disallowed IP"" when sending requests.

I guess maybe we can enable it by modifying the env file, but I don't know
which configuration should I change. Does anyone know if we can enable these
local/private connections? and how to do that?



Answers:
(Answered on: 2021-11-20 17:32:25)


Per the [chainlink docs on the http
task](https://docs.chain.link/docs/jobs/task-types/http/):

> allowUnrestrictedNetworkAccess (optional): permits the task to access a URL
> at localhost, which could present a security risk. Note that Bridge tasks
> allow this by default.

ie:

    
    
    my_http_task [type=""http""
                  method=PUT
                  url=""http://chain.link""
                  requestData=""{\\""foo\\"": $(foo), \\""bar\\"": $(bar), \\""jobID\\"": 123}""
                  allowUnrestrictedNetworkAccess=true
                  ]
    

You can also use this flag in JSON



"
What is the purpose of the Proof of Reserve feeds mentioned in the text?,"The Proof of Reserve feeds are used to attest to the reserves held by various assets, including US Dollar, Gold, Staked ETH, Bitcoin, and Wrapped Filecoin, among others.",{'source': 'https://docs.chain.link/data-feeds/proof-of-reserve/addresses/'},"The purpose of the Proof of Reserve feeds mentioned in the text is to provide the status of reserves for several assets. These feeds can be used to verify the reserves of both off-chain assets and cross-chain assets. The feeds provide data attestation variations and help highlight the inherent market risks surrounding the data quality of these feeds. The Proof of Reserve feeds can be read in the same way as other Data Feeds, by specifying the Proof of Reserve Feed Address. The feeds can be used to drive breakthroughs in various areas such as cancer, Alzheimer's, and diabetes. It is important to carefully review the quality of the data and assume full responsibility for any loss caused by the use of these feeds.

",https://docs.chain.link/data-feeds/proof-of-reserve/,"# Proof of Reserve Feeds

  * Overview
  * Types of Proof of Reserve Feeds
  * Off-chain reserves
  * Cross-chain reserves
  * Using Proof of Reserve Feeds

Chainlink Proof of Reserve Feeds provide the status of the reserves for
several assets. You can read these feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

To find a list of available Proof of Reserve Feeds, see the [Proof of Reserve
Feed Addresses](/data-feeds/proof-of-reserve/addresses) page.

## Types of Proof of Reserve Feeds

Reserves are available for both cross-chain assets and off-chain assets. This
categorization describes the data attestation variations of Proof of Reserve
feeds and helps highlight some of the inherent market risks surrounding the
data quality of these feeds.

Reserves are available for both off-chain assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
  * ⚠️ Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

### Cross-chain reserves

Cross-chain reserves are sourced from the network where the reserves are held.
Chainlink node operators can report cross-chain reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of funding smart contracts with LINK or ETH?,Some smart contracts require funding at their addresses so they can operate without you having to call functions manually and pay for the transactions through MetaMask.,{'source': 'https://docs.chain.link/resources/fund-your-contract/'},"The purpose of funding smart contracts with LINK or ETH is to ensure that the contract has the necessary tokens to perform certain functions or transactions. This can include paying fees for using Chainlink services, such as the VRF (Verifiable Random Function) oracles, or interacting with other contracts that require LINK or ETH as payment. There are different ways to fund a smart contract, including pre-funding the contract with tokens before deployment, having a process that periodically funds the contract externally, or using meta-transactions where the contract is funded by an external entity. It is important to ensure that the smart contract has enough tokens to perform its intended functions.

","
- https://docs.chain.link/getting-started/conceptual-overview/
- https://stackoverflow.com/questions/71902735/how-to-reference-link-token-on-forked-development-network-without-invalid-opc
- https://stackoverflow.com/questions/69576173/is-this-how-how-i-should-implement-the-vrf-random-nft-traits-using-chainlink
- https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically","# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-04-17 14:30:53)
How to reference LINK token on (forked) development network without &quot;invalid opcode&quot;?
URL: https://stackoverflow.com/questions/71902735/how-to-reference-link-token-on-forked-development-network-without-invalid-opc

Question Body:


I like to run a number of local tests. Everything works well on `rinkeby` and
other test chains. However, the local `development` chain disagrees with my
configuration. When I run a forked development network:

    
    
    brownie console --network mainnet-fork
    

The ganache-cli initiates as expected:

    
    
    Brownie v1.18.1 - Python development framework for Ethereum
    
    BlockchainProject is the active project.
    
    Launching 'ganache-cli --accounts 10 --hardfork istanbul --fork https://mainnet.infura.io/v3/6a633a4ecae8449abbc69974cdd3a9b9 --gasLimit 12000000 --mnemonic brownie --port 8545 --chainId 1'...
    Brownie environment is ready.
    

However, even the most simple contract interaction fails:

    
    
    >>> link_token = Contract.from_explorer(""0x514910771AF9Ca656af840dff83E8264EcF986CA"")
    Fetching source of 0x514910771AF9Ca656af840dff83E8264EcF986CA from api.etherscan.io...
    >>> accounts[0].balance()
    100000000000000000000
    >>> accounts[1].balance()
    100000000000000000000
    >>> link_token.transfer(accounts[0].address, 100, {'from': accounts[0].address})
    Transaction sent: 0x1542b679e4d09b2f4523427c7f5048ed01ee0d194c34cd27b82bbd177e1b3f23
      Gas price: 0.0 gwei   Gas limit: 12000000   Nonce: 2
      LinkToken.transfer confirmed (invalid opcode)   Block: 14604608   Gas used: 12000000 (100.00%)
    
    <Transaction '0x1542b679e4d09b2f4523427c7f5048ed01ee0d194c34cd27b82bbd177e1b3f23'>
    

Since the Link token is compiled with an unsupported compiler I do not get any
further information on why this results in `LinkToken.transfer confirmed
(invalid opcode)`.

How do I (correctly) run chainlink code against a forked `development` network
using brownie - am I missing a step such as funding??

My `networks:` configuration in `brownie-config.yaml`:

    
    
    networks:
      mainnet-fork:
        vrf_coordinator: '0xf0d54349aDdcf704F77AE15b96510dEA15cb7952'
        link_token: '0x514910771AF9Ca656af840dff83E8264EcF986CA'
        keyhash: '0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445'
    

I did try to `rm -rf build` but that does not change anything.

System environment:

  * Brownie v1.18.1
  * Node 8.5.5
  * Ganache v7.0.4
  * 21.3.0 Darwin Kernel Version (macOS 12.2.1)
  * Python 3.9.7



Answers:
(Answered on: 2022-04-17 20:44:28)


In this instance, the account used for Link token funding does not have any
Link. For some reason, the transaction does not get reverted but the `unlock:`
option of `brownie` provides assistance.

First adjusting the `networks:`settings to include an arbitrary account with a
large Link balance:

    
    
      mainnet-fork:
        cmd_settings:
          unlock:
            - 0xf37c348b7d19b17b29cd5cfa64cfa48e2d6eb8db
        vrf_coordinator: '0xf0d54349aDdcf704F77AE15b96510dEA15cb7952'
        link_token: '0x514910771AF9Ca656af840dff83E8264EcF986CA'
        keyhash: '0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445'
    

Second, run a mainnet-fork as before:

    
    
    brownie console --network mainnet-fork
    

Third, confirm that the unlocked account is available and funded:

    
    
    >>> accounts[10]
    <Account '0xF37C348B7d19b17B29CD5CfA64cfA48E2d6eb8Db'>
    >>> accounts[10].balance()
    426496436000000000
    

Fourth, instantiate the contract of the token, Link in this instance:

    
    
    link_token = Contract.from_explorer(""0x514910771AF9Ca656af840dff83E8264EcF986CA"")
    

Finally, transfer Link from the unlocked account to some other account (or
contract):

    
    
    link_token.transfer(accounts[0], 20, {""from"": accounts[10]})
    

Alternatively, funding the mainnet address with Link, or even unlocking the
Link owner and minting new Link would work too...





:::NEXT DOC:::

Question: (Asked on: 2021-10-14 19:11:35)
Is this how how I should implement the VRF random NFT traits using chainlink?
URL: https://stackoverflow.com/questions/69576173/is-this-how-how-i-should-implement-the-vrf-random-nft-traits-using-chainlink

Question Body:


I was able to implement an ERC-1155 random mint on Polygon with the help of
Chainlink VRF (to get the random number), Price Feeds (to query the MATIC/LINK
price), Quickswap (to buy the 0.0001 link fee), PegSwap (to turn the LINK into
ERC-677 LINK). I tested it and it's working fine. However I don't know if this
is the recommended approach or if I'm missing something. I would appreciate
any opinions or recommendations.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity 0.8.9;
    
    import ""@openzeppelin/contracts/token/ERC1155/ERC1155.sol"";
    import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract Router {
        function swapETHForExactTokens(
            uint amountOut,
            address[] calldata path,
            address to,
            uint deadline
        ) external payable returns (uint[] memory amounts) {}
    }
    
    contract PegSwap {
        function swap(
            uint256 amount,
            address source,
            address target
        ) external {}
    }
    
    contract MyNFT is ERC1155, VRFConsumerBase {
        uint256 SLIPPAGE_PERCENTAGE = 20;
        address CREATOR = 0x0000000000000000000000000000000000000000;
        uint256 public PRICE = 0.1 ether;
    
        bytes32 VRF_KEYHASH = 0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;
        uint256 VRF_FEE = 0.0001 ether;
        address VRF_COORDINATOR = 0x3d2341ADb2D31f1c5530cDC622016af293177AE0;
    
        Router quickswap = Router(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);
        PegSwap peg_swap = PegSwap(0xAA1DC356dc4B18f30C347798FD5379F3D77ABC5b);
        ERC20 WMATIC_token  = ERC20(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);
        ERC20 LINK_token  = ERC20(0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39);
        ERC20 LINK_ERC677_token  = ERC20(0xb0897686c545045aFc77CF20eC7A532E3120E0F1);
        AggregatorV3Interface MATIC_LINK_price_feed = AggregatorV3Interface(0x5787BefDc0ECd210Dfa948264631CD53E68F7802);
    
        mapping(bytes32  => address) public sender_request_ids;
    
        constructor()
            ERC1155(""https://YOURURL/{id}.json"")
            VRFConsumerBase(
                VRF_COORDINATOR,
                address(LINK_token)
            )
        {
        }
    
        function mintNFT(address to) public payable
        {
            require(msg.value >= PRICE, ""Value below price"");
            swapMATICToLINK();
            sender_request_ids[requestRandomness(VRF_KEYHASH, VRF_FEE)] = to;
        }
    
        function swapMATICToLINK() public payable
        {
            address[] memory path = new address[](2);
            path[0] = address(WMATIC_token);
            path[1] = address(LINK_token);
    
            quickswap.swapETHForExactTokens{value: getMaticPrice() * VRF_FEE * (100+SLIPPAGE_PERCENTAGE) / 100}(
                VRF_FEE,
                path,
                address(this),
                block.timestamp
            );
            LINK_token.approve(address(peg_swap), VRF_FEE);
            peg_swap.swap(
                VRF_FEE,
                address(LINK_token),
                address(LINK_ERC677_token)
            );
        }
    
        function getMaticPrice() public view returns (uint) {
            (
                uint80 roundID, 
                int price,
                uint startedAt,
                uint timeStamp,
                uint80 answeredInRound
            ) = MATIC_LINK_price_feed.latestRoundData();
            roundID;
            startedAt;
            timeStamp;
            answeredInRound;
            return uint(price);
        }
    
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            uint token_id = randomness % 2 + 1;
            uint amount = 1;
            _mint(sender_request_ids[requestId], token_id, amount, """");
        }
    
        function withdraw() public
        {
            payable(CREATOR).transfer(address(this).balance);
            LINK_token.transfer(payable(CREATOR), LINK_token.balanceOf(address(this)));
            LINK_ERC677_token.transfer(payable(CREATOR), LINK_ERC677_token.balanceOf(address(this)));
        }
    }
    



Answers:
(Answered on: 2021-10-15 05:17:32)


Why don't you save yourself some trouble and just pre-fund the contract with
link once its deployed?





:::NEXT DOC:::

Question: (Asked on: 2021-05-09 12:01:16)
How to make a Smart Contract purchase LINK (or other ERC20) tokens automatically?
URL: https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically

Question Body:


I am trying to interact with the Chainlink VRF function.

I have a Coordinator contract that needs random numbers to draw cards out of a
deck. The Coordinator calls a Random Number Generation Oracle that implements
Chainlink's VRFConsumerBase contract.

I want my Coordinator/Oracle to purchase LINK tokens automatically using the
Ether that the user sent for the draw price so that it can always provide the
required LINK fee to the VRF function and it does not need a human to manually
top up the contract with LINK.

Is there any working example/tutorial on how one could achieve this? I really
wish to avoid forcing the users of my contract to purchase LINK themselves.

Thanks!



Answers:
(Answered on: 2021-05-09 12:37:13)


A contract itself can't 'automatically have LINK transferred to it', because
to transfer LINK from one account to another, the owner of the LINK must be
the one that signs the transaction, however, there are a few other ways to
achieve the end result you're looking for.

1 - Rather than a straight transfer, you can do a swap on a DEX like Uniswap
programatically, ie <https://docs.uniswap.org/protocol/V2/guides/smart-
contract-integration/trading-from-a-smart-contract>

2 - If you know how much LINK will be required for the contract, you can
simply pre-fund it beforehand, or when it's created. Am guessing this isn't
the case for you though.

3 - Do it external to the blockchain. ie you can have a process running that
funds the contract with link every so often, checking if its empty or near
empty

4 - You can make use of meta-transactions so that the people playing the game
don't need any LINK. See [this example](https://github.com/pappas999/Link-Gas-
Station). Take note this still uses an external relayer like I mentioned in
the last point

5 - I've seen examples where others just pay an upfront cost to ensure the
coordinator contracts are well funded with LINK, and then they manually just
top them up as needed, using users deposited eth/funds as a kind of payment to
offset them having to send LINK to the contract.



"
What is the purpose of the `fulfillOracleRequest` function in the Oracle contract?,The `fulfillOracleRequest` function is used by the node to fulfill a request once it has the result of the job. This function returns the result to the `ChainlinkClient` using the callback function defined in the original request.,{'source': 'https://docs.chain.link/architecture-overview/architecture-request-model/'},"The purpose of the `fulfillOracleRequest` function in the Oracle contract is to fulfill a request made by the off-chain oracle node. Once the off-chain oracle node has the result of the job, it uses the `fulfillOracleRequest` function to return the result to the `ChainlinkClient` contract using the callback function defined in the original request. This function is crucial for completing the data retrieval process and providing the requested data to the consumer contract.

","
- https://docs.chain.link/architecture-overview/architecture-request-model/
- https://docs.chain.link/chainlink-functions/resources/architecture/","# Basic Request Model

  * Overview
  * Contracts Overview
  * ChainlinkClient
  * LINK Token
  * Oracle Contract
  * Off-Chain Oracle Node
  * Consumer UML

## Contracts Overview

All source code is open source and available in the [Chainlink Github
repository](https://github.com/smartcontractkit/chainlink).

### ChainlinkClient

[`ChainlinkClient`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol)
is a parent contract that enables smart contracts to consume data from
oracles. It's available in the Chainlink smart contract library which can be
[installed using the latest package managers](/resources/create-a-chainlinked-project).

The client constructs and makes a request to a known Chainlink oracle through
the `transferAndCall` function, implemented by the LINK token. This request
contains encoded information that is required for the cycle to succeed. In the
`ChainlinkClient` contract, this call is initiated with a call to
`sendChainlinkRequestTo`.

To build your own client contract using `ChainlinkClient`, see [Introduction
to Using Any API](/any-api/introduction), or view the [ChainlinkClient API
Reference](/any-api/api-reference) for the `ChainlinkClient` contract.

### LINK Token

LINK is an [ERC-677](https://github.com/ethereum/EIPs/issues/677) compliant
token which implements `transferAndCall`, a function that allows tokens to be
transferred whilst also triggering logic in the receiving contract within a
single transaction.

Learn more about [ERC-677 and the LINK token](/resources/link-token-contracts).

### Oracle Contract

[`Oracle`
contracts](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/Oracle.sol)
are owned by oracle node operators, which run alongside off-chain oracle
nodes.

#### Request

The client contract that initiates this cycle must create a request with the
following items:

  * The oracle address.
  * The job ID, so the oracle knows which tasks to perform.
  * The callback function, which the oracle sends the response to.

To learn about how to find oracles to suit your needs, see [Find Existing
Jobs](/any-api/find-oracle).

Oracle contracts are responsible for handling on-chain requests made through
the LINK token, by implementing `onTokenTransfer` as a
[`LinkTokenReceiver`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/LinkTokenReceiver.sol).
Upon execution of this function, the oracle contract **emits an`OracleRequest`
event** containing information about the request. This event is crucial, as it
is monitored by the off-chain oracle node which acts upon it.

#### Fulfillment

For fulfillment, the oracle contract has a `fulfillOracleRequest` function
which is used by the node to fulfill a request once it has the result of the
job. This function returns the result to the `ChainlinkClient` using the
callback function defined in the original request.

### Off-Chain Oracle Node

The off-chain oracle node is responsible for listening for events emitted by
its corresponding on-chain smart contract. Once it detects an `OracleRequest`
event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API,
retrieve some data from it, parse the response, convert the result into
blockchain compatible data, then submit it in a transaction back to the oracle
contract, using the `fulfillOracleRequest` function.

For more information on how to become a node operator, learn how to [run a
Chainlink node](/chainlink-nodes/v1/running-a-chainlink-node).

## Consumer UML

Below is a UML diagram describing the contract structure of
`ATestnetConsumer`, a deployed example contract implementing
`ChainlinkClient`.

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-request-model.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates with the _Functions Billing Registry_ , which
assigns a unique identifier (aka _Subscription ID_ ).

### Fund Subscription

You must fund your subscription accounts with enough LINK tokens:

  1. Connect your EOA to the _Subscription App_.
  2. Fund your subscription account. The _Subscriptions App_ abstracts the following: 
    1. Call `transferAndCall` on the LINK token contract, transferring LINK tokens along with the _Subscription ID_ in the payload.
    2. The _Functions Billing Registry_ contract implements `onTokenTransfer`: It parses the _Subscription ID_ from the payload and funds the subscription account with the transferred LINK amount.

### Add Consumer

You must allowlist your consumers' contracts on your subscription account
before they can make Chainlink Functions requests. To do so:

  1. Connect your EOA to the _Subscription App_.
  2. Add the address of your consumer contract to your subscription account.
  3. The _Subscription App_ calls the _Functions Billing Registry_ contract to add the consumer contract address to your subscription account.

### Remove Consumer

To remove a consumer contract:

  1. Connect your EOA to the _Subscription App_.
  2. Remove the address of your consumer contract from the allowlist.
  3. The _Subscription App_ calls the _Functions Billing Registry_ contract to remove the consumer contract address from your subscription account.

**Note** : You can still remove consumers from your subscription if there are
in-flight requests. Your consumer contract will still be called back, and your
_Subscription Account_ will be charged.

### Cancel Subscription

To cancel a subscription:

  1. Connect your EOA to the _Subscription App_.
  2. Cancel your subscription, passing the _Subscription Balance_ receiver account address. The _Subscriptions App_ abstracts the following: 
    1. Call the `cancelSubscription` function on the _Functions Billing Registry_ contract, deleting the _Subscription ID_ and removing any existing consumers.
    2. The outstanding _Subscription Balance_ is sent to the receiver account.

**Note** : You cannot cancel a subscription if there are in-flight requests.

### Transferring ownership of a Subscription

Transferring ownership works as follows:

  1. Connect your EOA to the _Subscription App_.
  2. Initiate the ownership transfer by specifying the new owner's address.
  3. The new owner must connect their EOA to the _Subscription App_ and accept the ownership.

## What's next

  * [› Billing](/chainlink-functions/resources/billing)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/architecture.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-12-16 18:52:48)
Testing Chainlink API calls using Hardhat
URL: https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat

Question Body:


I am having trouble testing Chainlink API calls locally. I have a contract
which calls my API consumer contract to make an API call. However, when I try
to do that, the MockOracle (mocked oracle for local testing, from chainlink)
contract reverts (VM exception) saying ""Must use whitelisted functions"". I am
making an API call for a bytes32 get request.

This is the function modifier (inside of LinkTokenReceiver) where the
MockOracle reverts (it gets called by the MockOracle when receiving LINK
tokens):

    
    
    /**
       * @dev Reverts if the given data does not begin with the `oracleRequest` function selector
       * @param _data The data payload of the request
       */
      modifier permittedFunctionsForLINK(bytes memory _data) {
        bytes4 funcSelector;
        assembly {
          // solhint-disable-next-line avoid-low-level-calls
          funcSelector := mload(add(_data, 32))
        }
        require(funcSelector == ORACLE_REQUEST_SELECTOR, ""Must use whitelisted functions"");
        _;
      }
    

The ApiConsumer is properly funded, and the LINK token is a local deployment
of the chainlink Token. So, what am I doing wrong? Or what is the best way to
test Chainlink API calls (bytes32 get request) locally using hardhat?



Answers:
(Answered on: 2023-03-04 12:21:04)


If you are testing locally the chainlink node will not be able to detect any
requests.  
You have a few options:

  1. Deploy your APIConsumer contract to a testnet and make use of an already deployed operator contract. A list can be found on chainlinks website [https://docs.chain.link/any-api/testnet-oracles/]. Then select a jobId for a node job that can provide the API data you need e.g. bytes32, Int, multi words etc. The jobId can be specified in your APIConsumer contract.
  2. Deploy your own operator contract, setup your own node (chainlink has an option for setting up temporary development nodes), and then create a custom job for your API. You will then need to put you node address as an authorised sender in your operator contract to permit data to be returned from your node.
  3. For local testing you will need to write a function in your test script that sends a mock response to your mock operator contract. Make sure you setAuthorisedSenders for the account you use to send the fulfillOracleRequest transaction, to test properly I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:

    
    
      modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata _data) {
        require(_data.length >= 32, ""Response must be > 32 bytes""); 
        bytes memory firstDataWord = new bytes(32);
        for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript snippet for test script 
    //If local network - Set Authorised senders on Mock Oracle to account[1]
        const [owner, mockNode] = await ethers.getSigners();
        const mockNodeAccount = mockNode.address
        await mockOracle.setAuthorizedSenders([mockNodeAccount])
        
        
        const transaction: ContractTransaction = await apiConsumer.requestWithWords(ANY_ARGS_FOR_API)
        const transactionReceipt: ContractReceipt = await transaction.wait(1)
        const requestId = transactionReceipt.events[0].topics[1]
    
        const apiFilter = apiConsumer.filters.ChainlinkRequested()
        const apiEvents = await apiConsumer.queryFilter(apiFilter)
        console.log(apiEvents)
    
        const filter = mockOracle.filters.OracleRequest()
        const events = await mockOracle.queryFilter(filter)
        const {specId, requester, requestIdEvent, payment, callbackAddr, callbackFunctionId, cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
    
        const encodeRequestId = web3.eth.abi.encodeParameters(
            ['bytes32'],
            [requestId])
            
        await mockOracle.connect(mockNode).fulfillOracleRequest2(requestIdfirst, payment, callbackAddr, callbackFunctionId, cancelExpiration, encodeMwr)

To improve on this you could then look to add an API http GET call into your
test script for getting the rest of the callback data for fulfillOracleRequest
or fulfillOracleRequest2 function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I am guessing you are currently using the `oracle.sol` and
`ChainlinkClient.sol` in version v0.6. In version v0.6, AFAIK, ChainlinkClient
doesn't not help users to add function selector `oracleRequest` in the users'
Chainlink request, which means you will get the error if you doesn't manually
add the function selector in your request. In v0.7, ChainlinkClient helps you
add the selector in the request. Just check the function
`sendChainlinkRequestTo` in [ChainlinkClient
v0.6](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/ChainlinkClient.sol)
and [ChainlinkClient
v0.7](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/ChainlinkClient.sol)
by yourself.

Solutions:

  1. Use the v0.7 ChainlinkClient and [operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)(smart contract oracle.sol is renamed as operator.sol in v0.7) for your test. The document can be found [here](https://docs.chain.link/any-api/get-request/examples/single-word-response).
  2. There is a repo called [hardhat-starter-kit](https://github.com/smartcontractkit/hardhat-starter-kit) in Chainlink official github, there are sample codes you can try. Or you can directly use starterkit to test AnyApi and any other services.



"
What is the purpose of the 'proposedFeed' function?,The 'proposedFeed' function is used to propose a new price feed for a given base and quote currency pair.,{'source': 'https://docs.chain.link/data-feeds/feed-registry/'},"The `getLatestPrice()` function in the contract is a view function that returns the current feed price. However, in the `performUpkeep()` function, there is no code that actually stores or uses the result of `getLatestPrice()`. Therefore, even though the upkeep job is being called, it is not updating the value of the counter variable or performing any other action with the price data.

To update the counter variable or perform any other action with the price data, you need to add code in the `performUpkeep()` function to store or use the result of `getLatestPrice()`. For example, you can store the result in a variable or use it to perform some calculations or logic within the contract.

Here is an example of how you can update the counter variable with the latest price in the `performUpkeep()` function:

```solidity
function performUpkeep(bytes calldata performData) external override {
    lastTimeStamp = block.timestamp;
    counter = counter + 1;
    int latestPrice = getLatestPrice();
    // Perform actions with the latest price data
}
```

Make sure to add the necessary code to handle the price data according to your specific use case.

",https://stackoverflow.com/questions/69923069/chainlink-price-fee-using-keepers,"# Feed Registry

  * Overview
  * Base and Quote
  * Denominations library
  * Code Examples
  * Solidity
  * Solidity Hardhat Example
  * Javascript
  * Contract Addresses

The Chainlink Feed Registry is an on-chain mapping of assets to feeds. It
enables you to query Chainlink data feeds from asset addresses directly,
without needing to know the feed contract addresses. They enable smart
contracts to get the latest price of an asset in a single call, from a single
contract.

Note

The Feed Registry only lists feeds with a canonical token address on a
network. Non-token feeds such as stock indexes are not supported because they
do not have a canonical token address.

For a complete list of functions and parameters for the
`FeedRegistryInterface` contract, see the [Feed Registry API Reference](/data-feeds/feed-registry/feed-registry-functions).

## Base and Quote

The Feed Registry fully supports the
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
API for multiple feeds. It maps feeds from `base` and `quote` address pairs.
To get the latest LINK / USD round data from the registry, call:


    latestRoundData(address base, address quote)

For example, to get the latest LINK / USD price:

  * `base`: The LINK token address on that network e.g. `0x514910771AF9Ca656af840dff83E8264EcF986CA` for LINK on Ethereum mainnet
  * `quote`: A `Denominations.USD` address (`0x0000000000000000000000000000000000000348`), which is based on [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).


    latestRoundData(0x514910771AF9Ca656af840dff83E8264EcF986CA, 0x0000000000000000000000000000000000000348)

To get the latest LINK / ETH price on Ethereum:

  * `base`: The LINK token address on that network e.g. `0x514910771AF9Ca656af840dff83E8264EcF986CA` for LINK on Ethereum mainnet
  * `quote`: A `Denominations.ETH` address (`0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`)


    latestRoundData(0x514910771AF9Ca656af840dff83E8264EcF986CA, 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE)

### Denominations library

A
[`Denominations`](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)
Solidity library is available for you to fetch currency identifiers which lack
a canonical Ethereum address:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    library Denominations {
        address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
        address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;
    
        // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217
        address public constant USD = address(840);
        address public constant GBP = address(826);
        address public constant EUR = address(978);
    
        // ... other fiat currencies
    }
    

## Code Examples

### Solidity

To consume price data from the Feed Registry, your smart contract should
reference
[`FeedRegistryInterface`](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol),
which defines the external functions implemented by the Feed Registry.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/Denominations.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract PriceConsumer {
        FeedRegistryInterface internal registry;
    
        /**
         * Network: Ethereum Mainnet
         * Feed Registry: 0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf
         */
        constructor(address _registry) {
            registry = FeedRegistryInterface(_registry);
        }
    
        /**
         * Returns the ETH / USD price
         */
        function getEthUsdPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = registry.latestRoundData(Denominations.ETH, Denominations.USD);
            return price;
        }
    
        /**
         * Returns the latest price
         */
        function getPrice(address base, address quote) public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = registry.latestRoundData(base, quote);
            return price;
        }
    }
    

### Solidity Hardhat Example

Note

You can find a working Feed Registry Hardhat project
[here](https://github.com/smartcontractkit/feed-registry-example). Clone the
repo and follow the setup instructions to run the example locally.

### Javascript


    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const web3 = new Web3(""https://rpc.ankr.com/eth"")
    const feedRegistryInterfaceABI = [
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: ""address"", name: ""accessController"", type: ""address"" },
          { indexed: true, internalType: ""address"", name: ""sender"", type: ""address"" },
        ],
        name: ""AccessControllerSet"",
        type: ""event"",
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: ""address"", name: ""asset"", type: ""address"" },
          { indexed: true, internalType: ""address"", name: ""denomination"", type: ""address"" },
          { indexed: true, internalType: ""address"", name: ""latestAggregator"", type: ""address"" },
          { indexed: false, internalType: ""address"", name: ""previousAggregator"", type: ""address"" },
          { indexed: false, internalType: ""uint16"", name: ""nextPhaseId"", type: ""uint16"" },
          { indexed: false, internalType: ""address"", name: ""sender"", type: ""address"" },
        ],
        name: ""FeedConfirmed"",
        type: ""event"",
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: ""address"", name: ""asset"", type: ""address"" },
          { indexed: true, internalType: ""address"", name: ""denomination"", type: ""address"" },
          { indexed: true, internalType: ""address"", name: ""proposedAggregator"", type: ""address"" },
          { indexed: false, internalType: ""address"", name: ""currentAggregator"", type: ""address"" },
          { indexed: false, internalType: ""address"", name: ""sender"", type: ""address"" },
        ],
        name: ""FeedProposed"",
        type: ""event"",
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: ""address"", name: ""from"", type: ""address"" },
          { indexed: true, internalType: ""address"", name: ""to"", type: ""address"" },
        ],
        name: ""OwnershipTransferRequested"",
        type: ""event"",
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, internalType: ""address"", name: ""from"", type: ""address"" },
          { indexed: true, internalType: ""address"", name: ""to"", type: ""address"" },
        ],
        name: ""OwnershipTransferred"",
        type: ""event"",
      },
      { inputs: [], name: ""acceptOwnership"", outputs: [], stateMutability: ""nonpayable"", type: ""function"" },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""address"", name: ""aggregator"", type: ""address"" },
        ],
        name: ""confirmFeed"",
        outputs: [],
        stateMutability: ""nonpayable"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""getAccessController"",
        outputs: [{ internalType: ""contract AccessControllerInterface"", name: """", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint256"", name: ""roundId"", type: ""uint256"" },
        ],
        name: ""getAnswer"",
        outputs: [{ internalType: ""int256"", name: ""answer"", type: ""int256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""getCurrentPhaseId"",
        outputs: [{ internalType: ""uint16"", name: ""currentPhaseId"", type: ""uint16"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""getFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""aggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""getNextRoundId"",
        outputs: [{ internalType: ""uint80"", name: ""nextRoundId"", type: ""uint80"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint16"", name: ""phaseId"", type: ""uint16"" },
        ],
        name: ""getPhase"",
        outputs: [
          {
            components: [
              { internalType: ""uint16"", name: ""phaseId"", type: ""uint16"" },
              { internalType: ""uint80"", name: ""startingAggregatorRoundId"", type: ""uint80"" },
              { internalType: ""uint80"", name: ""endingAggregatorRoundId"", type: ""uint80"" },
            ],
            internalType: ""struct FeedRegistryInterface.Phase"",
            name: ""phase"",
            type: ""tuple"",
          },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint16"", name: ""phaseId"", type: ""uint16"" },
        ],
        name: ""getPhaseFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""aggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint16"", name: ""phaseId"", type: ""uint16"" },
        ],
        name: ""getPhaseRange"",
        outputs: [
          { internalType: ""uint80"", name: ""startingRoundId"", type: ""uint80"" },
          { internalType: ""uint80"", name: ""endingRoundId"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""getPreviousRoundId"",
        outputs: [{ internalType: ""uint80"", name: ""previousRoundId"", type: ""uint80"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""getProposedFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""proposedAggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" },
        ],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""getRoundFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""aggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint256"", name: ""roundId"", type: ""uint256"" },
        ],
        name: ""getTimestamp"",
        outputs: [{ internalType: ""uint256"", name: ""timestamp"", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""address"", name: ""aggregator"", type: ""address"" }],
        name: ""isFeedEnabled"",
        outputs: [{ internalType: ""bool"", name: """", type: ""bool"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""latestAnswer"",
        outputs: [{ internalType: ""int256"", name: ""answer"", type: ""int256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""latestRound"",
        outputs: [{ internalType: ""uint256"", name: ""roundId"", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""latestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""latestTimestamp"",
        outputs: [{ internalType: ""uint256"", name: ""timestamp"", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""owner"",
        outputs: [{ internalType: ""address"", name: """", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""address"", name: ""aggregator"", type: ""address"" },
        ],
        name: ""proposeFeed"",
        outputs: [],
        stateMutability: ""nonpayable"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""proposedGetRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""id"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""proposedLatestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""id"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""contract AccessControllerInterface"", name: ""_accessController"", type: ""address"" }],
        name: ""setAccessController"",
        outputs: [],
        stateMutability: ""nonpayable"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""address"", name: ""to"", type: ""address"" }],
        name: ""transferOwnership"",
        outputs: [],
        stateMutability: ""nonpayable"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""typeAndVersion"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""pure"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf""
    const feedRegistry = new web3.eth.Contract(feedRegistryInterfaceABI, addr)
    const LINK = ""0x514910771AF9Ca656af840dff83E8264EcF986CA""
    const USD = ""0x0000000000000000000000000000000000000348""
    
    feedRegistry.methods
      .latestRoundData(LINK, USD)
      .call()
      .then((roundData) => {
        // Do something with roundData
        console.log(""Latest Round Data"", roundData)
      })
    

Latest Price

## Contract Addresses

This section lists the blockchains that Chainlink Feed Registry are currently
available on.

| Network          | Address                                    |
|:-----------------|:-------------------------------------------|
| Ethereum Mainnet | 0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf |
## What's next

  * [› Read the Feed Registry API Reference](/data-feeds/feed-registry/feed-registry-functions)
  * [› See the FeedRegistryInterface contract on GitHub](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/feed-registry/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Feed Registry API Reference

  * Overview
  * Functions
  * decimals
  * Return Values
  * description
  * getRoundData
  * latestRoundData
  * version
  * getFeed
  * getPhaseFeed
  * isFeedEnabled
  * getPhase
  * getRoundFeed
  * getPhaseRange
  * getPreviousRoundId
  * getNextRoundId
  * getCurrentPhaseId

This guide outlines the functions which can be used with Chainlink's Feed
Registry. You can learn more about the feed registry [here](/data-feeds/feed-registry).

## Functions

| Name               | Description                                                                            |
|:-------------------|:---------------------------------------------------------------------------------------|
| decimals           | The number of decimals in the response.                                                |
| description        | The description of the aggregator that the proxy points to.                            |
| getRoundData       | Get data from a specific round.                                                        |
| latestRoundData    | Get data from the latest round.                                                        |
| version            | The version representing the type of aggregator the proxy points to.                   |
| getFeed            | Returns the primary aggregator address of a base / quote pair.                         |
| getPhaseFeed       | Returns the aggregator address of a base / quote pair at a specified phase.            |
| isFeedEnabled      | Returns true if an aggregator is enabled as primary on the registry.                   |
| getPhase           | Returns the raw starting and ending aggregator round ids of a base / quote pair.       |
| getRoundFeed       | Returns the underlying aggregator address of a base / quote pair at a specified round. |
| getPhaseRange      | Returns the starting and ending round ids of a base / quote pair at a specified phase. |
| getPreviousRoundId | Returns the previous round id of a base / quote pair given a specified round.          |
| getNextRoundId     | Returns the next round id of a base / quote pair given a specified round.              |
| getCurrentPhaseId  | Returns the current phase id of a base / quote pair.                                   |
### decimals

Get the number of decimals present in the response value.


    function decimals(address base, address quote) external view returns (uint8)

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.

### Return Values

  * `RETURN`: The number of decimals.

## description

Get the description of the underlying aggregator that the proxy points to.


    function description(address base, address quote) external view returns (string memory)

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.

#### Return Values

  * `RETURN`: The description of the underlying aggregator.

### getRoundData

Get data about a specific round, using the `roundId`.


    function getRoundData(address base, address quote, uint80 _roundId) external view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.
  * `roundId`: The round ID.

#### Return Values

  * `roundId`: The round ID.
  * `answer`: The price.
  * `startedAt`: Timestamp of when the round started.
  * `updatedAt`: Timestamp of when the round was updated.
  * `answeredInRound`: The round ID of the round in which the answer was computed.

### latestRoundData

Get the price from the latest round.


    function latestRoundData(address base, address quote) external view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )

#### Return Values

  * `roundId`: The round ID.
  * `answer`: The price.
  * `startedAt`: Timestamp of when the round started.
  * `updatedAt`: Timestamp of when the round was updated.
  * `answeredInRound`: The round ID of the round in which the answer was computed.

### version

The version representing the type of aggregator the proxy points to.


    function version(address base, address quote) external view returns (uint256)

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.

#### Return Values

  * `RETURN`: The version number.

### getFeed

Returns the primary aggregator address of a base / quote pair. Note that on-
chain contracts cannot read from aggregators directly, only through Feed
Registry or Proxy contracts.


    function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);
    

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.

#### Return Values

  * `aggregator`: The primary aggregator address.

### getPhaseFeed

Returns the underlying aggregator address of a base / quote pair at a
specified phase. Note that on-chain contracts cannot read from aggregators
directly, only through Feed Registry or Proxy contracts. Phase ids start at
`1`. You can get the current Phase by calling `getCurrentPhaseId()`.


    function getPhaseFeed(
      address base,
      address quote,
      uint16 phaseId
    ) external view returns (AggregatorV2V3Interface aggregator);
    

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.
  * `phaseId`: The phase id.

#### Return Values

  * `aggregator`: The primary aggregator address at the specified phase.

### isFeedEnabled

Returns true if an aggregator is enabled as primary on the feed registry. This
is useful to check if you should index events from an aggregator contract,
because you want to only index events of primary aggregators.


    function isFeedEnabled(address aggregator) external view returns (bool);
    

#### Parameters

  * `aggregator`: The aggregator address

#### Return Values

  * `RETURN`: `true` if the supplied aggregator is a primary aggregator for any base / quote pair.

### getPhase

Returns the starting and ending aggregator round ids of a base / quote pair.


    function getPhase(address base, address quote, uint16 phaseId) external view returns (Phase memory phase);
    

Phases hold the following information:


    struct Phase {
      uint16 phaseId;
      uint80 startingAggregatorRoundId;
      uint80 endingAggregatorRoundId;
    }
    

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.
  * `phaseId`: The phase id.

#### Return Values

  * `RETURN`: `Phase` details of a base / quote pair.

### getRoundFeed

Returns the underlying aggregator address of a base / quote pair at a
specified round. Note that on-chain contracts cannot read from aggregators
directly, only through Feed Registry or Proxy contracts.


    function getRoundFeed(
      address base,
      address quote,
      uint80 roundId
    ) external view returns (AggregatorV2V3Interface aggregator);
    

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.
  * `roundId`: The round id.

#### Return Values

  * `aggregator`: The underlying aggregator address of a base / quote pair at the specified round.

### getPhaseRange

Returns the starting and ending round ids of a base / quote pair at a
specified phase.

Please note that this `roundId` is calculated from the phase id and the
underlying aggregator's round id. To get the raw aggregator round ids of a
phase for indexing purposes, please use `getPhase()`.


    function getPhaseRange(
      address base,
      address quote,
      uint16 phaseId
    ) external view returns (uint80 startingRoundId, uint80 endingRoundId);
    

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.
  * `phaseId`: The phase id.

#### Return Values

  * `startingRoundId`: The starting round id
  * `endingRoundId`: The ending round id

### getPreviousRoundId

Returns the previous round id of a base / quote pair given a specified round.
Note that rounds are non-monotonic across phases.


    function getPreviousRoundId(address base, address quote, uint80 roundId) external view returns (uint80 previousRoundId);
    

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.
  * `roundId`: The round id.

#### Return Values

  * `previousRoundId`: The previous round id of a base / quote pair.

### getNextRoundId

Returns the next round id of a base / quote pair given a specified round. Note
that rounds are non-monotonic across phases.


    function getNextRoundId(address base, address quote, uint80 roundId) external view returns (uint80 nextRoundId);
    

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.
  * `roundId`: The round id.

#### Return Values

  * `nextRoundId`: The next round id of a base / quote pair.

### getCurrentPhaseId

Returns the current phase id of a base / quote pair.


    function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);
    

#### Parameters

  * `base`: The base asset address.
  * `quote`: The quote asset address.

#### Return Values

  * `phaseId`: The current phase id of a base / quote pair.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/feed-registry/feed-registry-functions.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside off-chain.
  * **LP Token Feeds:** These feeds use a decentralized feed for the underlying asset as well as calculations to value the LP tokens.
  * **Wrapped Calculated Feeds:** These feeds are typically pegged 1:1 to the underlying token or asset. Under normal market conditions, these feeds track their underlying value accurately. However, the price is a derivative formed from a calculated method and might not always track value precisely.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⭕ Deprecating

These feeds are being deprecated. To find the deprecation dates for specific
feeds, see the [Feeds Scheduled For Deprecation](/data-feeds/deprecating-feeds) page.

## Risk Mitigation

As a development best practice, design your systems and smart contracts to be
resilient and mitigate risk to your protocol and your users. Ensure that your
systems can tolerate known and unknown exceptions that might occur. Some
examples include but are not limited to volatile market conditions, the
degraded performance of infrastructure, chains, or networks, and any other
upstream outage related to data providers or node operators. You bear
responsibility for any manner in which you use the Chainlink Network, its
software, and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel: <https://discord.gg/Dqy5N9UbsR>

## Chainlink Community Deployments

Chainlink technology is used by many within the blockchain community to
support their use cases. Deployments built and run by community members are
not tracked in the Chainlink documentation. Chainlink's community is
continuously growing, and we believe they play a vital role in developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Fast Gas Reliability

### Liquidity and its Distribution

If your smart contract relies on pricing data for a specific asset, make sure
that the asset has sufficient liquidity in the market to avoid price
manipulation. Assets with low liquidity can be volatile, which might
negatively impact your application and its users. Malicious actors might try
to exploit volatility to take advantage of the logic in a smart contract and
cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather
than from aggregated price tracking services that gather their data from
multiple exchanges. These are marked as such in the docs page for that feed.
Assess the liquidity and reliability of that specific exchange.

_Liquidity migrations_ occur when a project moves its tokens from one
liquidity provider (such as a DEX, a CEX, or a new DeFi application) to
another. When liquidity migrations occur, it can result in low liquidity in
the original pool, making the asset susceptible to market manipulation. If
your project is considering a liquidity migration, you should coordinate with
relevant stakeholders, including liquidity providers, exchanges, oracle node
operators, and users, to ensure prices are accurately reported throughout the
migration.

Feeds for assets with low market liquidity where data providers exhibit an
abnormal price spread may, on occasion, see a price oscillate between two or
more price points within regular intervals. To mitigate risk associated with
such price oscillation, users must regularly monitor & assess the quality of
an asset’s liquidity. Similarly, assets with low market liquidity may
experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk
management measures to protect your assets. For example, create mock tests
that return various oracle responses.

### Single Source Data Providers

Some data providers use a single data source, which might be necessary if only
one source exists off-chain for a specific type of data. Evaluate data
providers to make sure they provide high-quality data that your smart
contracts can rely on. Any error or omission in the provider's data might
negatively impact your application and its users.

### Crypto and Blockchain Actions

Price data quality is subject to crypto actions by the crypto and blockchain
project teams. Crypto actions are similar to [corporate
actions](https://en.wikipedia.org/wiki/Corporate_action) but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on. Periods of
high network congestion might impact the frequency of Chainlink Price Feeds.
It is advised that you configure your applications to detect such chain
performance issues and to respond appropriately.

### Unknown and Known Users

Routine maintenance is carried out on Chainlink Data Feeds, including
decommissioning, on an ad-hoc basis. These maintenance periods might require
users to take action in order to maintain business continuity.

Notifications are sent to inform known users regarding such occurrences, and
it is strongly encouraged for all users, including those users utilizing data
feeds for off-chain purposes, [to provide their contact
information](https://chain.link/contact?ref_id=DataFeed) before utilizing data
feeds. Without providing contact information, users will be unable to receive
notifications regarding important price feed updates.

If you are using Price Feeds but have not provided your contact information,
you can do so [here](https://chain.link/contact?ref_id=DataFeed). Users that
fail to provide notification information do so at their own risk.

## Evaluating Wrapped or Bridged Assets

### Assessing how to Price Wrapped or Bridged Assets

When assessing a Chainlink Price Feed for a wrapped or bridged asset such as
WBTC, users should evaluate the tradeoffs between using a price feed
specifically built for the wrapped or bridged asset or a price feed built for
the underlying asset.

Decisions should be made on a case-by-case basis considering the liquidity,
depth, and trading volatility of the underlying asset compared to its
derivative. In addition, users must consider the security mechanism that is
designed to keep the wrapped or bridged asset coupled to its underlying asset.
Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets

Chainlink Price Feeds are designed to provide the market-wide price of various
assets, as determined by a volume-weighted average across a wide range of
exchanges. On blockchain networks where assets are wrapped and/or bridged from
another environment using a cross-chain token bridge, Chainlink Price Feeds
built for the underlying asset will continue to report the market-wide price
of the underlying asset as opposed to the price of the wrapped/bridged asset.
This methodology reduces risks around market manipulation because
wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price
deviations between the wrapped/bridged asset and its underlying counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible for reviewing the quality of the data that you integrate into your
smart contracts.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/selecting-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-11-11 04:05:43)
ChainLink Price Fee using Keepers
URL: https://stackoverflow.com/questions/69923069/chainlink-price-fee-using-keepers

Question Body:


I am trying to use the keepers chainlink service to get the eth/usd on the
Kovan test net. I deployed my contract and registered it with keepers and
funded with link token. Still I am not seeing the getLatestPrice() update.

contract address: 0xA29196C270cC15cb5D758Ae3613285720e6DEEb9 Upkeep address:
0xA29196C270cC15cb5D758Ae3613285720e6DEEb9

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity 0.8.6;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    
    interface KeeperCompatibleInterface {
        function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);
        function performUpkeep(bytes calldata performData) external;
    }
    
    contract Counter is KeeperCompatibleInterface {
        
        AggregatorV3Interface internal priceFeed;
    
        uint public counter;    // Public counter variable
    
        // Use an interval in seconds and a timestamp to slow execution of Upkeep
        uint public immutable interval;
        uint public lastTimeStamp;
        
        constructor(uint updateInterval) {
          interval = updateInterval;
          lastTimeStamp = block.timestamp;
          counter = 0;
          priceFeed = AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331);
        }
        
        function getLatestPrice() public view returns (int) {
            (
                uint80 roundID, 
                int price,
                uint startedAt,
                uint timeStamp,
                uint80 answeredInRound
            ) = priceFeed.latestRoundData();
            return price;
        }
    
        function checkUpkeep(bytes calldata checkData) external view override returns (bool upkeepNeeded, bytes memory performData) {
            upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
            performData = checkData;
        }
    
        function performUpkeep(bytes calldata performData) external override {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            performData;
            getLatestPrice();
        }
    }
    



Answers:
(Answered on: 2021-11-11 23:55:20)


your upkeep job would be getting called, but the problem is you're not doing
anything with the getLatestPrice function. This is a view function that just
returns the current feed price. If you were to add a line in your
performUpkeep function to actually store the result of getLatestPrice() in a
variable in the contract, then you would see that it is getting called



"
What is Chainlink VRF and how can it be used in smart contracts?,Chainlink VRF is a provably-fair and verifiable source of randomness designed for smart contracts. Smart contract developers can use Chainlink VRF as a tamper-proof random number generator (RNG) to build reliable smart contracts for any applications which rely on unpredictable outcomes.,{'source': 'https://docs.chain.link/vrf/v1/introduction/'},"Chainlink VRF (Verifiable Random Function) is a provably fair and verifiable random number generator that allows smart contracts to access random values without compromising security or usability. It generates random values and cryptographic proof of how those values were determined, which is published and verified on-chain before being used by consuming applications. Chainlink VRF can be used in smart contracts for applications such as blockchain games, random assignment of duties and resources, and choosing representative samples for consensus mechanisms. There are two methods to request randomness: subscription and direct funding, each with its own characteristics and considerations. The choice of method depends on the use case and requirements of the smart contract. Chainlink VRF is supported on various networks, and the contract addresses and gas price limits differ depending on the method used. For more information and details, refer to the official Chainlink VRF documentation.

","- https://docs.chain.link/vrf/
- https://docs.chain.link/vrf/v1/introduction/
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-4/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-3/course.md","# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                                                                                                          | Suitable for infrequent one-off requests                                                                                                                                                                    |
| Supports multiple VRF consuming contracts connected to one subscription account                                                                                        | Each VRF consuming contract directly pays for its requests                                                                                                                                                  |
| VRF costs are calculated after requests are fulfilled and then deducted from the subscription balance. Learn how VRF costs are calculated for the subscription method. | VRF costs are estimated and charged at request time, which may make it easier to transfer the cost of VRF to the end user. Learn how VRF costs are calculated for the direct funding method.                |
| Reduced gas overhead and more control over the maximum gas price for requests                                                                                          | Higher gas overhead than the subscription method                                                                                                                                                            |
| More random values returned per single request. See the maximum random values per request for the Subscription supported networks.                                     | Fewer random values returned per single request than the subscription method, due to higher overhead. See the maximum random values per request and gas overhead for the Direct funding supported networks. |
| You don't have to estimate costs precisely for each request. Ensure that the subscription account has enough funds.                                                    | You must estimate transaction costs carefully for each request to ensure the consuming contract has enough funds to pay for the request.                                                                    |
| Requires a subscription account                                                                                                                                        | No subscription account required                                                                                                                                                                            |
| Supported on Arbitrum                                                                                                                                                  | Not yet supported on Arbitrum                                                                                                                                                                               |
| VRF costs are billed to your subscription account. Manage and monitor your balance                                                                                     | No refunds for overpayment after requests are completed                                                                                                                                                     |
| Flexible funding method first introduced in VRF v2. Compare the VRF v2 subscription method to VRF v1.                                                                  | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Introduction to Chainlink VRF [v1]

  * Overview
  * Generate Random Numbers in your Smart Contracts
  * On-chain Verification of Randomness

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

## Generate Random Numbers in your Smart Contracts

Chainlink VRF (Verifiable Random Function) is a provably-fair and verifiable
source of randomness designed for smart contracts. Smart contract developers
can use Chainlink VRF as a tamper-proof random number generator (RNG) to build
reliable smart contracts for any applications which rely on unpredictable
outcomes:

  * Blockchain games and NFTs
  * Random assignment of duties and resources (e.g. randomly assigning judges to cases)
  * Choosing a representative sample for consensus mechanisms

Learn how to write smart contracts that consume random numbers: [Get a Random
Number](/vrf/v1/examples/get-a-random-number).

## On-chain Verification of Randomness

Chainlink VRF enables smart contracts to access randomness without
compromising on security or usability. With every new request for randomness,
Chainlink VRF generates a random number and cryptographic proof of how that
number was determined. The proof is published and verified on-chain before it
can be used by any consuming applications. This process ensures that the
results cannot be tampered with nor manipulated by anyone, including oracle
operators, miners, users and even smart contract developers.

Read more about Chainlink VRF in [our announcement
post](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/).

## What's next

  * [› Get a Random Number](/vrf/v1/examples/get-a-random-number)
  * [› API Reference](/vrf/v1/api-reference)
  * [› Supported Networks](/vrf/v1/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.


:::NEXT DOC:::

#####Chapter 3:

# Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson randomness provided by an outside service needs to be verifiable and decentralized, and that’s exactly what Chainlink VRF is! VRF stands for Verifiable Randomness Function. Essentially Chainlink VRF provides cryptographic proof alongside every random number generated, that the random number wasn’t tampered with (and indeed generated in a random way).

How does this cryptographic proof work? It’s quite mathematically complicated and outside the scope of this lesson, but you can read more about it in the “Technical Walkthrough” section of this [blog post](https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/). The cryptographic proof is then verified by a smart contract on-chain, which means it is verified by every node on the blockchain! This completes our verifiable and decentralized criteria. So now we understand that Chainlink VRF is verifiably random and decentralized how do we use it?
"
What is the purpose of the useChainlinkWithENS function?,"The useChainlinkWithENS function allows a Chainlink contract to store the addresses of the LINK token and oracle contract addresses without supplying the addresses themselves, using ENS where available to resolve these addresses.",{'source': 'https://docs.chain.link/any-api/api-reference/'},"The purpose of the useChainlinkWithENS function is to allow a Chainlink contract to store the addresses of the LINK token and Oracle contract through the Ethereum Name Service (ENS). It requires the address of the ENS contract and the node (which is a hash) for the domain. This function is used to update the stored addresses with the latest addresses resolved through ENS.

",https://docs.chain.link/any-api/api-reference/,"# ChainlinkClient API Reference

  * Overview
  * Index
  * Methods
  * Events
  * Modifiers
  * Constants
  * Structs
  * Methods
  * setChainlinkOracle
  * setChainlinkToken
  * buildChainlinkRequest
  * buildOperatorRequest
  * sendChainlinkRequest
  * sendChainlinkRequestTo
  * sendOperatorRequest
  * sendOperatorRequestTo
  * validateChainlinkCallback
  * addChainlinkExternalRequest
  * cancelChainlinkRequest
  * useChainlinkWithENS
  * updateChainlinkOracleWithENS
  * chainlinkTokenAddress
  * chainlinkOracleAddress
  * Events
  * ChainlinkRequested
  * ChainlinkFulfilled
  * ChainlinkCancelled
  * Constants
  * LINK_DIVISIBILITY
  * Modifiers
  * recordChainlinkFulfillment
  * Chainlink.Request
  * Attributes
  * Methods

API reference for ChainlinkClient

`ChainlinkClient`
[contracts](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol)
can communicate with legacy `Oracle`
[contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or `Operator`
[contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).

## Index

### Methods

| Name                         | Description                                                                                                                    |
|:-----------------------------|:-------------------------------------------------------------------------------------------------------------------------------|
| setChainlinkOracle           | Sets the stored address for the oracle contract                                                                                |
| setChainlinkToken            | Sets the stored address for the LINK token                                                                                     |
| buildChainlinkRequest        | Instantiates a Request object with the required parameters                                                                     |
| buildOperatorRequest         | Instantiates a Request object with the required parameters. Note the oracle must be an Operator contract                       |
| sendChainlinkRequest         | Sends the request payload to the stored address stored as chainlinkOracleAddress                                               |
| sendChainlinkRequestTo       | Sends a request to the oracle address specified                                                                                |
| sendOperatorRequest          | Sends the request payload to the stored address stored as chainlinkOracleAddress. Note the oracle must be an Operator contract |
| sendOperatorRequestTo        | Sends a request to the oracle address specified. Note the oracle must be an Operator contract                                  |
| validateChainlinkCallback    | Secures the fulfillment callback to make sure it is only called by permissioned senders                                        |
| addChainlinkExternalRequest  | Allows a Chainlinked contract to track unfulfilled requests that it hasn't created itself                                      |
| cancelChainlinkRequest       | Cancels Chainlink requests attempting to contact an unresponsive node                                                          |
| useChainlinkWithENS          | Looks up the addresses of the LINK token and Oracle contract through ENS                                                       |
| updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS                                                 |
| chainlinkTokenAddress        | Returns the stored address of the LINK token                                                                                   |
| chainlinkOracleAddress       | Returns the stored address of the oracle contract                                                                              |
### Events

| Name               | Description                                                                  |
|:-------------------|:-----------------------------------------------------------------------------|
| ChainlinkRequested | Emitted from a Chainlinked contract when a request is sent to an oracle      |
| ChainlinkFulfilled | Emitted from a Chainlinked contract when a request is fulfilled by an oracle |
| ChainlinkCancelled | Emitted from a Chainlinked contract when a request is cancelled              |
### Modifiers

| Name                       | Description                                                                                                                                              |
|:---------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------|
| recordChainlinkFulfillment | Used on fulfillment callbacks to ensure that the caller and requestId are valid. This is the modifier equivalent of the method validateChainlinkCallback |
### Constants

| Name              | Description                                                                       |
|:------------------|:----------------------------------------------------------------------------------|
| LINK_DIVISIBILITY | Helper uint256 to represent the divisibility of a LINK token. Equivalent to 10^18 |
### Structs

| Name              | Description                                                          |
|:------------------|:---------------------------------------------------------------------|
| Chainlink.Request | All of the parameters that can be passed over in a Chainlink request |
## Methods

Below you'll find each helper explained in greater detail alongside respective
implementation examples to help you leverage these methods once you start
building your own Chainlinked contract.

After the function signature and a short description, two code examples are
provided, one focusing on the exact usage of the method and one where the
helper is presented in the context of a full contract.

### setChainlinkOracle


    function setChainlinkOracle(
      address _oracle
    )

Sets a private storage variable provided for convenience if your contract only
needs to talk to one oracle and you do not want to specify it on every
request. Once an oracle is set with `setChainlinkOracle` that is the address
used with sendChainlinkRequest.

Retrieve the oracle address using chainlinkOracleAddress. These getters and
setters are provided to enforce that changes to the oracle are explicitly made
in the code.


    constructor(address _oracle)
    {
      setChainlinkOracle(_oracle);
    }

### setChainlinkToken


    setChainlinkToken(
      address _link
    )

Sets the stored address for the LINK token which is used to send requests to
Oracles. There are different token addresses on different network. See [LINK
Token Contracts](/resources/link-token-contracts) for the address of the LINK
token on the network you're deploying to.


    constructor(address _link)
      public
    {
      setChainlinkToken(_link);
    }

### buildChainlinkRequest

Use `buildOperatorRequest` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function buildChainlinkRequest(
        bytes32 _jobId,
        address _callbackAddress,
        bytes4 _callbackFunctionSignature
    ) returns (Chainlink.Request memory request)

Instantiates a Request from the Chainlink contract. A Request is a struct
which contains the necessary parameters to be sent to the oracle contract. The
`buildChainlinkRequest` function takes an ID, which can be a [Job
ID](/chainlink-nodes/oracle-jobs/jobs), a callback address to receive the
resulting data, and a callback function signature to call on the callback
address.


    function requestPrice()
      public
    {
      bytes32 jobId = ""493610cff14346f786f88ed791ab7704"";
      bytes4 selector = this.myCallback.selector;
      // build a request that calls the myCallback function defined
      //   below by specifying the address of this contract and the function
      //   selector of the myCallback
      Chainlink.Request memory request = buildChainlinkRequest(
        jobId,
        address(this),
        selector);
    }

### buildOperatorRequest

This function is similar to `buildChainlinkRequest`function. One major
difference is that `buildOperatorRequest` does not allow setting up the
address of the callback. The callback address is set to the address of the
calling contract.

It is recommended to use `buildOperatorRequest` but make sure the oracle you
are contacting is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function buildOperatorRequest(
        bytes32 _jobId,
        bytes4 _callbackFunctionSignature
    ) returns (Chainlink.Request memory request)

Instantiates a _Request_ from the Chainlink contract. A Request is a struct
that contains the necessary parameters to be sent to the oracle contract. The
`buildOperatorRequest` function takes an ID, which can be a [Job
ID](/chainlink-nodes/oracle-jobs/jobs), and a callback function signature to
call on the calling contract address.


    function requestPrice()
      public
    {
      bytes32 jobId = ""493610cff14346f786f88ed791ab7704"";
      bytes4 selector = this.myCallback.selector;
      // build a request that calls the myCallback function defined
      //   below by specifying the function selector of myCallback
      Chainlink.Request memory request = buildOperatorRequest(
        jobId,
        selector);
    }

### sendChainlinkRequest

Use `sendOperatorRequest` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequest(
        Chainlink.Request memory _req,
        uint256 _payment
    ) returns (bytes32 requestId)

Sends the request payload to the stored oracle address. It takes a
Chainlink.Request and the amount of LINK to send amount as parameters. The
request is serialized and calls `oracleRequest` on the address stored in
`chainlinkOracleAddress` via the LINK token's `transferAndCall` method.

`sendChainlinkRequest` returns the ID of the request. If your application
needs to, your contract can store that ID, but you don't need to. The
ChainlinkClient helpers will store the ID under the hood, along with the
oracle address, and use them when you call `recordChainlinkFulfillment` in
your callback function to make sure only that the address you want can call
your Chainlink callback function.

`sendChainlinkRequest` emits a ChainlinkRequested event containing the request
ID, if you would like to use it in your Web3 application.


    function requestPrice()
      public
    {
      Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.callback.selector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK
    
      // send the request that you just built
      sendChainlinkRequest(request, paymentAmount);
    }

### sendChainlinkRequestTo

Use `sendOperatorRequestTo` function if the oracle is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequestTo(
      address _oracle,
      Chainlink.Request memory _req,
      uint256 _payment
    ) returns (bytes32 requestId)

Similar to sendChainlinkRequest, `sendChainlinkRequestTo` sends a Request but
allows the target oracle to be specified. It requires an address, a Request,
and an amount, and returns the `requestId`. This allows a requesting contract
to create and track requests sent to multiple oracle contract addresses.

`sendChainlinkRequestTo` emits a ChainlinkRequested event containing the
request ID, if you would like to use it in your Web3 application.


    function requestPriceFrom(address _oracle)
      public
    {
      Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.callback.callbackSelector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK
    
      // send the request that you just built to a specified oracle
      sendChainlinkRequestTo(_oracle, request, paymentAmount);
    }

### sendOperatorRequest

This function is similar to `sendChainlinkRequest`function. It is recommended
to use `sendOperatorRequest` but make sure the oracle you are contacting is an
`Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendOperatorRequest(
        Chainlink.Request memory _req,
        uint256 _payment
    ) returns (bytes32 requestId)

The `sendOperatorRequest` function sends the request payload to the stored
oracle address. It takes a Chainlink.Request and the amount of LINK to send
amount as parameters. The request is serialized and calls `operatorRequest` on
the address stored in `chainlinkOracleAddress` using the LINK token's
`transferAndCall` method.

`sendOperatorRequest` returns the ID of the request. Optionally, your contract
can store the ID if your application needs it. The `ChainlinkClient` helpers
store the ID and the oracle address and use them when you call
`recordChainlinkFulfillment` in your callback function. This ensures that only
the specified address can call your Chainlink callback function.

`sendOperatorRequest` emits a ChainlinkRequested event containing the request
ID that you can use in your Web3 application.


    function requestPrice()
      public
    {
      Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.selector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY / 10; // Equivalent to 0.1 LINK
    
      // send the request that you just built
      sendOperatorRequest(request, paymentAmount);
    }

### sendOperatorRequestTo

This function is similar to `sendChainlinkRequestTo`function. It is
recommended to use `sendOperatorRequestTo`, but make sure the oracle you are
contacting is an `Operator`
[contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol).


    function sendChainlinkRequestTo(
      address _oracle,
      Chainlink.Request memory _req,
      uint256 _payment
    ) returns (bytes32 requestId)

Similar to sendOperatorRequest, `sendOperatorRequestTo` sends a Request but
allows the target oracle to be specified. It requires an address, a Request,
and an amount, and returns the `requestId`. This allows a requesting contract
to create and track requests sent to multiple oracle contract addresses.

`sendOperatorRequestTo` emits a ChainlinkRequested event containing a request
ID that you can use in your Web3 application.


    function requestPriceFrom(address _oracle)
      public
    {
      Chainlink.Request memory request = buildOperatorRequest(jobId, this.callback.callbackSelector);
      uint256 paymentAmount = 1 * LINK_DIVISIBILITY; // = 1 LINK
    
      // send the request that you just built to a specified oracle
      sendOperatorRequestTo(_oracle, request, paymentAmount);
    }

### validateChainlinkCallback


    function validateChainlinkCallback(
        bytes32 _requestId
    )

Used on fulfillment callbacks to ensure that the caller and `requestId` are
valid. They protect ChainlinkClient callbacks from being called by malicious
callers. `validateChainlinkCallback` allows for a request to be called

This is the method equivalent of the modifier `recordChainlinkFulfillment`.
Either `validateChainlinkCallback` or `recordChainlinkFulfillment` should be
used on all fulfillment functions to ensure that the caller and `requestId`
are valid. Use the modifier or the method, not both.

`validateChainlinkCallback` emits a ChainlinkFulfilled event.


    function myCallback(bytes32 _requestId, uint256 _price)
      public
    {
      validateChainlinkCallback(_requestId);
      currentPrice = _price;
    }

Do not call multiple times

Do not call `validateChainlinkCallback` multiple times. The nature of
validating the callback is to ensure the response is only received once and
not replayed. Calling a second time with the same method ID will trigger a
revert. Similarly, your callback should validate using either
`validateChainlinkCallback` or `recordChainlinkFulfillment`, not both.

### addChainlinkExternalRequest


    function addChainlinkExternalRequest(
      address _oracle,
      bytes32 _requestId
    )

`addChainlinkExternalRequest` allows a Chainlink contract to track unfulfilled
requests that it hasn't created itself. For example, contract A creates a
request and sets the callback for contract B. Contract B needs to know about
the request created by contract A so that it can validate the callback when it
is executed.


    function expectResponseFor(bytes32 _requestId)
      public
    {
      addChainlinkExternalRequest(chainlinkOracleAddress(), _requestId);
    }

Be careful adding external requests

Being able to change a request means that you can change the data fed into a
contract. Permissioning someone to make external requests can allow them to
change the outcome of your contract. You should be sure to make sure that they
are a trusted to do so. If they are not trusted to do so, you should put the
request making logic on-chain where it is auditable and tamperproof.

### cancelChainlinkRequest


    function cancelChainlinkRequest(bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    )

In case an oracle node does not respond, it may be necessary to retrieve the
LINK used to pay for the unfulfilled request. The `cancelChainlinkRequest`
will send the cancel request to the address used for the request, which
transfers the amount of LINK back to the requesting contract, and delete it
from the tracked requests.

The default expiration for a request is five minutes, after which it can be
cancelled. The cancellation must be sent by the address which was specified as
the callback location of the contract.

For the sake of efficient gas usage, only a hash of the request's parameters
are stored on-chain. In order to validate the terms of the request and that it
can be calculated, the request parameters must be provided. Additionally,
cancellation must be called by the address which the callback would otherwise
have been called on.

`cancelChainlinkRequest` emits a ChainlinkCancelled event.


    function cancelRequest(
        bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    ) public {
      cancelChainlinkRequest(_requestId, _payment, _callbackFunc, _expiration);
    }

### useChainlinkWithENS


    function useChainlinkWithENS(
      address _ens,
      bytes32 _node
    )

Allows a Chainlink contract to store the addresses of the LINK token and
oracle contract addresses without supplying the addresses themselves. We use
ENS where available to resolve these addresses. It requires the address of the
ENS contract and the node (which is a hash) for the domain.

If your Oracle provider supports using ENS for rolling upgrades to their
oracle contract, once you've pointed your Chainlinked contract to the ENS
records then you can update the records using updateChainlinkOracleWithENS.


    address constant ROPSTEN_ENS = 0x112234455C3a32FD11230C42E7Bccd4A84e02010;
    bytes32 constant ROPSTEN_CHAINLINK_ENS = 0xead9c0180f6d685e43522fcfe277c2f0465fe930fb32b5b415826eacf9803727;
    
    constructor(){
      useChainlinkWithENS(ROPSTEN_ENS, ROPSTEN_CHAINLINK_ENS);
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Oracle.sol)
or trust whoever can update the records.

### updateChainlinkOracleWithENS


    function updateChainlinkOracleWithENS()

Updates the stored oracle contract address with the latest address resolved
through the ENS contract. This requires the oracle provider to support listing
their address on ENS.

This method only works after useChainlinkWithENS has been called on the
contract.


    function updateOracleAddressToLatest() public {
      updateChainlinkOracleWithENS();
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or trust whoever can update the records.

### chainlinkTokenAddress


    function chainlinkTokenAddress() returns (address)

The `chainlinkTokenAddress` function is a helper used to return the stored
address of the Chainlink token. This variable is protected and so only made
available through getters and setters.


    function withdrawLink() public {
      LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
    
      require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
    }

### chainlinkOracleAddress

The `chainlinkOracleAddress` function is a helper used to return the stored
address of the oracle contract.


    function getOracle() public view returns (address) {
      return chainlinkOracleAddress();
    }
    

## Events

### ChainlinkRequested


    event ChainlinkRequested(
      bytes32 indexed id
    )

Emitted when sendChainlinkRequest and sendChainlinkRequestTo are called.
Includes the request ID as an event topic.

### ChainlinkFulfilled


    event ChainlinkFulfilled(
      bytes32 indexed id
    )

Emitted when validateChainlinkCallback or recordChainlinkFulfillment are
called. Includes the request ID as an event topic.

### ChainlinkCancelled


    event ChainlinkCancelled(
      bytes32 indexed id
    )

Emitted when cancelChainlinkRequest is called. Includes the request ID as an
event topic.

## Constants

### LINK_DIVISIBILITY

`LINK_DIVISIBILITY` is a uint256 constant to represent one whole unit of the
LINK token (1000000000000000000). It can be used with another value to specify
payment in an easy-to-read format, instead of hardcoding magic numbers.


    uint256 constant private ORACLE_PAYMENT = 100 * LINK_DIVISIBILITY; // = 100 LINK

## Modifiers

### recordChainlinkFulfillment

`recordChainlinkFulfillment` is used on fulfillment callbacks to ensure that
the caller and `requestId` are valid. This is the method equivalent of the
method `validateChainlinkCallback`.

Either `validateChainlinkCallback` or `recordChainlinkFulfillment` should be
used on all Chainlink callback functions to ensure that the sender and
`requestId` are valid. They protect ChainlinkClient callbacks from being
called by malicious callers. Do not call both of them, or your callback may
revert before you can record the reported response.


    function myCallback(bytes32 _requestId, uint256 _price)
      public
      recordChainlinkFulfillment(_requestId) // always validate callbacks
    {
      currentPrice = _price;
    }

## Chainlink.Request


    library Chainlink {
      struct Request {
        bytes32 id;
        address callbackAddress;
        bytes4 callbackFunctionId;
        uint256 nonce;
        Buffer.buffer buf;
      }
    }

The Chainlink Request struct encapsulates all of the fields needed for a
Chainlink request and its corresponding response callback.

The Chainlink protocol aims to be flexible and not restrict application
developers. The Solidity Chainlink Request model is a great example of that.
It is exceptionally flexible, given the limitations of Solidity. The request
can contain an arbitrary amount of keys and values to be passed off-chain to
the oracles for each request. It does so by converting the parameters into
CBOR, and then storing them in a buffer. This allows for any number of
parameters all of different types to be encoded on-chain.

The request's ID is generated by hashing the sender's address and the
request's nonce. This scheme ensures that only the requester can generate
their request ID, and no other contract can trigger a response from an oracle
with that ID. New requests whose IDs match an unfulfilled request ID will not
be accepted by the oracle.

Intended for memory

The Request object was intended to be stored in memory. If you have a reason
to persist the struct in storage, it is recommended that you do so by copying
each attribute over and explicitly copying the bytes in the buffer.

### Attributes

| Name               | Description                                                                                             |
|:-------------------|:--------------------------------------------------------------------------------------------------------|
| id                 | Identifier for the request                                                                              |
| callbackAddress    | Address that the response will be sent to upon fulfillment                                              |
| callbackFunctionId | Selector of the function on the callbackAddress that will be invoked with the response upon fulfillment |
| nonce              | Used to generate the request ID                                                                         |
| buf                | Buffer that stores additional user defined parameters as CBOR                                           |
### Methods

| Name           | Description                                                      |
|:---------------|:-----------------------------------------------------------------|
| add            | Add a string value to the run request parameters                 |
| addBytes       | Add a bytes value to the run request parameters                  |
| addInt         | Add an integer value to the run request parameters               |
| addUint        | Add an unsigned integer to the run request parameters            |
| addStringArray | Add an array of strings as a value in the run request parameters |
| setBuffer      | Directly set the CBOR of the run request parameters              |
#### add


    function add(
      Request memory self,
      string _key,
      string _value
    )

Add a string value to the run request parameters. Commonly used for `get` with
jobs using `httpGet` tasks.


    function requestEthereumPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.add(""get"", ""https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD,EUR,JPY"");
    
      sendChainlinkRequest(req, 1 * LINK_DIVISIBILITY); // =1 LINK
    }

#### addBytes


    function addBytes(
      Request memory self,
      string _key,
      bytes _value
    )

Add a CBOR bytes type value to the run request parameters.


    function requestEmojiPopularity(bytes _unicode)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addBytes(""emojiUnicode"", _unicode);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

Note that this can also be used as a workaround to pass other data types like
arrays or addresses. For instance, to add an _address_ , one would first
encode it using `abi.encode` then pass the result to `addBytes`:


    Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
    req.addBytes(""address"", abi.encode(msg.sender)); // msg.sender used in this example. Replace it with your address
    

#### addInt


    function addInt(
      Request memory self,
      string _key,
      int256 _value
    )

Add a CBOR signed integer type value to the run request parameters. Commonly
used with the `times` parameter of any job using a `multiply` task.


    function requestPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addInt(""times"", 100);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

#### addUint


    function addUint(
      Request memory self,
      string _key,
      uint256 _value
    )

Add a CBOR unsigned integer type value to the run request parameters. Commonly
used with the `times` parameter of any job using a `multiply` task.


    function requestPrice()
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(jobId, this, this.fulfill.selector);
    
      req.addUint(""times"", 100);
    
      sendChainlinkRequest(req, LINK_DIVISIBILITY * 1);
    }

#### addStringArray


    function addStringArray(
      Request memory self,
      string _key,
      string[] memory _values
    )

Add a CBOR array of strings to the run request parameters. Commonly used with
the `path` parameter for any job including a `jsonParse` task.


    function requestPrice(string _currency)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
      string[] memory path = new string[](2);
      path[0] = _currency;
      path[1] = ""recent"";
    
      // specify templated fields in a job specification
      req.addStringArray(""path"", path);
    
      sendChainlinkRequest(req, PAYMENT);
    }

#### setBuffer


    function setBuffer(
      Request memory self,
      bytes _data
    )

Set the CBOR payload directly on the request object, avoiding the cost of
encoding the parameters in CBOR. This can be helpful when reading the bytes
from storage or having them passed in from off-chain where they were pre-
encoded.


    function requestPrice(bytes _cbor)
      public
    {
      Chainlink.Request memory req = buildChainlinkRequest(JOB_ID, this, this.myCallback.selector);
    
      req.setBuffer(_cbor);
    
      sendChainlinkRequest(req, PAYMENT);
    }

Be careful setting the request buffer directly

Moving the CBOR encoding logic off-chain can save some gas, but it also opens
up the opportunity for people to encode parameters that not all parties agreed
to. Be sure that whoever is permissioned to call `setBuffer` is trusted or
auditable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/api-reference.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature improvements
along with interface and contract changes. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and add your EVM account address to the allow list.

## Supported networks

See the [Supported Networks](/chainlink-functions/supported-networks) page to
find a list of supported networks and contract addresses.

## What's next

  * [› Learn the basics in the Getting Started guide.](/chainlink-functions/getting-started)
  * [› Learn how to use more advanced capabilities in one of the Tutorials.](/chainlink-functions/tutorials)
  * [› Learn about core concepts, the Chainlink Functions architecture, and billing.](/chainlink-functions/resources)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the minimum spend requirement for each registered upkeep in the Keepers Registry v1.2?,"Each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam.",{'source': 'https://docs.chain.link/chainlink-automation/automation-release-notes/'},The minimum spend requirement for each registered upkeep in the Keepers Registry v1.2 is 0.1 LINK.,,"# Chainlink Automation Release Notes

  * Overview
  * 2023-05-15 - Automation on Optimism
  * Chainlink Keepers is now Chainlink Automation
  * 2022-09-23 - v1.3 Release
  * 2022-08-04 - v1.2 Release
  * Manually migrating upkeeps from v1.1 to v1.2
  * 2022-07-21 - Underfunded upkeep notifications
  * 2022-06-29 - Keepers on Fantom
  * 2022-06-09 - Keepers on Avalanche
  * 2022-03-01 - Keepers on Ethereum Rinkeby
  * 2021-11-18 - Keepers on Binance Smart Chain and Polygon
  * 2021-08-05 - Keepers v1.1 launch on Ethereum
  * Questions

**Chainlink Automation release notes:**

  * Automation on Optimism
  * Chainlink Keepers is now Chainlink Automation
  * v1.3 release
  * v1.2 release
    * Manually migrating upkeeps from v1.1 to v1.2
  * Underfunded upkeep email notifications
  * Keepers on Fantom
  * Keepers on Avalanche
  * Keepers on Ethereum Rinkeby
  * Keepers on Binance Smart Chain and Polygon
  * Keepers v1.1 launch on Ethereum
  * Questions

## 2023-05-15 - Automation on Optimism

Chainlink Automation is live on [Optimism](/chainlink-automation/supported-networks#optimism).

## Chainlink Keepers is now Chainlink Automation

Chainlink Keepers has been renamed to **Chainlink Automation**. The table
below describes what terms under the former Keepers naming system translate to
under the current Automation naming system:

| Keepers Term                  | Automation Term                   |
|:------------------------------|:----------------------------------|
| Chainlink Keepers Network     | Chainlink Automation Network      |
| Keeper/Keeper Node            | Automation/Automation Node        |
| Keepers Job                   | Automation Job                    |
| Keepers Registry/Registrar    | Automation Registry/Registrar     |
| KeeperCompatible.sol          | AutomationCompatible.sol          |
| KeeperBase.sol                | AutomationBase.sol                |
| KeeperCompatibleInterface.sol | AutomationCompatibleInterface.sol |
## 2022-09-23 - v1.3 Release

Keepers Registry v1.3 [launched on Arbitrum Mainnet](/chainlink-automation/supported-networks/#arbitrum).

## 2022-08-04 - v1.2 Release

Keepers Registry v1.2 launched on Ethereum, Binance Smart Chain, Polygon,
Avalanche, and Fantom

  * **Automatic upkeep registration approval** : All upkeeps on supported mainnets are now automatically approved.

  * **Programmatic control** : With automatic approval, you can now dynamically create, manage, and fund upkeeps from within your dApps and even have an upkeep fund itself. Learn more [here](/chainlink-automation/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract).

  * **Advanced turn-taking algorithm** : Our turn taking algorithm now supports upkeeps that require high-frequency execution.

  * **Durable ID and user-triggered migration** : All upkeeps created in versions v1.2 and later will have durable IDs. v1.2 also supports user-triggered migration to future registry versions to make it easier to migrate to a new Keepers Registry and benefit from new features. Future migrations can still retain the existing ID. The ID is now a hash in format of a 77 digit integer.

  * **Configurable upkeeps** : You can now edit the gas limit of your upkeep to easily customize your upkeep to fit your needs without having to create a new upkeep.

  * **Off-chain compute improvements** : The off-chain compute sequence is improved for higher-fidelity representation of the gas and logic before transactions are submitted on-chain. This helps to reduce reverts and reduce fees.

  * **Minimum spend requirement** : As part of the mission to continuously enhance the security of the Chainlink Network for all participants, each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam. Note that an _upkeep_ is the automation job itself. It is not a transaction. Each upkeep can have thousands of transactions. If an upkeep has not spent more than 0.1 LINK across all transactions at the time of cancellation, then 0.1 LINK will be retained for the network. If more than 0.1 LINK has been spent by an upkeep, the full remaining balance of the upkeep will be withdrawable when the upkeep is canceled.

### Manually migrating upkeeps from v1.1 to v1.2

If your upkeep ID has 77 digits, it is already migrated to v1.2 and no further
action is required. If your upkeep ID has less than 4 digits, your upkeep is
on the v1.1 registry. To migrate your upkeep from Keepers v1.1 to Keepers
v1.2, you can cancel it in the Keepers App, and register an exact copy of the
upkeep in the Keepers App. While you can see upkeeps from both v1.1 and v1.2
in the [Keepers App](https://automation.chain.link), all new upkeeps in the
Keepers App will be automatically created on Keepers v1.2.

## 2022-07-21 - Underfunded upkeep notifications

You will now receive notifications to the email address you register in your
upkeep when your upkeep is underfunded. We are limiting notifications on the
same upkeep to once per week.

## 2022-06-29 - Keepers on Fantom

Chainlink Keepers is live on the Fantom Network,
[Mainnet](https://automation.chain.link/fantom) and
[Testnet](https://automation.chain.link/fantom-testnet).

## 2022-06-09 - Keepers on Avalanche

Chainlink Keepers is live on the Avalanche Network,
[Mainnet](https://automation.chain.link/avalanche) and
[Testnet](https://automation.chain.link/fuji).

## 2022-03-01 - Keepers on Ethereum Rinkeby

Chainlink Keepers is live on [Ethereum
Rinkeby](https://automation.chain.link/rinkeby).

## 2021-11-18 - Keepers on Binance Smart Chain and Polygon

Chainlink Keepers is live on the both Binance Smart Chain
[Mainnet](https://automation.chain.link/bsc) and
[Testnet](https://automation.chain.link/chapel), and Polygon
[Mainnet](https://automation.chain.link/polygon) and
[Testnet](https://automation.chain.link/mumbai).

## 2021-08-05 - Keepers v1.1 launch on Ethereum

Chainlink Keepers officially launched on [Ethereum
Mainnet](https://keepers.chain.link/mainnet).

## Questions

If you have questions, read the [Chainlink Automation Frequently Asked
Questions](/chainlink-automation/faqs) page. You can also ask questions in the
[#automation
channel](https://discord.com/channels/592041321326182401/821350860302581771)
in our [Discord server](https://discord.gg/qj9qarT), or [contact
us](https://forms.gle/WadxnzzjHPtta5Zd9) for assistance with registration.

## What's next

  * [› Register a time-based upkeep](/chainlink-automation/job-scheduler/)
  * [› Register a Custom Logic Upkeep](/chainlink-automation/register-upkeep/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/automation-release-notes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Managing Upkeeps

  * Overview
  * Fund your Upkeep
  * Maintain a Minimum Balance
  * Withdraw funds
  * Interacting directly with the Chainlink Automation Registry

Manage your Upkeeps to get the best performance.

## Fund your Upkeep

You must monitor the balance of your Upkeep. If the Upkeep LINK balance drops
below the [minimum balance](/chainlink-automation/automation-economics/#minimum-balance), the Chainlink Automation Network will not perform
the Upkeep.

ERC677 Link

For funding on Mainnet, you need ERC-677 LINK. Many token bridges give you
ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be
ERC-677 compatible](https://pegswap.chain.link/). To fund on a supported
testnet, get [LINK](/resources/link-token-contracts) from
[faucets.chain.link](https://faucets.chain.link/).

Follow these steps to fund your Upkeep:

  1. **Click`View Upkeep`** or go to the [Chainlink Automation App](https://automation.chain.link) and click on your recently registered Upkeep under My Upkeeps.

  2. **Click the`Add funds` button**

  3. **Approve the LINK spend allowance**

  4. **Confirm the LINK transfer** by sending funds to the Chainlink Automation Network Registry 

  5. **Receive a success message** and verify that the funds were added to the Upkeep 

## Maintain a Minimum Balance

Each Upkeep has a [minimum balance](/chainlink-automation/automation-economics/#minimum-balance) to ensure that an Upkeeps will still run should a
sudden spike occur. If your Upkeep LINK balance drops below this amount, the
Upkeep will not be performed.

To account for Upkeep execution over time and possible extended gas spikes,
maintain an Upkeep LINK balance that is 3 to 5 times the minimum balance. Note
if you have an upkeep that performs frequently you may want to increase the
buffer to ensure a reasonable interval before you need to fund again.
Developers also have the ability to update `performGasLimit` for an upkeep.

## Withdraw funds

To withdraw funds, the Upkeep administrator have to cancel the Upkeep first.
There is a 50 block delay once an Upkeep has been cancelled before funds can
be withdrawn. Once 50 blocks have passed, select **Withdraw funds**.

## Interacting directly with the Chainlink Automation Registry

After registration, you can interact directly with the [registry
contract](/chainlink-automation/supported-networks/#configurations) functions
such as `cancelUpkeep` and `addFunds` using your **Upkeep ID**. The Registry
Address might change when new contracts are deployed with new functionality.

## What's next

  * [› Automation economics](/chainlink-automation/automation-economics/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/manage-upkeeps.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Register a Custom Logic Upkeep

  * Overview
  * Register an Upkeep using the Chainlink Automation App
  * Register an Upkeep using your own deployed contract
  * Prerequisites
  * Code examples
  * Mainnet parameters
  * Testnet parameters

This guide explains how to register a custom logic Upkeep that uses a
[compatible contract](/chainlink-automation/compatible-contracts). You can
register it using the Chainlink Automation App or from within a contract that
you deploy.

## Register an Upkeep using the Chainlink Automation App

  1. **Click the Register New Upkeep button**

  2. **Connect your wallet** using the _Connect Wallet_ choose a network. For a list of supported networks, see the [Supported Blockchain Networks](/chainlink-automation/supported-networks) section. The Chainlink Automation App also lists the currently supported networks. 

  3. **Select the custom logic trigger**

  4. **Provide the address of your[compatible contract](/chainlink-automation/compatible-contracts)** You do not need to verify the contract on-chain, but it must be [compatible](/chainlink-automation/compatible-contracts) with the `AutomationCompatibleInterface` contract.

  5. **Complete the required details:**

    * **Upkeep name** : This will be publicly visible in the Chainlink Automation app.

    * **Gas limit** : This is the maximum amount of gas that your transaction requires to execute on chain. This limit cannot exceed the `performGasLimit` value configured on the [registry](/chainlink-automation/supported-networks/#configurations). Before the network executes your transaction on chain, it simulates the transaction. If the gas required to execute your transaction exceeds the gas limit that you specified, your transaction will not be confirmed. Developers also have the ability to update `performGasLimit` for an upkeep. Consider running your function on a testnet to see how much gas it uses before you select a gas limit. This can be changed afterwards.

    * **Starting balance (LINK)** : Specify a LINK starting balance to fund your upkeep. See the [LINK Token Contracts](/resources/link-token-contracts) page to find the correct contract address and access faucets for testnet LINK. This field is required. You must have LINK before you can use the Chainlink Automation service.

    * **Check data** : This field is provided as an input for when your `checkUpkeep` function is simulated. Either leave this field blank or specify a hexadecimal value starting with `0x`. To learn how to make flexible upkeeps using `checkData`, see the [Flexible Upkeeps](/chainlink-automation/flexible-upkeeps) guide.

    * **Your email address** : This email address will be encrypted and is used to send you an email when your upkeep is underfunded.

Funding Upkeep

You should fund your contract with more LINK that you anticipate you will
need. The network will not check or perform your Upkeep if your balance is too
low based on current exchange rates. View the [Automation
economics](/chainlink-automation/automation-economics) page to learn more
about the cost of using Chainlink Automation.

ERC677 Link

Fund your Upkeep with more LINK than you anticipate you will need. The network
will not check or perform your upkeep if your balance is too low based on
current exchange rates. View the [Automation Economics](/chainlink-automation/automation-economics) page to learn more about the cost of using
Chainlink Automation.

Testing and best practices

Follow the [best practices](/chainlink-automation/compatible-contract-best-practice) when creating a compatible contract and test your upkeep on a
testnet before deploying it to a mainnet.

  6. **Click`Register upkeep`** and confirm the transaction in MetaMask. 

Your upkeeps will be displayed in your list of **Active Upkeeps**. You must
monitor the balance of your upkeep. If the balance drops below the **minimum
balance** , the Chainlink Automation Network will not perform the Upkeep. See
[Managing Upkeeps](/chainlink-automation/manage-upkeeps) to learn how to
manage your upkeeps.

## Register an Upkeep using your own deployed contract

You can dynamically create and manage Upkeeps using your own smart contracts.
The following example displays a smart contract that can create an Upkeep and
determine the Upkeep ID. You can also program your Upkeep to check its own
balance and fund itself by interacting with the registry.

### Prerequisites

Find the following addresses for your network:

  * Correct [LINK token contract](/resources/link-token-contracts)
  * [Registry and registrar addresses for your network](/chainlink-automation/supported-networks/#configurations)

Optionally, you can fetch the LINK address and registrar address from the
intended registry at run-time.

Fund your contract

Make sure your contract has enough [ERC-677 LINK](/resources/link-token-contracts) to fund the Upkeep at creation. _The minimum amount is 0.1 LINK._

Mainnets and testnets use different versions of the Registry and Registrar
interfaces.

  * Mainnets: Use the v1.x registrar and registry interfaces. See the Mainnet parameters section.
  * Testnets: Use the v2.0 registrar and registry interfaces. See the Testnet parameters section.

## Code examples

### Mainnet parameters

This uses v1.x registrar and registry interfaces.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    // UpkeepIDConsumerExamplev1.sol imports functions from both ./AutomationRegistryInterface1_2.sol and
    // ./interfaces/LinkTokenInterface.sol
    
    import {AutomationRegistryInterface, State, Config} from ""@chainlink/contracts/src/v0.8/interfaces/AutomationRegistryInterface1_2.sol"";
    import {LinkTokenInterface} from ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface KeeperRegistrarInterface {
        function register(
            string memory name,
            bytes calldata encryptedEmail,
            address upkeepContract,
            uint32 gasLimit,
            address adminAddress,
            bytes calldata checkData,
            uint96 amount,
            uint8 source,
            address sender
        ) external;
    }
    
    contract UpkeepIDConsumerExamplev1 {
        LinkTokenInterface public immutable i_link;
        address public immutable registrar;
        AutomationRegistryInterface public immutable i_registry;
        bytes4 registerSig = KeeperRegistrarInterface.register.selector;
    
        constructor(
            LinkTokenInterface _link,
            address _registrar,
            AutomationRegistryInterface _registry
        ) {
            i_link = _link;
            registrar = _registrar;
            i_registry = _registry;
        }
    
        function registerAndPredictID(
            string memory name,
            bytes calldata encryptedEmail,
            address upkeepContract,
            uint32 gasLimit,
            address adminAddress,
            bytes calldata checkData,
            uint96 amount,
            uint8 source
        ) public {
            (State memory state, , ) = i_registry.getState();
            uint256 oldNonce = state.nonce;
            bytes memory payload = abi.encode(
                name,
                encryptedEmail,
                upkeepContract,
                gasLimit,
                adminAddress,
                checkData,
                amount,
                source,
                address(this)
            );
    
            i_link.transferAndCall(
                registrar,
                amount,
                bytes.concat(registerSig, payload)
            );
            (state, , ) = i_registry.getState();
            uint256 newNonce = state.nonce;
            if (newNonce == oldNonce + 1) {
                uint256 upkeepID = uint256(
                    keccak256(
                        abi.encodePacked(
                            blockhash(block.number - 1),
                            address(i_registry),
                            uint32(oldNonce)
                        )
                    )
                );
                // DEV - Use the upkeepID however you see fit
            } else {
                revert(""auto-approve disabled"");
            }
        }
    }
    

#### `registerAndPredictID` parameters

| Name           | Description                                                                                                                             |
|:---------------|:----------------------------------------------------------------------------------------------------------------------------------------|
| name           | Name of Upkeep                                                                                                                          |
| encryptedEmail | Not in use in programmatic registration. Please specify with 0x                                                                         |
| upkeepContract | Address of Keepers-compatible contract that will be automated                                                                           |
| gasLimit       | The maximum amount of gas that will be used to execute your function on-chain                                                           |
| adminAddress   | Address for Upkeep administrator. Upkeep administrator can fund contract.                                                               |
| checkData      | ABI-encoded fixed and specified at Upkeep registration and used in every checkUpkeep. Can be empty (0x)                                 |
| amount         | The amount of LINK (in Wei) to fund your Upkeep. The minimum amount is 0.1 LINK. To fund 0.1 LINK please set this to 100000000000000000 |
| source         | Not in use in programmatic registration. Please specify with 0.                                                                         |
### Testnet parameters

This uses v2.0 registry and registrar interfaces.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    // UpkeepIDConsumerExample.sol imports functions from both ./AutomationRegistryInterface2_0.sol and
    // ./interfaces/LinkTokenInterface.sol
    
    import {LinkTokenInterface} from ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    struct RegistrationParams {
        string name;
        bytes encryptedEmail;
        address upkeepContract;
        uint32 gasLimit;
        address adminAddress;
        bytes checkData;
        bytes offchainConfig;
        uint96 amount;
    }
    
    interface KeeperRegistrarInterface {
        function registerUpkeep(
            RegistrationParams calldata requestParams
        ) external returns (uint256);
    }
    
    contract UpkeepIDConsumerExample {
        LinkTokenInterface public immutable i_link;
        KeeperRegistrarInterface public immutable i_registrar;
    
        constructor(LinkTokenInterface link, KeeperRegistrarInterface registrar) {
            i_link = link;
            i_registrar = registrar;
        }
    
        function registerAndPredictID(RegistrationParams memory params) public {
            // LINK must be approved for transfer - this can be done every time or once
            // with an infinite approval
            i_link.approve(address(i_registrar), params.amount);
            uint256 upkeepID = i_registrar.registerUpkeep(params);
            if (upkeepID != 0) {
                // DEV - Use the upkeepID however you see fit
            } else {
                revert(""auto-approve disabled"");
            }
        }
    }
    

#### `registerAndPredictID` parameters

| Name           | Description                                                                                                                             |
|:---------------|:----------------------------------------------------------------------------------------------------------------------------------------|
| name           | Name of Upkeep                                                                                                                          |
| encryptedEmail | Not in use in programmatic registration. Please specify with 0x                                                                         |
| upkeepContract | Address of Keepers-compatible contract that will be automated                                                                           |
| gasLimit       | The maximum amount of gas that will be used to execute your function on-chain                                                           |
| adminAddress   | Address for Upkeep administrator. Upkeep administrator can fund contract.                                                               |
| checkData      | ABI-encoded fixed and specified at Upkeep registration and used in every checkUpkeep. Can be empty (0x)                                 |
| offchainConfig | Not in use. Please specify as 0x                                                                                                        |
| amount         | The amount of LINK (in Wei) to fund your Upkeep. The minimum amount is 0.1 LINK. To fund 0.1 LINK please set this to 100000000000000000 |
## What's next

  * [› Create a compatible contract for custom logic Upkeep](/chainlink-automation/compatible-contracts/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/register-upkeep.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of setting the `const consumerAddress` in the `request.js` script?,To set the deployed consumer address,{'source': 'https://docs.chain.link/chainlink-functions/resources/add-functions-to-projects/'},The purpose of setting the `const consumerAddress` in the `request.js` script is to specify the address of the consumer contract that will send requests to the Chainlink Functions decentralized oracle network (DON). This address is used to identify the consumer contract and ensure that it has the necessary permissions to interact with the DON.,,"# Adding Chainlink Functions to an Existing Project

  * Overview
  * Before you begin
  * Configure Hardhat
  * Get the dependency contracts and scripts
  * Configure on-chain resources
  * Create a consumer contract
  * Deploy a consumer contract
  * Create and fund a subscription
  * Send requests
  * Create a request script

The [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) lets
you run several example requests, but extra steps are required to add
Chainlink Functions to your existing projects.

If you are new to Chainlink Functions, complete the steps in the [Getting
Started Guide](/chainlink-functions/getting-started) to learn the basics. If
you already have a project, you can skip to the Libraries and Dependencies
section.

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

Using Chainlink Functions to your existing projects requires the following
components:

  * **A consumer contract:** Use this contract to send requests to the Chainlink Functions decentralized oracle network (DON). The consumer contract imports the following dependencies: 
    * [FunctionsClient.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/dev/functions/FunctionsClient.sol): This includes several functions necessary to submit requests to the DON.
    * [ConfirmedOwner.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwner.sol) from the [@chainlink/contracts](https://www.npmjs.com/package/@chainlink/contracts) NPM package.
  * **A Chainlink Functions subscription:** The subscription is used to pay for Chainlink Functions requests when they are fulfilled. You can [create and fund](/chainlink-functions/resources/subscriptions) subscriptions using the starter kit tools, but this guide shows you how to manage subscriptions programmatically.

## Before you begin

This guide assumes you are using a [Hardhat](https://hardhat.org/) JavaScript
project with Node.js, but you can modify it to work with other frameworks. If
you already have a project, you can skip to the Libraries and Dependencies
section.

You must have a wallet with testnet LINK and native tokens to run this
example. This example uses Polygon Mumbai, but you can use any of the
[Supported Networks](/chainlink-functions/supported-networks). You can get
testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai) and
testnet MATIC at the [Polygon Faucet](https://faucet.polygon.technology/). To
learn how to get testnet funds for other networks, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

### Configure Hardhat

If you don't already have a Hardhat project, start one with the following
steps:

  1. Install [Node.js](https://nodejs.org/en/download/). **Note** : Node.js version 18 is required.

  2. Make a new project directory:
    
        mkdir new-functions-project && cd new-functions-project

  3. Create a new Node.js project:
    
        npm init

  4. Install Hardhat as a dev dependency:
    
        npm install --save-dev hardhat

  5. Install the dependency packages:
    
        npm install @chainlink/contracts @chainlink/env-enc @openzeppelin/contracts @openzeppelin/contracts-upgradeable eth-crypto dotenv axios vm2 is-http-url prompt-sync

  6. Create a new Hardhat project. For this example, create a JavaScript project and use the default configurations:
    
        npx hardhat

  7. Remove the `Lock.sol` contract that Hardhat creates by default. This contract is not necessary to compile it for this tutorial.
    
        rm ./contracts/Lock.sol

  8. Use `curl` to get the example hardhat config file `hardhat.config.js`:
    
        curl -o hardhat.config.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/hardhat.config.js

  9. Open `hardhat.config.js`. To use a different network, see the [Supported Networks](/chainlink-functions/supported-networks) page for a list of networks where Chainlink Functions DONs are available. This example uses Polygon Mumbai by default.

  10. For higher security, you should encrypt your environment variables at rest.

    1. Set an encryption password for your environment variables.
        
                npx env-enc set-pw

    2. Run `npx env-enc set` to configure a `.env.enc` file with the basic variables that you need to send your requests to the Polygon Mumbai network.

      * `POLYGON_MUMBAI_RPC_URL`: Set a URL for the Polygon Mumbai testnet. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.

      * `PRIVATE_KEY`: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to [Export a Private Key](https://metamask.zendesk.com/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key). Set this in the `.env` file. **Note** : The Chainlink Functions hardhat starter kit uses your private key to sign any transactions you make such as deploying your consumer contract, creating subscriptions, and making requests.
        
                npx env-enc set

Run the compile command for Hardhat or your framework of choice to make sure
everything is configured correctly. You will see several compile warnings, but
everything is correct if the Solidity files compile successfully. For this
example, run:


    npx hardhat compile

## Get the dependency contracts and scripts

Get the required libraries from the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You
can clone the repo and copy the folders into your existing project manually,
or use a single command to get a tarball through the GitHub API and extract
the folders you need to the correct location in your project.

  1. Open a terminal and change directories to the root of your project. Usually this is the folder with `package.json`.

  2. Run the `curl` command to download the latest tarball from the starter kit `main` branch and then run `tar -xf` with the `--strip` flag to extract only the files you need. The following command combines both steps:

MacOSLinux

    
        curl -L -o ../functions.tar.gz https://api.github.com/repos/smartcontractkit/functions-hardhat-starter-kit/tarball/main &&
    tar -xf ../functions.tar.gz --strip=1 --wildcards smartcontractkit-functions-hardhat-starter-kit-*/contracts/dev smartcontractkit-functions-hardhat-starter-kit-*/contracts/test smartcontractkit-functions-hardhat-starter-kit-*/FunctionsSandboxLibrary smartcontractkit-functions-hardhat-starter-kit-*/contracts/FunctionsConsumer.sol
    
        curl -L -o ../functions.tar.gz https://api.github.com/repos/smartcontractkit/functions-hardhat-starter-kit/tarball/main &&
    tar -xf ../functions.tar.gz --strip=1 -T <(echo -e ""smartcontractkit-functions-hardhat-starter-kit-*/contracts/dev\nsmartcontractkit-functions-hardhat-starter-kit-*/contracts/test\nsmartcontractkit-functions-hardhat-starter-kit-*/FunctionsSandboxLibrary\nsmartcontractkit-functions-hardhat-starter-kit-*/contracts/FunctionsConsumer.sol"")

When you are done, you should have the necessary dependencies in the following
directories:

  * `contracts/dev`
  * `contracts/test`
  * `FunctionsSandboxLibrary`

Run the compile command to make sure all the dependencies are satisfied. Add
missing dependencies or Hardhat configuration options as necessary. For
Hardhat, run `npx hardhat compile`.


    npx hardhat compile

## Configure on-chain resources

The on-chain resources are critical for Chainlink Functions to process your
requests.

  1. Create a consumer contract
  2. Deploy a consumer contract

### Create a consumer contract

Use the [FunctionsConsumer.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/FunctionsConsumer.sol), which is
already in your `./contracts` folder. You can modify it to fit your needs and
redeploy it later. Optionally, you can take an existing contract of your own
and enable it to handle Chainlink Functions requests. Just make sure that it
meets the requirements listed in this guide.

In general, a consumer contract requires several components:

  * To write a Chainlink Functions consumer contract, your contract must import [FunctionsClient.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol). You can read the API reference: [FunctionsClient](/chainlink-functions/api-reference/FunctionsClient).

This contract is not available in an NPM package, so you must download and
import it from within your project.

    
        import {Functions, FunctionsClient} from ""./dev/functions/FunctionsClient.sol"";

  * Use the [Functions.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/Functions.sol) library to get all the functions needed for building a Chainlink Functions request. You can read the API reference: [Functions](/chainlink-functions/api-reference/Functions).
    
        using Functions for Functions.Request;
    

  * The latest request id, latest received response, and latest received error (if any) are defined as state variables. Note `latestResponse` and `latestError` are encoded as dynamically sized byte array `bytes`, so you will still need to decode them to read the response or error:
    
        bytes32 public latestRequestId;
    bytes public latestResponse;
    bytes public latestError;

  * We define the `OCRResponse` event that your smart contract will emit during the callback
    
        event OCRResponse(bytes32 indexed requestId, bytes result, bytes err);

  * Pass the oracle address for your network when you deploy the contract:
    
        constructor(address oracle) FunctionsClient(oracle)

  * At any time, you can change the oracle address by calling the `updateOracleAddress` function.

  * The two remaining functions are:

    * `executeRequest` for sending a request. It receives the JavaScript source code, encrypted secrets, list of arguments to pass to the source code, subscription id, and callback gas limit as parameters. Then:

      * It uses the `Functions`library to initialize the request and add any passed encrypted secrets or arguments. You can read the API Reference for [Initializing a request](/chainlink-functions/api-reference/Functions/#initializerequest), [adding secrets](/chainlink-functions/api-reference/Functions/#addinlinesecrets), and [adding arguments](/chainlink-functions/api-reference/Functions/#addargs).
            
                        Functions.Request memory req;
            req.initializeRequest(Functions.Location.Inline, Functions.CodeLanguage.JavaScript, source);
            if (secrets.length > 0) {
              req.addRemoteSecrets(secrets);
            }
            if (args.length > 0) req.addArgs(args);

      * It sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Finally, it stores the request id in `latestRequestId`.
            
                        bytes32 assignedReqID = sendRequest(req, subscriptionId, gasLimit);
            latestRequestId = assignedReqID;

    * `fulfillRequest` to be invoked during the callback. This function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest` [API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must override the function to implement the callback. The implementation of the callback is straightforward: the contract stores the latest response and error in `latestResponse` and `latestError` before emitting the `OCRResponse` event.
        
                latestResponse = response;
        latestError = err;
        emit OCRResponse(requestId, response, err);

Next, deploy the contract.

### Deploy a consumer contract

You can deploy consumer contracts using the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit), but
this example shows how to deploy the contract programmatically using a script.

  1. Use `curl` to get the example deployment script `deploy.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/deploy.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/deploy.js

  2. Open `deploy.js` in your editor of choice.

  3. Set the `oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  4. Set `const contractName` to the name of the contract that you want Hardhat to deploy. The `ethers.getContractFactory(contractName);` line creates a `ContractFactory` object using the contract that you define. For this example, use `FunctionsConsumer`.
    
        const contractName = ""FunctionsConsumer""
    
    ⋮
    
    const consumerContract = await ethers.getContractFactory(contractName);

  5. Save the file and run the script to deploy your contract. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run ./scripts/deploy.js --network your_network

Example:

    
        npx hardhat run ./scripts/deploy.js --network polygonMumbai

  6. If your contract deployed successfully, you will see the deployed consumer address. Record this address to use later:
    
        Deployed Functions Consumer address: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Next, create and fund your Chainlink Functions subscription.

### Create and fund a subscription

You can use the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to
create and manage your subscriptions. See [Managing Subscriptions](/chainlink-functions/resources/subscriptions) for instructions.

This example shows how to create and manage subscriptions programmatically.
You can create the subscription, fund the subscription, and authorize the
consumer all in one script. If you have not already signed up for limited Beta
access to Chainlink Functions, apply [here](http://functions.chain.link/) to
add your EVM account address to the Allow List.

  1. Ensure that the wallet address you are using to create the subscription has a sufficient LINK balance. You can get testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai). To get testnet funds for other networks, see the [LINK Token Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

  2. Use `curl` to get the example subscription script `functions-sub.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/functions-sub.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/functions-sub.js

  3. Open `functions-sub.js` in your editor of choice.

  4. Set `const linkAmount` with the amount of LINK you want to send to the subscription. You can retrieve extra funds later when you cancel the subscription.
    
        const linkAmount = ""1""

  5. Set `const consumer` to the address of the consumer contract that you deployed:
    
        const consumer = ""0x5484e266c2cD379800e6F27EaB097Bb806647CbF""

  6. Save the file and run the script. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run scripts/functions-sub.js --network your_network

Example:

    
        npx hardhat run scripts/functions-sub.js --network polygonMumbai

  7. If the script is successful, you the terminal prints your subscription ID. Record this ID to use for Chainlink Functions requests. You should see output similar to the following example:
    
        Subscription created with ID: 917
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Subscription 917 funded with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Adding consumer contract address 0x5484e266c2cD379800e6F27EaB097Bb806647CbF to subscription 917
    Authorized consumer contract: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Now that the consumer contract is deployed and the subscription is created and
funded with LINK, the on-chain resources are ready to handle your requests.
Next, create JavaScript code that you want to run on the DON, configure
arguments for the code, and create a script to send your request.

## Send requests

After your on-chain resources are configured, you can send Chainlink Functions
requests to the DON. This can be done from a Web3 application, script, another
on-chain smart contract, or any other location capable of submitting requests
to your consumer contract. This example shows you how to generate a request,
encrypt secrets, send your request, and read the fulfillment response.

Each request has the following components:

  * **Source code:** JavaScript code that will run on the DON.
  * **Arguments:** Optional arguments for the source code. The arguments that you need are defined in your source code. Depending on how you configured your source, you might not need any arguments at all.
  * **Secrets:** Optional secrets that your source code needs to access APIs or other interfaces. See the [Using Secrets in Requests](/chainlink-functions/tutorials/api-use-secrets) and [Using Off-chain Secrets](/chainlink-functions/tutorials/api-use-secrets-offchain) tutorials for examples.

### Create a request script

If you already have source code or want to write your own source code, put it
in a file in your project. Later, you can specify the path to this file before
you submit your request.

For this example, download some example source code and create a script to
assemble the required components. The script will read your source code,
define arguments, encrypt secrets, and send requests to your consumer
contract. This example script does not require Hardhat, so you can modify it
to run in a browser using Ethers or another framework.

  1. Use `curl` to get the example source code. This code runs on each node in the DON and returns a response to your consumer contract. For this example, use the source from the [Call an API](/chainlink-functions/tutorials/api-query-parameters) tutorial. The following `curl` request creates a file named `Functions-request-source.js` with the source code:
    
        curl -o Functions-request-source.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/Functions-request-source.js

  2. Get the example script and put it in the `./scripts` directory:
    
        curl -o ./scripts/request.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/request.js

  3. Edit the `request.js` script and set your deployed consumer address in `const consumerAddress`:
    
        const consumerAddress = 0x5484e266c2cd379800e6f27eab097bb806647cbf

  4. Set `const subscriptionId` to your Chainlink Functions subscription ID. This must be the same ID that your consumer contract is authorized to use. You can [add a consumer contract to a subscription](/chainlink-functions/resources/subscriptions#add-a-consumer-contract-to-a-subscription) later if you need to.
    
        const subscriptionId = 917

  5. Set `const consumerAbiPath` to the ABI file that you created when you ran `npx hardhat compile`. The ABI tells Ethers how to interact with your deployed contract. If you compiled and deployed `FunctionsConsumer.sol`, set a path like the following example:
    
        const consumerAbiPath = ""./artifacts/contracts/FunctionsConsumer.sol/FunctionsConsumer.json""

  6. Set `const source` with the path to the request source code that you downloaded earlier:
    
        const source = ./Functions-request-source.js

  7. Set `const args` with an array of arguments for the DON to use when it runs your source. If you look at the `Functions-request-source.js` file, you can see that it requires two arguments. The args define which assets to retrieve from the data source URL.
    
        const args = [""ETH"", ""USD""]

  8. Set `const oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  9. Set `const oracleAbiPath` to the ABI for the oracle contract. If you downloaded and compiled the dependencies for deploying your consumer contract, the oracle ABI is already generated in `./artifacts/contracts/dev/functions/`:
    
        const oracleAbiPath = ""./artifacts/contracts/dev/functions/FunctionsOracle.sol/FunctionsOracle.json""

  10. Secrets are not required for this example.

  11. Save and close the script.

  12. Run the script to send the request to the DON.
    
        npx hardhat run scripts/request.js --network your_network

Example:

    
        npx hardhat run scripts/request.js --network polygonMumbai

If the script runs successfully, the script reads your consumer contract and
prints the stored value that the DON returned.


    Waiting 2 blocks for transaction 0x949184e7b605f034ce1d1d954973dc7132efb815bfa4861c54774cee457566d8 to be confirmed...
    
    Request 0xb3a4f9f47caeb83c5125ee61e2db1ca41beaa8a6781fb3c4364b4d394c40bc6b initiated
    Waiting for fulfillment...
    
    
    Request 0xb3a4f9f47caeb83c5125ee61e2db1ca41beaa8a6781fb3c4364b4d394c40bc6b fulfilled!
    Response returned to client contract represented as a hex string: 180972

Now you have the tools you need to build your own applications that use
Chainlink Functions. Modify `Functions-request-source.js` and your input
arguments to try out different capabilities. For more examples, see the
[Tutorials](/chainlink-functions/tutorials) section.

## What's next

  * [› Try out the Chainlink Functions Tutorials](/chainlink-functions/tutorials)
  * [› Read the Concepts page to learn about the core concepts behind Chainlink Functions](/chainlink-functions/resources/concepts)
  * [› Read the Architecture to understand how Chainlink Functions operates](/chainlink-functions/resources/architecture)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/add-functions-to-projects.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Programmatic Subscription

  * Overview
  * Modifying subscriptions and configurations
  * Subscription manager contract
  * Funding and requesting simultaneously

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

How you manage the subscription depends on your randomness needs. You can
configure your subscriptions using the [Subscription
Manager](/vrf/v2/subscription/ui), but these examples demonstrate how to
create your subscription and add your consumer contracts programmatically. For
these examples, the contract owns and manages the subscription. Any wallet can
provide funding to those subscriptions.

You can view and monitor your subscriptions in the [Subscription
Manager](/vrf/v2/subscription/ui) even if you create them programmatically. Go
to [vrf.chain.link](https://vrf.chain.link) to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    * `acceptSubscriptionOwnerTransfer(uint64 subId)`.
  * View the subscription with `getSubscription(uint64 subId)`.
  * Cancel the subscription with `cancelSubscription(uint64 subId)`.

To send LINK to the subscription balance, use the LINK token interface with
`LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(subId))`.
Any wallet can fund a subscription.

See the example in the Subscription manager contract section to learn how to
create a contract that can change your subscription configuration.

## Subscription manager contract

In this example, the contract operates as a subscription owner and can run
functions to add consuming contracts to the subscription. The consuming
contracts must include the `requestRandomWords()` function with the correct
coordinator parameters and the correct subscription ID to request random
values and use the subscription balance. The consuming contracts must also
include the `fulfillRandomWords()` function to receive the random values.

Subscription owners and consumers do not have to be separate. This contract
not only allows adding consumers with `addConsumer(address consumerAddress)`
but can also act as a consumer by running its own `requestRandomWords()`
function. This example contract includes a `createNewSubscription()` function
in the `constructor()` that creates the subscription and adds itself as a
consumer automatically when you deploy it.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that also owns and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Sepolia coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    
        // Sepolia LINK token contract. For other networks, see
        // https://docs.chain.link/docs/vrf-contracts/#configurations
        address link_token_contract = 0x779877A7B0D9E8603169DdbD7836e478b4624789;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 keyHash =
            0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;
    
        // A reasonable default is 100000, but this value could be different
        // on other networks.
        uint32 callbackGasLimit = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 requestConfirmations = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
        uint32 numWords = 2;
    
        // Storage parameters
        uint256[] public s_randomWords;
        uint256 public s_requestId;
        uint64 public s_subscriptionId;
        address s_owner;
    
        constructor() VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            LINKTOKEN = LinkTokenInterface(link_token_contract);
            s_owner = msg.sender;
            //Create a new subscription when you deploy the contract.
            createNewSubscription();
        }
    
        // Assumes the subscription is funded sufficiently.
        function requestRandomWords() external onlyOwner {
            // Will revert if subscription is not set and funded.
            s_requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
        }
    
        function fulfillRandomWords(
            uint256 /* requestId */,
            uint256[] memory randomWords
        ) internal override {
            s_randomWords = randomWords;
        }
    
        // Create a new subscription when the contract is initially deployed.
        function createNewSubscription() private onlyOwner {
            s_subscriptionId = COORDINATOR.createSubscription();
            // Add this contract as a consumer of its own subscription.
            COORDINATOR.addConsumer(s_subscriptionId, address(this));
        }
    
        // Assumes this contract owns link.
        // 1000000000000000000 = 1 LINK
        function topUpSubscription(uint256 amount) external onlyOwner {
            LINKTOKEN.transferAndCall(
                address(COORDINATOR),
                amount,
                abi.encode(s_subscriptionId)
            );
        }
    
        function addConsumer(address consumerAddress) external onlyOwner {
            // Add a consumer contract to the subscription.
            COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
        }
    
        function removeConsumer(address consumerAddress) external onlyOwner {
            // Remove a consumer contract from the subscription.
            COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
        }
    
        function cancelSubscription(address receivingWallet) external onlyOwner {
            // Cancel the subscription and send the remaining LINK to a wallet address.
            COORDINATOR.cancelSubscription(s_subscriptionId, receivingWallet);
            s_subscriptionId = 0;
        }
    
        // Transfer this contract's funds to an address.
        // 1000000000000000000 = 1 LINK
        function withdraw(uint256 amount, address to) external onlyOwner {
            LINKTOKEN.transfer(to, amount);
        }
    
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }
    

To use this contract, compile and deploy it in Remix.

  1. Open the contract in [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol).

  2. Compile and deploy the contract using the Injected Provider environment. The contract includes all of the configuration variables that you need, but you can edit them if necessary. For a full list of available configuration variables, see the [Supported Networks](/vrf/v2/subscription/supported-networks) page.

This contract automatically creates a new subscription when you deploy it.
Read the `s_subscriptionId` variable to find your subscription ID. You can use
this value to find the subscription at
[vrf.chain.link](https://vrf.chain.link).

  3. In this example, the `topUpSubscription()` function sends LINK from your contract to the subscription. Fund your contract with at least three testnet LINK. Alternatively, you can send LINK directly to the subscription at [vrf.chain.link](https://vrf.chain.link). Any address can provide funding to a subscription balance. If you need testnet LINK, you can get it from [faucets.chain.link](https://faucets.chain.link/sepolia/).

  4. Run the `topUpSubscription()` function to send LINK from your contract to your subscription balance. For this example, specify a value of `3000000000000000000`, which is equivalent to three LINK.

  5. Run the `requestRandomWords()` function. The request might take several minutes to process. Track the pending request status at [vrf.chain.link](https://vrf.chain.link).

  6. You can also add and test consumer contracts using the same programmatic subscription process:

    1. Create and deploy a consumer contract that includes the following components:

      * The `requestRandomWords()` function and the required variables and your subscription ID.
      * The `fulfillRandomWords()` callback function.

You can use the example from the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number/#analyzing-the-contract) guide.

    2. After you deploy the consumer contract, add it to the subscription as an approved consumer using the `addConsumer()` function on your subscription manager contract. Specify the address of your consumer contract.

    3. On the consumer contract, run the `requestRandomWords()` function to request and receive random values. The request might take several minutes to process. Track the pending request status at [vrf.chain.link](https://vrf.chain.link).

The consumer contract can continue to make requests until your subscription
balance runs out. The subscription manager contract must maintain sufficient
balance in the subscription so that the consumers can continue to operate.

    4. If you need to remove consumer contracts from the subscription, use the `removeConsumer()` function. Specify the address of the consumer contract to be removed.

  7. When you are done with your contracts and the subscription, run the `cancelSubscription()` function to close the subscription and send the remaining LINK to your wallet address. Specify the address of the receiving wallet.

## Funding and requesting simultaneously

You can fund a subscription and request randomness in a single transaction.
You must estimate how much the transaction might cost and determine the amount
of funding to send to the subscription yourself. See the [Subscription
billing](/vrf/v2/subscription/#subscription-limits) page to learn how to
estimate request costs.


    // Assumes this contract owns link
    // You must estimate LINK cost yourself based on the gas lane and limits.
    // 1_000_000_000_000_000_000 = 1 LINK
    function fundAndRequestRandomWords(uint256 amount) external onlyOwner {
        LINKTOKEN.transferAndCall(
            address(COORDINATOR),
            amount,
            abi.encode(s_subscriptionId)
        );
        // Will revert if subscription is not set and funded.
        s_requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
    }
    

Add this function to your contracts if you need to provide funding
simultaneously with your requests. The `transferAndCall()` function sends LINK
from your contract to the subscription, and the `requestRandomWords()`
function requests the random words. Your contract still needs the
`fulfillRandomWords()` callback function to receive the random values.

## What's next

  * [› Subscription Manager UI](/vrf/v2/subscription/ui)
  * [› Security Considerations](/vrf/v2/security)
  * [› Best Practices](/vrf/v2/best-practices)
  * [› Migrating from VRF v1 to v2](/vrf/v2/subscription/migration-from-v1)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/examples/programmatic-subscription.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the Subscription Manager in Chainlink VRF?,"The Subscription Manager lets you create an account and pre-pay for VRF requests, so that funding of all your application requests are managed in a single location.",{'source': 'https://docs.chain.link/getting-started/intermediates-tutorial/'},"The purpose of the Subscription Manager in Chainlink VRF is to create and manage a subscription account that can be funded with LINK tokens and used to request random numbers without having to provide funding each time. The Subscription Manager allows for the reduction of gas costs and provides a simple way to fund the use of Chainlink products from a single location. It also supports the addition and removal of consuming contracts, maintains a subscription balance, and sets limits for gas price and callback gas. The Subscription Manager is an important component in the process of generating random numbers using the subscription method in Chainlink VRF.

","
- https://docs.chain.link/vrf/v2/subscription/
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-5/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-5/course.md","# Subscription Method

  * Overview
  * Subscriptions
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits
  * Subscription limits
  * Coordinator contract limits

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This section explains how to generate random numbers using the subscription
method.

## Subscriptions

VRF v2 requests receive funding from subscription accounts. The [Subscription
Manager](/vrf/v2/subscription/ui) lets you create an account and pre-pay for
VRF v2, so you don't provide funding each time your application requests
randomness. This reduces the total gas cost to use VRF v2. It also provides a
simple way to fund your use of Chainlink products from a single location, so
you don't have to manage multiple wallets across several different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends on current network conditions. The callback gas depends
on your callback function, and the number of random values in your request.
The cost of each request is final only after the transaction is complete, but
you define the limits you are willing to spend for the request with the
following variables:

  * **Gas lane:** The maximum gas price you are willing to pay for a request in wei. Define this limit by specifying the appropriate `keyHash` in your request. The limits of each gas lane are important for handling gas price spikes when Chainlink VRF bumps the gas price to fulfill your request quickly.

  * **Callback gas limit:** Specifies the maximum amount of gas you are willing to spend on the callback request. Define this limit by specifying the `callbackGasLimit` value in your request.

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF subscription
request, and registering a smart contract with a VRF subscription account:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can only be initiated by EOAs.
  * Smart contract: A contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFConsumerBaseV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol).

  2. Your contract must implement the implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling `requestRandomWords` of the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol). Include the following parameters in your request:

    * `keyHash`: Identifier that maps to a job and a private key on the VRF service and that represents a specified gas lane. If your request is urgent, specify a gas lane with a higher gas price limit. The configuration for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).
    * `s_subscriptionId`: The subscription ID that the consuming contract is registered to. LINK funds are deducted from this subscription.
    * `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).
    * `callbackGasLimit`: The maximum amount of gas a user is willing to pay for completing the callback VRF function. Note that you cannot put a value larger than maxGasLimit of the VRF Coordinator contract (read coordinator contract limits for more details).
    * `numWords`: The number of random numbers to request. The maximum random values that can be requested for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).

### How VRF processes your request

After you submit your request, it is processed using the Request & Receive
Data cycle. The VRF coordinator processes the request and determines the final
charge to your subscription using the following steps:

  1. The VRF coordinator emits an event.

  2. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

  3. The VRF coordinator verifies the proof on-chain, then it calls back the consuming contract `fulfillRandomWords` function.

## Limits

Chainlink VRF v2 has some subscription limits and coordinator contract limits.

### Subscription limits

Subscriptions are required to maintain a minimum balance, and they can support
a limited number of consuming contracts.

#### Minimum subscription balance

Each subscription must maintain a minimum balance to fund requests from
consuming contracts. This minimum balance requirement serves as a buffer
against gas volatility by ensuring that all your requests have more than
enough funding to go through. If your balance is below the minimum, your
requests remain pending for up to 24 hours before they expire. After you add
sufficient LINK to a subscription, pending requests automatically process as
long as they have not expired.

In the Subscription Manager, the minimum subscription balance is displayed as
the **Max Cost** , and it indicates the amount of LINK you need to add for a
pending request to process. After the request is processed, only the amount
actually consumed by the request is deducted from your balance. For example,
if your minimum balance is 10 LINK, but your subscription balance is 5 LINK,
you need to add at least 5 more LINK for your request to process. This does
not mean that your request will ultimately cost 10 LINK. If the request
ultimately costs 3 LINK after it has processed, then 3 LINK is deducted from
your subscription balance.

The minimum subscription balance must be sufficient for each new consuming
contract that you add to a subscription. For example, the minimum balance for
a subscription that supports 20 consuming contracts needs to cover all the
requests for all 20 contracts, while a subscription with one consuming
contract only needs to cover that one contract.

For one request, the required size of the minimum balance depends on the gas
lane and the size of the request. For example, a consuming contract that
requests one random value will require a smaller minimum balance than a
consuming contract that requests 50 random values. In general, you can
estimate the required minimum LINK balance using the following formula where
max verification gas is always 200,000 gwei.


    (((Gas lane maximum * (Max verification gas + Callback gas limit)) / (1,000,000,000 Gwei/ETH)) / (ETH/LINK price)) + LINK premium = Minimum LINK

Here is the same formula, broken out into steps:


    Gas lane maximum * (Max verification gas + Callback gas limit) = Total estimated gas (Gwei)
    Total estimated gas (Gwei) / 1,000,000,000 Gwei/ETH = Total estimated gas (ETH)
    Total estimated gas (ETH) / (ETH/LINK price) = Total estimated gas (LINK)
    Total estimated gas (LINK) + LINK premium = Minimum subscription balance (LINK)

#### Maximum consuming contracts

Each subscription supports up to 100 consuming contracts. If you need more
than 100 consuming contracts, create multiple subscriptions.

### Coordinator contract limits

You can see the configuration for each network on the [Supported
networks](/vrf/v2/subscription/supported-networks) page. You can also view the
full configuration for each coordinator contract directly in Etherscan. As an
example, view the [Ethereum Mainnet VRF v2 coordinator
contract](https://etherscan.io/token/0x271682DEB8C4E0901D1a1550aD2e64D568E69909#readContract)
configuration.

  * Each coordinator has a `MAX_NUM_WORDS` parameter that limits the maximum number of random values you can receive in each request.
  * Each coordinator has a `maxGasLimit` parameter, which is the maximum allowed `callbackGasLimit` value for your requests. You must specify a sufficient `callbackGasLimit` to fund the callback request to your consuming contract. This depends on the number of random values you request and how you process them in your `fulfillRandomWords()` function. If your `callbackGasLimit` is not sufficient, the callback fails but your subscription is still charged for the work done to generate your requested random values.

## What's next

  * [› Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 5: VRF Subscriptions

# Subscription Manager Contract

Now that we learned more about the theoretical background, let’s get practical. We want to create and manage a subscription contract. We will use the example contract that you can find here on [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js). It shows an example implementation of a VRF v2 Subscription manager for the Goerli network. But you can also adjust it to work with other networks by changing the code's hardcoded addresses. You can find a complete list of available networks [here](https://docs.chain.link/docs/vrf-contracts/#configurations).

Hint: This course assumes you are already familiar with the Architecture of Chainlink VRF from [VRFv2 Introduction Chapter 4](https://www.chainlink.education/vrfIntroduction/chapter-4).

Generally, consumer contracts must implement the requestRandomWords() function providing coordinator parameters and subscription ID. This function is used to create random values. A second function, fulfillRandomWords(), must be implemented to receive the random values. Learn about how to implement the basics of such a contract in [chapters 6-12](https://www.chainlink.education/vrfIntroduction/chapter-6) from the introduction course.

We want to focus on the mentioned functions here and show how to manage subscriptions in this contract. So let’s start by creating a new subscription:

<Highlight class=""language-javascript"">
uint64 public s_subscriptionId;
 function createNewSubscription() private onlyOwner {
   s_subscriptionId = COORDINATOR.createSubscription();
   COORDINATOR.addConsumer(s_subscriptionId, address(this));
 }
</Highlight>

We shall call this function when the contract is initially deployed using the constructor. The COORDINATOR is set to the COORDINATOR address in your network of choice. It is used to call the createSubscription() function. This returns an ID which is then used to add a new consumer using the same COORDINATOR contract. That’s already all you need to create a subscription and add a consumer. Now we can expand this and add or remove consumers using the corresponding functions (addConsumer, removeConsumer) to generate random numbers.

<Highlight class=""language-javascript"">
 function addConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
 }
 
 function removeConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
 }
</Highlight>

This was pretty straight forward. Before we implement the mandatory functions mentioned in the beginning, we will also add a function to topup the subscription with LINK tokens. That means we pre-fund the subscription so it can then be used to request random numbers without paying again, like in VRF v1.

<Highlight class=""language-javascript"">
 function topUpSubscription(uint256 amount) external onlyOwner {
   LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subscriptionId));
 }
</Highlight>

We assume that the contract itself has Link that we can use here. LINKTOKEN is the Link token contract. Now that we have the ability to manage consumers and funding, we will implement a simple function to request random words and received a request ID that we can use to get the random words. If the subscription is not set and funded it will revert. Note that the request might take several minutes to process.

<Highlight class=""language-javascript"">
function requestRandomWords() external onlyOwner {
   s_requestId = COORDINATOR.requestRandomWords(
     keyHash,
     s_subscriptionId,
     requestConfirmations,
     callbackGasLimit,
     numWords
   );
 }
</Highlight>

You can see that we don’t need to provide any parameters here though the COORDINATOR expects 5 of them. We have hard coded these values in the contract, but you could also ask the caller of the function to provide these values depending on your implementation. Let’s look into each parameter.

- **keyHash** defines which gas lane to use, which specifies the maximum gas price
- **s_subscriptionId** is set when the contract is deployed and a new subscription is created.
- **requestConfirmations** is three by default but you can set it higher.
- **callbackGasLimit** allows to set the the limit so more complex contracts can be developed using a single transaction to get verifiable randomness to their contract.
- **numWords** defines the number of random values which we want to get in one request.

So now that we have a function to request random words, we still need to implement a function to actually get the random words. This function is then called as a callback by the COORDINATOR to set the random values.

<Highlight class=""language-javascript"">
 uint256[] public s_randomWords;
 function fulfillRandomWords(
   uint256, /* requestId */
   uint256[] memory randomWords
 ) internal override {
   s_randomWords = randomWords;
 }
</Highlight>

The results are stored as a uint256 array. It can now be used by other functions or applications for further processing. If you wanted to have a random number between 0 and 10 you would simply use modulo: s_randomWords[0] % 10.


:::NEXT DOC:::

#####Chapter 5: VRF Subscriptions

# Subscribing to the VRF
Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number. 

## VRFv2
In VRFv2, the most recent version of the VRF, the concept of a subscription was added. What is a subscription? Essentially, it's an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. Once a subscription is set-up a consumer contract can then request randomness, the VRF respondes with a random number and proof, and then after the random number is included on-chain the VRF is paid with some of the LINK prepaid in the subscription.

The power that comes from this subscription model is that now consumer contracts have much more flexibility in requesting random numbers. Before subscriptions it was a static price, and the VRF always returned a single random number. 
 
But what if the consumer contract needs more than one random number? The consumer contract can now specify how many random numbers it wants to request.  
 
What if the consumer contract needs the random number to be included very fast by paying a higher gas price? The consumer contract can now request how much it's willing to pay for gas. This is called the **gas lane**. 
 
What if the consumer contract needs to run some heavy calculations after recieving the random number? It can set a limit to how much gas will be spent by the VRF when submitting the random number. This is called the **callbackGasLimit**.

And because this is all pre-paid via the subscription, and credited from the subscription amount after the VRF has responded with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! 

:::NEXT DOC:::

#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!
"
What is the purpose of operating a Chainlink node?,"Operating a Chainlink node allows you to be part of the Chainlink Network, helping developers build hybrid smart contracts, giving them access to real-world data and services.",{'source': 'https://docs.chain.link/chainlink-nodes/'},,,"# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Configuring Chainlink Nodes

  * Overview
  * TOML Configuration
  * Changes to node configuration starting in v1.1.0 nodes
  * Essential environment variables
  * DATABASE_URL
  * General Node Configuration
  * CL_CONFIG
  * CHAIN_TYPE
  * CHAINLINK_DEV
  * EXPLORER_ACCESS_KEY
  * EXPLORER_SECRET
  * EXPLORER_URL
  * ROOT
  * TELEMETRY_INGRESS_UNICONN
  * TELEMETRY_INGRESS_LOGGING
  * TELEMETRY_INGRESS_URL
  * TELEMETRY_INGRESS_SERVER_PUB_KEY
  * TELEMETRY_INGRESS_BUFFER_SIZE
  * TELEMETRY_INGRESS_MAX_BATCH_SIZE
  * TELEMETRY_INGRESS_SEND_INTERVAL
  * TELEMETRY_INGRESS_SEND_TIMEOUT
  * TELEMETRY_INGRESS_USE_BATCH_SEND
  * Chains
  * SOLANA_ENABLED
  * EVM_ENABLED
  * Database Settings
  * MIGRATE_DATABASE
  * ORM_MAX_IDLE_CONNS
  * ORM_MAX_OPEN_CONNS
  * Database Global Lock
  * DATABASE_LOCKING_MODE
  * ADVISORY_LOCK_CHECK_INTERVAL
  * ADVISORY_LOCK_ID
  * LEASE_LOCK_DURATION
  * LEASE_LOCK_REFRESH_INTERVAL
  * Database Automatic Backups
  * DATABASE_BACKUP_FREQUENCY
  * DATABASE_BACKUP_MODE
  * DATABASE_BACKUP_URL
  * DATABASE_BACKUP_DIR
  * Logging
  * JSON_CONSOLE
  * LOG_FILE_DIR
  * LOG_LEVEL
  * LOG_SQL
  * LOG_FILE_MAX_SIZE
  * LOG_FILE_MAX_AGE
  * LOG_FILE_MAX_BACKUPS
  * LOG_UNIX_TS
  * AUDIT_LOGGER_FORWARD_TO_URL
  * AUDIT_LOGGER_HEADERS
  * AUDIT_LOGGER_JSON_WRAPPER_KEY
  * Nurse service (auto-pprof)
  * AUTO_PPROF_ENABLED
  * AUTO_PPROF_PROFILE_ROOT
  * AUTO_PPROF_POLL_INTERVAL
  * AUTO_PPROF_GATHER_DURATION
  * AUTO_PPROF_GATHER_TRACE_DURATION
  * AUTO_PPROF_MAX_PROFILE_SIZE
  * AUTO_PPROF_CPU_PROFILE_RATE
  * AUTO_PPROF_MEM_PROFILE_RATE
  * AUTO_PPROF_BLOCK_PROFILE_RATE
  * AUTO_PPROF_MUTEX_PROFILE_FRACTION
  * AUTO_PPROF_MEM_THRESHOLD
  * AUTO_PPROF_GOROUTINE_THRESHOLD
  * Chainlink Web Server
  * ALLOW_ORIGINS
  * AUTHENTICATED_RATE_LIMIT
  * AUTHENTICATED_RATE_LIMIT_PERIOD
  * BRIDGE_CACHE_TTL
  * BRIDGE_RESPONSE_URL
  * HTTP_SERVER_WRITE_TIMEOUT
  * CHAINLINK_PORT
  * SECURE_COOKIES
  * SESSION_TIMEOUT
  * UNAUTHENTICATED_RATE_LIMIT
  * UNAUTHENTICATED_RATE_LIMIT_PERIOD
  * Web Server MFA
  * MFA_RPID
  * MFA_RPORIGIN
  * Web Server TLS
  * CHAINLINK_TLS_HOST
  * CHAINLINK_TLS_PORT
  * CHAINLINK_TLS_REDIRECT
  * TLS_CERT_PATH
  * TLS_KEY_PATH
  * EVM/Ethereum Legacy Environment Variables
  * ETH_URL
  * ETH_HTTP_URL
  * EVM_NODES
  * ETH_SECONDARY_URLS
  * EVM/Ethereum Global Settings
  * ETH_CHAIN_ID
  * EVM_RPC_ENABLED
  * EVM/Ethereum Chain-specific Overrides
  * BALANCE_MONITOR_ENABLED
  * BLOCK_BACKFILL_DEPTH
  * BLOCK_BACKFILL_SKIP
  * ETH_TX_REAPER_INTERVAL
  * ETH_TX_REAPER_THRESHOLD
  * ETH_TX_RESEND_AFTER_THRESHOLD
  * ETH_FINALITY_DEPTH
  * ETH_HEAD_TRACKER_HISTORY_DEPTH
  * ETH_HEAD_TRACKER_MAX_BUFFER_SIZE
  * ETH_HEAD_TRACKER_SAMPLING_INTERVAL
  * ETH_LOG_BACKFILL_BATCH_SIZE
  * ETH_LOG_POLL_INTERVAL
  * ETH_RPC_DEFAULT_BATCH_SIZE
  * LINK_CONTRACT_ADDRESS
  * MIN_INCOMING_CONFIRMATIONS
  * MIN_OUTGOING_CONFIRMATIONS
  * MINIMUM_CONTRACT_PAYMENT_LINK_JUELS
  * NODE_NO_NEW_HEADS_THRESHOLD
  * NODE_POLL_FAILURE_THRESHOLD
  * NODE_POLL_INTERVAL
  * NODE_SELECTION_MODE
  * NODE_SYNC_THRESHOLD
  * EVM Gas Controls
  * Configuring your ETH node
  * EVM_EIP1559_DYNAMIC_FEES
  * ETH_GAS_BUMP_PERCENT
  * ETH_GAS_BUMP_THRESHOLD
  * ETH_GAS_BUMP_TX_DEPTH
  * ETH_GAS_BUMP_WEI
  * EVM_GAS_FEE_CAP_DEFAULT
  * ETH_GAS_LIMIT_DEFAULT
  * ETH_GAS_LIMIT_MAX
  * ETH_GAS_LIMIT_MULTIPLIER
  * ETH_GAS_LIMIT_TRANSFER
  * ETH_GAS_PRICE_DEFAULT
  * EVM_GAS_TIP_CAP_DEFAULT
  * EVM_GAS_TIP_CAP_MINIMUM
  * ETH_MAX_GAS_PRICE_WEI
  * ETH_MAX_IN_FLIGHT_TRANSACTIONS
  * ETH_MAX_QUEUED_TRANSACTIONS
  * ETH_MIN_GAS_PRICE_WEI
  * ETH_GAS_LIMIT_OCR_JOB_TYPE
  * ETH_GAS_LIMIT_DR_JOB_TYPE
  * ETH_GAS_LIMIT_VRF_JOB_TYPE
  * ETH_GAS_LIMIT_FM_JOB_TYPE
  * ETH_GAS_LIMIT_KEEPER_JOB_TYPE
  * ETH_NONCE_AUTO_SYNC
  * ETH_USE_FORWARDERS
  * EVM/Ethereum Gas Price Estimation
  * GAS_ESTIMATOR_MODE
  * BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE
  * BLOCK_HISTORY_ESTIMATOR_BLOCK_HISTORY_SIZE
  * BLOCK_HISTORY_ESTIMATOR_BLOCK_DELAY
  * BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS
  * BLOCK_HISTORY_ESTIMATOR_TRANSACTION_PERCENTILE
  * EVM/Ethereum Transaction Simulation
  * Job Pipeline and tasks
  * DEFAULT_HTTP_LIMIT
  * DEFAULT_HTTP_TIMEOUT
  * FEATURE_EXTERNAL_INITIATORS
  * JOB_PIPELINE_MAX_RUN_DURATION
  * JOB_PIPELINE_MAX_SUCCESSFUL_RUNS
  * JOB_PIPELINE_REAPER_INTERVAL
  * JOB_PIPELINE_REAPER_THRESHOLD
  * JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH
  * OCR
  * FEATURE_OFFCHAIN_REPORTING
  * OCR_KEY_BUNDLE_ID
  * OCR_MONITORING_ENDPOINT
  * OCR_TRANSMITTER_ADDRESS
  * P2P_NETWORKING_STACK
  * Networking Stack V1
  * Networking Stack V2
  * Keeper
  * KEEPER_GAS_PRICE_BUFFER_PERCENT
  * KEEPER_GAS_TIP_CAP_BUFFER_PERCENT
  * KEEPER_BASE_FEE_BUFFER_PERCENT
  * KEEPER_MAXIMUM_GRACE_PERIOD
  * KEEPER_REGISTRY_CHECK_GAS_OVERHEAD
  * KEEPER_REGISTRY_PERFORM_GAS_OVERHEAD
  * KEEPER_REGISTRY_SYNC_INTERVAL
  * KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE
  * KEEPER_TURN_LOOK_BACK
  * CLI Client
  * ADMIN_CREDENTIALS_FILE
  * CLIENT_NODE_URL
  * INSECURE_SKIP_VERIFY
  * Notes on setting environment variables

Recent versions of the Chainlink node use sensible defaults for most
configuration variables. You do not need to change much to get a standard
deployment working.

Not all environment variables are documented here. Any undocumented
environment variable is subject to change in future releases. In almost all
cases, you should leave any environment variable not listed here to its
default value unless you really understand what you are doing.

To reiterate: _If you have an environment variable set that is not listed
here, and you don't know exactly why you have it set, you should remove it!_

The environment variables listed here are explicitly supported and current as
of Chainlink node v1.3.0.

### TOML Configuration

TOML configuration for Chainlink nodes is stable and recommended for mainnet
deployments. TOML configuration will be the only supported configuration
method starting with `v2.0.0`. Enable TOML configuration by specifying the
`-config <filename>.toml` flag with the path to your TOML file. Alternatively,
you can specify the raw TOML config in the [`CL_CONFIG` environment
variable](/chainlink-nodes/v1/configuration#cl_config). See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/CONFIG.md)
and
[SECRETS.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/SECRETS.md)
on GitHub to learn more.

## Changes to node configuration starting in v1.1.0 nodes

As of Chainlink node v1.1.0 and up, the way nodes manage configuration is
changing. Previously, environment variables exclusively handled all node
configuration. Although this configuration method worked well in the past, it
has its limitations. Notably, it doesn't mesh well with chain-specific
configuration profiles.

For this reason, Chainlink nodes are moving towards a model where you set
variables using the API, CLI, or GUI, and the configuration is saved in the
database. We encourage you to become familiar with this model because it is
likely that nodes will continue to move away from environment variable
configuration in the future.

As of v1.1.0, Chainlink nodes still support environment variables to configure
node settings and chain-specific settings. If the environment variable is set,
it overrides any chain-specific, job-specific, or database configuration
setting. The log displays a warning to indicate when an override happens, so
you know when variables lower in the hierarchy are being ignored.

Your node applies configuration settings using following hierarchy:

  1. Environment variables
  2. Chain-specific variables
  3. Job-specific variables

## Essential environment variables

These are the only environment variables that are _required_ for a Chainlink
node to run.

### DATABASE_URL

**Required**

  * Default: _none_

The PostgreSQL URI to connect to your database. Chainlink nodes require
Postgres versions >= 11. See the [Running a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node) for an example.

## General Node Configuration

### CL_CONFIG

This environment variable is used to set static configuration using TOML
format. Specify the raw TOML config in this environment variable. Unlike the
`-config` flag, it does not accept a path to a TOML file.

See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/CONFIG.md)
and
[SECRETS.md](https://github.com/smartcontractkit/chainlink/blob/v1.13.0/docs/SECRETS.md)
on GitHub to learn more.

### CHAIN_TYPE

  * Default: _none_

CHAIN_TYPE overrides all chains and forces them to act as a particular chain
type. An up-to-date list of chain types is given in
[`chaintype.go`](https://github.com/smartcontractkit/chainlink/blob/v1.3.0/core/chains/chaintype.go).

This variable enables some chain-specific hacks and optimizations. It is
recommended not to use this environment variable and set the chain-type on a
per-chain basis instead.

### CHAINLINK_DEV

  * Default: `""false""`

Setting `CHAINLINK_DEV` to `true` enables development mode. Do not use this
for production deployments. It can be useful for enabling experimental
features and collecting debug information in test environments.

### EXPLORER_ACCESS_KEY

  * Default: _none_

The access key for authenticating with the explorer. This variable is required
to deliver telemetry.

### EXPLORER_SECRET

  * Default: _none_

The secret for authenticating with the explorer. This variable is required to
deliver telemetry.

### EXPLORER_URL

  * Default: _none_

The explorer websocket URL for the node to push stats to. This variable is
required to deliver telemetry.

### ROOT

  * Default: `""~/.chainlink""`

The Chainlink node's root directory. This is the default directory for
logging, database backups, cookies, and other misc Chainlink node files.
Chainlink nodes will always ensure this directory has `700` permissions
because it might contain sensitive data.

### TELEMETRY_INGRESS_UNICONN

  * Default: `""true""`

Toggles which ws connection style is used.

### TELEMETRY_INGRESS_LOGGING

  * Default: `""false""`

Toggles verbose logging of the raw telemetry messages being sent.

### TELEMETRY_INGRESS_URL

  * Default: _none_

The URL to connect to for sending telemetry.

### TELEMETRY_INGRESS_SERVER_PUB_KEY

  * Default: _none_

The public key of the telemetry server.

### TELEMETRY_INGRESS_BUFFER_SIZE

  * Default: `""100""`

The number of telemetry messages to buffer before dropping new ones.

### TELEMETRY_INGRESS_MAX_BATCH_SIZE

  * Default: `""50""`

The maximum number of messages to batch into one telemetry request.

### TELEMETRY_INGRESS_SEND_INTERVAL

  * Default: `""500ms""`

The interval on which batched telemetry is sent to the ingress server.

### TELEMETRY_INGRESS_SEND_TIMEOUT

  * Default: `""10s""`

The max duration to wait for the request to complete when sending batch
telemetry.

### TELEMETRY_INGRESS_USE_BATCH_SEND

  * Default: `""true""`

Toggles sending telemetry to the ingress server using the batch client.

## Chains

### SOLANA_ENABLED

caution

  * Default: `""false""`

Enables Solana support.

### EVM_ENABLED

  * Default: `""true""`

Enables support for EVM-based chains. By default, this variable is set to
`true` to provide legacy compatibility and ease the upgrade path from older
versions of Chainlink which did not support disabling EVM.

## Database Settings

### MIGRATE_DATABASE

  * Default: `""true""`

This variable controls whether a Chainlink node will attempt to automatically
migrate the database on boot. If you want more control over your database
migration process, set this variable to `false` and manually migrate the
database using the CLI `migrate` command instead.

### ORM_MAX_IDLE_CONNS

  * Default: `""10""`

This setting configures the maximum number of idle database connections that
the Chainlink node will keep open. Think of this as the baseline number of
database connections per Chainlink node instance. Increasing this number can
help to improve performance under database-heavy workloads.

Postgres has connection limits, so you must use cation when increasing this
value. If you are running several instances of a Chainlink node or another
application on a single database server, you might run out of Postgres
connection slots if you raise this value too high.

### ORM_MAX_OPEN_CONNS

  * Default: `""20""`

This setting configures the maximum number of database connections that a
Chainlink node will have open at any one time. Think of this as the maximum
burst upper bound limit of database connections per Chainlink node instance.
Increasing this number can help to improve performance under database-heavy
workloads.

Postgres has connection limits, so you must use cation when increasing this
value. If you are running several instances of a Chainlink node or another
application on a single database server, you might run out of Postgres
connection slots if you raise this value too high.

## Database Global Lock

Chainlink nodes use a database lock to ensure that only one Chainlink node
instance can be run on the database at a time. If you run multiple instances
of a Chainlink node that share a single database at the same time, the node
will encounter strange errors and data integrity failures. Do not allow
multiple nodes to write data to the database at the same time.

### DATABASE_LOCKING_MODE

  * Default: `""dual""`

The `DATABASE_LOCKING_MODE` variable can be set to 'dual', 'advisorylock',
'lease', or 'none'. It controls which mode to use to enforce that only one
Chainlink node can use the database. It is recommended to set this to `lease`.

  * `dual` \- The default: Uses both advisory locks and lease locks for backward and forward compatibility
  * `advisorylock` \- Advisory lock only
  * `lease` \- Lease lock only
  * _none_ \- No locking at all: This option useful for advanced deployment environments when you are sure that only one instance of a Chainlink node will ever be running.

#### Technical details

Ideally, you should use a container orchestration system like
[Kubernetes](https://kubernetes.io/) to ensure that only one Chainlink node
instance can ever use a specific Postgres database. However, some node
operators do not have the technical capacity to do this. Common use cases run
multiple Chainlink node instances in failover mode as recommended by our
official documentation. The first instance takes a lock on the database and
subsequent instances will wait trying to take this lock in case the first
instance fails.

By default, Chainlink nodes use the `dual` setting to provide both advisory
locks and lease locks for backward and forward compatibility. Using advisory
locks alone presents the following problems:

  * If your nodes or applications hold locks open for several hours or days, Postgres is unable to complete internal cleanup tasks. The Postgres maintainers explicitly discourage holding locks open for long periods of time.
  * Advisory locks can silently disappear when you upgrade Postgres, so a new Chainlink node instance can take over even while the old node is still running.
  * Advisory locks do not work well with pooling tools such as [pgbouncer](https://www.pgbouncer.org/).
  * If the Chainlink node crashes, an advisory lock can hang around for up to several hours, which might require you to manually remove it so another instance of the Chainlink node will allow itself to boot.

Because of the complications with advisory locks, Chainlink nodes with v1.1.0
and later support a new `lease` locking mode. This mode might become the
default in future. The `lease` locking mode works using the following process:

  * Node A creates one row in the database with the client ID and updates it once per second.
  * Node B spinlocks and checks periodically to see if the client ID is too old. If the client ID is not updated after a period of time, node B assumes that node A failed and takes over. Node B becomes the owner of the row and updates the client ID once per second.
  * If node A comes back, it attempts to take out a lease, realizes that the database has been leased to another process, and exits the entire application immediately.

### ADVISORY_LOCK_CHECK_INTERVAL

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable advisory
locking.

  * Default: `""1s""`

`ADVISORY_LOCK_CHECK_INTERVAL` controls how often the Chainlink node checks to
make sure it still holds the advisory lock when advisory locking is enabled.
If a node no longer holds the lock, it will try to re-acquire it. If the node
cannot re-acquire the lock, the application will exit.

### ADVISORY_LOCK_ID

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable advisory
locking.

  * Default: `""1027321974924625846""`

`ADVISORY_LOCK_ID` is the application advisory lock ID. This must match all
other Chainlink nodes that might access this database. It is unlikely you will
ever need to change this from the default.

### LEASE_LOCK_DURATION

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable lease
locking.

  * Default: `""30s""`

How long the lease lock will last before expiring.

### LEASE_LOCK_REFRESH_INTERVAL

**ADVANCED**

Do not change this setting unless you know what you are doing.

This setting applies only if `DATABASE_LOCKING_MODE` is set to enable lease
locking.

  * Default: `""1s""`

How often to refresh the lease lock. Also controls how often a standby node
will check to see if it can grab the lease.

## Database Automatic Backups

As a best practice, take regular database backups in case of accidental data
loss. This best practice is especially important when you upgrade your
Chainlink node to a new version. Chainlink nodes support automated database
backups to make this process easier.

NOTE: Dumps can cause high load and massive database latencies, which will
negatively impact the normal functioning of the Chainlink node. For this
reason, it is recommended to set a DATABASE_BACKUP_URL and point it to a read
replica if you enable automatic backups.

### DATABASE_BACKUP_FREQUENCY

  * Default: `""1h""`

If this variable is set to a positive duration and `DATABASE_BACKUP_MODE` is
not _none_ , the node will dump the database at this regular interval.

Set to `0` to disable periodic backups.

### DATABASE_BACKUP_MODE

  * Default: `""none""`

Set the mode for automatic database backups, which can be one of _none_ ,
`lite`, or `full`. If enabled, the Chainlink node will always dump a backup on
every boot before running migrations. Additionally, it will automatically take
database backups that overwrite the backup file for the given version at
regular intervals if `DATABASE_BACKUP_FREQUENCY` is set to a non-zero
interval.

_none_ \- Disables backups. `lite` \- Dumps small tables including
configuration and keys that are essential for the node to function, which
excludes historical data like job runs, transaction history, etc. `full` \-
Dumps the entire database.

It will write to a file like `$ROOT/backup/cl_backup_<VERSION>.dump`. There is
one backup dump file per version of the Chainlink node. If you upgrade the
node, it will keep the backup taken right before the upgrade migration so you
can restore to an older version if necessary.

### DATABASE_BACKUP_URL

If specified, the automatic database backup will pull from this URL rather
than the main `DATABASE_URL`. It is recommended to set this value to a read
replica if you have one to avoid excessive load on the main database.

### DATABASE_BACKUP_DIR

This variable sets the directory to use for saving the backup file. Use this
if you want to save the backup file in a directory other than the default ROOT
directory.

## Logging

### JSON_CONSOLE

  * Default: `""false""`

Set this to true to enable JSON logging. Otherwise, the log is saved in a
human-friendly console format.

### LOG_FILE_DIR

  * Default: `""$ROOT""`

By default, Chainlink nodes write log data to `$ROOT/log.jsonl`. The log
directory can be changed by setting this var. For example,
`LOG_FILE_DIR=/my/log/directory`.

### LOG_LEVEL

  * Default: `""info""`

The `LOG_LEVEL` environment variable determines both what is printed on the
screen and what is written to the log file.

The available options are:

  * `""debug""`: Useful for forensic debugging of issues.
  * `""info""`: High-level informational messages.
  * `""warn""`: A mild error occurred that might require non-urgent action. Check these warnings semi-regularly to see if any of them require attention. These warnings usually happen due to factors outside of the control of the node operator. Examples: Unexpected responses from a remote API or misleading networking errors.
  * `""error""`: An unexpected error occurred during the regular operation of a well-maintained node. Node operators might need to take action to remedy this error. Check these regularly to see if any of them require attention. Examples: Use of deprecated configuration options or incorrectly configured settings that cause a job to fail.
  * `""crit""`: A critical error occurred. The node might be unable to function. Node operators should take immediate action to fix these errors. Examples: The node could not boot because a network socket could not be opened or the database became inaccessible.
  * `""panic""`: An exceptional error occurred that could not be handled. If the node is unresponsive, node operators should try to restart their nodes and notify the Chainlink team of a potential bug.
  * `""fatal""`: The node encountered an unrecoverable problem and had to exit.

### LOG_SQL

  * Default: `""false""`

This setting tells the Chainlink node to log SQL statements made using the
default logger. SQL statements will be logged at `debug` level. Not all
statements can be logged. The best way to get a true log of all SQL statements
is to enable SQL statement logging on Postgres.

### LOG_FILE_MAX_SIZE

  * Default: `""5120mb""`

Determines the log file's max size in megabytes before file rotation. Having
this not set will disable logging to disk. If your disk doesn't have enough
disk space, the logging will pause and the application will log errors until
space is available again.

Values must have suffixes with a unit like: `5120mb` (5,120 megabytes). If no
unit suffix is provided, the value defaults to `b` (bytes). The list of valid
unit suffixes are:

  * b (bytes)
  * kb (kilobytes)
  * mb (megabytes)
  * gb (gigabytes)
  * tb (terabytes)

### LOG_FILE_MAX_AGE

  * Default: `""0""`

Determines the log file's max age in days before file rotation. Keeping this
config with the default value will not remove log files based on age.

### LOG_FILE_MAX_BACKUPS

  * Default: `""1""`

Determines the maximum number of old log files to retain. Keeping this config
with the default value retains all old log files. The `LOG_FILE_MAX_AGE`
variable can still cause them to get deleted.

### LOG_UNIX_TS

  * Default: _none_

Previous versions of Chainlink nodes wrote JSON logs with a unix timestamp. As
of v1.1.0 and up, the default has changed to use ISO8601 timestamps for better
readability. Setting `LOG_UNIX_TS=true` will enable the old behavior.

### AUDIT_LOGGER_FORWARD_TO_URL

  * Default: _none_

When set, this environment variable configures and enables an optional HTTP
logger which is used specifically to send audit log events. Audit logs events
are emitted when specific actions are performed by any of the users through
the node's API. The value of this variable should be a full URL. Log items
will be sent via POST HTTP requests.

There are audit log implemented for the following events:

  * Auth & Sessions (new session, login success, login failed, 2FA enrolled, 2FA failed, password reset, password reset failed, etc.)
  * CRUD actions for all resources (add/create/delete resources such as bridges, nodes, keys)
  * Sensitive actions (keys exported/imported, config changed, log level changed, environment dumped)

A full list of audit log enum types can be found in the source within the
`audit` package
([`audit_types.go`](https://github.com/smartcontractkit/chainlink/blob/develop/core/logger/audit/audit_types.go)).

Log events follow this schema:


    {
        ""eventID"":  EVENT_ID_ENUM,
        ""hostname"": HOSTNAME,
        ""localIP"" : CL_NODE_IP,
        ""env"" : ENVIRONMENT_NAME,
        ""data"": ...
    }

The `AUDIT_LOGGER_*` environment variables configure this optional audit log
HTTP forwarder.

### AUDIT_LOGGER_HEADERS

  * Default: _none_

An optional list of HTTP headers to be added for every optional audit log
event. If the above `AUDIT_LOGGER_FORWARD_TO_URL` is set, audit log events
will be POSTed to that URL, and will include headers specified in this
environment variable. One example use case is auth for example:
`AUDIT_LOGGER_HEADERS=""Authorization||{token}""`

Header keys and values are delimited on `||`, and multiple headers can be
added with a forward slash delimiter (`\`). An example of multiple key value
pairs: `AUDIT_LOGGER_HEADERS=""Authorization||{token}\Some-Other-
Header||{token2}""`

### AUDIT_LOGGER_JSON_WRAPPER_KEY

  * Default: _none_

When the audit log HTTP forwarder is enabled, if there is a value set for this
optional environment variable then the POST body will be wrapped in a
dictionary in a field specified by the value of set variable. This is to help
enable specific logging service integrations that may require the event JSON
in a special shape. For example: `AUDIT_LOGGER_JSON_WRAPPER_KEY=event` will
create the POST body:


    {
      ""event"": {
        ""eventID"":  EVENT_ID_ENUM,
        ""hostname"": HOSTNAME,
        ""localIP"" : CL_NODE_IP,
        ""env"" : ENVIRONMENT_NAME,
        ""data"": ...
      }
    }

## Nurse service (auto-pprof)

The Chainlink node is equipped with an internal ""nurse"" service that can
perform automatic `pprof` profiling when the certain resource thresholds are
exceeded, such as memory and goroutine count. These profiles are saved to disk
to facilitate fine-grained debugging of performance-related issues. In
general, if you notice that your node has begun to accumulate profiles,
forward them to the Chainlink team.

To learn more about these profiles, read the [Profiling Go programs with
pprof](https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/) guide.

### AUTO_PPROF_ENABLED

  * Default: `""false""`

Set to `true` to enable the automatic profiling service.

### AUTO_PPROF_PROFILE_ROOT

Defaults to `$CHAINLINK_ROOT`

The location on disk where pprof profiles will be stored.

### AUTO_PPROF_POLL_INTERVAL

  * Default: `""10s""`

The interval at which the node's resources are checked.

### AUTO_PPROF_GATHER_DURATION

  * Default: `""10s""`

The duration for which profiles are gathered when profiling starts.

### AUTO_PPROF_GATHER_TRACE_DURATION

  * Default: `""5s""`

The duration for which traces are gathered when profiling is kicked off. This
is separately configurable because traces are significantly larger than other
types of profiles.

### AUTO_PPROF_MAX_PROFILE_SIZE

  * Default: `""100mb""`

The maximum amount of disk space that profiles may consume before profiling is
disabled.

### AUTO_PPROF_CPU_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetCPUProfileRate>.

### AUTO_PPROF_MEM_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#pkg-variables>.

### AUTO_PPROF_BLOCK_PROFILE_RATE

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetBlockProfileRate>.

### AUTO_PPROF_MUTEX_PROFILE_FRACTION

  * Default: `""1""`

See <https://pkg.go.dev/runtime#SetMutexProfileFraction>.

  * Default: `""1""`

### AUTO_PPROF_MEM_THRESHOLD

  * Default: `""4gb""`

The maximum amount of memory the node can actively consume before profiling
begins.

### AUTO_PPROF_GOROUTINE_THRESHOLD

  * Default: `""5000""`

The maximum number of actively-running goroutines the node can spawn before
profiling begins.

## Chainlink Web Server

### ALLOW_ORIGINS

  * Default: `""http://localhost:3000,http://localhost:6688""`

Controls the URLs Chainlink nodes emit in the `Allow-Origins` header of its
API responses. The setting can be a comma-separated list with no spaces. You
might experience CORS issues if this is not set correctly.

You should set this to the external URL that you use to access the Chainlink
UI.

You can set `ALLOW_ORIGINS=*` to allow the UI to work from any URL, but it is
recommended for security reasons to make it explicit instead.

### AUTHENTICATED_RATE_LIMIT

  * Default: `""1000""`

`AUTHENTICATED_RATE_LIMIT` defines the threshold to which authenticated
requests get limited. More than this many authenticated requests per
`AUTHENTICATED_RATE_LIMIT_PERIOD` will be rejected.

### AUTHENTICATED_RATE_LIMIT_PERIOD

  * Default: `""1m""`

`AUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which authenticated
requests get limited.

### BRIDGE_CACHE_TTL

  * Default: 0s

When set to `d` units of time, this variable enables using cached bridge
responses that are at most `d` units old. Caching is disabled by default.

Example `BRIDGE_CACHE_TTL=10s`, `BRIDGE_CACHE_TTL=1m`

### BRIDGE_RESPONSE_URL

  * Default: _none_

`BRIDGE_RESPONSE_URL` defines the URL for bridges to send a response to.

Usually this will be the same as the URL/IP and port you use to connect to the
Chainlink UI, such as `https://my-chainlink-node.example.com:6688`.

### HTTP_SERVER_WRITE_TIMEOUT

**ADVANCED**

Do not change this setting unless you know what you are doing.

  * Default: `""10s""`

`HTTP_SERVER_WRITE_TIMEOUT` controls how long the Chainlink node's API server
can hold a socket open for writing a response to an HTTP request. Sometimes,
this must be increased for pprof.

### CHAINLINK_PORT

  * Default: `""6688""`

Port used for the Chainlink Node API, CLI, and GUI.

### SECURE_COOKIES

  * Default: `""true""`

Requires the use of secure cookies for authentication. Set to false to enable
standard HTTP requests along with `CHAINLINK_TLS_PORT=0`.

### SESSION_TIMEOUT

  * Default: `""15m""`

This value determines the amount of idle time to elapse before session cookies
expire. This signs out GUI users from their sessions.

### UNAUTHENTICATED_RATE_LIMIT

  * Default: `""5""`

`UNAUTHENTICATED_RATE_LIMIT` defines the threshold to which authenticated
requests get limited. More than this many unauthenticated requests per
`UNAUTHENTICATED_RATE_LIMIT_PERIOD` will be rejected.

### UNAUTHENTICATED_RATE_LIMIT_PERIOD

  * Default: `""20s""`

`UNAUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which
unauthenticated requests get limited.

## Web Server MFA

The Operator UI frontend now supports enabling Multi Factor Authentication via
Webauthn per account. When enabled, logging in will require the account
password and a hardware or OS security key such as Yubikey. To enroll, log in
to the operator UI and click the circle purple profile button at the top right
and then click **Register MFA Token**. Tap your hardware security key or use
the OS public key management feature to enroll a key. Next time you log in,
this key will be required to authenticate.

This feature must be enabled by setting the following environment variables:
`MFA_RPID` and `MFA_RPORIGIN`.

### MFA_RPID

  * Default: _none_

The `MFA_RPID` value should be the FQDN of where the Operator UI is served.
When serving locally, the value should be `localhost`.

### MFA_RPORIGIN

  * Default: _none_

The `MFA_RPORIGIN` value should be the origin URL where WebAuthn requests
initiate, including scheme and port. When serving locally, the value should be
`http://localhost:6688/`.

## Web Server TLS

The TLS settings below apply only if you want to enable TLS security on your
Chainlink node.

### CHAINLINK_TLS_HOST

  * Default: _none_

The hostname configured for TLS to be used by the Chainlink node. This is
useful if you configured a domain name specific for your Chainlink node.

### CHAINLINK_TLS_PORT

  * Default: `""6689""`

The port used for HTTPS connections. Set this to `0` to disable HTTPS.
Disabling HTTPS also relieves Chainlink nodes of the requirement for a TLS
certificate.

### CHAINLINK_TLS_REDIRECT

  * Default: `""false""`

Forces TLS redirect for unencrypted connections.

### TLS_CERT_PATH

  * Default: _none_

The location of the TLS certificate file. Example:
`/home/$USER/.chainlink/tls/server.crt`

### TLS_KEY_PATH

  * Default: _none_

The location of the TLS private key file. Example:
`/home/$USER/.chainlink/tls/server.key`

## EVM/Ethereum Legacy Environment Variables

Previous Chainlink node versions supported only one chain. From v1.1.0 and up,
Chainlink nodes support multiple EVM and non-EVM chains, so the way that
chains and nodes are configured has changed.

The preferred way of configuring Chainlink nodes as of v1.1.0 and up is to use
the API, CLI, or UI to set chain-specific configuration and create nodes.

The old way of specifying chains using environment variables is still
supported, but discouraged. It works as follows:

If you set any value for `ETH_URL`, the values of `ETH_CHAIN_ID`, `ETH_URL`,
`ETH_HTTP_URL` and `ETH_SECONDARY_URLS` will be used to create and update
chains and nodes representing these values in the database. If an existing
chain or node is found, it will be overwritten. This mode is used mainly to
ease the process of upgrading. On subsequent runs (once your old settings have
been written to the database) it is recommended to unset `ETH_URL` and use the
API commands exclusively to administer chains and nodes.

In the future, support for the `ETH_URL` and associated environment variables
might be removed, so it is recommended to use the API, CLI, or GUI instead to
setup chains and nodes.

### ETH_URL

Setting this will enable ""legacy eth ENV"" mode, which is not compatible with
multi-chain. It is better to configure settings using the API, CLI, or GUI
instead.

  * Default: _none_

This is the websocket address of the Ethereum client that the Chainlink node
will connect to. All interaction with the Ethereum blockchain will occur
through this connection.

NOTE: It is also required to set `ETH_CHAIN_ID` if you set ETH_URL.

### ETH_HTTP_URL

Only has effect if `ETH_URL` set. Otherwise, it can be set in the API, CLI, or
GUI.

  * Default: _none_

This should be set to the HTTP URL that points to the same ETH node as the
primary. If set, the Chainlink node will automatically use HTTP mode for heavy
requests, which can improve reliability.

### EVM_NODES

caution

Setting this environment variable will **COMPLETELY ERASE** your `evm_nodes`
table on every boot and repopulate from the given data to nullify any runtime
modifications. This is a temporary solution until this configuration can be
defined in a file in the future.

  * Default: _none_

A JSON array of node specifications that allows you to configure multiple
nodes or chains using an environment variable. This is not compatible with
other environment variables that specify the node such as `ETH_URL` or
`ETH_SECONDARY_URLS`. Set this variable using a configuration like the
following example:


    EVM_NODES='
    [
    	{
    		""name"": ""primary_0_1"",
    		""evmChainId"": ""0"",
    		""wsUrl"": ""ws://test1.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""primary_0_2"",
    		""evmChainId"": ""0"",
    		""wsUrl"": ""ws://test2.invalid"",
    		""httpUrl"": ""https://test3.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""primary_1337_1"",
    		""evmChainId"": ""1337"",
    		""wsUrl"": ""ws://test4.invalid"",
    		""httpUrl"": ""http://test5.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""sendonly_1337_1"",
    		""evmChainId"": ""1337"",
    		""httpUrl"": ""http://test6.invalid"",
    		""sendOnly"": true
    	},
    	{
    		""name"": ""sendonly_0_1"",
    		""evmChainId"": ""0"",
    		""httpUrl"": ""http://test7.invalid"",
    		""sendOnly"": true
    	},
    	{
    		""name"": ""primary_42_1"",
    		""evmChainId"": ""42"",
    		""wsUrl"": ""ws://test8.invalid"",
    		""sendOnly"": false
    	},
    	{
    		""name"": ""sendonly_43_1"",
    		""evmChainId"": ""43"",
    		""httpUrl"": ""http://test9.invalid"",
    		""sendOnly"": true
    	}
    ]
    '

Usage of Docker requires the variable to be formatted as one line with no
whitespaces and quotes wrapping it, as follows in the example:


    EVM_NODES=[{""name"":""primary_0_1"",""evmChainId"":""0"",""wsUrl"":""ws://test1.invalid"",""sendOnly"":false},{""name"":""primary_0_2"",""evmChainId"":""0"",""wsUrl"":""ws://test2.invalid"",""httpUrl"":""https://test3.invalid"",""sendOnly"":false},{""name"":""primary_1337_1"",""evmChainId"":""1337"",""wsUrl"":""ws://test4.invalid"",""httpUrl"":""http://test5.invalid"",""sendOnly"":false}]

### ETH_SECONDARY_URLS

Only has effect if `ETH_URL` set. Otherwise, it can be set in the API, CLI, or
GUI.

  * Default: _none_

If set, transactions will also be broadcast to this secondary Ethereum node.
This allows transaction broadcasting to be more robust in the face of primary
Ethereum node bugs or failures.

It is recommended to set at least one secondary ETH node here that is
different from your primary.

Multiple URLs can be specified as a comma-separated list e.g.

`ETH_SECONDARY_URLS=https://example.com/1,https://example.text/2,...`

## EVM/Ethereum Global Settings

This configuration is specific to EVM/Ethereum chains.

### ETH_CHAIN_ID

  * Default: _none_

This environment variable specifies the default chain ID. Any job spec that
has not explicitly set `EVMChainID` will connect to this default chain. If you
do not have a chain in the database matching this value, any jobs that try to
use it will throw an error.

### EVM_RPC_ENABLED

  * Default: `""true""`

Enables connecting to real EVM RPC nodes. Disabling this can be useful in
certain cases such as spinning up a Chainlink node and adding EVM-based jobs
without having it actually execute anything on-chain, or for debugging to see
what the node _would_ do without actually doing it.

## EVM/Ethereum Chain-specific Overrides

These configuration options act as an override, setting the value for _all_
chains.

This often doesn't make sense, e.g. `ETH_FINALITY_DEPTH` on Avalanche could be
quite different from `ETH_FINALITY_DEPTH` on Ethereum mainnet.

We recommend setting this on a per-chain basis using the API, CLI, or GUI
instead.

In general, Chainlink nodes contain built-in defaults for most of these
settings that should work out of the box on all officially supported chains,
so it is unlikely you must make any changes here.

### BALANCE_MONITOR_ENABLED

  * Default: `""true""`

Enables Balance Monitor feature. This is required to track balances of keys
locally and warn if it drops too low. It also enables displaying balance in
the Chainlink UI and API.

### BLOCK_BACKFILL_DEPTH

  * Default: `""10""`

This variable specifies the number of blocks before the current head that the
log broadcaster will try to re-consume logs from, e.g. after adding a new job.

### BLOCK_BACKFILL_SKIP

  * Default: `""false""`

This variable enables skipping of very long log backfills. For example, this
happens in a situation when the node is started after being offline for a long
time. This might be useful on fast chains and if only recent chain events are
relevant

### ETH_TX_REAPER_INTERVAL

NOTE: This overrides the setting for _all_ chains, you might want to set this
on a per-chain basis using the API, CLI, or GUI instead

  * Default: `""1h""`

Controls how often the ETH transaction reaper should run, used to delete old
confirmed or fatally_errored transaction records from the database. Setting to
`0` disables the reaper.

### ETH_TX_REAPER_THRESHOLD

  * Default: `""24h""`

Represents how long any confirmed or fatally_errored `eth_tx` transactions
will hang around in the database. If the `eth_tx` is confirmed but still below
`ETH_FINALITY_DEPTH`, it will not be deleted even if it was created at a time
older than this value.

EXAMPLE: With: `EthTxReaperThreshold=1h` and `EthFinalityDepth=50` If current
head is 142, any `eth_tx` confirmed in block 91 or below will be reaped as
long as its `created_at` value is older than the value set for
`EthTxReaperThreshold`.

Setting to `0` disables the reaper.

### ETH_TX_RESEND_AFTER_THRESHOLD

NOTE: This overrides the setting for _all_ chains, you might want to set this
on a per-chain basis using the API, CLI, or GUI instead.

  * Default: _automatically set based on Chain ID, typically 1m_

Controls how long the `ethResender` will wait before re-sending the latest
`eth_tx_attempt`. This is designed a as a fallback to protect against the ETH
nodes dropping transactions (which has been anecdotally observed to happen),
networking issues, or transactions being ejected from the mempool.

Setting to `0` disables the resender.

### ETH_FINALITY_DEPTH

  * Default: _automatically set based on Chain ID, typically 50_

The number of blocks after which an Ethereum transaction is considered
""final"".

`ETH_FINALITY_DEPTH` determines how deeply we look back to ensure that
transactions are confirmed onto the longest chain. There is not a large
performance penalty to setting this relatively high (on the order of
hundreds).

It is practically limited by the number of heads we store in the database
(`HEAD_TRACKER_HISTORY_DEPTH`) and should be less than this with a comfortable
margin. If a transaction is mined in a block more than this many blocks ago,
and is reorged out, we will NOT retransmit this transaction and undefined
behavior can occur including gaps in the nonce sequence that require manual
intervention to fix. Therefore, this number represents a number of blocks we
consider large enough that no re-org this deep will ever feasibly happen.

### ETH_HEAD_TRACKER_HISTORY_DEPTH

  * Default: _automatically set based on Chain ID, typically 100_

Tracks the top N block numbers to keep in the `heads` database table. Note
that this can easily result in MORE than N total records since in the case of
re-orgs we keep multiple heads for a particular block height, and it is also
scoped per chain. This number should be at least as large as
`ETH_FINALITY_DEPTH`. There might be a small performance penalty to setting
this to something very large (10,000+)

### ETH_HEAD_TRACKER_MAX_BUFFER_SIZE

  * Default: `""3""`

The maximum number of heads that can be buffered in front of the head tracker
before older heads start to be dropped. Think this setting as the maximum
permitted ""lag"" for the head tracker before the Chainlink node starts dropping
heads to keep up.

### ETH_HEAD_TRACKER_SAMPLING_INTERVAL

  * Default: _automatically set based on Chain ID, typically 1s_

Head tracker sampling was introduced to handle chains with very high
throughput. If this is set, the head tracker will ""gap"" heads and deliver a
maximum of 1 head per this period.

Set to `0` to disable head tracker sampling.

### ETH_LOG_BACKFILL_BATCH_SIZE

  * Default: _automatic based on Chain ID, typically 100_

Controls the batch size for calling FilterLogs when backfilling missing or
recent logs.

### ETH_LOG_POLL_INTERVAL

  * Default: _automatic based on Chain ID_

Defines how frequently to poll for new logs.

### ETH_RPC_DEFAULT_BATCH_SIZE

  * Default: _automatic based on chain ID_

Chainlink nodes use batch mode for certain RPC calls to increase efficiency of
communication with the remote ETH node. In some cases, trying to request too
many items in a single batch will result in an error (e.g. due to bugs in go-
ethereum, third-party provider limitations, limits inherent to the websocket
channel etc). This setting controls the maximum number of items that can be
requested in a single batch. Chainlink nodes use built-in conservative
defaults for different chains that should work out of the box.

If you have enabled HTTP URLs for all of your ETH nodes, you can safely
increase this to a larger value e.g. 100 and see significant RPC performance
improvements.

### LINK_CONTRACT_ADDRESS

  * Default: _automatic based on Chain ID_

The address of the LINK token contract. It is not essential to provide this,
but if given, it is used for displaying the node account's LINK balance. For
supported chains, this is automatically set based on the given chain ID. For
unsupported chains, you must supply it yourself.

This environment variable is a global override. It is recommended instead to
set this on a per-chain basis.

### MIN_INCOMING_CONFIRMATIONS

  * Default: _automatic based on chain ID, typically 3_

The number of block confirmations to wait before kicking off a job run or
proceeding with a task that listens to blockchain and log events. Setting this
to a lower value improves node response time at the expense of occasionally
submitting duplicate transactions in the event of chain re-orgs (duplicate
transactions are harmless but cost some ETH).

You can override this on a per-job basis.

`MIN_INCOMING_CONFIRMATIONS=1` would kick off a job after seeing the
transaction in just one block.

caution

The lowest value allowed here is 1, since setting to 0 would imply that logs
are processed from the mempool before they are even mined into a block, which
isn't possible with Chainlink's current architecture.

### MIN_OUTGOING_CONFIRMATIONS

  * Default: _automatic based on chain ID, typically 12_

The default minimum number of block confirmations that need to be recorded on
an outgoing `ethtx` task before the run can move onto the next task.

This can be overridden on a per-task basis by setting the
`MinRequiredOutgoingConfirmations` parameter.

`MIN_OUTGOING_CONFIRMATIONS=1` considers a transaction as ""done"" once it has
been mined into one block. `MIN_OUTGOING_CONFIRMATIONS=0` would consider a
transaction as ""done"" even before it has been mined.

### MINIMUM_CONTRACT_PAYMENT_LINK_JUELS

note

  * Default: _automatically set based on Chain ID, typically 10000000000000 (0.00001 LINK) on all chains except Ethereum Mainnet and Sepolia where it is 100000000000000000 (0.1 LINK)._

For jobs that use the `EthTx` adapter, this is the minimum payment amount in
order for the node to accept and process the job. Since there are no decimals
on the EVM, the value is represented like wei.

note

Keep in mind, the Chainlink node currently responds with a 500,000 gas limit.
Under pricing your node could mean it spends more in ETH (on gas) than it
earns in LINK.

### NODE_NO_NEW_HEADS_THRESHOLD

  * Default: _automatically set based on Chain ID, typically ""3m"" (3 minutes)_

Controls how long to wait after receiving no new heads before marking the node
as out-of-sync.

Set to zero to disable out-of-sync checking.

### NODE_POLL_FAILURE_THRESHOLD

  * Default: _automatically set based on Chain ID, typically 3_

Indicates how many consecutive polls must fail in order to mark a node as
unreachable.

Set to zero to disable poll checking.

### NODE_POLL_INTERVAL

  * Default: _automatically set based on Chain ID, typically ""10s"" (10 seconds)_

Controls how often to poll the node to check for liveness.

Set to zero to disable poll checking.

### NODE_SELECTION_MODE

  * Default: `""HighestHead""`

Controls node picking strategy. Supported values:

  * `HighestHead` (default) mode picks a node having the highest reported head number among other alive nodes. When several nodes have the same latest head number, the strategy sticks to the last used node. This mode requires `NODE_NO_NEW_HEADS_THRESHOLD` to be configured, otherwise it will always use the first alive node.
  * `RoundRobin` mode simply iterates among available alive nodes. This was the default behavior prior to this release.
  * `TotalDifficulty` mode selects the node with the greatest total difficulty.

### NODE_SYNC_THRESHOLD

  * Default: `5`

SyncThreshold controls how far a node may lag behind the best node before
being marked out-of-sync. Depending on the [`NODE_SELECTION_MODE`
variable](/chainlink-nodes/v1/configuration/#node_selection_mode), this
represents a difference in either the number of blocks (`HighestHead`,
`RoundRobin`), or the total difficulty (`TotalDifficulty`).

Set to `0` to disable this check.

## EVM Gas Controls

These settings allow you to tune your node's gas limits and pricing. In most
cases, leaving these values at their defaults should give good results.

As of Chainlink node v1.1.0, it is recommended to use the API, CLI, or GUI to
configure gas controls because you might want to use different settings for
different chains. Setting the environment variable typically overrides the
setting for all chains.

### Configuring your ETH node

Your ETH node might need some configuration tweaks to make it fully compatible
with Chainlink nodes depending on your configuration.

#### go-ethereum

WARNING: By default, go-ethereum will reject transactions that exceed it's
built-in RPC gas or txfee caps. Chainlink nodes will fatally error
transactions if this happens which means if you ever exceed the caps your node
will miss transactions.

You should at a bare minimum disable the default RPC gas and txfee caps on
your ETH node. This can be done in the TOML file as seen below, or by running
go-ethereum with the command line arguments: `--rpc.gascap=0
--rpc.txfeecap=0`.

It is also recommended to configure go-ethereum properly before increasing
`ETH_MAX_IN_FLIGHT_TRANSACTIONS` to ensure all in-flight transactions are
maintained in the mempool.

Relevant settings for geth and forks (such as BSC).


    [Eth]
    RPCGasCap = 0 # it is recommended to disable both gas and txfee cap
    RPCTxFeeCap = 0.0
    [Eth.TxPool]
    Locals = [""0xYourNodeAddress1"", ""0xYourNodeAddress2""]  # Add your node addresses here
    NoLocals = false # Disabled by default but might as well make sure
    Journal = ""transactions.rlp"" # Make sure you set a journal file
    Rejournal = 3600000000000 # Default 1h, it might make sense to reduce this to e.g. 5m
    PriceBump = 10 # Must be set less than or equal to Chainlink's ETH_GAS_BUMP_PERCENT
    AccountSlots = 16 # Highly recommended to increase this, must be greater than or equal to Chainlink's ETH_MAX_IN_FLIGHT_TRANSACTIONS setting
    GlobalSlots = 4096 # Increase this as necessary
    AccountQueue = 64 # Increase this as necessary
    GlobalQueue = 1024 # Increase this as necessary
    Lifetime = 10800000000000 # Default 3h, this is probably ok, you might even consider reducing it

### EVM_EIP1559_DYNAMIC_FEES

  * Default: _automatic based on chain ID_

Forces EIP-1559 transaction mode for all chains. Enabling EIP-1559 mode can
help reduce gas costs on chains that support it. This is supported only on
official Ethereum mainnet and testnets. It is not recommended to enable this
setting on Polygon because the EIP-1559 fee market appears to be broken on all
Polygon chains and EIP-1559 transactions are less likely to be included than
legacy transactions.

#### Technical details

Chainlink nodes include experimental support for submitting transactions using
type 0x2 (EIP-1559) envelope.

EIP-1559 mode is enabled by default on the Ethereum Mainnet, but can be
enabled on a per-chain basis or globally.

This might help to save gas on spikes. Chainlink nodes should react faster on
the upleg and avoid overpaying on the downleg. It might also be possible to
set `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` to a smaller value such as 12 or even
6 because tip cap should be a more consistent indicator of inclusion time than
total gas price. This would make Chainlink nodes more responsive and should
reduce response time variance. Some experimentation is required to find
optimum settings.

To enable globally, set `EVM_EIP1559_DYNAMIC_FEES=true`. Set with caution, if
you set this on a chain that does not actually support EIP-1559 your node will
be broken.

In EIP-1559 mode, the total price for the transaction is the minimum of base
fee + tip cap and fee cap. More information can be found on the [official
EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).

Chainlink's implementation of EIP-1559 works as follows:

If you are using FixedPriceEstimator:

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and `tipcap=EVM_GAS_TIP_CAP_DEFAULT`
  * With gas bumping enabled, it will submit all transactions initially with `feecap=EVM_GAS_FEE_CAP_DEFAULT` and `tipcap=EVM_GAS_TIP_CAP_DEFAULT`.

If you are using BlockHistoryEstimator (default for most chains):

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and `tipcap=<calculated using past blocks>`
  * With gas bumping enabled (default for most chains) it will submit all transactions initially with `feecap=current block base fee * (1.125 ^ N)` where N is configurable by setting BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS but defaults to `gas bump threshold+1` and `tipcap=<calculated using past blocks>`

Bumping works as follows:

  * Increase tipcap by `max(tipcap * (1 + ETH_GAS_BUMP_PERCENT), tipcap + ETH_GAS_BUMP_WEI)`
  * Increase feecap by `max(feecap * (1 + ETH_GAS_BUMP_PERCENT), feecap + ETH_GAS_BUMP_WEI)`

A quick note on terminology - Chainlink nodes use the same terms used
internally by go-ethereum source code to describe various prices. This is not
the same as the externally used terms. For reference:

  * Base Fee Per Gas = BaseFeePerGas
  * Max Fee Per Gas = FeeCap
  * Max Priority Fee Per Gas = TipCap

In EIP-1559 mode, the following changes occur to how configuration works:

  * All new transactions will be sent as type 0x2 transactions specifying a TipCap and FeeCap. Be aware that existing pending legacy transactions will continue to be gas bumped in legacy mode.
  * `BlockHistoryEstimator` will apply its calculations (gas percentile etc) to the TipCap and this value will be used for new transactions (GasPrice will be ignored)
  * `FixedPriceEstimator` will use `EVM_GAS_TIP_CAP_DEFAULT` instead of `ETH_GAS_PRICE_DEFAULT` for the tip cap
  * `FixedPriceEstimator` will use `EVM_GAS_FEE_CAP_DEFAULT` instaed of `ETH_GAS_PRICE_DEFAULT` for the fee cap
  * `ETH_MIN_GAS_PRICE_WEI` is ignored for new transactions and `EVM_GAS_TIP_CAP_MINIMUM` is used instead (default 0)
  * `ETH_MAX_GAS_PRICE_WEI` still represents that absolute upper limit that Chainlink will ever spend (total) on a single tx
  * `KEEPER_GAS_PRICE_BUFFER_PERCENT` is ignored in EIP-1559 mode and `KEEPER_TIP_CAP_BUFFER_PERCENT` is used instead

### ETH_GAS_BUMP_PERCENT

  * Default: _automatic based on chain ID_

The percentage by which to bump gas on a transaction that has exceeded
`ETH_GAS_BUMP_THRESHOLD`. The larger of `ETH_GAS_BUMP_PERCENT` and
`ETH_GAS_BUMP_WEI` is taken for gas bumps.

### ETH_GAS_BUMP_THRESHOLD

  * Default: _automatic based on chain ID_

Chainlink nodes can be configured to automatically bump gas on transactions
that have been stuck waiting in the mempool for at least this many blocks. Set
to 0 to disable gas bumping completely.

### ETH_GAS_BUMP_TX_DEPTH

  * Default: `""10""`

The number of transactions to gas bump starting from oldest. Set to 0 for no
limit (i.e. bump all).

### ETH_GAS_BUMP_WEI

  * Default: _automatic based on chain ID_

The minimum fixed amount of wei by which gas is bumped on each transaction
attempt.

### EVM_GAS_FEE_CAP_DEFAULT

  * Default: _automatic based on chain ID_

If EIP1559 mode is enabled, and FixedPrice gas estimator is used, this env var
controls the fixed initial fee cap.

### ETH_GAS_LIMIT_DEFAULT

  * Default: _automatically set based on Chain ID, typically 500000_

The default gas limit for outgoing transactions. This should not need to be
changed in most cases. Some job types, such as Keeper jobs, might set their
own gas limit unrelated to this value.

### ETH_GAS_LIMIT_MAX

  * Default: _automatically set based on Chain ID, typically 500000_

The maxium for gas limits estimated by the `Arbitrum` `GAS_ESTIMATOR_MODE`.
This should not need to be changed in most cases.

### ETH_GAS_LIMIT_MULTIPLIER

  * Default: `""1.0""`

A factor by which a transaction's GasLimit is multiplied before transmission.
So if the value is 1.1, and the GasLimit for a transaction is 10, 10% will be
added before transmission.

This factor is always applied, so includes Optimism L2 transactions which uses
a default gas limit of 1 and is also applied to EthGasLimitDefault.

### ETH_GAS_LIMIT_TRANSFER

  * Default: _automatically set based on Chain ID, typically 21000_

The gas limit used for an ordinary ETH transfer.

### ETH_GAS_PRICE_DEFAULT

(Only applies to legacy transactions)

  * Default: _automatic based on chain ID_

The default gas price to use when submitting transactions to the blockchain.
Will be overridden by the built-in `BlockHistoryEstimator` if enabled, and
might be increased if gas bumping is enabled.

Can be used with the `chainlink setgasprice` to be updated while the node is
still running.

### EVM_GAS_TIP_CAP_DEFAULT

(Only applies to EIP-1559 transactions)

  * Default: _automatic based on chain ID_

The default gas tip to use when submitting transactions to the blockchain.
Will be overridden by the built-in `BlockHistoryEstimator` if enabled, and
might be increased if gas bumping is enabled.

### EVM_GAS_TIP_CAP_MINIMUM

(Only applies to EIP-1559 transactions)

  * Default: _automatic based on chain ID_

The minimum gas tip to use when submitting transactions to the blockchain.

### ETH_MAX_GAS_PRICE_WEI

  * Default: _automatic based on chain ID_

Chainlink nodes will never pay more than this for a transaction.

### ETH_MAX_IN_FLIGHT_TRANSACTIONS

  * Default: `""16""`

Controls how many transactions are allowed to be ""in-flight"" i.e. broadcast
but unconfirmed at any one time. You can consider this a form of transaction
throttling.

The default is set conservatively at 16 because this is a pessimistic minimum
that geth will hold without evicting local transactions. If your node is
falling behind and you need higher throughput, you can increase this setting,
but you MUST make sure that your ETH node is configured properly otherwise you
can get nonce gapped and your node will get stuck.

0 value disables the limit. Use with caution.

### ETH_MAX_QUEUED_TRANSACTIONS

  * Default: _automatically set based on Chain ID, typically 250_

The maximum number of unbroadcast transactions per key that are allowed to be
enqueued before jobs will start failing and rejecting send of any further
transactions. This represents a sanity limit and generally indicates a problem
with your ETH node (transactions are not getting mined).

Do NOT blindly increase this value thinking it will fix things if you start
hitting this limit because transactions are not getting mined, you will
instead only make things worse.

In deployments with very high burst rates, or on chains with large re-orgs,
you _may_ consider increasing this.

0 value disables any limit on queue size. Use with caution.

### ETH_MIN_GAS_PRICE_WEI

(Only applies to legacy transactions)

  * Default: _automatic based on chain ID_

Chainlink nodes will never pay less than this for a transaction.

It is possible to force the Chainlink node to use a fixed gas price by setting
a combination of these, e.g.


    EVM_EIP1559_DYNAMIC_FEES=false
    ETH_MAX_GAS_PRICE_WEI=100
    ETH_MIN_GAS_PRICE_WEI=100
    ETH_GAS_PRICE_DEFAULT=100
    ETH_GAS_BUMP_THRESHOLD=0
    GAS_ESTIMATOR_MODE=""FixedPrice""

### ETH_GAS_LIMIT_OCR_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for OCR jobs. This environment variable does
not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_GAS_LIMIT_DR_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for direct request jobs. This environment
variable does not override task-specific or job-specific `gasLimit` parameters
or attributes.

### ETH_GAS_LIMIT_VRF_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for VRF jobs. This environment variable does
not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_GAS_LIMIT_FM_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for Flux Monitor jobs. This environment
variable does not override task-specific or job-specific `gasLimit` parameters
or attributes.

### ETH_GAS_LIMIT_KEEPER_JOB_TYPE

  * Default: _none_

Overrides the default gas limit for Keeper jobs. This environment variable
does not override task-specific or job-specific `gasLimit` parameters or
attributes.

### ETH_NONCE_AUTO_SYNC

  * Default: `""false""`

Chainlink nodes will automatically try to sync its local nonce with the remote
chain on startup and fast forward if necessary. This is almost always safe but
can be disabled in exceptional cases by setting this value to false.

### ETH_USE_FORWARDERS

  * Default: `""false""`

Enables or disables sending transactions through forwarder contracts.

## EVM/Ethereum Gas Price Estimation

These settings allow you to configure how your node calculates gas prices. In
most cases, leaving these values at their defaults should give good results.

As of Chainlink node v1.1.0, it is recommended to use the API, CLI, or GUI to
configure gas controls because you might want to use different settings for
different chains. Setting the environment variable typically overrides the
setting for all chains.

Chainlink nodes decide what gas price to use using an `Estimator`. It ships
with several simple and battle-hardened built-in estimators that should work
well for almost all use-cases. Note that estimators will change their
behaviour slightly depending on if you are in EIP-1559 mode or not.

You can also use your own estimator for gas price by selecting the
`FixedPrice` estimator and using the exposed API to set the price.

An important point to note is that the Chainlink node does _not_ ship with
built-in support for go-ethereum's `estimateGas` call. This is for several
reasons, including security and reliability. We have found empirically that it
is not generally safe to rely on the remote ETH node's idea of what gas price
should be.

### GAS_ESTIMATOR_MODE

  * Default: _automatic, based on chain ID_

Controls what type of gas estimator is used.

  * `FixedPrice` uses static configured values for gas price (can be set via API call).
  * `BlockHistory` dynamically adjusts default gas price based on heuristics from mined blocks.
  * `Optimism2`/`L2Suggested` is a special mode only for use with Optimism and Metis blockchains. This mode will use the gas price suggested by the rpc endpoint via `eth_gasPrice`.
  * `Arbitrum` is a special mode only for use with Arbitrum blockchains. It uses the suggested gas price (up to `ETH_MAX_GAS_PRICE_WEI`, with `1000 gwei` default) as well as an estimated gas limit (up to `ETH_GAS_LIMIT_MAX`, with `1,000,000,000` default).

### BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE

  * Default: _automatic, based on chain ID, typically 4_

Sets the maximum number of blocks to fetch in one batch in the block history
estimator. If the `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` environment variable is
set to 0, it defaults to ETH_RPC_DEFAULT_BATCH_SIZE.

### BLOCK_HISTORY_ESTIMATOR_BLOCK_HISTORY_SIZE

  * Default: _automatic, based on chain ID_

Controls the number of past blocks to keep in memory to use as a basis for
calculating a percentile gas price.

### BLOCK_HISTORY_ESTIMATOR_BLOCK_DELAY

  * Default: _automatic, based on chain ID_

Controls the number of blocks that the block history estimator trails behind
head. For example, if this is set to 3, and we receive block 10, block history
estimator will fetch block 7.

CAUTION: You might be tempted to set this to 0 to use the latest possible
block, but it is possible to receive a head BEFORE that block is actually
available from the connected node via RPC, due to race conditions in the code
of the remote ETH node. In this case you will get false ""zero"" blocks that are
missing transactions.

### BLOCK_HISTORY_ESTIMATOR_EIP1559_FEE_CAP_BUFFER_BLOCKS

**ADVANCED**

  * Default: _gas bump threshold + 1 block_

If EIP1559 mode is enabled, this optional env var controls the buffer blocks
to add to the current base fee when sending a transaction. By default, the gas
bumping threshold + 1 block is used. It is not recommended to change this
unless you know what you are doing.

### BLOCK_HISTORY_ESTIMATOR_TRANSACTION_PERCENTILE

  * Default: `""60""`

Must be in range 0-100.

Only has an effect if gas updater is enabled. Specifies percentile gas price
to choose. E.g. if the block history contains four transactions with gas
prices `[100, 200, 300, 400]` then picking 25 for this number will give a
value of 200. If the calculated gas price is higher than
`ETH_GAS_PRICE_DEFAULT` then the higher price will be used as the base price
for new transactions.

Think of this number as an indicator of how aggressive you want your node to
price its transactions.

Setting this number higher will cause the Chainlink node to select higher gas
prices.

Setting it lower will tend to set lower gas prices.

## EVM/Ethereum Transaction Simulation

Chainlink nodes support transaction simulation for certain types of job. When
this is enabled, transactions will be simulated using `eth_call` before
initial send. If the transaction would revert, the transaction is marked as an
error without being broadcast, potentially avoiding an expensive on-chain
revert.

This can add a tiny bit of latency with an upper bound of 2s, but generally
much shorter under good conditions. This will add marginally more load to the
ETH client, because it adds an extra call for every transaction sent. However,
it might help to save gas in some cases especially during periods of high
demand by avoiding unnecessary reverts due to outdated round etc.

This option is EXPERIMENTAL and disabled by default.

To enable for FM or OCR:

`FM_SIMULATE_TRANSACTIONs=true` `OCR_SIMULATE_TRANSACTIONS=true`

To enable in the pipeline, use the `simulate=true` option like so:


    submit [type=ethtx to=""0xDeadDeadDeadDeadDeadDeadDeadDead"" data=""0xDead"" simulate=true]

Use at your own risk.

#### FM_SIMULATE_TRANSACTIONS

NOTE: This overrides the setting for _all_ chains, it is not currently
possible to configure this on a per-chain basis.

  * Default: `""false""`

`FM_SIMULATE_TRANSACTIONS` allows to enable transaction simulation for Flux
Monitor.

#### OCR_SIMULATE_TRANSACTIONS

NOTE: This overrides the setting for _all_ chains, it is not currently
possible to configure this on a per-chain basis.

  * Default: `""false""`

`OCR_SIMULATE_TRANSACTIONS` allows to enable transaction simulation for OCR.

## Job Pipeline and tasks

### DEFAULT_HTTP_LIMIT

  * Default: `""32768""`

`DEFAULT_HTTP_LIMIT` defines the maximum number of bytes for HTTP requests and
responses made by `http` and `bridge` adapters.

### DEFAULT_HTTP_TIMEOUT

  * Default: `""15s""`

`DEFAULT_HTTP_TIMEOUT` defines the default timeout for HTTP requests made by
`http` and `bridge` adapters.

### FEATURE_EXTERNAL_INITIATORS

  * Default: `""false""`

Enables the External Initiator feature. If disabled, `webhook` jobs can ONLY
be initiated by a logged-in user. If enabled, `webhook` jobs can be initiated
by a whitelisted external initiator.

### JOB_PIPELINE_MAX_RUN_DURATION

  * Default: `""10m""`

`JOB_PIPELINE_MAX_RUN_DURATION` is the maximum time that a single job run
might take. If it takes longer, it will exit early and be marked errored. If
set to zero, disables the time limit completely.

### JOB_PIPELINE_MAX_SUCCESSFUL_RUNS

This option is not supported as an environment variable. Use
`JobPipeline.MaxSuccessfulRuns` in the config file instead. See the
[CONFIG.md](https://github.com/smartcontractkit/chainlink/blob/v1.12.0/docs/CONFIG.md)
reference for details.

### JOB_PIPELINE_REAPER_INTERVAL

  * Default: `""1h""`

In order to keep database size manageable, Chainlink nodes will run a reaper
that deletes completed job runs older than a certain threshold age.
`JOB_PIPELINE_REAPER_INTERVAL` controls how often the job pipeline reaper will
run.

Set to `0` to disable the periodic reaper.

### JOB_PIPELINE_REAPER_THRESHOLD

  * Default: `""24h""`

`JOB_PIPELINE_REAPER_THRESHOLD` determines the age limit for job runs.
Completed job runs older than this will be automatically purged from the
database.

### JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH

  * Default: `""100""`

Some jobs write their results asynchronously for performance reasons such as
OCR. `JOB_PIPELINE_RESULT_WRITE_QUEUE_DEPTH` controls how many writes will be
buffered before subsequent writes are dropped.

Do not change this setting unless you know what you are doing.

## OCR

This section applies only if you are running off-chain reporting jobs.

### FEATURE_OFFCHAIN_REPORTING

  * Default: `""false""`

Set to `true` to enable OCR jobs.

### OCR_KEY_BUNDLE_ID

  * Default: _none_

`OCR_KEY_BUNDLE_ID` is the default key bundle ID to use for OCR jobs. If you
have an OCR job that does not explicitly specify a key bundle ID, it will fall
back to this value.

### OCR_MONITORING_ENDPOINT

  * Default: _none_

Optional URL of OCR monitoring endpoint.

### OCR_TRANSMITTER_ADDRESS

  * Default: _none_

`OCR_TRANSMITTER_ADDRESS` is the default sending address to use for OCR. If
you have an OCR job that does not explicitly specify a transmitter address, it
will fall back to this value.

### P2P_NETWORKING_STACK

  * Default: `""V1""`

OCR supports multiple networking stacks. `P2P_NETWORKING_STACK` chooses which
stack to use. Possible values are:

  * `V1`
  * `V1V2` \- Runs both stacks simultaneously. For each link with another peer, V2 networking will be preferred. If V2 does not work, the link will automatically fall back to V1. If V2 starts working again later, it will automatically be prefered again. This is useful for migrating networks without downtime. Note that the two networking stacks _must not_ be configured to bind to the same IP/port.
  * `V2`

All nodes in the OCR network should share the same networking stack. The `V1`
stack is deprecated and is being phased out. Do not use it for new
deployments. Expect the default value of this variable to change to `V2` in
the future.

#### P2P_PEER_ID

  * Default: _none_

This environment variable is used for both Networking Stack V1 and V2.

The default peer ID to use for OCR jobs. If unspecified, uses the first
available peer ID. Example:
`P2P_PEER_ID=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U`

### Networking Stack V1

caution

Do not set environment variables for Networking Stack v1 if you are using
Networking Stack V2.

#### P2P_ANNOUNCE_IP

  * Default: _none_

Should be set as the externally reachable IP address of the Chainlink node.
Example: `P2P_ANNOUNCE_IP=1.2.3.4`

#### P2P_ANNOUNCE_PORT

  * Default: _none_

Should be set as the externally reachable port of the Chainlink node. Example:
`P2P_ANNOUNCE_PORT=1337`

#### P2P_BOOTSTRAP_PEERS

  * Default: _none_

Default set of bootstrap peers. Example:
`P2P_BOOTSTRAP_PEERS=/dns4/example.com/tcp/1337/p2p/12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U
/ip4/1.2.3.4/tcp/9999/p2p/12D3KooWLZ9uTC3MrvKfDpGju6RAQubiMDL7CuJcAgDRTYP7fh7R`

#### P2P_LISTEN_IP

  * Default: `""0.0.0.0""`

The default IP address to bind to.

#### P2P_LISTEN_PORT

  * Default: _none_

The port to listen on. If left blank, the node randomly selects a different
port each time it boots. It is highly recommended to set this to a static
value to avoid network instability.

#### P2P_PEER_ID

  * Default: _none_

This environment variable is used for both Networking Stack V1 and V2.

The default peer ID to use for OCR jobs. If unspecified, uses the first
available peer ID. Example:
`P2P_PEER_ID=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U`

### Networking Stack V2

caution

If using the Networking Stack V2, you must unset the following Networking
Stack V1 configuration variables:

  * P2P_ANNOUNCE_IP
  * P2P_ANNOUNCE_PORT
  * P2P_BOOTSTRAP_PEERS
  * P2P_LISTEN_IP
  * P2P_LISTEN_PORT

`P2P_PEER_ID` is used for both Networking Stack V1 and V2.

The Networking Stack V2 uses TCP, any ports mentioned in this section refer to
TCP ports.

#### P2PV2_ANNOUNCE_ADDRESSES

  * Default: _none_

`P2PV2_ANNOUNCE_ADDRESSES` contains the addresses the node will advertise for
peer discovery in host:port form as accepted by the TCP version of Go's
[`net.Dial`](https://pkg.go.dev/net#Dial). The addresses should be reachable
by other nodes on the network. When attempting to connect to another node, a
node will attempt to dial all of the other node's `P2PV2_ANNOUNCE_ADDRESSES`
in round-robin fashion. Example: `P2PV2_ANNOUNCE_ADDRESSES=1.2.3.4:9999
[a52d:0:a88:1274::abcd]:1337`

#### P2PV2_BOOTSTRAPPERS

  * Default: _none_

`P2PV2_BOOTSTRAPPERS` returns the default bootstrapper peers for libocr's v2
networking stack. Example:
`P2PV2_BOOTSTRAPPERS=12D3KooWMHMRLQkgPbFSYHwD3NBuwtS1AmxhvKVUrcfyaGDASR4U@1.2.3.4:9999
12D3KooWLZ9uTC3MrvKfDpGju6RAQubiMDL7CuJcAgDRTYP7fh7R@[a52d:0:a88:1274::abcd]:1337
12D3KooWM55u5Swtpw9r8aFLQHEtw7HR4t44GdNs654ej5gRs2Dh@example.com:1234`

Oracle nodes typically only know each other's PeerIDs, but not their
hostnames, IP addresses, or ports. Bootstrappers are special nodes that help
other nodes discover each other's `P2PV2_ANNOUNCE_ADDRESSES` so they can
communicate. Nodes continuously attempt to connect to bootstrappers configured
in `P2PV2_BOOTSTRAPPERS`. When a node wants to connect to another node (which
it knows only by PeerID, but not by address), it discovers the other node's
`P2PV2_ANNOUNCE_ADDRESSES` from communications received from its
`P2PV2_BOOTSTRAPPERS` or other discovered nodes. To facilitate discovery,
nodes will regularly broadcast signed announcements containing their PeerID
and `P2PV2_ANNOUNCE_ADDRESSES`.

#### P2PV2_LISTEN_ADDRESSES

  * Default: _none_

`P2PV2_LISTEN_ADDRESSES` contains the addresses the peer will listen to on the
network in `host:port` form as accepted by `net.Listen()`, but the host and
port must be fully specified and cannot be empty. You can specify `0.0.0.0`
(IPv4) or `::` (IPv6) to listen on all interfaces, but that is not
recommended.

Example: `P2PV2_LISTEN_ADDRESSES=1.2.3.4:9999 [a52d:0:a88:1274::abcd]:1337`

## Keeper

These environment variables are used specificly for Chainlink Keepers. For
most Chainlink Nodes, leave these values at their defaults and do not
configure these environment variables.

### KEEPER_GAS_PRICE_BUFFER_PERCENT

caution

  * Default: `""20""`

`KEEPER_GAS_PRICE_BUFFER_PERCENT` adds the specified percentage to the gas
price used for checking whether to perform an upkeep. Only applies in legacy
mode (EIP-1559 off).

### KEEPER_GAS_TIP_CAP_BUFFER_PERCENT

caution

  * Default: `""20""`

`KEEPER_GAS_TIP_CAP_BUFFER_PERCENT` adds the specified percentage to the gas
price used for checking whether to perform an upkeep. Only applies in EIP-1559
mode.

### KEEPER_BASE_FEE_BUFFER_PERCENT

caution

  * Default: `""20""`

Adds the specified percentage to the base fee used for checking whether to
perform an upkeep. Applies only in EIP-1559 mode.

### KEEPER_MAXIMUM_GRACE_PERIOD

caution

  * Default: `""100""`

The maximum number of blocks that a keeper will wait after performing an
upkeep before it resumes checking that upkeep

### KEEPER_REGISTRY_CHECK_GAS_OVERHEAD

caution

  * Default: `""200000""`

The amount of extra gas to provide checkUpkeep() calls to account for the gas
consumed by the keeper registry.

### KEEPER_REGISTRY_PERFORM_GAS_OVERHEAD

caution

  * Default: `""300000""`

The amount of extra gas to provide performUpkeep() calls to account for the
gas consumed by the keeper registry

### KEEPER_REGISTRY_SYNC_INTERVAL

caution

  * Default: `""30m""`

The interval in which the RegistrySynchronizer performs a full sync of the
keeper registry contract it is tracking.

### KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE

caution

  * Default: `""10""`

`KEEPER_REGISTRY_SYNC_UPKEEP_QUEUE_SIZE` represents the maximum number of
upkeeps that can be synced in parallel.

### KEEPER_TURN_LOOK_BACK

caution

  * Default: `""1000""`

The number of blocks in the past to look back when getting a block for a turn.

## CLI Client

The environment variables in this section apply only when running CLI commands
that connect to a remote running instance of a Chainlink node.

### ADMIN_CREDENTIALS_FILE

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--admin-credentials-file FILE` CLI argument instead.

  * Default: `$ROOT/apicredentials`

`ADMIN_CREDENTIALS_FILE` optionally points to a text file containing admin
credentials for logging in. It is useful for running client CLI commands and
has no effect when passed to a running node.

The file should contain two lines, the first line is the username and second
line is the password. e.g.


    myusername@example.com
    mysecurepassw0rd

### CLIENT_NODE_URL

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--remote-node-url URL` CLI argument instead.

  * Default: `""http://localhost:6688""`

This is the URL that you will use to interact with the node, including the
GUI. Use this URL to connect to the GUI or to run commands remotely using the
Chainlink CLI.

### INSECURE_SKIP_VERIFY

caution

[Deprecated] This environment variable is deprecated and will be removed in a
future release. Use the `--insecure-skip-verify` CLI argument instead.

  * Default: `""false""`

`INSECURE_SKIP_VERIFY` disables SSL certificate verification when connection
to a Chainlink node using the remote client. For example, when executing most
remote commands in the CLI. This is mostly useful for people who want to use
TLS on localhost.

It is not recommended to change this unless you know what you are doing.

## Notes on setting environment variables

note

Some environment variables require a duration. A duration string is a possibly
signed sequence of decimal numbers, each with optional fraction and a unit
suffix, such as ""300ms"", ""-1.5h"" or ""2h45m"". Valid time units are ""ns"", ""us""
(or ""µs""), ""ms"", ""s"", ""m"", ""h"". Some examples:

`10ms` `1h15m` `42m30s`

note

Some configuration variables require a file size. A file size string is an
unsigned integer (123) or a float (12.3) followed by a unit suffix. Valid file
size units are ""b"", ""kb"", ""mb"", ""gb"", and ""tb"". If the unit is omitted, it is
assumed to be ""b"" (bytes). Capitalization does not matter. Some examples:

`123gb` `1.2TB` `12345`

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/configuration.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Fulfilling Requests

  * Overview
  * Requirements
  * Address Types
  * Setup your Operator contract
  * Deploy your own Operator contract
  * Whitelist your node address in the Operator contract
  * Add a job to the node
  * Create a request to your node
  * Withdrawing LINK

Run a Chainlink node

This guide assumes you have a running Chainlink node. To learn how to run a
node, see the [Running a Chainlink Node locally](/chainlink-nodes/v1/running-a-chainlink-node) guide.

You can use your Chainlink nodes to fulfill requests. This guide shows you how
to deploy your own operator contract and add jobs to your node so that it can
provide data to smart contracts.

Chainlink nodes can fulfill requests from open or unauthenticated APIs without
the need for [External Adapters](/chainlink-nodes/external-adapters/external-adapters) as long as you've added the jobs to the node. For these requests,
requesters supply the URL to the open API that they want each node to
retrieve. The Chainlink node will use [tasks](/chainlink-nodes/oracle-jobs/tasks) to fulfill the request.

Some APIs require authentication by providing request headers for the
operator's API key, which the Chainlink node supports. If you would like to
provide access to an API that requires authentication, you must create a job
that is specific for that API either using an [external adapter](/chainlink-nodes/external-adapters/external-adapters) or by using the parameters of the
[HTTP task](/chainlink-nodes/oracle-jobs/all-tasks/#http-task).

## Requirements

Before you begin this guide, complete the following tasks to make sure you
have all of the tools that you need:

  * [Set up MetaMask](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) and [obtain testnet LINK](/resources/acquire-link).

  * [Run a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node).

  * Fund the Ethereum address that your Chainlink node uses. You can find the address in the node Operator GUI under the **Key Management** configuration. The address of the node is the `Regular` type. You can obtain test ETH from several [faucets](/resources/link-token-contracts). For this tutorial to work, you will have to fund the node's Ethereum address with Sepolia ETH. Here is an example:

## Address Types

Your node works with several different types of addresses. Each address type
has a specific function:

  * **Node address:** This is the address for your Chainlink node wallet. The node requires native blockchain tokens at all times to respond to requests. For this example, the node uses Sepolia ETH. When you start a Chainlink node, it automatically generates this address. You can find this address on the Node Operator GUI under **Key Management > EVM Chain Accounts**.
  * **Oracle contract address:** This is the address for contracts like `Operator.sol` or `Oracle.sol` that are deployed to a blockchain. Do not fund these addresses with native blockchain tokens such as ETH. When you make API call requests, the funds pass through this contract to interact with your Chainlink node. This will be the address that smart contract developers point to when they choose a node for an API call.
  * **Admin wallet address:** This is the address that owns your `Operator.sol` or `Oracle.sol` contract addresses. If you're on OCR, this is the wallet address that receives LINK tokens.

## Setup your Operator contract

### Deploy your own Operator contract

  1. Go to Remix and open the [`Operator.sol` smart contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkNodes/Operator.sol).

  2. On the **Compile** tab, click the **Compile** button for `Operator.sol`. Remix automatically selects the compiler version and language from the `pragma` line unless you select a specific version manually.

  3. On the **Deploy and Run** tab, configure the following settings:

    * Select ""Injected Provider"" as your **Environment**. The Javascript VM environment cannot access your oracle node. Make sure your Metamask is connected to Sepolia testnet.

    * Select the ""Operator"" contract from the **Contract** menu.

    * Copy the [LINK token contract address](/resources/link-token-contracts) for the network you are using and paste it into the `LINK` field next to the **Deploy** button. For Sepolia, you can use this address:
        
                0x779877A7B0D9E8603169DdbD7836e478b4624789

    * Copy the _Admin wallet address_ into the `OWNER` field.

  4. Click **transact**. MetaMask prompts you to confirm the transaction.

MetaMask doesn't pop up?

If MetaMask does not prompt you and instead displays the error below, disable
""Privacy Mode"" in MetaMask. You can do this by clicking on your unique account
icon at the top-right, then go to the Settings. Privacy Mode will be a switch
near the bottom.

  

Error: **Send transaction failed: Invalid address. If you use an injected
provider, please check it is properly unlocked.**

  5. If the transaction is successful, a new address displays in the **Deployed Contracts** section.

  6. Keep note of the Operator contract address. You need it later for your consuming contract.

### Whitelist your node address in the Operator contract

  1. In the Chainlink node GUI, find and copy the address of your chainlink node. see Requirements.

  2. In Remix, call the `setAuthorizedSenders` function with the address of your node. Note the function expects an array.

  3. Click the `transact` function to run it. Approve the transaction in MetaMask and wait for it to confirm on the blockchain.

  4. Call `isAuthorizedSender` function with the address of your node to verify that your chainlink node address can call the operator contract. The function must return `true`.

## Add a job to the node

You will create a job that calls an OpenAPI , parses the response and then
return a `uint256`.

  1. In the Chainlink Operator UI on the **Jobs** tab, click **New Job**.

  2. Paste the job specification from above into the text field.
    
        # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    name = ""Get > Uint256 - (TOML)""
    schemaVersion = 1
    type = ""directrequest""
    # Optional External Job ID: Automatically generated if unspecified
    # externalJobID = ""b1d42cd5-4a3a-4200-b1f7-25a68e48aad8""
    contractAddress = ""YOUR_OPERATOR_CONTRACT_ADDRESS""
    maxTaskDuration = ""0s""
    minIncomingConfirmations = 0
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=""cborparse"" data=""$(decode_log.data)""]
        fetch        [type=""http"" method=GET url=""$(decode_cbor.get)"" allowUnrestrictedNetworkAccess=""true""]
        parse        [type=""jsonparse"" path=""$(decode_cbor.path)"" data=""$(fetch)""]
    
        multiply     [type=""multiply"" input=""$(parse)"" times=""$(decode_cbor.times)""]
    
        encode_data  [type=""ethabiencode"" abi=""(bytes32 requestId, uint256 value)"" data=""{ \\""requestId\\"": $(decode_log.requestId), \\""value\\"": $(multiply) }""]
        encode_tx    [type=""ethabiencode""
                      abi=""fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes calldata data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"":   $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                      ]
        submit_tx    [type=""ethtx"" to=""YOUR_OPERATOR_CONTRACT_ADDRESS"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> multiply -> encode_data -> encode_tx -> submit_tx
    """"""
    

  3. Replace `YOUR_OPERATOR_CONTRACT_ADDRESS` with the address of your deployed operator contract address from the previous steps.

  4. Click **Create Job**. If the node creates the job successfully, a notice with the job number appears.

  5. Click the job number to view the job details. You can also find the job listed on the **Jobs** tab in the Node Operators UI. Save the `externalJobID` value because you will need it later to tell your consumer contract what job ID to request from your node.

## Create a request to your node

After you add jobs to your node, you can use the node to fulfill requests.
This section shows what a requester does when they send requests to your node.
It is also a way to test and make sure that your node is functioning
correctly.

  1. Open [ATestnetConsumer.sol in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol).

  2. Note that `setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789)` is configured for _Sepolia_.

  3. On the **Compiler** tab, click the **Compile** button for `ATestnetConsumer.sol`.

  4. On the **Deploy and Run** tab, configure the following settings:

    * Select _Injected Provider_ as your environment. Make sure your metamask is connected to Sepolia.
    * Select _ATestnetConsumer_ from the **Contract** menu.
  5. Click **Deploy**. MetaMask prompts you to confirm the transaction.

  6. Fund the contract by sending LINK to the contract's address. See the [Fund your contract](/resources/fund-your-contract) page for instructions. The address for the `ATestnetConsumer` contract is on the list of your deployed contracts in Remix. You can fund your contract with 1 LINK.

  7. After you fund the contract, create a request. Input your operator contract address and the job ID for the `Get > Uint256` job into the `requestEthereumPrice` request method **without dashes**. The job ID is the `externalJobID` parameter, which you can find on your job's definition page in the Node Operators UI.

  8. Click the **transact** button for the `requestEthereumPrice` function and approve the transaction in Metamask. The `requestEthereumPrice` function asks the node to retrieve `uint256` data specifically from [https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD](https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD).

  9. After the transaction processes, you can see the details for the complete the job run the **Runs** page in the Node Operators UI.

  10. In Remix, click the `currentPrice` variable to see the current price updated on your consumer contract.

## Withdrawing LINK

You can withdraw LINK from the operator contract. In Remix under the list of
deployed contracts, click on your Operator contract and find the `withdraw`
function in the function list. Note that only the admin (see Admin wallet
address) can withdraw LINK.



Paste the address you want to withdraw to, and specify the amount of LINK that
you want to withdraw. Then, click `withdraw`. Confirm the transaction in
MetaMask when the popup appears.

## What's next

  * [› Performing System Maintenance](/chainlink-nodes/resources/performing-system-maintenance)
  * [› v2 Jobs](/chainlink-nodes/oracle-jobs/jobs)
  * [› Security and Operation Best Practices](/chainlink-nodes/resources/best-security-practices)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/fulfilling-requests.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.



"
Why is randomness important in many types of applications?,Randomness is important in many types of applications because it is an essential component of a majority of games.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-1/course.md'},"Randomness is important in many types of applications because it adds unpredictability and fairness. In games, randomness creates variety and challenges for players. In cryptographic applications, randomness is crucial for generating secure keys and protecting sensitive information. Deterministic systems like computers cannot produce true randomness on their own, so methods like true random number generators (RNGs) and pseudo-random number generators (PRNGs) are used. True RNGs rely on measuring physical phenomena like atmospheric noise to generate random numbers, while PRNGs use computational algorithms to produce apparently random results based on an initial seed. The use of true randomness is especially important in applications where security is a concern, as it reduces the risk of brute-force attacks. Overall, randomness plays a vital role in ensuring fairness, security, and variety in various applications.

","- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-2/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-1/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md","#####Chapter 2:

# Randomness and Deterministic Machines

Computers are deterministic machines. Per definition, they cannot produce randomness without any external inputs. Once this external input is given, Computer Science has found different methods to generate random numbers. We distinguish between true random number generators (RNG) and pseudo-random number generators (PRNG). You can use a PRNG if your random generator does not need any security guarantees. For example, if you are programming a simple coin-flipping game that you want to use daily to decide between two options, you can use a PRNG like JavaScripts Math.random(). It uses computational algorithms to produce apparently random results. These results are entirely depending on an initial seed. So if the seed is known, the same result can be reproduced.

This might work for prototypes and many practical applications. But imagine you want to encrypt a message. You would use a public key to encrypt the message and only the private key could decrypt it. The private key needs to be created at some point. Public key cryptography uses random numbers as input to calculate and create key pairs. If your source of randomness is something like Math.random(), it will be far more feasible for an attacker to guess your private key by brute-forcing the “random” numbers which is produced by this function. In other words, it drastically reduces the search space for the attacker. And the more they know about your conditions, the easier it is for them to find the correct private key as they have to search through fewer options.

Luckily, there are also true random number generators that we can use. They usually rely on measuring physical phenomena like atmospheric noise. It uses a natural source of entropy to avoid any brute-force attacks. This is critical to generating random numbers. Unpredictability is an essential requirement for true random number generators. Unpredictable means no one can reproduce the result by taking the same system as an input. So you cannot simply measure the same atmospheric noise to produce similar results. They will be completely different. So the quality of entropy becomes a fundamental metric. Once this is given, there are different tools to translate this into random numbers.


:::NEXT DOC:::

#####Chapter 1:

# Randomness

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      With your newfound power, understanding of what smart contracts are you want to develop a smart contract to raffle an NFT to your friends. But how will you get randomness into your raffle smart contract?
    </div>
  </div>
</ContentWrapp>

Randomness is essential for many types of applications. Think about how many games have randomness built-in. Rolling dice in dungeons and dragons, a random starting hand of poker, or a random next block in Tetris, randomness is an essential component of a majority of games. As we learned in Chainlink 101, smart contracts are a powerful tool for decentralized applications (dapps). But what if you want to build a game, raffle or any other type of application that utilizes randomness on the blockchain? Let's learn about randomness on the blockchain in the next lesson!


:::NEXT DOC:::

#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let’s take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.
"
What is the Monte Carlo fallacy?,The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md'},"The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. It is a fallacy because the occurrence of events is random and independent of previous events. An example of this fallacy is believing that if red has appeared ten times in a row in a game of roulette, the next color is more likely to be black. However, statistically, there is no reason to assume that the next color will be black. The occurrence of colors in roulette is random and independent.

",- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md,"Question: (Asked on: 2022-01-05 20:46:56)
Python: Error 54 &#39;Connection reset by peer&#39;
URL: https://stackoverflow.com/questions/70599391/python-error-54-connection-reset-by-peer

Question Body:


I'm getting the folllowing error: ChunkedEncodingError: (""Connection broken:
ConnectionResetError(54, 'Connection reset by peer') while downloading this:
Downloading from <https://solc-bin.ethereum.org/macosx-amd64/solc-macosx-
amd64-v0.8.11+commit.d7f03943>. Please let me know how I can solve this. Thank
you in advance!!!

here is the code:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.4.11;
    
    import ""@chainlink/contracts/src/v0.4/ERC677Token.sol"";
    import {StandardToken as linkStandardToken} from ""@chainlink/contracts/src/v0.4/vendor/StandardToken.sol"";
    
    contract LinkToken is linkStandardToken, ERC677Token {
        uint256 public constant totalSupply = 10**27;
        string public constant name = ""ChainLink Token"";
        uint8 public constant decimals = 18;
        string public constant symbol = ""LINK"";
    
        function LinkToken() public {
            balances[msg.sender] = totalSupply;
        }
    
        /**
         * @dev transfer token to a specified address with additional data if the recipient is a contract.
         * @param _to The address to transfer to.
         * @param _value The amount to be transferred.
         * @param _data The extra data to be passed to the receiving contract.
         */
        function transferAndCall(
            address _to,
            uint256 _value,
            bytes _data
        ) public validRecipient(_to) returns (bool success) {
            return super.transferAndCall(_to, _value, _data);
        }
    
        /**
         * @dev transfer token to a specified address.
         * @param _to The address to transfer to.
         * @param _value The amount to be transferred.
         */
        function transfer(address _to, uint256 _value)
            public
            validRecipient(_to)
            returns (bool success)
        {
            return super.transfer(_to, _value);
        }
    
        /**
         * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
         * @param _spender The address which will spend the funds.
         * @param _value The amount of tokens to be spent.
         */
        function approve(address _spender, uint256 _value)
            public
            validRecipient(_spender)
            returns (bool)
        {
            return super.approve(_spender, _value);
        }
    
        /**
         * @dev Transfer tokens from one address to another
         * @param _from address The address which you want to send tokens from
         * @param _to address The address which you want to transfer to
         * @param _value uint256 the amount of tokens to be transferred
         */
        function transferFrom(
            address _from,
            address _to,
            uint256 _value
        ) public validRecipient(_to) returns (bool) {
            return super.transferFrom(_from, _to, _value);
        }
    
        // MODIFIERS
    
        modifier validRecipient(address _recipient) {
            require(_recipient != address(0) && _recipient != address(this));
            _;
        }
    }
    

Here is an error message:

    
    
    Downloading from https://solc-bin.ethereum.org/macosx-amd64/solc-macosx-amd64-v0.8.11+commit.d7f03943
     37%|████████████████████████████████████████████▉                                                                             | 14.2M/38.5M [00:53<01:32, 264kiB/s]
      File ""brownie/_cli/__main__.py"", line 64, in main
        importlib.import_module(f""brownie._cli.{cmd}"").main()
      File ""brownie/_cli/run.py"", line 40, in main
        active_project = project.load()
      File ""brownie/project/main.py"", line 751, in load
        return Project(name, project_path)
      File ""brownie/project/main.py"", line 183, in __init__
        self.load()
      File ""brownie/project/main.py"", line 238, in load
        self._compile(changed, self._compiler_config, False)
      File ""brownie/project/main.py"", line 95, in _compile
        build_json = compiler.compile_and_format(
      File ""brownie/project/compiler/__init__.py"", line 105, in compile_and_format
        find_solc_versions(solc_sources, install_needed=True, silent=silent)
      File ""brownie/project/compiler/solidity.py"", line 173, in find_solc_versions
        install_solc(*to_install)
      File ""brownie/project/compiler/solidity.py"", line 105, in install_solc
        solcx.install_solc(version, show_progress=True)
      File ""solcx/install.py"", line 454, in install_solc
        _install_solc_unix(version, filename, show_progress, solcx_binary_path)
      File ""solcx/install.py"", line 603, in _install_solc_unix
        content = _download_solc(download, show_progress)
      File ""solcx/install.py"", line 589, in _download_solc
        for data in response.iter_content(1024, decode_unicode=True):
      File ""requests/utils.py"", line 536, in stream_decode_response_unicode
        for item in iterator:
      File ""requests/models.py"", line 761, in generate
        raise ChunkedEncodingError(e)
    ChunkedEncodingError: (""Connection broken: ConnectionResetError(54, 'Connection reset by peer')"", ConnectionResetError(54, 'Connection reset by peer'))
    



Answers:
(Answered on: 2022-01-06 14:23:10)


The error is in the solidity compiler download, you could look for another
link to download it. [solc-bin.ethereum.org](https://solc-bin.ethereum.org/)
is deprecated.

Here are updated link: <https://docs.soliditylang.org/en/latest/installing-
solidity.html#static-binaries>

One comment: it is trying to download solidity 0.8.11. Even though the code is
for version ^0.4.11, it will not work with this compiler version.

You can check the breaking changes

<https://docs.soliditylang.org/en/latest/080-breaking-changes.html>





:::NEXT DOC:::

#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let’s take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.


:::NEXT DOC:::

#####Chapter 3:

# Randomness and Blockchains

Blockchains heavily rely on cryptography and randomness for security. The most straightforward example is the creation of key pairs used to do transactions. When you create a new key pair, a random number is needed as the initial input. We have learned in the previous example how to obtain this number from, e.g., the physical world. This number is then used to calculate a seed which is further used to derive all further key pairs.

This works well for key creation, but how to use random numbers on-chain? While the initial number could be completely random, as soon as you add it to a transaction, everyone who observes the mempool can see it. And also, the miners/validators can see it and decide how to deal with your transaction based on the number. This also would mean that someone controls the creation of the random number. So you must trust this source. So the random number cannot be created on-chain and must be provided from the outside. Is there no other way?

You might argue that you can use the content of a block as a source of randomness. But these values can be actively manipulated by miners. They could add or remove transactions to find a result that benefits them. In addition, blocks also have particular properties that could reduce the search space to calculate probabilities that a specific number will be selected. So this is an insecure way of creating random numbers.

So if you cannot trust the miners, you could argue for using Oracles. A trusted third-party system could be used to create random numbers and then provide them to services via an oracle. But depending on the economic incentive, someone could be interested in hacking this system to provide non-random numbers as input. And while they might use a true random number generator, you don’t know for sure and do not have any way to check the validity of such a statement once the number was generated.

So we must address two further issues here. The single point of failure (single oracle) and validating that the number was generated with a particular function. For the first issue, you could argue that you could use decentralized oracle network (DON). So it wouldn’t be a single oracle that we need to trust.
But how do we know this DON is not generating numbers based on certain conditions? For this reason, Verifiable Random Functions are used. They allow everyone to verify that a specific VRF was used and that the number was produced by a particular VRF and no other function. This allows us to generate verifiable random numbers for on-chain usage in a decentralized way.
"
What does VRF stand for in Chainlink VRF?,VRF stands for Verifiable Randomness Function.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-3/course.md'},"VRF stands for Verifiable Random Function in Chainlink VRF.
","https://docs.chain.link/vrf/, https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-3/course.md","Question: (Asked on: 2022-01-18 13:13:16)
Can you develop an independent, secure oracle for your dApp?
URL: https://stackoverflow.com/questions/70756168/can-you-develop-an-independent-secure-oracle-for-your-dapp

Question Body:


I need random number generation for the dApp I am developing and would love to
Not have to pay for a service like Chainlink or Provable. Not that I don't
support their work, but bootstrapping is bootstrapping and the funds are
limited.

I'm assuming that developing an independent oracle is possible, but probably
discouraged because security is a whole industry, but I am wondering if anyone
has attempted Or if any experts here believe it is possible to do this and
feel good about the decision.

Looking forward to a lively debate! Maybe this is a simple question to answer
and I am missing something...



Answers:
(Answered on: 2022-01-18 20:58:48)


Random numbers and blockchains don't go together very well due to the fact a
blockchain is deterministic. This means you should not rely on any on-chain
values for a source of randomness (like block hashes or timestamps etc), as
they can be manipulated or pre-determined by miners and used to game your
contract that relies on randomness.

In addition to this, just using an oracle to get a source of randomness from
an external API is also strongly discouraged, because there's no real way of
knowing if the returned number is _actually_ random, of it's been sent back by
a malicious actor wanting to game your contract that relies on it. Ie if your
oracle returned **123456789** , how do you know if its a truly random number,
or if its returning that because it knows it can then call your contract and
take funds if that random number is used?

This is where a _verifiable random number_ comes into play. With a verifiable
random number, an oracle is used, however there is a
[seed](https://en.wikipedia.org/wiki/Random_seed#:%7E:text=A%20random%20seed%20)
generated based on something (could be user input or on-chain data, it doesn't
matter) before the call to the oracle is made (the call passes the seed to the
oracle). Once the oracle generates a random number, the VRF function can then
use math and cryptography to actually verify that the random number was
created based from the initial seed, and that it's not just some random number
plucked from the air (and potentially malicious). This is the magic of VRF,
being able to verify a random number was created with a previously committed
seed. So combining a VRF function with an oracle is the best possible way for
a safe and secure source of randomness in a smart contract.

[Chainlink VRF](https://chain.link/chainlink-vrf) is the industry standard for
randomness on blockchains, and I highly suggest you look into it. If it's cost
you're worried about, I think its cheaper to use on other chains like Polygon
or BSC. Also if you speak to the Chainlink Labs team, they can possibly work
out some agreement that is more feasible for bootstrapped projects





:::NEXT DOC:::

#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.


:::NEXT DOC:::

#####Chapter 3:

# Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson randomness provided by an outside service needs to be verifiable and decentralized, and that’s exactly what Chainlink VRF is! VRF stands for Verifiable Randomness Function. Essentially Chainlink VRF provides cryptographic proof alongside every random number generated, that the random number wasn’t tampered with (and indeed generated in a random way).

How does this cryptographic proof work? It’s quite mathematically complicated and outside the scope of this lesson, but you can read more about it in the “Technical Walkthrough” section of this [blog post](https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/). The cryptographic proof is then verified by a smart contract on-chain, which means it is verified by every node on the blockchain! This completes our verifiable and decentralized criteria. So now we understand that Chainlink VRF is verifiably random and decentralized how do we use it?


:::NEXT DOC:::

#####Chapter 5: VRF Subscriptions

# Subscribing to the VRF
Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number. 

## VRFv2
In VRFv2, the most recent version of the VRF, the concept of a subscription was added. What is a subscription? Essentially, it's an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. Once a subscription is set-up a consumer contract can then request randomness, the VRF respondes with a random number and proof, and then after the random number is included on-chain the VRF is paid with some of the LINK prepaid in the subscription.

The power that comes from this subscription model is that now consumer contracts have much more flexibility in requesting random numbers. Before subscriptions it was a static price, and the VRF always returned a single random number. 
 
But what if the consumer contract needs more than one random number? The consumer contract can now specify how many random numbers it wants to request.  
 
What if the consumer contract needs the random number to be included very fast by paying a higher gas price? The consumer contract can now request how much it's willing to pay for gas. This is called the **gas lane**. 
 
What if the consumer contract needs to run some heavy calculations after recieving the random number? It can set a limit to how much gas will be spent by the VRF when submitting the random number. This is called the **callbackGasLimit**.

And because this is all pre-paid via the subscription, and credited from the subscription amount after the VRF has responded with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! "
What is Solidity?,"Solidity is a smart contract programming language created by Ethereum developers to work with Ethereum, the first major smart contract blockchain.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-1/course.md'},"Solidity is a programming language used for writing smart contracts on the Ethereum blockchain. It is an object-oriented programming language and is the most popular language for writing smart contracts on Ethereum. Smart contracts written in Solidity are transparent, tamper-proof, and provide reliable and guaranteed execution. Solidity is constantly being updated and is specifically designed for smart contract development. It is used to define the terms and conditions of a smart contract and how it responds to input. Solidity contracts can be deployed on the blockchain and their functions can be executed, resulting in changes to the contract's state. Solidity is the language used for Chainlink smart contracts. 

","
- https://docs.chain.link/getting-started/conceptual-overview/
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-1/course.md","# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Deploy Your First Smart Contract

  * Overview
  * Install and fund your MetaMask wallet
  * Write, compile, and deploy your first smart contract
  * Run functions in your contract

You can write your first smart contract and run it in your browser without any
knowledge about Ethereum or blockchains. This guide shows you how easy it is
to develop smart contracts using the [Solidity
language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io)
and the [Remix Development Environment](https://remix.ethereum.org/). You can
use all of these tools in your browser for free with no signup required.

Already know Solidity and have MetaMask configured?

If you are already familiar with how to deploy Smart Contracts and use
MetaMask, you can skip to the [Consuming Data Feeds](/getting-started/consuming-data-feeds) guide to learn how to connect your smart
contracts to Chainlink data feeds.

In general, you create and deploy your smart contracts operate using the
following process:

  1. **Write:** Write a contract to define how the contract functions, what data it can store, what other contracts it interacts with, and what external APIs it might call.

  2. **Compile:** Pass your smart contract code through a compiler to translate the contract into byte code that the blockchain can understand. For example, [Solidity](https://soliditylang.org) code must be compiled before it can run in the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/).

  3. **Deploy:** Send the compiled smart contract to the blockchain. From that point forward, the contract cannot be altered. However, you can still interact with the contract in several ways.

  4. **Run functions:** When you run the functions that you defined for the contract, the network processes those functions and modifies the state of your contract. For some functions, the network charges a small fee to complete the work. Your contract can also have functions that transfer funds to other contracts or wallets.

This guide walks you through each step, but you must install and fund your
MetaMask wallet first.

## Install and fund your MetaMask wallet

Deploying smart contracts on-chain requires a wallet and ETH. The ETH pays for
the work required by the Ethereum network to add the contract to the
blockchain and store the variables. The wallet holds the ETH that you need to
pay for the transaction. Install MetaMask, configure it to use the [Sepolia
testnet](https://sepolia.dev/), and fund your wallet with free testnet ETH.

  1. [Install and configure the MetaMask extension](https://metamask.io/download) in your browser.

  2. After you install the extension, open your browser extension list and click MetaMask to open MetaMask.

  3. Follow the instructions in MetaMask to create a new MetaMask wallet. The new wallet includes a 12-word mnemonic phrase. This phrase is the key to your wallet. Copy that phrase down in a very secure location that only you can access. You can use this phrase to retrieve your wallet later or add it to another browser.

  4. Set MetaMask to use the Sepolia test network.

  5. Choose a Sepolia ETH [faucet](https://faucetlink.to/sepolia) and follow the steps to send testnet ETH to your MetaMask wallet address. You can copy your wallet address by clicking your account name in MetaMask. After the faucet completes the transaction, you should have testnet ETH in your MetaMask wallet on the Sepolia testnet.

Now that you configured your wallet and funded it with testnet ETH, you can
write, compile, and deploy your contract.

## Write, compile, and deploy your first smart contract

Your first contract is a simple `HelloWorld.sol` example. This example shows
you how to set and retrieve variables in a smart contract on-chain.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol) in the Remix IDE. Remix opens and shows the contents of the smart contract. You can modify the code in this editor when you write your own contract.

[ Open in Remix
](https://remix.ethereum.org/#url=https://docs.chain.link/samples/Tutorials/HelloWorld.sol)
[What is Remix?](/getting-started/conceptual-overview#what-is-remix)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. For this contract, use the default compiler settings. Click the **Compile HelloWorld.sol** button to compile the contract. This converts the contract from Solidity into bytecode that the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/) can understand. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract.

  4. After Remix compiles the contract, deploy it. On the left side of Remix, click the **Deploy and Run** tab to view the deployment settings.

  5. In the deployment settings, select the **Injected Provider** environment. This tells Remix that you want to deploy your contract to the blockchain that you configured in MetaMask. You could optionally use one of the Javascript VM options, but they run in a virtual environment with no connection to an actual blockchain or Chainlink oracles.

  6. Next to the **Deploy** button, enter a message that you want to send with the smart contract when you deploy it. This contract has a constructor that sets an initial message when you deploy the contract.

  7. Click the **Deploy** button to deploy the contract and its initial message to the blockchain network. MetaMask opens and asks you to confirm payment to deploy the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  8. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  9. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  10. Click the `message` variable. Remix retrieves and prints the initial message that you set.

The contract has an address just like your wallet address. If you save this
address, you can return to your deployed contract at any time to retrieve
variables or execute functions. To see details about your deployed contract,
copy the contract address from the list in Remix and search for it in the
[Etherscan Sepolia Testnet Explorer](https://sepolia.etherscan.io/).

## Run functions in your contract

Because you deployed the contract to an actual blockchain, several nodes on
the test network confirmed your payment for the smart contract. The contract,
its variables, and its functions remain in the blockchain permanently. To
change the `message` variable that is stored with your contract, run the
`updateMessage` function.

  1. In your deployed contract, enter a new message next to the `updateMessage` function.

  2. Click the `updateMessage` button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.

  3. In the new MetaMask prompt, click **Confirm** to approve the transaction.

  4. Click the `message` variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

Now you know how to deploy example contracts to a test network and run the
functions in those contracts. You can write your own contracts and test them
using this same process.

Next, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds)
guide to learn how to connect your smart contracts to Chainlink Data Feeds and
retrieve on-chain data that your smart contracts can act on.

## What's next

  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/deploy-your-first-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 1:

# Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Inspired by the power of smart contracts and blockchain, it’s time to dive in.
    </div>
  </div>
</ContentWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent. If you are familiar with some programming, it may help to know that Solidity is an **object-oriented programming language**. If you are not familiar with what that means, don’t worry, we’ll cover it in a future course.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!




:::NEXT DOC:::

#####Chapter 4:

# Smart Contracts - The Future

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Check out this video on what smart contracts are and how they are changing the nature of agreements and the Internet. 
    </div>
  </div>
</ContentWrapp>

<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/Un7-hW6GAec"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>

Smart contracts result from the evolution of digital agreements. A smart contract is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract isn’t immediately executed after the conditions have been met. Rather, a lengthy review process is initiated and it could take months, even years before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial crisis were programmed as smart contracts, they would be completely transparent and any member of the public would have had the ability to audit them.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Trust Minimization</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.
          <b>Example</b>: Robinhood can no longer stop people from trading Gamestop, unless it is coded into the agreement.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label"">Efficiency:</p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
         The characteristics of smart contracts outlined earlier can create more efficient, automated processes that save business cost. 
         <b>Example:</b> Businesses could use a smart contract to settle inter-company transactions without needing to spend time and money on complicated systems of trusted neutral third parties to hold both sides accountable.
          </p>
      </li>
    </ul>
  </div>
</ListItemsContainer>

<MissionContainer>  
  <div className=""title"">Activities:</div>
  <ul className=""mission-goals"">
    <li>
      Think about an industry where agreements and contracts play a crucial role in ensuring its success. 
    </li>
    <li>
      Brainstorm ways smart contracts can be used in those industries and how it can improve the current state of the industry.
    </li>
  </ul>
</MissionContainer>

# Blockchain Introduction 
&nbsp;
<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/4ff9esY_4aU"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>
&nbsp;
The previous section explained the beneficial properties of smart contracts, but how can self-executing code that doesn’t rely on a trusted intermediary be created and implemented? To achieve this feat, another technology was invented: the <ColorWord>blockchain</ColorWord>. A blockchain is a global network of computers that stores data and transactions in a shared ledger that is <i>decentralized</i>. This means that the ledger isn’t controlled by anyone. Essentially, a blockchain can be compared to a database that is replicated over many computers all over the world secured with the use of cryptography and game theory (a combination of math and sociology).

You may have heard of a cryptocurrency called Bitcoin. Bitcoin is built on a blockchain (referred to as the <i>Bitcoin blockchain</i>)! No one entity controls Bitcoin so it can be thought of as a sort of “proto-smartcontract”. It has all the properties of smart contracts listed before, but only has one use: transferring value between individuals.

Today, there are blockchains where <i>any</i> code or applications can be built from. The code deployed to a blockchain is indeed a Smart Contract. This ability was truly pioneered by the Ethereum blockchain, but there are many other blockchains such as Polygon, Avalanche, Solana, Terra, and many others have the same capability. Smart contracts are often written in a programming language called <ColorWord>Solidity</ColorWord>, but others such as Rust are gaining popularity.

<MissionContainer>
  <div className=""title"">Activities:</div>
  <ul className=""mission-goals"">
    <li>
      Watch <a target=""__blank"" href=""https://www.youtube.com/watch?v=_160oMzblY8""> Anders Brownsworth video walkthrough </a> of his blockchain demo.
    </li>
    <li>
      Interact with the <a target=""__blank"" href=""https://andersbrownworth.com/blockchain/hash""> blockchain demo </a> yourself until you have a good understanding of the basics of how blockchains operate.
    </li>
  </ul>
</MissionContainer>
"
What are the four types of variable access modifiers in Solidity?,"The four types of variable access modifiers in Solidity are Public, Private, Internal, and External.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-7/course.md'},"The four types of variable access modifiers in Solidity are public, private, internal, and external.
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-7/course.md,"# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract, you need an address. Not only that, but you need an address which
you can easily use with Remix. Fortunately, [MetaMask](https://metamask.io) is
just what is needed. **MetaMask** allows anyone to create an address, store
funds, and interact with Ethereum compatible blockchains from a browser
extension.

## What's next

  * [› Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract)
  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/conceptual-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 2:

# Storage

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When someone says the data is stored on the blockchain, what does it actually mean from a perspective of a smart contract? Where is the data stored? How is it stored?
    </div>
  </div>
</ContentWrapp>

As we learned in the previous chapter, Ethereum could be described as a state machine. Transactions are then used to transition from one state to another state. The transactions are stored into individual blocks. These blocks are linked to each other creating the Ethereum blockchain. Everyone can take these transactions and follow the transition rules resulting in the same state for everyone.
But how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function calls. As block space is very valuable, storage variables are arranged in a compact way into storage slots into blocks of 32 bytes. Variables that take less than 32 bytes are combined into the same slot. Taking the least amount of space. Data is stored in order of the declaration in the contract in successive order. So we have slot 0x0, slot 0x1, slot 0x2, and so on.

```Solidity
contract StorageExample {
    uint256 nubmerOne = 1; // slot 0x0
    string customGreeting = ""Hello Chainlink""; // slot 0x1
    uint256 numberTwo; // slot 0x2

    string constant greeting = ""Hello World""; // no storage

    bool active; // slot 0x3
    bool admin; // slot 0x3
    bytes16 foo; // slot 0x3
    bytes16 bar; // slot 0x4
}
```

As you can see here, **numberOne**, **customGreeting** and **numberTwo** each take a full slot as they cannot be combined to consume less space. And constant variables (greeting) are not stored in storage slots. When a constant state variable is read the EVM uses the assigned value instead. the booleans active and admin just take 1 bit each and bytes16 takes 16 bits, so a total of 18 bits. That’s why they are all stored in slot 0x3. The last bytes16 variables bar takes another 16 bits but cannot be stored in slot 0x3 because the max size is 32 bytes. So a new slot is occupied.

Dynamic-sized arrays and structs are handled a little differently though as the size is unknown at the point of declaration. They always start with a slot that takes 32 bytes and their elements are stored in a different storage slot. The beginning of this storage slot is computed using a Keccack-256 hash.

**Memory** variables live only in memory and exist in the scope of a function. They are mutable inside that scope but cannot be called outside of the function. Once a function execution is completed, all variables in memory are released.

```Solidity
function add(uint256 a, uint256 b) pure returns(uint256) {
    uint256 result = a + b;
    return result;
}
```

Any manipulations done to memory variables is not written into the blockchain resulting in less gas consumption. So this is why we always need to ask if we need persistence.

There is an exception though as arrays, structs and mappings are stored in storage. This is important to remember as it might introduce critical bugs into your code when not considered. We will learn more about these data types in the upcoming chapters.


:::NEXT DOC:::

#####Chapter 7:

# Access Modifiers

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

We can actually give more information to the Solidity compiler on how we want to use our variables (and later functions). We can tell the compiler how we want our variables to be accessed. Many blockchains, such as Ethereum, act as one monolithic computer. While Ethereum is a network of computers distributed around the world, when you deploy code to a blockchain like Ethereum, that code can access any other code anyone has deployed to that blockchain. This is like how programs downloaded to your computer can access other programs on your computer. This allows smart contracts to interact in many unique and interesting ways that regular web application back ends may not be able to do so easily. However, this can also open risks of other code using our code in unintended ways.

To help prevent this we can declare “access modifiers” when declaring our variables, which limit what code on the blockchain can access and change those variables. The four types of variable access modifiers are:


* Public 
    * The variable/function can be accessed or changed by any other code or wallet on the blockchain.
* Private
    * The variable/function can only be accessed or changed within the current contract
* Internal
    * The variable/function can only be accessed or changed within the current contract or any other contract that inherits the current contract (we’ll discuss inheritance in another lesson)
* External
    * The variable/function can only be accessed/changed from outside code or blockchain wallets

To declare the access modifier of a variable we put it inbetween the function type and name like this:

<Highlight class=""language-javascript"">
uint public myFavNum;
</Highlight>

If no access modifier is declared then the variable is automatically assigned the private modifier. For example

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>
 
Is equivalent to 

<Highlight class=""language-javascript"">
uint private myFavNum;
</Highlight>
"
What are some important data types in Solidity?,"Some important data types in Solidity are int, uint, string, bool, and address.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-5/course.md'},"Some important data types in Solidity are:
- int: Integers
- uint: Unsigned Integers
- string: Strings
- bool: Booleans
- address: An Account Address
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-5/course.md,"#####Chapter 2:

# Storage

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When someone says the data is stored on the blockchain, what does it actually mean from a perspective of a smart contract? Where is the data stored? How is it stored?
    </div>
  </div>
</ContentWrapp>

As we learned in the previous chapter, Ethereum could be described as a state machine. Transactions are then used to transition from one state to another state. The transactions are stored into individual blocks. These blocks are linked to each other creating the Ethereum blockchain. Everyone can take these transactions and follow the transition rules resulting in the same state for everyone.
But how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function calls. As block space is very valuable, storage variables are arranged in a compact way into storage slots into blocks of 32 bytes. Variables that take less than 32 bytes are combined into the same slot. Taking the least amount of space. Data is stored in order of the declaration in the contract in successive order. So we have slot 0x0, slot 0x1, slot 0x2, and so on.

```Solidity
contract StorageExample {
    uint256 nubmerOne = 1; // slot 0x0
    string customGreeting = ""Hello Chainlink""; // slot 0x1
    uint256 numberTwo; // slot 0x2

    string constant greeting = ""Hello World""; // no storage

    bool active; // slot 0x3
    bool admin; // slot 0x3
    bytes16 foo; // slot 0x3
    bytes16 bar; // slot 0x4
}
```

As you can see here, **numberOne**, **customGreeting** and **numberTwo** each take a full slot as they cannot be combined to consume less space. And constant variables (greeting) are not stored in storage slots. When a constant state variable is read the EVM uses the assigned value instead. the booleans active and admin just take 1 bit each and bytes16 takes 16 bits, so a total of 18 bits. That’s why they are all stored in slot 0x3. The last bytes16 variables bar takes another 16 bits but cannot be stored in slot 0x3 because the max size is 32 bytes. So a new slot is occupied.

Dynamic-sized arrays and structs are handled a little differently though as the size is unknown at the point of declaration. They always start with a slot that takes 32 bytes and their elements are stored in a different storage slot. The beginning of this storage slot is computed using a Keccack-256 hash.

**Memory** variables live only in memory and exist in the scope of a function. They are mutable inside that scope but cannot be called outside of the function. Once a function execution is completed, all variables in memory are released.

```Solidity
function add(uint256 a, uint256 b) pure returns(uint256) {
    uint256 result = a + b;
    return result;
}
```

Any manipulations done to memory variables is not written into the blockchain resulting in less gas consumption. So this is why we always need to ask if we need persistence.

There is an exception though as arrays, structs and mappings are stored in storage. This is important to remember as it might introduce critical bugs into your code when not considered. We will learn more about these data types in the upcoming chapters.


:::NEXT DOC:::

#####Chapter 5:

# Contract State, Variables and Data Types

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now you want to connect your artwork to the physical (off-chain) world. Tell your artwork how to behave. 
    </div>
  </div>
</ContentWrapp> -->

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing **variables** and change data by defining logic in **functions**. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time. When defining a variable, you must give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
    * These are phrases that meant to be read. You can store numbers in a string but you can’t do math on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>

This creates a variable called “myFavNum” and assigns it the type uint, or unsigned integer. Now we can use myFavoriteNumber to store numbers like 0,1,2,3,4…etc. in our contract. 
"
Why do customers tend not to read digital agreements?,"Customers tend not to read digital agreements due to lengthy, complex legalese and the fact that these agreements give consumers very little recourse.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-3/course.md'},"Customers tend not to read digital agreements due to their lengthy and complex legalese, as well as the limited recourse they provide for consumers. These agreements are often skewed in favor of the institutions that create them, rather than being fair and equitable for both parties. The power of digital agreements lies heavily with the institutions, and individual consumers may not find it worth the cost to enforce these agreements in court. This lack of understanding and imbalance in power contributes to customers' tendency to not read digital agreements.",,"#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>
"
What do you need to do after completing the contract in order to use the VRFCoordinator?,You need to subscribe your contract to the VRFCoordinator.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-12/course.md'},"After completing the contract, you need to subscribe your contract to the VRFCoordinator. You can do this through the Subscription Manager at vrf.chain.link. Visit the website and follow the steps to set up a subscription.
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-12/course.md,"# Local testing using a Mock contract

  * Overview
  * Benefits of local testing
  * Testing logic
  * Prerequisites
  * Testing
  * Open the contracts on RemixIDE
  * Select the correct RemixIDE environment
  * Deploy VRFCoordinatorV2Mock
  * Deploy MockV3Aggregator
  * Deploy LinkToken
  * Deploy VRFV2Wrapper
  * Configure the VRFV2Wrapper
  * Fund the VRFV2Wrapper subscription
  * Deploy the VRF consumer contract
  * Fund your VRF consumer contract
  * Request random words
  * Fulfill the VRF request
  * Check the results
  * Next steps

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to test Chainlink VRF v2 on a [Remix
IDE](https://remix-ide.readthedocs.io/en/latest/run.html#environment) sandbox
blockchain environment. **Note** : You can reuse the same logic on another
development environment, such as Hardhat or Truffle. For example, read the
Hardhat Starter Kit [RandomNumberDirectFundingConsumer unit
tests](https://github.com/smartcontractkit/hardhat-starter-kit/blob/main/test/unit/RandomNumberDirectFundingConsumer.spec.js).

Test on public testnets thoroughly

Even though local testing has several benefits, testing with a VRF mock covers
the bare minimum of use cases. Make sure to test your consumer contract
throughly on public testnets.

## Benefits of local testing

Testing locally using mock contracts saves you time and resources during
development. Some of the key benefits include:

  * Faster feedback loop: Immediate feedback on the functionality and correctness of your smart contracts. This helps you quickly identify and fix issues without waiting for transactions to be mined/validated on a testnet.
  * Saving your native testnet tokens: Deploying and interacting with contracts requires paying gas fees. Although testnet native tokens do not have any value associated with them, their supply is limited by public faucets. Using mock contracts locally allows you to test your contracts freely without incurring any expenses.
  * Controlled environment: Local testing allows you to create a controlled environment where you can manipulate various parameters, such as block time and gas prices, to test your smart contracts' function as expected under different conditions.
  * Isolated testing: You can focus on testing individual parts of your contract, ensuring they work as intended before integrating them with other components.
  * Easier debugging: Because local tests run on your machine, you have better control over the debugging process. You can set breakpoints, inspect variables, and step through your code to identify and fix issues.
  * Comprehensive test coverage: You can create test cases to cover all possible scenarios and edge cases.

## Testing logic

Complete the following tasks to test your VRF v2 consumer locally:

  1. Deploy the [VRFCoordinatorV2Mock](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol). This contract is a mock of the [VRFCoordinatorV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) contract.
  2. Deploy the [MockV3Aggregator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/tests/MockV3Aggregator.sol) contract.
  3. Deploy the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/LinkToken.sol) contract.
  4. Deploy the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) contract.
  5. Call the VRFV2Wrapper [setConfig function](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol#L119) to set wrapper specific parameters.
  6. Fund the VRFv2Wrapper subscription.
  7. Call the the VRFCoordinatorV2Mock [addConsumer function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L229) to add the wrapper contract to your subscription.
  8. Deploy your VRF consumer contract.
  9. Fund your consumer contract with LINK tokens.
  10. Request random words from your consumer contract.
  11. Call the VRFCoordinatorV2Mock [fulfillRandomWords function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L88) to fulfill your consumer contract request.

## Prerequisites

This guide will require you to finetune the gas limit when fulfilling
requests. When writing, manually setting up the gas limits on RemixIDE is not
supported, so you will use RemixIDE in conjunction with
[Metamask](https://metamask.io/). [Ganache](https://trufflesuite.com/ganache/)
lets you quickly fire up a personal Ethereum blockchain. If you still need to
install Ganache, follow the [official
guide](https://trufflesuite.com/docs/ganache/quickstart/).

  1. Once Ganache is installed, click the _QUICKSTART_ button to start a local Ethereum node.

**Note** : Make sure to note the RPC server. In this example, the RPC server
is _<http://127.0.0.1:7545/>_.

  2. Follow the Metamask [official guide](https://support.metamask.io/hc/en-us/articles/360043227612-How-to-add-a-custom-network-RPC#h_01G63GGJ83DGDRCS2ZWXM37CV5) to add a custom network manually.

  3. Import a Ganache account into Metamask.

    1. On Ganache, click on the _key_ symbol of the first account:

    2. Copy the private key:

    3. Follow the Metamask [official guide](https://support.metamask.io/hc/en-us/articles/360015489331-How-to-import-an-account) to import an account using a private key.

    4. Your Metamask is connected to _Ganache_ , and you should have access to the newly imported account.

## Testing

### Open the contracts on RemixIDE

Open _VRFCoordinatorV2Mock_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol"";
    

Open _MockV3Aggregator_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol"";
    

Open _LinkToken_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.4.24;
    
    import ""@chainlink/contracts/src/v0.4/LinkToken.sol"";
    

Open _VRFV2Wrapper_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/VRFV2Wrapper.sol"";
    

Open _RandomNumberDirectFundingConsumerV2_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UNAUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract RandomNumberDirectFundingConsumerV2 is
        VRFV2WrapperConsumerBase,
        ConfirmedOwner
    {
        event RequestSent(uint256 requestId, uint32 numWords, uint256 paid);
        event RequestFulfilled(
            uint256 requestId,
            uint256[] randomWords,
            uint256 payment
        );
        error InsufficientFunds(uint256 balance, uint256 paid);
        error RequestNotFound(uint256 requestId);
        error LinkTransferError(address sender, address receiver, uint256 amount);
    
        struct RequestStatus {
            uint256 paid; // amount paid in link
            bool fulfilled; // whether the request has been successfully fulfilled
            uint256[] randomWords;
        }
        mapping(uint256 => RequestStatus)
            public s_requests; /* requestId --> requestStatus */
    
        // past requests Id.
        uint256[] public requestIds;
        uint256 public lastRequestId;
    
        // configuration: https://docs.chain.link/vrf/v2/direct-funding/supported-networks#configurations
        constructor(
            address _linkAddress,
            address _wrapperAddress
        )
            ConfirmedOwner(msg.sender)
            VRFV2WrapperConsumerBase(_linkAddress, _wrapperAddress)
        {}
    
        // Depends on the number of requested values that you want sent to the
        // fulfillRandomWords() function. Test and adjust
        // this limit based on the network that you select, the size of the request,
        // and the processing of the callback request in the fulfillRandomWords()
        // function.
        // The default is 3, but you can set this higher.
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.
        function requestRandomWords(
            uint32 _callbackGasLimit,
            uint16 _requestConfirmations,
            uint32 _numWords
        ) external onlyOwner returns (uint256 requestId) {
            requestId = requestRandomness(
                _callbackGasLimit,
                _requestConfirmations,
                _numWords
            );
            uint256 paid = VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit);
            uint256 balance = LINK.balanceOf(address(this));
            if (balance < paid) revert InsufficientFunds(balance, paid);
            s_requests[requestId] = RequestStatus({
                paid: paid,
                randomWords: new uint256[](0),
                fulfilled: false
            });
            requestIds.push(requestId);
            lastRequestId = requestId;
            emit RequestSent(requestId, _numWords, paid);
            return requestId;
        }
    
        function fulfillRandomWords(
            uint256 _requestId,
            uint256[] memory _randomWords
        ) internal override {
            RequestStatus storage request = s_requests[_requestId];
            if (request.paid == 0) revert RequestNotFound(_requestId);
            request.fulfilled = true;
            request.randomWords = _randomWords;
            emit RequestFulfilled(_requestId, _randomWords, request.paid);
        }
    
        function getNumberOfRequests() external view returns (uint256) {
            return requestIds.length;
        }
    
        function getRequestStatus(
            uint256 _requestId
        )
            external
            view
            returns (uint256 paid, bool fulfilled, uint256[] memory randomWords)
        {
            RequestStatus memory request = s_requests[_requestId];
            if (request.paid == 0) revert RequestNotFound(_requestId);
            return (request.paid, request.fulfilled, request.randomWords);
        }
    
        /**
         * Allow withdraw of Link tokens from the contract
         */
        function withdrawLink(address _receiver) public onlyOwner {
            bool success = LINK.transfer(_receiver, LINK.balanceOf(address(this)));
            if (!success)
                revert LinkTransferError(
                    msg.sender,
                    _receiver,
                    LINK.balanceOf(address(this))
                );
        }
    }
    

Your RemixIDE file explorer should display the opened contracts:

### Select the correct RemixIDE environment

Under _DEPLOY & RUN TRANSACTIONS_:

  1. Set the Environment to _Injected Provider - Metamask_ :

  2. On Metamask, connect your Ganache account to the Remix IDE.

  3. Click on Connect. The RemixIDE environment should be set to the correct environment, and the account should be the Ganache account.

### Deploy VRFCoordinatorV2Mock

  1. Open _VRFCoordinatorV2Mock.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _VRFCoordinatorV2Mock_.

  3. Under _DEPLOY_ , fill in the `_BASEFEE` and `_GASPRICELINK`. These variables are used in the _VRFCoordinatorV2Mock_ contract to represent the base fee and the gas price (in LINK tokens) for the VRF requests. You can set: `_BASEFEE=100000000000000000` and `_GASPRICELINK=1000000000`.

  4. Click on _transact_ to deploy the _VRFCoordinatorV2Mock_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _VRFCoordinatorV2Mock_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Deploy MockV3Aggregator

The _MockV3Aggregator_ contract is designed for testing purposes, allowing you
to simulate an oracle price feed without interacting with the existing
Chainlink network.

  1. Open _MockV3Aggregator.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _MockV3Aggregator_.

  3. Under _DEPLOY_ , fill in `_DECIMALS` and `_INITIALANSWER`. These variables are used in the _MockV3Aggregator_ contract to represent the number of decimals the aggregator's answer should have and the most recent price feed answer. You can set: `_DECIMALS=18` and `_INITIALANSWER=3000000000000000` (We are considering that `1 LINK = 0.003 native tokens`).

  4. Click on _transact_ to deploy the _MockV3Aggregator_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _MockV3Aggregator_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Deploy LinkToken

The Chainlink VRF v2 direct funding method requires your consumer contract to
pay for VRF requests in LINK. Therefore, you have to deploy the _LinkToken_
contract to your local blockchain.

  1. Open _LinkToken.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _LinkToken_.

  3. Under _DEPLOY_ , click on _transact_ to deploy the _LinkToken_ contract.

  4. A Metamask popup will open. Click on _Confirm_.

  5. Once deployed, you should see the _LinkToken_ contract under _Deployed Contracts_.

  6. Note the address of the deployed contract.

### Deploy VRFV2Wrapper

As the VRF v2 direct funding [end-to-end diagram](/vrf/v2/direct-funding#request-and-receive-data) explains, the _VRFV2Wrapper_ acts as a
wrapper for the coordinator contract.

  1. Open _VRFV2Wrapper.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _VRFV2Wrapper_.

  3. Under _DEPLOY_ , fill in `_LINK` with the _LinkToken_ contract address, `_LINKETHFEED` with the _MockV3Aggregator_ contract address, and `_COORDINATOR` with the _VRFCoordinatorV2Mock_ contract address.

  4. click on _transact_ to deploy the _VRFV2Wrapper_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _VRFV2Wrapper_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Configure the VRFV2Wrapper

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFV2Wrapper_ contract.

  2. Click on `setConfig` and fill in `_wrapperGasOverhead` with `60000`, `_coordinatorGasOverhead` with `52000`, `_wrapperPremiumPercentage` with `10`, `_keyHash` with `0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc`, and `_maxNumWords` with `10`. **Note** on these variables:

    1. `_wrapperGasOverhead`: This variable reflects the gas overhead of the wrapper's fulfillRandomWords function. The cost for this gas is passed to the user.

    2. `_coordinatorGasOverhead`: This variable reflects the gas overhead of the coordinator's `fulfillRandomWords` function. The cost for this gas is billed to the _VRFV2Wrapper_ subscription and must, therefore, be included in the VRF v2 direct funding requests pricing.

    3. `_wrapperPremiumPercentage`: This variable is the premium ratio in percentage. For example, a value of 0 indicates no premium. A value of 15 indicates a 15 percent premium.

    4. `_keyHash`: The gas lane key hash value is the maximum gas price you are willing to pay for a request in wei.

    5. `_maxNumWords`: This variable is the maximum number of words requested in a VRF v2 direct funding request.

  3. click on _transact_.

  4. A Metamask popup will open. Click on _Confirm_.

### Fund the VRFV2Wrapper subscription

When deployed, the _VRFV2Wrapper_ contract creates a new subscription and adds
itself to the newly created subscription. If you started this guide from
scratch, the subscription ID should be 1.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click `fundSubscription` to fund the _VRFV2Wrapper_ subscription. In this example, you can set the `_subid` to `1` (which is your newly created subscription ID) and the `_amount` to `10000000000000000000` (10 LINK).

  3. A Metamask popup will open. Click on _Confirm_.

### Deploy the VRF consumer contract

  1. In the file explorer, open _RandomNumberDirectFundingConsumerV2.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _RandomNumberDirectFundingConsumerV2_.

  3. Under _DEPLOY_ , fill in `_LINKADDRESS_` with the _LinkToken_ contract address, and `_WRAPPERADDRESS_` with the deployed _VRFV2Wrapper_ address.

  4. Click on _transact_ to deploy the _RandomNumberDirectFundingConsumerV2_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _RandomNumberDirectFundingConsumerV2_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Fund your VRF consumer contract

  1. Under _Deployed Contracts_ , open the functions list of your deployed _LinkToken_ contract.

  2. Click on _transfer_ and fill in the `_to` with your consumer contract address and `_value` with LINK tokens amount. For this example, you can set the `_value` to `10000000000000000000` (10 LINK).

  3. Click on _transact_.

  4. A Metamask popup will open. Click on _Confirm_.

### Request random words

Request three random words.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_ contract.

  2. In `requestRandomWords`, fill in `_callbackGasLimit` with `300000`, `_requestConfirmations` with `3` and `_numWords` with `3`.

  3. Click on _transact_.

  4. A Metamask popup will open.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _400,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _400000_ and select **Save**.
Finally, confirm the transaction.

  5. Click on _Confirm_.

  6. In the RemixIDE console, read your transaction logs to find the VRF request ID. In this example, the request ID is _1_.

  7. Note your request ID.

### Fulfill the VRF request

Because you are testing on a local blockchain environment, you must fulfill
the VRF request yourself.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click `fulfillRandomWords` and fill in `_requestId` with your VRF request ID and `_consumer` with the _VRFV2Wrapper_ contract address.

  3. Click on `transact`.

  4. A Metamask popup will open.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _1,000,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _1000000_ and select **Save**.
Finally, confirm the transaction.

  5. Click on _Confirm_.

  6. In the RemixIDE console, read your transaction logs to find the random words.

### Check the results

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberDirectFundingConsumerV2_ contract.

  2. Click on `lastRequestId` to display the last request ID. In this example, the output is _1_.

  3. Click on `getRequestStatus` with `_requestId` equal to `1`:

  4. You will get the amount paid, the status, and the random words.

## Next steps

This guide demonstrated how to test a VRF v2 consumer contract on your local
blockchain. We made the guide on RemixIDE for learning purposes, but you can
reuse the same testing logic on another development environment, such as
Truffle or Hardhat. For example, read the Hardhat Starter Kit
[RandomNumberDirectFundingConsumer unit
tests](https://github.com/smartcontractkit/hardhat-starter-kit/blob/main/test/unit/RandomNumberDirectFundingConsumer.spec.js).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding/examples/test-locally.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Local testing using a Mock contract

  * Overview
  * Benefits of local testing
  * Testing logic
  * Testing
  * Open the contracts on RemixIDE
  * Deploy VRFCoordinatorV2Mock
  * Create and fund a subscription
  * Deploy the VRF consumer contract
  * Add the consumer contract to your subscription
  * Request random words
  * Fulfill the VRF request
  * Check the results
  * Next steps

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to test Chainlink VRF v2 on a [Remix
IDE](https://remix-ide.readthedocs.io/en/latest/run.html#environment) sandbox
blockchain environment. **Note** : You can reuse the same logic on another
development environment, such as Hardhat or Truffle. For example, read the
Hardhat Starter Kit [RandomNumberConsumer unit
tests](https://github.com/smartcontractkit/hardhat-starter-kit/blob/main/test/unit/RandomNumberConsumer.spec.js).

Test on public testnets thoroughly

Even though local testing has several benefits, testing with a VRF mock covers
the bare minimum of use cases. Make sure to test your consumer contract
throughly on public testnets.

## Benefits of local testing

Testing locally using mock contracts saves you time and resources during
development. Some of the key benefits include:

  * Faster feedback loop: Immediate feedback on the functionality and correctness of your smart contracts. This helps you quickly identify and fix issues without waiting for transactions to be mined/validated on a testnet.
  * Saving your native testnet tokens: Deploying and interacting with contracts requires paying gas fees. Although testnet native tokens do not have any value associated with them, their supply is limited by public faucets. Using mock contracts locally allows you to test your contracts freely without incurring any expenses.
  * Controlled environment: Local testing allows you to create a controlled environment where you can manipulate various parameters, such as block time and gas prices, to test your smart contracts' function as expected under different conditions.
  * Isolated testing: You can focus on testing individual parts of your contract, ensuring they work as intended before integrating them with other components.
  * Easier debugging: Because local tests run on your machine, you have better control over the debugging process. You can set breakpoints, inspect variables, and step through your code to identify and fix issues.
  * Comprehensive test coverage: You can create test cases to cover all possible scenarios and edge cases.

## Testing logic

Complete the following tasks to test your VRF v2 consumer locally:

  1. Deploy the [VRFCoordinatorV2Mock](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol). This contract is a mock of the [VRFCoordinatorV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) contract.
  2. Call the VRFCoordinatorV2Mock [createSubscription function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L176) to create a new subscription.
  3. Call the VRFCoordinatorV2Mock [fundSubscription function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L138) to fund your newly created subscription. **Note** : You can fund with an arbitrary amount.
  4. Deploy your VRF consumer contract.
  5. Call the the VRFCoordinatorV2Mock [addConsumer function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L229) to add your consumer contract to your subscription.
  6. Request random words from your consumer contract.
  7. Call the VRFCoordinatorV2Mock [fulfillRandomWords function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L88) to fulfill your consumer contract request.

## Testing

### Open the contracts on RemixIDE

Open _VRFCoordinatorV2Mock_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol"";
    

Open _VRFv2Consumer_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that relies on a subscription for funding.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    /**
     * @title The RandomNumberConsumerV2 contract
     * @notice A contract that gets random values from Chainlink VRF V2
     */
    contract RandomNumberConsumerV2 is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface immutable COORDINATOR;
    
        // Your subscription ID.
        uint64 immutable s_subscriptionId;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 immutable s_keyHash;
    
        // Depends on the number of requested values that you want sent to the
        // fulfillRandomWords() function. Storing each word costs about 20,000 gas,
        // so 100,000 is a safe default for this example contract. Test and adjust
        // this limit based on the network that you select, the size of the request,
        // and the processing of the callback request in the fulfillRandomWords()
        // function.
        uint32 constant CALLBACK_GAS_LIMIT = 100000;
    
        // The default is 3, but you can set this higher.
        uint16 constant REQUEST_CONFIRMATIONS = 3;
    
        // For this example, retrieve 2 random values in one request.
        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
        uint32 constant NUM_WORDS = 2;
    
        uint256[] public s_randomWords;
        uint256 public s_requestId;
        address s_owner;
    
        event ReturnedRandomness(uint256[] randomWords);
    
        /**
         * @notice Constructor inherits VRFConsumerBaseV2
         *
         * @param subscriptionId - the subscription ID that this contract uses for funding requests
         * @param vrfCoordinator - coordinator, check https://docs.chain.link/docs/vrf-contracts/#configurations
         * @param keyHash - the gas lane to use, which specifies the maximum gas price to bump to
         */
        constructor(
            uint64 subscriptionId,
            address vrfCoordinator,
            bytes32 keyHash
        ) VRFConsumerBaseV2(vrfCoordinator) {
            COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
            s_keyHash = keyHash;
            s_owner = msg.sender;
            s_subscriptionId = subscriptionId;
        }
    
        /**
         * @notice Requests randomness
         * Assumes the subscription is funded sufficiently; ""Words"" refers to unit of data in Computer Science
         */
        function requestRandomWords() external onlyOwner {
            // Will revert if subscription is not set and funded.
            s_requestId = COORDINATOR.requestRandomWords(
                s_keyHash,
                s_subscriptionId,
                REQUEST_CONFIRMATIONS,
                CALLBACK_GAS_LIMIT,
                NUM_WORDS
            );
        }
    
        /**
         * @notice Callback function used by VRF Coordinator
         *
         * @param  - id of the request
         * @param randomWords - array of random results from VRF Coordinator
         */
        function fulfillRandomWords(
            uint256 /* requestId */,
            uint256[] memory randomWords
        ) internal override {
            s_randomWords = randomWords;
            emit ReturnedRandomness(randomWords);
        }
    
        modifier onlyOwner() {
            require(msg.sender == s_owner);
            _;
        }
    }
    

Your RemixIDE file explorer should display _VRFCoordinatorV2Mock.sol_ and
_VRFv2Consumer.sol_ :

### Deploy VRFCoordinatorV2Mock

  1. Open _VRFCoordinatorV2Mock.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _VRFCoordinatorV2Mock_.

  3. Under _DEPLOY_ , fill in the `_BASEFEE` and `_GASPRICELINK`. These variables are used in the _VRFCoordinatorV2Mock_ contract to represent the base fee and the gas price (in LINK tokens) for the VRF requests. You can set: `_BASEFEE=100000000000000000` and `_GASPRICELINK=1000000000`.

  4. Click on _transact_ to deploy the _VRFCoordinatorV2Mock_ contract.

  5. Once deployed, you should see the _VRFCoordinatorV2Mock_ contract under _Deployed Contracts_.

  6. Note the address of the deployed contract.

### Create and fund a subscription

  1. Click on `createSubscription` to create a new subscription.

  2. In the RemixIDE console, read your transaction decoded output to find the subscription ID. In this example, the subscription ID is _1_.

  3. Click on `fundSubscription` to fund your subscription. In this example, you can set the `_subid` to `1` (which is your newly created subscription ID) and the `_amount` to `1000000000000000000`.

### Deploy the VRF consumer contract

  1. In the file explorer, open _VRFv2Consumer.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _RandomNumberConsumerV2_.

  3. Under _DEPLOY_ , fill in `SUBSCRIPTIONID` with your subscription ID, `vrfCoordinator` with the deployed _VRFCoordinatorV2Mock_ address and, _KEYHASH_ with an arbitrary `bytes32` (In this example, you can set the _KEYHASH_ to `0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc`).

  4. Click on _transact_ to deploy the _RandomNumberConsumerV2_ contract.

  5. After the consumer contract is deployed, you should see the _RandomNumberConsumerV2_ contract under _Deployed Contracts_.

  6. Note the address of the deployed contract.

### Add the consumer contract to your subscription

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click on _addConsumer_ and fill in the `_subid` with your subscription ID and `_consumer` with your deployed consumer contract address.

  3. Click on _transact_.

### Request random words

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_ contract.

  2. Click on `requestRandomWords`.

  3. In the RemixIDE console, read your transaction logs to find the VRF request ID. In this example, the request ID is _1_.

  4. Note your request ID.

### Fulfill the VRF request

Because you are testing on a local blockchain environment, you must fulfill
the VRF request yourself.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click `fulfillRandomWords` and fill in `_requestId` with your VRF request ID and `_consumer` with your consumer contract address.

  3. Click on `transact`.

### Check the results

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_ contract.

  2. Click on `s_requestId` to display the last request ID. In this example, the output is _1_.

  3. Each time you make a VRF request, your consumer contract requests two random words. After the request is fulfilled, the two random words are stored in the `s_randomWords` array. You can check the stored random words by reading the two first indexes of the `s_randomWords` array. To do so, click on the _s_randomWords_ function and:

    1. Fill in the index with _0_ then click on _call_ to read the first random word.

    2. Fill in the index with _1_ then click on _call_ to read the second random word.

## Next steps

This guide demonstrated how to test a VRF v2 consumer contract on your local
blockchain. We made the guide on RemixIDE for learning purposes, but you can
reuse the same testing logic on another development environment, such as
Truffle or Hardhat. For example, read the Hardhat Starter Kit
[RandomNumberConsumer unit tests](https://github.com/smartcontractkit/hardhat-starter-kit/blob/main/test/unit/RandomNumberConsumer.spec.js).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/examples/test-locally.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 12: Subscribing to the VRF

# Subscribing

Congrats you have completed the contract! Your final contract should look like this:

<Highlight class=""language-javascript"">
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;


  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address linkTokenContract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
    LINKTOKEN = LinkTokenInterface(linkTokenContract);
    s_owner = msg.sender;
  }

  function requestRandomWords() external {
    s_requestId = COORDINATOR.requestRandomWords(
      keyHash,
      s_subscriptionId,
      requestConfirmations,
      callbackGasLimit,
      numWords
    );
  }

  function fulfillRandomWords(
    uint256, // requestId
    uint256[] memory randomWords
  ) internal override {
    s_randomWords = randomWords;
  }
}
</Highlight>

Now that the contract is complete you need to subscribe your contract to the VRFCoordinator. You can do so via the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/). Go to the website and follow the steps to see what it would be like to set up a subscription."
What are the three different ways to throw an error in Solidity?,"The three different ways to throw an error in Solidity are require, revert, and assert.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-6/course.md'},"The three different ways to throw an error in Solidity are: require, revert, and assert.
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-6/course.md,"Question: (Asked on: 2022-06-01 10:30:03)
How fix TypeError and DeclarationError with ChainLink Solidity smart contract?
URL: https://stackoverflow.com/questions/72460303/how-fix-typeerror-and-declarationerror-with-chainlink-solidity-smart-contract

Question Body:


I have created a smart contract which return to each user the amount deposited
+ a certain amount if the price of ETH decreases during the lock period. I
have two problems with the last part of the code.

The first one concerns mapping the price of ethereum at the moment the user
makes the deposit. I have tried several solutions but none of them seem to
work. The problem arises on line 64 `mapping(uint => uint) ethPrice;`. Console
returns:

    
    
    DeclarationError: Identifier already declared.
    --> oracle.sol:65:5:
    |
    65 | mapping(uint => uint) ethPrice;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    Note: The previous declaration is here:
    --> oracle.sol:63:5:
    |
    63 | uint public ethPrice = 0; 
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    

The second is found on line no. 91. `msg.sender.transfer(amountToWithdraw);`
with the transfer function. The console continues to return the following
error despite the fact that the address of each user is defined as payable in
the previous functions. Console returns:

    
    
    TypeError: ""send"" and ""transfer"" are only available for objects of type ""address payable"", not ""address"".
    --> oracle.sol:97:9:
    |
    97 | msg.sender.transfer(amountToWithdraw);
    | ^^^^^^^^^^^^^^^^^^^
    

These two problems severely invalidate the smart contract and are holding up
the completion of coding the latest functions. I have contacted several people
and looked in forums concerning programming on solidity but no one seems to
have an answer to my problem.

I hope that my question can be answered by the community and can help any
other person trying to use ChainLink with Solidity in the future. I am happy
to listen to any advice on the matter.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
        // EACAggregatorProxy is used for chainlink oracle
    interface EACAggregatorProxy {
        function latestAnswer() external view returns (int256);
    }
    
    contract oracleLink {
    
        // Address dev
        address public dev;
        // Dev's public deposit amount
        uint public devDeposit;
        // Array dev's public amount
        uint[] public devDeposits;
    
        // List each user and amount
        address[] public users;                   
        uint[] public totalDeposited;  
    
        // Mapping user's deposit
        mapping(address => uint) balances;
    
        // Deployer = dev & Dev deposit function 
        function deployerIsDeveloper() public payable {
            dev = msg.sender;
            devDeposit = msg.value;
            devDeposits.push(devDeposit);                   
        }
    
        // User's address
        address user;
        // Amount's address 
        uint amountDeposit;
        // Deadline time 
        uint256 deadline;
    
        // Amount's each user
        uint256 lockAmount = lockAmounts[msg.sender];
        // Mapping of deposit for each user        
        mapping(address => uint) lockAmounts;
    
        // Timestamp for each user 
        uint256 startTime = startTimes[block.timestamp];
        // Mapping timestamp for each user  
        mapping(uint => uint) startTimes; 
    
        // Kovan ETH/USD oracle address 
        address public chainLinkETHUSDAddress = 0x9326BFA02ADD2366b30bacB125260Af641031331;
    
        // ethPrice 
        uint public ethPrice = 0; 
        uint256 price = ethPrice;
        mapping(uint => uint) ethPrice;
    
        // Deposit function for each user 
        function deposit(uint256 numberOfSeconds) public payable {
    
            lockAmounts[msg.sender] = msg.value;
            startTimes[block.timestamp] = block.timestamp;
            
            user = msg.sender;           
            amountDeposit = msg.value;      
            
            users.push(user);                     
            totalDeposited.push(amountDeposit);
    
            deadline = block.timestamp + (numberOfSeconds * 1 seconds);
    
            int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();
            ethPrice = uint(chainLinkEthPrice / 100000000);
            //return ethPrice = price;
            //price.push(ethPrice);
        }
    
        // Withdraw function for each user 
        function withdraw() public payable {
            require(block.timestamp >= deadline);
            uint amountToWithdraw = lockAmounts[msg.sender];
            lockAmounts[msg.sender] = 0; 
            msg.sender.transfer(amountToWithdraw); 
        }
    }
    



Answers:
(Answered on: 2022-06-01 17:02:50)


For the first issue, Solidity compiler said that you declared two variables
with the identifier. In details in your case, you give `ethPrice` for
`mapping` and `uint` variable. To solve this issue, try to change one of these
names in this way:

    
    
     uint256 price = ethPrice;
     mapping(uint => uint) mappingEthPrice;
    

Second issue refers that msg.sender keyword doesn't cast automatically with
address payable and to solve it you can use `payable()` function that allows
you convert an `address` to `address payable`. In your smart contract you must
to change in this way:

    
    
    payable(msg.sender).transfer(amountToWithdraw); 
    

This should be your smart contract fixed:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
        // EACAggregatorProxy is used for chainlink oracle
    interface EACAggregatorProxy {
        function latestAnswer() external view returns (int256);
    }
    
    contract oracleLink {
    
        // Address dev
        address public dev;
        // Dev's public deposit amount
        uint public devDeposit;
        // Array dev's public amount
        uint[] public devDeposits;
    
        // List each user and amount
        address[] public users;                   
        uint[] public totalDeposited;  
    
        // Mapping user's deposit
        mapping(address => uint) balances;
    
        // Deployer = dev & Dev deposit function 
        function deployerIsDeveloper() public payable {
            dev = msg.sender;
            devDeposit = msg.value;
            devDeposits.push(devDeposit);                   
        }
    
        // User's address
        address user;
        // Amount's address 
        uint amountDeposit;
        // Deadline time 
        uint256 deadline;
    
        // Amount's each user
        uint256 lockAmount = lockAmounts[msg.sender];
        // Mapping of deposit for each user        
        mapping(address => uint) lockAmounts;
    
        // Timestamp for each user 
        uint256 startTime = startTimes[block.timestamp];
        // Mapping timestamp for each user  
        mapping(uint => uint) startTimes; 
    
        // Kovan ETH/USD oracle address 
        address public chainLinkETHUSDAddress = 0x9326BFA02ADD2366b30bacB125260Af641031331;
    
        // ethPrice 
        uint public ethPrice = 0; 
        uint256 price = ethPrice;
        mapping(uint => uint) mappingEthPrice;
    
        // Deposit function for each user 
        function deposit(uint256 numberOfSeconds) public payable {
    
            lockAmounts[msg.sender] = msg.value;
            startTimes[block.timestamp] = block.timestamp;
            
            user = msg.sender;           
            amountDeposit = msg.value;      
            
            users.push(user);                     
            totalDeposited.push(amountDeposit);
    
            deadline = block.timestamp + (numberOfSeconds * 1 seconds);
    
            int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();
            ethPrice = uint(chainLinkEthPrice / 100000000);
            //return ethPrice = price;
            //price.push(ethPrice);
        }
    
        // Withdraw function for each user 
        function withdraw() public payable {
            require(block.timestamp >= deadline);
            uint amountToWithdraw = lockAmounts[msg.sender];
            lockAmounts[msg.sender] = 0; 
            payable(msg.sender).transfer(amountToWithdraw); 
        }
    }
    





:::NEXT DOC:::

#####Chapter 3:

# Pragma Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Now let's dive into programming in Solidity!
    </div>
  </div>
</ContentWrapp>

One of the first things you will write for any Solidity is the pragma statement. The pragma tells the solidity compiler what version of Solidity you are writing. It typically looks something like this:

<Highlight class=""language-javascript"">
pragma solidity ^0.8.7;
</Highlight>

This says we are writing our code in Solidity, and the

<Highlight class=""language-javascript"">
^
</Highlight>

followed by

<Highlight class=""language-javascript"">
0.8.7;
</Highlight>

means that we will not allow the compiler to compile to a version earlier than 0.8.7 and must compile to a version earlier than 0.9.0.

The semi-colon
<Highlight class=""language-javascript"">
;
</Highlight>

means we are finished writing that line. Whenever a line of logic is complete in Solidity, it must be followed with a semi-colon.

<!-- <MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer> -->


:::NEXT DOC:::

#####Chapter 6:

# Errors

In the previous chapter, we learned about function modifiers. We already used the keyword **require** to check for conditions. If a condition is not met, an error is raised. An error will revert all changes made to the state during a transaction. There are three different ways to throw an error: **require**, **revert** and **assert**.

We use require if we want to validate user input and return values from calls to other functions. The syntax asks for a condition and a custom error message as the second argument. If the condition is not met, an error is raised. Otherwise, the next line will be executed.

<Highlight class=""language-javascript"">
require(x <= 42, ""x must be smaller or equal to 42."");
</Highlight>

**Revert** is used in a similar fashion but directly throws an error without checking a condition. It is useful when the condition check is more complex and you do not want to do it in a single line to improve readability or if several conditions have to be met that you want to check one by one. It will return all remaining gas to the caller. You can call it like this:

<Highlight class=""language-javascript"">
if (x <= 42 && x > 0) {
  revert(""x must be greater than 0 and smaller or equal to 42"");
}
</Highlight>

**Assert** is used for internal logic and checks code that should never be false. If an assertion fails, it’s likely that there is a bug in the contract. We can use asserts to ensure that even if there is a bug, we can simply catch it here and make it more difficult to abuse the bug. For example, it is often used to check for overflow/underflow. The following code shows how can ensure that a is always bigger or equal to b so that we do not run into a situation causing an underflow.

<Highlight class=""language-javascript"">
uint c = a - b 
assert(a >= b);
</Highlight>
"
What is the difference between an agreement and a contract?,"Contracts are agreements that are enforceable in a court of law, while agreements are oftentimes informal and not legally binding.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md'},"The difference between an agreement and a contract is that an agreement is a general understanding or arrangement between parties, which can be oral or written, and may not be legally enforceable. On the other hand, a contract is a legally binding agreement between parties that is enforceable in a court of law. Contracts typically have specific terms and conditions, and any breach of those terms can be disputed and discussed within a court. Agreements, on the other hand, may not have the same level of enforceability. 

","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-3/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md","#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>
"
What is Chainlink and what does it allow developers to do?,"Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. It allows developers to create and customize any type of Decentralized Oracle Network (DON) that a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-5/course.md'},"Chainlink is a platform for creating decentralized oracle networks (DONs) that provide various smart contract services. It allows developers to build and customize DONs, which can connect smart contracts to external data sources and provide accurate and up-to-date data to the smart contracts. Chainlink Data Feeds are a type of DON that provide high-quality data on various currency and cryptocurrency pairs, among other types of data. Developers can import the AggregatorV3Interface into their smart contracts, point the interface to the desired data feed, and access the latest data. Using Chainlink and its decentralized oracle networks, developers can create dynamic NFTs that can change based on external conditions and have access to accurate and reliable data.

","
- https://docs.chain.link/resources/contributing-to-chainlink?parent=anyApi/
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-5/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-6/course.md","# Contributing to Chainlink

  * Overview
  * Contributing to Software and Tooling
  * Raising an Issue
  * Requesting a new Feature
  * Submitting a Pull Request
  * Contributing to the documentation
  * Creating Community Content
  * Becoming a Developer Expert
  * Joining the Chainlink Community Advocate program
  * Running a Chainlink Focused Developer Bootcamp
  * Running an In-Person Meetup or Watch Party
  * Participate in a Hackathon
  * Applying for a Grant

Chainlink is an open-source project licensed [under the MIT
license](https://github.com/smartcontractkit/chainlink/blob/master/LICENSE),
and we encourage contributions from all developers and community members.

# What It Means to Contribute

When you contribute to the Chainlink project, you as a developer or community
member contribute your time and effort to help improve and grow Chainlink.
Your contribution can be from various methods:

  * Building and maintaining the Chainlink software and tools
  * Improving and maintaining the documentation, including translations into other languages
  * Creating Chainlink focused content (blog posts, tutorials, videos etc)
  * Becoming a developer expert
  * Becoming a community advocate
  * Running a Chainlink focused developer Bootcamp (in person or online)
  * Running an in-person meetup or watch party
  * Participate in a hackathon
  * Applying for a grant

# Why Should You Contribute

[Open source software](https://en.wikipedia.org/wiki/Open-source_software) is
a model that brings multiple benefits for both the project and the
contributors. As a developer or community member, contributing to Chainlink
helps you to gain valuable skills and experience, improve the software that
you use, and grow your personal brand in the community which can lead to
future employment opportunities. On top of these awesome things, contributing
to open source is fun. It can give you a sense of community involvement, and
gives you a personal sense of satisfaction knowing that you're part of an
effort to build something that will enable a fairer, more transparent, and
efficient new world.

# Ways to Contribute

## Contributing to Software and Tooling

The most direct way you can contribute to Chainlink is to contribute to the
core code or the various tooling found in our [GitHub
repository](https://github.com/smartcontractkit/). Contributing to code or
code-based tools can generally be split into a few different categories:

  * Raising an issue
  * Requesting a new feature
  * Submitting a Pull Request (PR) for a fix, improvement, or new tool

### Raising an Issue

During the course of using Chainlink software or tools, you might encounter
errors or unexpected behavior that leads you to believe the software isn't
behaving correctly. You can bring this to the attention of the Chainlink Labs
team as well as the wider developer community by raising an issue in the
project’s GitHub repository. The 'Issues' tab lists all of the open issues for
the repository.

After an issue is raised and tagged, the Chainlink Labs team and the wider
community can address it. This gives the issue the visibility required for
someone to investigate it and resolve the issue.

When you first create an issue, you must also categorize it. This prefixes the
issue name to give viewers an indication of what category the issue relates
to:

  * [NODE]: The issue relates to the core node software
  * [DEVEL]: The issue is a result of working on code found in the current repository
  * [FEAT]: The issue relates to a new feature request
  * [SMRT]: The issue related to using Chainlink smart contracts
  * [EXPL]: The issue related to using the Chainlink Explorer
  * [FAUC]: The issue related to using the Chainlink Faucet



After you select a category, enter the details for the issue. Include as much
detail about the issue as possible. Provide a thorough description,
environment, and software version details. Also provide detailed steps that
describe how to reproduce the issue. The more thorough you make your
description, the better the chances are that someone will be able to pick up
the issue and resolve it.

Once a team member acknowledges that the issue has been received, they will
tag it with an appropriate label. You should then monitor the state of the
open issue for any questions or updates.

### Requesting a new Feature

Have you thought of an improvement or an awesome new feature that you think
should be implemented into Chainlink? Request a new feature to bring it to the
attention of the team and the wider community. You can request new features by
creating a new GitHub issue in the correct repository and tagging that issue
with the [FEAT] prefix (Feature request). The process for doing this is
covered in the Raising an Issue section. Provide as much detail as possible in
your feature request, including any benefits, risks, or considerations that
you can think of.

#### Voting on new features

Sometimes a new feature is put to a vote to decide if it's something that the
team and wider community should implement. When a feature is put to a vote,
the issue is tagged with the 'needs votes' label. You can contribute to the
voting process by reacting to the first post in the feature request with a
thumbs up or thumbs down emoji. This will help drive the decision. You can
also contribute your thoughts by replying directly to the feature request with
a new post in the thread.



### Submitting a Pull Request

The best way to contribute to Chainlink is to submit a [pull request
(PR)](https://docs.github.com/en/github/collaborating-with-pull-
requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests). PRs can be submitted for various reasons, such as fixing an
identified issue, adding a feature or improvement to the project, or even
adding an entirely new repository to the Chainlink source code for a new tool
or feature. If you're looking for something to pick up and create a PR for,
you can search through the Chainlink repositories to find open issues, and
approved feature requests.

If you're new to contributing to open-source software or Chainlink, we've
tagged some [good first
issues](https://github.com/smartcontractkit/chainlink/issues?q=is%3Aissue+label%3A%22good+first+issue%22)
against the main node software and smart contracts that you can tackle. Each
major repository in the Chainlink GitHub should also have some good first
issues tagged for developers to be able to take on.

All code changes must follow the [style guide]
(<https://github.com/smartcontractkit/chainlink/wiki/Code-Style-Guide>), All
PRs must be in an appropriately named branch with a format like 'feat/feature-
description' or 'devel/issue-description'. After you submit a PR, you should
get a response by a team member within a day or two acknowledging that the PR
has been received. After that, monitor the PR for any additional questions or
updates that come up while the team and the community review the changes.

## Contributing to the documentation

The [Chainlink documentation](https://docs.chain.link/) is the go-to place for
developers who want to learn how to build applications using Chainlink, and
node operators wanting useful information on running a Chainlink node. The
documentation is [open
source](https://github.com/smartcontractkit/documentation), allowing for other
developers and community members to contribute to adding or improving it. You
can contribute to the Chainlink documentation in various ways:

  * Improving the readability of pages
  * Fixing typos or grammar errors
  * Adding new guides or tutorials that you would find useful
  * Translating the documentation into other languages

The process for contributing to the documentation follows the process defined
earlier in the Submitting a Pull Request section. Each page also has a
'Suggest Edits' link on the top right, and will directly take you to the page
in the [documentation
repository](https://github.com/smartcontractkit/documentation), where you can
create a new PR with the suggested changes. Before you create a PR for the
documentation, read the [contributing
guidelines](https://github.com/smartcontractkit/documentation/blob/main/CONTRIBUTING.md).

If you want to translate the documentation into a new language that is not yet
supported, feel free to [reach out to the
team](mailto:devrel@smartcontract.com) beforehand, so we can make sure you get
the support you need.

## Creating Community Content

Chainlink has a strong and vibrant community of developers and community
advocates. Community members often create Chainlink-focused content in various
forms and publish it for the wider community on various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually hosted](https://blog.chain.link/smart-contract-developer-bootcamp-on-demand/) the first [Chainlink Developer
Bootcamp](http://chain.link/bootcamp). If you're passionate about educating
others about smart contracts and Chainlink, you can contribute by running your
own developer Bootcamp. You can also contribute by translating an existing
Bootcamp and running it in another language. Before you run your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 5:

# The Smart Contract Connectivity Problem

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     NFTs are a part of Web 3.0 so why not take truly advantage of this new primitive and make your NFT change depending on some conditions on the outside world? We call these changing NFTs <i>Dynamic NFT</i> or <i>dNFTs</i>. But how will you connect your dynamic NFT to outside data?  
    </div>
  </div>
</ContentWrapp>

Blockchains and smart contracts are unaware of any conditions or logic that occur outside of the blockchain itself; they cannot connect to outside resources. This is due to the distributed and deterministic nature of blockchains. All of the distributed nodes (nodes are computers running the blockchain software) in the blockchain must come to a consensus on what the blockchain is and any changes to it. If the blockchain just connected to a data source, the nodes could query the data at different times and get other answers, breaking the ability for the nodes to reach consensus. Even worse, if that data source changed locations or is down, the whole blockchain would break.

This means developers can program smart contracts as long as their logic doesn’t require any outside data. This may sound highly limiting, but there is a system in place that sits in between blockchains and the outside world (a concept aptly called “middleware”). This middleware system is called an Oracle. The name <ColorWord>Oracle</ColorWord> comes from the Greek concept of an Oracle since it needs to determine what is <i>true</i> in outside systems.

<Spacer>

## Centralized Oracles

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So an Oracle is the type of system you want to make a dNFT but it is important that the entire NFT remains decentralized so your art work can truly live on forever. You'll also want the NFT to be have the most accurate up-to-date data.
    </div>
  </div>
</ContentWrapp>

To create functional smart contracts we need a middleware system called an <ColorWord>Oracle</ColorWord>, but how will we make this Oracle? Well, we are trying to get price data into our smart contract for NFTs. My friend Jim (trust me, he is good!) is an expert in cryptocurrency prices, and he even has a server set up that we can access for price data. Awesome, we'll make Jim our oracle and he will provide price data to our NFT smart contract.

But wait….didn’t all the great properties of smart contracts and blockchains come from their decentralized nature? What if Jim wanted to maliciously send our smart contract bad price data so he could manipulate it in his favor? What if his server goes offline when the NFT needs to update and thus can’t? What if Jim isn’t even malicious but gets hacked by a malicious actor? This single oracle solution isn’t solving much of the oracle problem because it isn’t <i>decentralized</i>, and thus provides a weak link that ruins all of those awesome smart contract properties. You need to trust that Jim, and my word on Jim, that he is a great person and will act in the best interest of everyone. But what if we had a decentralized middleware solution, one where Jim doesn’t control everything (sorry Jim), so we didn’t have to trust him?

Finally we are here…...enter Chainlink!

<Spacer>

## Chainlink and Decentralized Oracles

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Using a Chainlink Decentralized Oracle Network (DON) as the Oracle for your dNFT can give you strong guarantees that your artwork will truly update with the latest, most acurate data and remain decentralized. 
    </div>
  </div>
</ContentWrapp>

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform. Finally, with Chainlink, developers can build smart contracts that can interact with the outside world to preserve the decentralized nature of smart contracts.

<Spacer>

## How Chainlink Works

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      Curious how Chainlink works? Read below! With Chainlink, any type of data the exists can be brought on chain, and the conditions on which that data is delivered can be customized! 
    </div>
  </div>
</ContentWrapp>

Chainlink allows developers to build and customize DONs. Chainlink allows DONs to work and assures that node operators are incentivized not to collude or act maliciously.

<p><ColorWord>How does Chainlink Work?</ColorWord></p>

<div>
  <p>Developers can customize several main areas of Chainlink DONs. These include:</p>
  <ul>
    <li>
      <p>Specifying what data DONs need to provide</p>
    </li>
    <li>
      <p>How DONs retrieve data </p>
    </li>
    <li>
      <p>When DONs provide data</p>
    </li>
    <li>
      <p>How agreement (also known as consensus) is achieved among the nodes to achieve a single source of truth for the specified data.</p>
    </li>
  </ul>
</div>

###Each step is outlined in more detail below:

<br><br>
<b>Specifying what data DONs need to provide</b>

Due to the proliferation of Decentralized Finance (DeFi), a popular use case of Chainlink DONs is relating them with price data. However, any type of data that is available in a digital format can be accessed. This includes but is not limited to weather data, YouTube views, sensor data, or even data from other blockchains. For the NFT we’re just going to stick to price data for now, specifically the ETH/USD price, but you can imagine all the possibilities of cool smart contracts we can make with all of the digital data available today!

<br>
<b>When DONS Provide Data</b>

Some applications require a DON that updates the data once a day. Others need updates once every five minutes or only when the data itself changes by a certain amount. The term <ColorWord>heartbeat</ColorWord> is used to describe the max amount of time that can elapse before a DON updates it's data feed The term <ColorWord>deviation threshold</ColorWord> is used to describe how much variation is allowed in the data before it is posted on-chain, regardless of how much time has elasped. For example, if the ETH/USD deviation threshold is set to 1%, then the DON will update the data feed if it senses the price of ETH versus USD fluctuates more than 1%.

<br>
<b>How DONs Provide Data</b>

Ideally, nodes should retrieve data from multiple sources and <i>aggregate</i>, or combine, the data to return the most accurate price they can. Developers can use external adapters to customize the sources that nodes use to aggregate data. <ColorWord>External adapters</ColorWord> are custom built software packages that can be added to the nodes. These can be built in any programming language and perform any operations developers may find useful. These operations can be as simple as basic arithmetic but can span to being complex machine learning algorithms.

<br>
<b>How Consensus is Reached Among Nodes</b>

All of the different nodes in the DON have their own version of the price. Using this information, developers customize the aggregation method of Chainlink DONs to determine one value for the true price. This is another level of aggregation beyond the aggregation completed at the individual node level. Having multiple levels of aggregation ensures the highest level of data quality. This <i>aggregation method</i> can consist of any type of operation including median, mean, weighted mean, mode, or other calculations. In our dynamic NFT will make use of a data feed that takes the median of all the node’s price data, since the median is more resistant to outliers than the mean.


:::NEXT DOC:::

#####Chapter 6:

# Chainlink Data Feeds

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now that you understood how to connect the off-chain world you can utilize this knowledge now for your NFT. Imagine a NFT that reacts to the price of Ethereum. It could rain when the price falls and it could be sunny when the price rises.
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson, Chainlink gives developers the ability to create extremely powerful DON’s that provide smart contracts with the highest quality data from outside the blockchain. As a smart contract developer, how can you take advantage of these DONs in your own smart contracts? Chainlink is open source so there’s always the option of making your own DON, but creating a DON is a complex and nuanced process. Instead, in the spirit of the old developer adage “Never build something twice”, use existing DONs if possible.

Luckily, many of the largest and highest quality node operators in the blockchain industry have already combined their knowledge and prowess to create DONs that serve the most in-demand data for smart contract developers to take advantage of. These data serving DONs are called <ColorWord>Chainlink Data Feeds</ColorWord>. Currently most of the data feeds provide data on various currency and cryptocurrency pairs, as that was initially what smart contract developers needed, but data feeds can be used to retrieve any type of data.

You can see these data feeds updating in real time at data.chain.link. There you can select different blockchains Chainlink DONs are posting data to, as well view the details of each DON that compose a particular data feed. For instance if you click on the ETH/USD data feed you will see all the nodes involved in the DON, what price each individual node posted, and the final aggregated price of the asset. Some important terms you may notice are:

<p><ColorWord>Rounds</ColorWord>DONs update data feeds in rounds. When a new round is initiated the nodes in a DON retrieve the latest data point from data providers, aggregate the data at the individual node level and finally aggregate the between the nodes. Once the final aggregated data point, along with each individual nodes observation, is posted on-chain the round is considered complete.</p>
<p><ColorWord>Heartbeat</ColorWord>The maximum amount of time that is allowed to pass before the DON automatically starts a new round and updates the data.</p>
<p><ColorWord>Deviation Threshold</ColorWord>If a node within the DON senses the data fluctuates by a certain percentage, they will automatically start a new round forcing the DON to update the data feed regardless of how much time has elapsed.</p>

<MissionContainer>
  <div className=""title"">Quizzes:</div>
  <ol className=""mission-goals"">
    <li>
      What is the heartbeat for the ETH/USD data feed on Ethereum mainnet?
    </li>
    <li>
      What is the deviation threshold for the BTC/USD data feed on Binance Smart Chain mainnet?
    </li>
  </ol>
</MissionContainer>

## Programming with Chainlink Data Feeds

Now that we understand how Chainlink data feeds work, lets use them within a smart contract. To use a Chainlink data feed within a smart contract you only have to complete three simple steps:

<div>
  <ul>
    <li>
      <p>Import the AggregatorV3Interface into your smart contract</p>
    </li>
    <li>
      <p>Point the interface to the desired data feed</p>
    </li>
    <li>
      <p>Access the latest data!</p>
    </li>
  </ul>
</div>
"
What are the three contracts being imported in the code?,"LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBaseV2",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-6/course.md'},"The three contracts being imported in the code are LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBaseV2.
",https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-6/course.md,"# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 6: Building a Basic Contract:

# Imports

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now that you know about Chainlink VRF v2 it’s time to begin building the raffle contract!
    </div>
  </div>
</ContentWrapp>

We will begin by declaring the Solidity compiler version and importing the code we need. There are 3 contracts we will be importing: LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBase:

<Highlight class=""language-javascript"">
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>
"
What are functions in Solidity and what do they do?,"Functions in Solidity are little machines that take in data, run some logic and produce an output. They manipulate data and can be customized to do anything.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-11/course.md'},"Functions in Solidity are used to manipulate data and perform calculations. They are like little machines that take in data, run some logic, and produce an output. Functions can have arguments, a body where the logic is defined, and a return value. They can be customized to perform various tasks and can be accessed only within the function. Solidity is a Turing Complete language, meaning it can solve any computational problem. Functions in Solidity can be defined using the ""function"" keyword, followed by the function name, parameters, modifiers, return type, and function body. They can be called by providing the necessary arguments and storing the result in a variable. (""SOURCE: https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-11/course.md"")",,"#####Chapter 13:

# Conclusion

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

Congrats for making it this far! That’s a lot of Solidity concepts! The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions). In future courses, we will go into more detail on more complex variables such as storing structs within arrays and more special functions such as the constructor and events. And as always, you know the best way to learn is by doing! Feel free to go to https://remix.ethereum.org/, and just mess around with writing code there. It may feel overwhelming at first, but don’t worry it’s just to get a feel for what’s to come!


:::NEXT DOC:::

#####Chapter 1:

# Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Inspired by the power of smart contracts and blockchain, it’s time to dive in.
    </div>
  </div>
</ContentWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent. If you are familiar with some programming, it may help to know that Solidity is an **object-oriented programming language**. If you are not familiar with what that means, don’t worry, we’ll cover it in a future course.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!




:::NEXT DOC:::

#####Chapter 11:

# Functions

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

Thus far, we’ve mainly been concerned with storing data in variables and accessing that stored data. But what if we want to manipulate data? That is the realm of **functions**. You can write the logic in a function and have it manipulate data in an infinite number of ways. Solidity and the EVM are called [Turing Complete](https://stackoverflow.com/questions/7284/what-is-turing-complete ""Turing Complete""), which essentially means they can solve any computational problem (although there’s no guarantee that it will complete within a reasonable amount of time). 

You can think of functions as little machines that take in data, run some logic and produce an output. The values that are input into functions are called **arguments**. The logic is put in the **body** of the function. If the function directly returns a value as an output of the function that output is called the **return** value. Finally, just like variables have access modifiers, functions also have **modifiers** (including access modifiers too). Some functions don’t take in any arguments. Some functions just run calculations to change some state variables or make a request to run other code (or to a Chainlink node!) Some functions don’t return a direct value and just run calculations based on storage variables, or make a request to run other code (or send a request to a Chainlink node!) Basically, functions can be customized to do anything.

To define a function, we first type the “function” keyword, define a name for the function and add a pair of parentheses beside the name as such:

<Highlight class=""language-javascript"">
function addNumbers()
</Highlight>

After this is complete you can define **parameters** for the function. Parameters are the name and types of the arguments we can input into the function. They are variables that only that function can access. For this example, we will define two parameters: 

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2)
</Highlight>

Now we can add any modifiers to the function. In this case we’ll simply add public for now:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public
</Highlight>

Now we’ll define what the function returns. Remember a function doesn’t **have** to return anything. In this example we will add the parameters and return the result. Since we are adding two uints, the return value will also have to be a uint:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public returns (uint)
</Highlight>

Finally we’ll create the function body by typing a pair of curly braces and typing our function logic within them:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public returns (uint) {
 answer = num1 + num2;
 return answer;
}
</Highlight>

As you can see the function takes the two parameters, num1 and num2, sums them, stores the sum in a variable called answer, and then returns the value inside the variable answer.

So if we were to call the function, we could store the result in another variable:

<Highlight class=""language-javascript"">
storedAnswer = addNumbers(1,2)
</Highlight>

The variable storedAnswer would then contain the uint 3.

"
What are the two main smart contracts of Chainlink VRF?,The two main smart contracts of Chainlink VRF are the Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2).,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-4/course.md'},"The two main smart contracts of Chainlink VRF are the VRF Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2).
",https://docs.chain.link/vrf/v2/direct-funding/ and https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-4/course.md,"# Direct Funding Method

  * Overview
  * VRF direct funding
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to generate random numbers using the _direct funding_
method. This method doesn't require a subscription and is optimal for one-off
requests for randomness. This method also works best for applications where
your end-users must pay the fees for VRF because the cost of the request is
determined at request time.

## VRF direct funding

Unlike the [subscription method](/vrf/v2/subscription), the direct funding
method does not require you to create subscriptions and pre-fund them.
Instead, you must directly fund consuming contracts with LINK tokens before
they request randomness. Because the consuming contract directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Wrapper (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol).

  2. Your contract must implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling the `requestRandomness` function in the [VRFV2WrapperConsumerBase](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) contract. Include the following parameters in your request:

    * `requestConfirmations`: The number of block confirmations the VRF service will wait to respond. The minimum and maximum confirmations for your network can be found [here](/vrf/v2/direct-funding/supported-networks/#configurations).
    * `callbackGasLimit`: The maximum amount of gas to pay for completing the callback VRF function.
    * `numWords`: The number of random numbers to request. You can find the maximum number of random values per request for your network in the [Supported networks](/vrf/v2/direct-funding/supported-networks/#configurations) page.

### How VRF processes your request

After you submit your request, it is processed using the Request & Receive
Data cycle:

  1. The consuming contract calls the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `calculateRequestPrice` function to estimate the total transaction cost to fulfill randomness. Learn [how to estimate transaction costs](/vrf/v2/estimating-costs).

  2. The consuming contract calls the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/LinkToken.sol) `transferAndCall` function to pay the wrapper with the calculated request price. This method sends LINK tokens and executes the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) `onTokenTransfer` logic.

  3. The VRFV2Wrapper's `onTokenTransfer` logic triggers the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) `requestRandomWords` function to request randomness.

  4. The VRF coordinator emits an event.

  5. The VRF service picks up the event and waits for the specified number of block confirmations to respond back to the VRF coordinator with the random values and a proof (`requestConfirmations`).

  6. The VRF coordinator verifies the proof on-chain, then it calls back the wrapper contract's `fulfillRandomWords` function.

  7. Finally, the VRF Wrapper calls back your consuming contract.

## Limits

You can see the configuration for each network on the [Supported
networks](/vrf/v2/direct-funding/supported-networks) page. You can also view
the full configuration for each VRF v2 Wrapper contract directly in Etherscan.
As an example, view the [Ethereum Mainnet VRF v2 Wrapper
contract](https://etherscan.io/address/0x5A861794B927983406fCE1D062e00b9368d97Df6#readContract)
configuration by calling `getConfig` function.

  * Each wrapper has a `maxNumWords` parameter that limits the maximum number of random values you can receive in each request.
  * The maximum allowed `callbackGasLimit` value for your requests is defined in the [Coordinator contract supported networks](/vrf/v2/subscription/supported-networks) page. Because the VRF v2 Wrapper adds an overhead, your `callbackGasLimit` must not exceed `maxGasLimit - wrapperGasOverhead`. Learn more about [estimating costs](/vrf/v2/estimating-costs).

## What's next

  * [› Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/direct-funding/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.


:::NEXT DOC:::

#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!
"
What is the purpose of the 'keyHash' parameter in Chainlink VRF?,The 'keyHash' parameter in Chainlink VRF functions as an ID of the off-chain VRF job that runs in response to requests.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-7/course.md'},"The purpose of the 'keyHash' parameter in Chainlink VRF is to provide cryptographic proof alongside every random number generated, ensuring that the random number wasn't tampered with and was generated in a random way. The 'keyHash' parameter is used to verify the correctness of the hash and allows for the production of unpredictable and uniformly distributed results while being fully verifiable. It is part of the Verifiable Random Function (VRF) implemented in Chainlink, which is based on Goldberg's VRF and provides cryptographic proof of randomness. The VRF is used to generate random numbers in a decentralized and verifiable manner. 
","
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-4/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-3/course.md
- https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-5/course.md","#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.


:::NEXT DOC:::

#####Chapter 3:

# Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson randomness provided by an outside service needs to be verifiable and decentralized, and that’s exactly what Chainlink VRF is! VRF stands for Verifiable Randomness Function. Essentially Chainlink VRF provides cryptographic proof alongside every random number generated, that the random number wasn’t tampered with (and indeed generated in a random way).

How does this cryptographic proof work? It’s quite mathematically complicated and outside the scope of this lesson, but you can read more about it in the “Technical Walkthrough” section of this [blog post](https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/). The cryptographic proof is then verified by a smart contract on-chain, which means it is verified by every node on the blockchain! This completes our verifiable and decentralized criteria. So now we understand that Chainlink VRF is verifiably random and decentralized how do we use it?


:::NEXT DOC:::

#####Chapter 5: VRF Subscriptions

# Subscribing to the VRF
Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number. 

## VRFv2
In VRFv2, the most recent version of the VRF, the concept of a subscription was added. What is a subscription? Essentially, it's an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. Once a subscription is set-up a consumer contract can then request randomness, the VRF respondes with a random number and proof, and then after the random number is included on-chain the VRF is paid with some of the LINK prepaid in the subscription.

The power that comes from this subscription model is that now consumer contracts have much more flexibility in requesting random numbers. Before subscriptions it was a static price, and the VRF always returned a single random number. 
 
But what if the consumer contract needs more than one random number? The consumer contract can now specify how many random numbers it wants to request.  
 
What if the consumer contract needs the random number to be included very fast by paying a higher gas price? The consumer contract can now request how much it's willing to pay for gas. This is called the **gas lane**. 
 
What if the consumer contract needs to run some heavy calculations after recieving the random number? It can set a limit to how much gas will be spent by the VRF when submitting the random number. This is called the **callbackGasLimit**.

And because this is all pre-paid via the subscription, and credited from the subscription amount after the VRF has responded with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! "
