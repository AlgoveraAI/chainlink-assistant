question,answer,metadata,result,retrieved_docs
Why does calling an external API in chainlink not cause inconsistency?,"Because oracle responses are stored on-chain. Instead of fetching external data during the validation process, Chainlink oracle network places the data on-chain in a transaction. This ensures that all nodes go through the same validation process and reach a consensus. Having an oracle system built into a blockchain is not possible.",{'source': 'https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency'},"Calling an external API in Chainlink does not cause inconsistency because the oracle responses are stored on-chain. The Chainlink oracle network places the data on-chain in a transaction, and then it goes through the same validation process as every other transaction. This ensures that all nodes have access to the same data and can reach a consensus. Additionally, using multiple Chainlink nodes and different data sources can further verify the correctness of the data.","Question: (Asked on: 2021-11-26 22:39:12)
Why does calling an external API in chainlink not cause inconsistency?
URL: https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency

Question Body:


Suppose I have a smart contract that uses Chainlink's ""Call Any External API""
capability to get some data from an external URL. My understanding is that
each Ethereum full node runs each smart contract to verify the status; it does
so to verify the latest block. But what if, between the time one full node
runs the contract and another one does, the data returned by calling tha
external API changes. Then it would seem that different full nodes would get
different results for that smart contract, resulting in inconsistent states.
Why does that not happen?



Answers:
(Answered on: 2021-12-10 18:05:16)


Because oracle responses are stored on-chain.

You are right, if fetching external data was part of the validation process,
no nodes would be able to reach a consensus. So instead, a Chainlink oracle
network places the data on-chain in a transaction, and then it goes through
the same validation process as every other transaction.

You can read more about how Chainlink's [Basic Request
Model](https://docs.chain.link/docs/architecture-request-model/) looks, but
this is basically the reason why having an oracle system built into a
blockchain is impossible.





:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.





:::NEXT DOC:::

Question: (Asked on: 2022-12-12 21:30:02)
Why is our Chainlink node not catching any OracleRequest events from our Arbitrum Operator? Requests are never fulfilled / v2 jobs never executed
URL: https://stackoverflow.com/questions/74777534/why-is-our-chainlink-node-not-catching-any-oraclerequest-events-from-our-arbitru

Question Body:


We're trying to get our Chainlink AnyAPI stack to work with an Arbitrum
Chainlink node. The same stack is being used on Ethereum, Polygon and
Avalanche without issue.

Chainlink AnyAPI empowers some of the use cases of DSLA Protocol, a middleware
for adding consumer protection capabilities to any monitorable marketplace
(e.g. OpenSea) using peer-to-peer service level agreements (SLA).

## Request Lifecycle

Here are the different steps involved in verifying that a SLA contract has
been respected, using Chainlink:

  1. A user calls the verification function on the Messenger smart contract that implements Chainlink.

  2. The `Messenger` smart contract sends the request the `PreCoordinator` smart contract .

  3. The `PreCoordinator` forwards the request to the Oracles defined in a Service Agreement (proxy of Oracles).

  4. Upon receiving LINK, each Oracle sends the request to the Chainlink node, by emitting an `OracleRequest` event with the id of the job to be executed.

  5. The Chainlink node captures such event, and executes the corresponding job.

  6. Once the job is executed, the Chainlink node calls the `fulfillOracleRequest2` function to return the result from the external adapter to the PreCoordinator.

  7. The PreCoordinator takes the mean of all Oracle results and ultimately registers the SLI in the messenger.

 

:::NEXT DOC:::

From the accompanying youtube video
(0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e &
29fa9aa13bf1468788b7cc4a500a45b8) And from
[chainlink](https://market.link/jobs/8b2792ab-24a3-4ed7-b7f4-f56f44828d9b)
market (set to kovan network). (0xA1d76ABD287d87d6E1d92262F7D53Cbe4f290505 &
fc3ea215bb9e44e088107b29bb495e2d)

I'm not sure where things go wrong, I don't think it's the code since it's
copy pasted from the example. But non of the adreses have worked.

    
    
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public volume;
    
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        constructor() {
            setPublicChainlinkToken();
            oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
            jobId = ""d5270d1c311941d0b08bead21fea7747"";
    

:::NEXT DOC:::

Question: (Asked on: 2022-12-25 12:25:30)
Why is recordChainlinkfulfillment not being executed?
URL: https://stackoverflow.com/questions/74913265/why-is-recordchainlinkfulfillment-not-being-executed

Question Body:


Anyone any idea why the recordChainlinkfulfillment is not being executed?

I've checked the API call and it's yield the correct results. I managed to got
this working with the chainlink job for fetching 1 value, but not for multiple
values.

As far as I can tell and was able to check, the API url was correctly set and
the request function was correctly executed. My contract is funded with enough
LINK.

    
    
        // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.9;
    
    
    import ""@openzeppelin/contracts/access/Ownable.sol"";
    import ""@openzeppelin/contracts/utils/Counters.sol"";
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    contract RealEstateBonus is ChainlinkClient, Ownable {
        using Chainlink for Chainlink.Request;
    
        bytes32 private jobId;
        uint256 private fee;
        string public url;
        string public urlresult;
        string public lastselldate;
        string public lastapn;
        bytes32 public lastrequestid;
    
        event

:::NEXT DOC:::

Question: (Asked on: 2021-11-02 20:20:58)
Requesting data with Chainlink, response not what expected
URL: https://stackoverflow.com/questions/69816494/requesting-data-with-chainlink-response-not-what-expected

Question Body:


I've been trying to integrate Chainlink into my contract, managed to get the
random number thingy working, but the API call doesn't work for me. Here's
what I got:

    
    
    contract ValorantCards is Ownable, ERC1155, VRFConsumerBase, ChainlinkClient {
    using Chainlink for Chainlink.Request;
    
    address private linkToken;
    
    // Chainlink VRF
    bytes32 private keyHash;
    uint256 private vrfFee;
    
    uint256 public randomResult;
    
    // Chainlink API calls
    address private oracle;
    bytes32 private jobId;
    uint256 private oracleFee;
    
    uint256 public playerLevel;
    
    constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        address _oracle,
        bytes32 _jobId,
        uint256 _oracleFee
    ) ERC1155("""") VRFConsumerBase(_vrfCoordinator, _linkToken) {
        setPublicChainlinkToken();
    
        linkToken = _linkToken;
        keyHash = _keyHash;
        vrfFee = 0.1 *

:::NEXT DOC:::

on: 2021-10-28 06:48:56)


Generally, When we create new job on node it assign externalJobId to job which
is like '07269a61-586c-4831-bc26-7d2b581fbd1c'. But when you call function in
consumer contract you have to provide this externalJobId in function without
dashes so it will be like '07269a61586c4831bc267d2b581fbd1c'. This is not
mentioned in chainlink docs in noticeable way

<https://docs.chain.link/docs/fulfilling-requests/>

[](https://i.stack.imgur.com/1EwZr.png)





:::NEXT DOC:::

the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

use [Chainlink Any-
API](https://docs.chain.link/docs/make-a-http-get-request/) calls to bring it
into your smart contract

To do so, you need to know 3 things

  1. The API endpoint that contains the data, and the inputs required
  2. The outputs that the API returns, including their types (integer, string etc), as well as the path in the resulting JSON that contains the data you want
  3. A Chainlink oracle on the network you're contract is on that has a compatible job that you can use (whether one you run yourself or someone elses)

Once you have these things, you can use the example consumer contract in the
docs linked above, and then change the values to suit. ie here is an example
contract that will make an API call to PancakeSwap to get the price of
PancakeSwap token on BSC testnet:

1 - API address and inputs. In this case, according to your linked docs, the
URL of the API call is
`https://api.pancakeswap.info/api/v2/tokens/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82`.
The only input required is the token address in the URL

2 - We want the price, which is an integer and in the 'price' JSON element. We
will multiply the price by 10**8 when we bring it on-chain because Solidity
can't handle decimals

3 - Because this is a simple API call, we can use a community run CL node that
takes a HTTP GET request, parses the JSON to find an element we specify, then
multiplies the result and converts it to the type we want before returning it
on-chain. Taking a look at the [BSC testnet jobs

:::NEXT DOC:::

  

Added my Oracle address and JobId (without dashes) to the APIConsumer.sol
contract:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
     */
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public games;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Kovan
         * Oracle: 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 (Chainlink Devrel   
         * Node)
         * Job ID: d5270d1c311941d0b08bead21fea7747
       "
How do I install dependencies for Yarn?,"To install dependencies for Yarn, you can use the command 'yarn install' in the main node's folder.",{'source': 'https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn'},"To install dependencies for Yarn, you can run the command ""yarn install"" in the main node's folder. Additionally, if you encounter errors related to locked yarn packages, you can try running ""yarn install"" before proceeding with the installation steps.","Question: (Asked on: 2021-11-30 19:30:53)
How do I install dependencies for Yarn?
URL: https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn

Question Body:


trying to install yarn for my chainlink node. This is the error I'm getting.
Any thoughts?

    
    
    node -e ""if(process.env.npm_execpath.indexOf('yarn') === -1) throw new Error('Please use yarn to install dependencies\n\n')""
    



Answers:
(Answered on: 2021-12-01 16:51:27)


Did you try

    
    
    yarn install
    

in the main node's folder?





:::NEXT DOC:::

for documentation about this command.
     | `yarn setup` failed with exit code 137
    Stopping 2 active children
    Aborted execution due to previous error
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    

What do I do?



Answers:
(Answered on: 2021-11-24 21:02:02)


Per the
[documentation](https://github.com/smartcontractkit/chainlink#install):

> If you got any errors regarding locked yarn package, try running yarn
> install before this step

So run `yarn install`





:::NEXT DOC:::

if it is not already configured on your system.

  2. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  3. Install [Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to simplify package management and run code samples.

  4. Install a C compiler such as the one included in [GCC](https://gcc.gnu.org/install/). Some of the dependencies require a C compiler.

  5. Install [Rust](https://www.rust-lang.org/tools/install):
    
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh &&
    source $HOME/.cargo/env

  6. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the CLI:
    
        sh -c ""$(curl -sSfL https://release.solana.com/v1.13.6/install)"" &&
    export PATH=""~/.local/share/solana/install/active_release/bin:$PATH""

Run `solana --version` to make sure the Solana CLI is installed correctly.

    
        solana --version

  7. [Install Anchor](https://book.anchor-lang.com/getting_started/installation.html). On some operating systems, you might need to build and install Anchor locally. See the [Anchor documentation](https://book.anchor-lang.com/getting_started/installation.html#build-from-source-for-other-operating-systems-without-avm) for

:::NEXT DOC:::

and then
I type the commands in the following order. So far so good.  
Frist create your project folder and then switch to it: PS C:\Users\alanh>
mkdir jackpot  
PS C:\Users\alanh> cd jackpot  
Then, start VS Code in that folder by typing the following command:  
PS C:\Users\alanh\jackpot> code .  
Then, add Hardhat to your projet and start the project: PS
C:\Users\alanh\jackpot> yarn add --dev hardhat  
PS C:\Users\alanh\jackpot> yarn add --dev hardhat

Hope this helps. Cheers!


---
(Answered on: 2022-03-02 13:20:35)


In my case I had a problem with the package-lock.json

I deleted the package-lock.json file and then ran the command

    
    
    npm install
    

That solved the problem for me.


---
(Answered on: 2022-01-22 13:32:06)


You can also check whether traces tell you something (`npx hardhat --show-
stack-traces`). I tried reinstalling `nvm`, `node`, searched whole PC for
anything that has `hardhat` within file name and deleted it.

In the end I was missing some packages in my project...


---
(Answered on: 2022-01-05 00:11:31)


To fix this problem, go into your terminal and write nvm use 17. It will
switch the node back to 17. The problem is that you may have inadvertently
updated your hardhat version so you have 2 versions running on your machine.


---
(Answered on: 2021-12-29 01:25:51)


First thing to check when this error comes up is whether you are running `npx
run

:::NEXT DOC:::

to make sure the Solana CLI is installed correctly.

    
        solana --version

  2. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  3. Change to your project directory or create a new directory.
    
        mkdir off-chain-project && cd off-chain-project

  4. Optionally [install Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to use as a package manager and initialize yarn if your project does not already have a `package.json` file:
    
        npm install -g yarn && yarn init

  5. Add the [Anchor library](https://www.npmjs.com/package/@project-serum/anchor) to your project:

npmyarn

    
        npm i @project-serum/anchor
    
        yarn add @project-serum/anchor

  6. Add the [Chainlink Solana NPM library](https://www.npmjs.com/package/@chainlink/solana-sdk) to your project:

npmyarn

    
        npm i -g @chainlink/solana-sdk
    
        yarn add @chainlink/solana-sdk

  7. Create a temporary Solana wallet to use for this example. Alternatively, if you have an existing wallet that you want to use, locate the path to your [keypair](https://docs.solana.com/terminology#keypair) file and use it as the keypair for the rest of this guide.
    
        solana-keygen new --outfile

:::NEXT DOC:::

       node --version

  4. [Install Anchor](https://book.anchor-lang.com/getting_started/installation.html). On some operating systems, you might need to build and install Anchor locally. See the [Anchor documentation](https://book.anchor-lang.com/getting_started/installation.html#build-from-source-for-other-operating-systems-without-avm) for instructions.

  5. Install [Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to simplify package management and run code samples in the Starter Kit.
    
        npm install -g yarn

### Run the example program

After you install the required tools, clone the example code from the [solana-
starter-kit](https://github.com/smartcontractkit/solana-starter-kit)
repository.

  1. In a terminal, clone the [solana-starter-kit](https://github.com/smartcontractkit/solana-starter-kit) repository and change to the `solana-starter-kit` directory:
    
        git clone https://github.com/smartcontractkit/solana-starter-kit &&
    cd ./solana-starter-kit

You can see the complete code for the example on
[GitHub](https://github.com/smartcontractkit/solana-starter-kit/).

  2. In the `./solana-starter-kit` directory, install Node.js dependencies defined in the `package.json` file:
    
        yarn install

  3. Create a temporary Solana wallet file to use for this example. Because your application runs off-chain and does not run any functions or alter data on-chain, the wallet does not require any SOL tokens to function.
    
        solana-keygen

:::NEXT DOC:::

and other frameworks.

If you already have a project, install the
[@chainlink/contracts](https://www.npmjs.com/package/@chainlink/contracts) NPM
package.

### NPM

Install using [NPM](https://www.npmjs.com/):


    npm install @chainlink/contracts --save

### Yarn

Install using [Yarn](https://yarnpkg.com/):


    yarn add @chainlink/contracts

## Create a new project

If you're creating a new project from scratch, these commands will help you
set up your project to interact with Chainlink tools and features via the use
of our Starter Kits.

### Hardhat Starter Kit

For the latest instructions, see the following repositories:

  * [Hardhat Starter Kit](https://github.com/smartcontractkit/hardhat-starter-kit)
  * [Hardhat Starter Kit (TypeScript)](https://github.com/smartcontractkit/hardhat-starter-kit/tree/typescript)

To learn more about Hardhat, read the [Hardhat
Documentation](https://hardhat.org/getting-started/).

For more details on how to use Chainlink with Hardhat, see the blog post for
[How to use Hardhat with Chainlink](https://blog.chain.link/using-chainlink-with-hardhat/).

### Brownie Starter Kit

For the latest instructions, see the [Brownie Starter
Kit](https://github.com/smartcontractkit/chainlink-mix) repository.

To learn more about Brownie, read the [Brownie Documentation](https://eth-brownie.readthedocs.io/en/stable/).

For more details on how to use Chainlink with Brownie, see the [Develop a DeFi
Project Using Python](https://blog.chain.link/develop-python-defi-project/)
blog post.

###

:::NEXT DOC:::

Question: (Asked on: 2021-11-24 16:18:20)
Chainlink Node step 5. Build and Install: getting error code 137 for yarn
URL: https://stackoverflow.com/questions/70099478/chainlink-node-step-5-build-and-install-getting-error-code-137-for-yarn

Question Body:


I am trying to run a [chainlink node from
source](https://github.com/smartcontractkit/chainlink#install) and am
following the install instructions.

I'm currently running `make install`

It looks like the error code says there is not enough memory on my machine,
but my linux container on my chrome duet has 50GB. I don't know the problem. I
ran the command:

These are the errors

    
    
    error Command failed with exit code 137.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 137.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
     | `yarn setup` failed with exit code 137
    Stopping 2 active children
    Aborted execution due to previous error
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    

What do I do?



Answers:
(Answered on: 2021-11-24 21:02:02)


Per the
[documentation](https://github.com/smartcontractkit/chainlink#install):

> If you got any errors

:::NEXT DOC:::

not run hardhat using npx hardhat ..., run it locally using npm hardhat
... or yarn hardhat ..., other thing that can cause this error on windows is
the git bash, if you are using the git bash you won't be able to run hardhat
in that case try what running it locally with npm or yarn in the cmd


---
(Answered on: 2021-11-15 11:22:55)


Do not install Hardhat globally. If you already have installed hardhat
globally, please uninstall as the issue might be because of that as mentioned
in the error message.

Things you need to do to mitigate this:

  1. Check if the project package.json has hardhat as its dev dependency. If it is not, run `npm install --save-dev hardhat` or `yarn add --dev hardhat`
  2. Uninstall any global version of hardhat
  3. Remove node_modules and run `npm install` or `yarn install` to install all dependencies.
  4. Try running `npx hardhat compile` or `npx hardhat node` to check if it works.





:::NEXT DOC:::

[`cairo-lang` 0.10.3](https://pypi.org/project/cairo-lang/0.10.3/) package. Check [starknet.io](https://docs.starknet.io/documentation/getting_started/setting_up_the_environment/) for the latest requirements.

  * [Install NodeJS](https://nodejs.org/en/download/) in the version in the `>=14 <=18` version range.

  * [Install Yarn](https://classic.yarnpkg.com/lang/en/docs/install/).

  * Clone and configure the code examples:

    1. Clone the [smartcontractkit/chainlink-starknet](https://github.com/smartcontractkit/chainlink-starknet) repository, which includes the example contracts for this guide:
        
                git clone https://github.com/smartcontractkit/chainlink-starknet.git

    2. In your clone of the [chainlink-starknet](https://github.com/smartcontractkit/chainlink-starknet) repository, change directories to the proxy consumer example:
        
                cd ./chainlink-starknet/examples/contracts/proxy-consumer/

    3. Run `yarn install` to install the required packages including [StarkNet.js](https://www.starknetjs.com/), [HardHat](https://hardhat.org/), and the [StarkNet Hardhat Plugin](https://shard-labs.github.io/starknet-hardhat-plugin/).
        
                yarn install

  * If you want to run the on-chain examples, you must [set up a StarkNet"
How can I change the price feed token from ETH/USD to BUSD/USD using the Chainlink oracle?,"If you are trying to get BUSD/USD via a price feed on Kovan testnet, it is not available on that specific network. It is available on Ethereum mainnet however. If you are testing using the price feed, you can always use a mock contract to mock the behavior of the feeds for testing purposes only.",{'source': 'https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin'},"According to the answer provided on Stack Overflow, BUSD/USD is not available on Kovan testnet, but it is available on Ethereum mainnet. If you are testing using the price feed, you can use a mock contract to mock the behavior of the feeds for testing purposes only. Additionally, you need to make sure that you are using the correct ChainLink address for the token you want to get the price feed for.","Question: (Asked on: 2021-09-23 11:16:52)
how do i change the price feed token from eth /usd to busd/usd with the chainlink oracle?
URL: https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin

Question Body:


I am trying to get the price feed for BUSD/USD using the chainlink pricefeed
oracle but it tells me that the code was reverted. this is also happening when
i switch to any other token, i am using the kovan test net

this is the error i get

> call to PriceConsumerV3.getLatestPrice call to
> PriceConsumerV3.getLatestPrice errored: VM execution error. Reverted 0x

and this is my code

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.7;
    
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
    
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Kovan
         * Aggregator: ETH/USD
         * Address: 0x9326BFA02ADD2366b30bacB125260Af641031331
         */
        constructor() public {
            priceFeed =

:::NEXT DOC:::

a price feed on Kovan testnet, [it is
not available on that specific network](https://docs.chain.link/docs/ethereum-
addresses/#Kovan%20Testnet). It is [available on Ethereum
mainnet](https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet)
however.

If you are testing using the price feed, you can always use a mock contract to
mock the behavior of the feeds for testing purposes only.


---
(Answered on: 2021-09-23 22:11:12)


You have set incorrect ChainLink address!

correct ETH/USD address: `0x9326BFA02ADD2366b30bacB125260Af641031331`

Address you are using in on BSC network, not Kovan network!





:::NEXT DOC:::

solidity ^0.6.7;
    
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
    
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Kovan
         * Aggregator: ETH/USD
         * Address: 0x9326BFA02ADD2366b30bacB125260Af641031331
         */
        constructor() public {
            priceFeed = AggregatorV3Interface(0xcBb98864Ef56E9042e7d2efef76141f15731B82f);
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            (
                uint80 roundID, 
                int price,
                uint startedAt,
                uint timeStamp,
                uint80 answeredInRound
            ) = priceFeed.latestRoundData();
            return price;
  

:::NEXT DOC:::

/**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            (
                uint80 roundID, 
                int price,
                uint startedAt,
                uint timeStamp,
                uint80 answeredInRound
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    



Answers:
(Answered on: 2021-09-27 03:10:51)


If you are trying to get BUSD/USD via a price feed on Kovan testnet, [it is
not available on that specific network](https://docs.chain.link/docs/ethereum-
addresses/#Kovan%20Testnet). It is [available on Ethereum
mainnet](https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet)
however.

If you are testing using the price feed, you can always use a mock contract to
mock the behavior of the feeds for testing purposes only.


---
(Answered on: 2021-09-23 22:11:12)


You have set incorrect ChainLink address!

correct ETH/USD address: `0x9326BFA02ADD2366b30bacB125260Af641031331`

Address you are using in on BSC network, not Kovan

:::NEXT DOC:::

of the API call is
`https://api.pancakeswap.info/api/v2/tokens/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82`.
The only input required is the token address in the URL

2 - We want the price, which is an integer and in the 'price' JSON element. We
will multiply the price by 10**8 when we bring it on-chain because Solidity
can't handle decimals

3 - Because this is a simple API call, we can use a community run CL node that
takes a HTTP GET request, parses the JSON to find an element we specify, then
multiplies the result and converts it to the type we want before returning it
on-chain. Taking a look at the [BSC testnet jobs on
market.link](https://market.link/search/jobs?hierarchicalMenu%5BhierarchicalCategories.lvl0%5D=Binance&sortBy=job_created_at_desc),
I found a suitable one
[here](https://market.link/jobs/c314932c-2ee7-449b-b9f7-c2ba8fcf0ad2) (GET,
multiples result, returns a uint). From here we take the job ID and the oracle
address, and note the cost in LINK required to use it

Now that we have all these details, we can modify the standard API consumer
contract and put them all in, as follows. Changes I made include updating
variables to reflect price instead of volume, also i changed the variables for
job, oracle contract and fee, and i changed the setPublicChainlinkToken()
method in the contructor to setChainlinkToken, specifically passing in the
address of the [LINK token on BSC testnet](https://docs.chain.link/docs/link-
token-contracts/)

    
    
 

:::NEXT DOC:::

|
| 🟢LINK / USD                           | Chainlink                                                | Crypto         | 1%          | 3600s       |     8 | 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c |
| 🟢LON / ETH                            | Tokenlon                                                 | Crypto         | 2%          | 86400s      |    18 | 0x13A8F2cC27ccC2761ca1b21d2F3E762445f201CE |
| 🟢LRC / ETH                            | Loopring                                                 | Crypto         | 1%          | 86400s      |    18 | 0x160AC928A16C93eD4895C2De6f81ECcE9a7eB7b4 |
| 🟢LTC / USD           

:::NEXT DOC:::

Question: (Asked on: 2021-11-21 09:18:55)
How to get price information from Chainlink?
URL: https://stackoverflow.com/questions/70053205/how-to-get-price-information-from-chainlink

Question Body:


I would like to get USD price of DeFi tokens from Chainlink.

However, it looks like, I can get the price of an asset through either the
[Chainlink API calls](https://docs.chain.link/docs/make-a-http-get-request/),
or [Chainlink price feeds](https://docs.chain.link/docs/get-the-latest-
price/).

What are the costs associated with each and the differences and tradeoffs?



Answers:
(Answered on: 2021-11-22 19:28:33)


**With[Chainlink price feeds](https://docs.chain.link/docs/get-the-latest-
price/)**, each data feed is updated by a decentralized oracle network. Each
oracle in the set publishes data during an aggregation round. That data is
validated and aggregated by a smart contract, which forms the feed's latest
and trusted answer.

Each oracle operator is rewarded for publishing data. On mainnet, [sponsors
are paying the LINK
associated](https://ethereum.stackexchange.com/questions/90728/what-is-the-
cost-of-using-a-chainlink-oracle/90752#90752) to keep those feeds live,
decentralized, and secure, so they are not free. This allows the network to be
a shared resource where everyone chips in a tiny bit and makes them even
cheaper than running even your own centralized feed.

That being said, the price feeds are currently a simple `view` function, and
anyone can technically use them as access controls are on the roadmap to be
built at some point.

:::NEXT DOC:::

use [Chainlink Any-
API](https://docs.chain.link/docs/make-a-http-get-request/) calls to bring it
into your smart contract

To do so, you need to know 3 things

  1. The API endpoint that contains the data, and the inputs required
  2. The outputs that the API returns, including their types (integer, string etc), as well as the path in the resulting JSON that contains the data you want
  3. A Chainlink oracle on the network you're contract is on that has a compatible job that you can use (whether one you run yourself or someone elses)

Once you have these things, you can use the example consumer contract in the
docs linked above, and then change the values to suit. ie here is an example
contract that will make an API call to PancakeSwap to get the price of
PancakeSwap token on BSC testnet:

1 - API address and inputs. In this case, according to your linked docs, the
URL of the API call is
`https://api.pancakeswap.info/api/v2/tokens/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82`.
The only input required is the token address in the URL

2 - We want the price, which is an integer and in the 'price' JSON element. We
will multiply the price by 10**8 when we bring it on-chain because Solidity
can't handle decimals

3 - Because this is a simple API call, we can use a community run CL node that
takes a HTTP GET request, parses the JSON to find an element we specify, then
multiplies the result and converts it to the type we want before returning it
on-chain. Taking a look at the [BSC testnet jobs

:::NEXT DOC:::

here](https://docs.chain.link/data-feeds/price-feeds/addresses/) get the
`ETH/USD` goerli testnet address:""0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e""

  * Now in order to call chainlink oracle you have to have `LINK` token in your contract. Get some link token to your conract address [from the faucet](https://faucets.chain.link/)

  * Import the token in metamask. you will see the amount

  * send link token from your metamask to your contract

  * deploy your contract. if you are using `Remix IDE` chose the `injected provider` to connect to metamask. Because chainlink contract is on goerli, so you need to be on Goerli testnet. Once deployment goes through you can call the `fund` function.

  * Since the `fund` function has no argument, you need to send the value alongside the transaction. That is why inside the function you have `msg.value` to access to the sent amount.

  * In `Remix` ide, under ""GAS LIMIT`input there is`VALUE`input. you need to pass the amount in there before you call the`fund` function.





:::NEXT DOC:::

                                              | Crypto         | 0.5%        | 3600s       |     8 | 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c |
| 🟢BUSD / ETH                           | Binance USD                                              | Crypto         | 1%          | 86400s      |    18 | 0x614715d2Af89E6EC99A233818275142cE88d1Cfd |
| 🟢BUSD / USD                           | Binance USD                                              | Crypto         | 0.5%        | 86400s      |     8 | 0x833D8Eb16D306ed1FbB5D7A2E019e106B960965A |
| 🟢CAD / USD                            | Canadian Dollar                             "
Why are no job runs appearing on my local Chainlink node when trying to fulfill requests?,"There are a couple of possible reasons why no job runs are appearing on your local Chainlink node. First, make sure that the external job id in the Jobs screen on the Operator UI does not contain dashes. If it does, remove the dashes when using it in the ATestnetConsumer contract. Additionally, the direct request toml may not work as is. Try appending 'allowunrestrictednetworkaccess=""true""' to the fetch section in the toml file.",{'source': 'https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally'},"There could be multiple reasons why no job runs are appearing on a local Chainlink node when trying to fulfill requests. However, based on the provided context information, two possible reasons are:

1. The external job id in the Jobs screen on the Operator UI has dashes in them. To use them in the ATestnetConsumer contract, the dashes need to be removed.

2. The direct request toml doesn't seem to work as is. It may require appending allowunrestrictednetworkaccess=""true"" to the fetch section.","Question: (Asked on: 2022-05-11 08:55:38)
No job show up in Runs page while trying to run a Chainlink node locally
URL: https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally

Question Body:


I am trying to fulfil requests on my local test chainlink node on rinkeby
(following <https://docs.chain.link/docs/fulfilling-requests/>) but can't see
any job runs appear on my operator ui.

The Oracle contract is at
[0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C](https://rinkeby.etherscan.io/address/0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C)

The ATestnetConsumer contract is at
[0x977129EE2f404F4327A2A60C5fD9E57890D85FD0](https://rinkeby.etherscan.io/address/0x977129ee2f404f4327a2a60c5fd9e57890d85fd0)

My job toml screenshot below [](https://i.stack.imgur.com/uabGd.png)

Have confirmed my .env that it is running the rinkeby wss url from infura and
the chain is 4 and the link token contract address is
0x01BE23585060835E02B77ef475b0Cc51aA1e0709

My node wallet has ETH and LINK. Both the contracts have Link too (but no
ETH).

I run the setFulfillmentPermission function in remix with my Node wallet
address and

:::NEXT DOC:::

job toml screenshot below [](https://i.stack.imgur.com/uabGd.png)

Have confirmed my .env that it is running the rinkeby wss url from infura and
the chain is 4 and the link token contract address is
0x01BE23585060835E02B77ef475b0Cc51aA1e0709

My node wallet has ETH and LINK. Both the contracts have Link too (but no
ETH).

I run the setFulfillmentPermission function in remix with my Node wallet
address and true

[](https://i.stack.imgur.com/tqQGo.png)

When I execute the requestEthereumPrice function with my oracle address and
job id, I can see the LINK being sent by the [ATestnetConsumer contract to the
Oracle
contract](https://rinkeby.etherscan.io/tx/0xd1b71dd8ec83b7e204de5d2d0a95fdde2be41d0eadb181231ee21596ef661f78)
but no job run gets created in my local Chainlink node.

[](https://i.stack.imgur.com/wK7ha.png)

Confirming that the job hasn't run, I get the 0 value when I run the
currentPrice function on ATestnetConsumer.

Can anyone please point me to where I am going wrong? Thanks in advance!



Answers:
(Answered on: 2022-05-11 12:13:48)


Finally got it to work. Posting my two findings as I do think the
documentation needs an update to account for these.

  1. The external job id in the Jobs screen on the Operator UI has dashes in them. To use them in the ATestnetConsumer contract you need to remove the dashes (so 0e84f38985eb4edb98c2e2a09b589666 and not

:::NEXT DOC:::

created in my local Chainlink node.

[](https://i.stack.imgur.com/wK7ha.png)

Confirming that the job hasn't run, I get the 0 value when I run the
currentPrice function on ATestnetConsumer.

Can anyone please point me to where I am going wrong? Thanks in advance!



Answers:
(Answered on: 2022-05-11 12:13:48)


Finally got it to work. Posting my two findings as I do think the
documentation needs an update to account for these.

  1. The external job id in the Jobs screen on the Operator UI has dashes in them. To use them in the ATestnetConsumer contract you need to remove the dashes (so 0e84f38985eb4edb98c2e2a09b589666 and not 0e84f389-85eb-4edb-98c2-e2a09b589666).

  2. The direct request toml doesn't seem to work as is. I had to append allowunrestrictednetworkaccess=""true"" to the fetch section so it becomes

fetch [type=""http"" method=GET url=""$(decode_cbor.get)""
allowunrestrictednetworkaccess=""true""]





:::NEXT DOC:::

Question: (Asked on: 2021-12-28 14:32:36)
Chainlink job not executing but node receiving link fee
URL: https://stackoverflow.com/questions/70508478/chainlink-job-not-executing-but-node-receiving-link-fee

Question Body:


I have a chainlink node running in a evm testnet. I have deployed the link
token and oracle contract, funded my node account with ether, created a job
and a smartcontract that send a request to that job. I use the externalJobID
from job definition in my Chainlink.Request. My oracle account is receieving
the link fee from contract execution and request but my job is not executing.
I dont see anything in my chainlink node logs.

Here is my contract code

    
    
    contract Metadata is ChainlinkClient{
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        //event variables
        struct EMetaData{
            address dataToken;
            bytes   flags;
            bytes   data;
            address sender;
        }
    
        mapping(bytes32 => EMetaData) public metadatas;
    
        constructor() public {
            setChainlinkOracle(0x6a61789194260F0BE95a18d0116d883A4b5284ed);
           

:::NEXT DOC:::

     }
    }
    ``
    
    
      [1]: https://market.link/jobs/0609deab-6d61-4937-85e4-a8e810b8b272/runs
      [2]: https://market.link/nodes/323602b9-3831-4f8d-a66b-3fb7531649eb/metrics?start=1631783169&end=1632387969
    



Answers:
(Answered on: 2021-09-27 02:49:55)


Looking at the Etherscan activity, it looks like the node you are using may be
inactive. Try this node and jobId:

    
    
    Oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8; 
    JobId = ""d5270d1c311941d0b08bead21fea7747"";
    

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node may be inactive or not, check out the oracle address
in a block explorer. [You can see
here](https://kovan.etherscan.io/address/0x56dd6586db0d08c6ce7b2f2805af28616e082455)
that the original node you tried to use hasn't posted a transaction in quite a
long time.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.





:::NEXT DOC:::

   

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node is running or not, check out the oracle address in a
block explorer. [You can see
here](https://kovan.etherscan.io/address/0x56dd6586db0d08c6ce7b2f2805af28616e082455)
that the original node you tried to use hasn't posted a transaction in quite a
long time.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.





:::NEXT DOC:::

Question: (Asked on: 2021-11-24 17:00:49)
Chainlink node external adapter job not returning value
URL: https://stackoverflow.com/questions/70100103/chainlink-node-external-adapter-job-not-returning-value

Question Body:


I am following the ""Chainlink Hackathon | Building and using External
Adapters"" video tutorial (Oct 2021) and have done the following:

-Successfully set up and ran my own Chainlink node (per ""Chainlink Hackathon | Running a Chainlink node, 1.0.0 update"" video tutorial [Oct 2021].

-Created `Oracle.sol` contract and `setFulfillmentPermission` to `true`

-Successfully created Job Run on my node for the `Get > Uint256` example

-Added Eth to my node.

Added the following bridge to my node:

    
    
    URL http://localhost:8080
    Confirmations   0
    Minimum Contract Payment    0
    Outgoing Token  OKKkCQpl84Kiw38WNZ77fg1UKLgyB5+c
    

Added the Job definition:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""soccer-data-ea-2""
    contractAddress = ""0x4664A91f79999fd9DD4587dDf3daA3D01Ec50825""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4

:::NEXT DOC:::

v0.7 setup.

The request is never fulfilled so we've been wondering if our job id syntax is
correct in the PreCoordinator service agreements (among other things) and if,
perhaps, there's a peculiar configuration to apply to the node / v2 job specs.

## AnyAPI Stack

  * PreCoordinator.sol: a proxy for using multiple Chainlink oracles using service agreements

  * v0.6 Chainlink contracts:

    
    
    import '@chainlink/contracts/src/v0.6/ChainlinkClient.sol';
    import '@chainlink/contracts/src/v0.6/LinkTokenReceiver.sol';
    import '@chainlink/contracts/src/v0.6/Median.sol';
    import '@chainlink/contracts/src/v0.6/vendor/Ownable.sol';
    import '@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol';
    

  * v0.7 `Operator.sol`* contract

  * Migrated from the v0.6 Oracle.sol smart contract, in an attempt to solve this issue.

  * An v1.9.0 Arbitrum Chainlink node with a v2 job specification:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""StakingParametricRequest""
    forwardingAllowed = false
    maxTaskDuration = ""0s""
    contractAddress = ""0x6Dc1147ca16C020579642D90042CeA252474fD67""
    minContractPaymentLinkJuels = ""0""
    observationSource = """"""
        decode_log  

:::NEXT DOC:::

Question: (Asked on: 2022-12-12 21:30:02)
Why is our Chainlink node not catching any OracleRequest events from our Arbitrum Operator? Requests are never fulfilled / v2 jobs never executed
URL: https://stackoverflow.com/questions/74777534/why-is-our-chainlink-node-not-catching-any-oraclerequest-events-from-our-arbitru

Question Body:


We're trying to get our Chainlink AnyAPI stack to work with an Arbitrum
Chainlink node. The same stack is being used on Ethereum, Polygon and
Avalanche without issue.

Chainlink AnyAPI empowers some of the use cases of DSLA Protocol, a middleware
for adding consumer protection capabilities to any monitorable marketplace
(e.g. OpenSea) using peer-to-peer service level agreements (SLA).

## Request Lifecycle

Here are the different steps involved in verifying that a SLA contract has
been respected, using Chainlink:

  1. A user calls the verification function on the Messenger smart contract that implements Chainlink.

  2. The `Messenger` smart contract sends the request the `PreCoordinator` smart contract .

  3. The `PreCoordinator` forwards the request to the Oracles defined in a Service Agreement (proxy of Oracles).

  4. Upon receiving LINK, each Oracle sends the request to the Chainlink node, by emitting an `OracleRequest` event with the id of the job to be executed.

  5. The Chainlink node captures such event, and executes the corresponding job.

  6. Once the job is executed, the Chainlink node calls the `fulfillOracleRequest2` function to return the result from the external adapter to the PreCoordinator.

  7. The PreCoordinator takes the mean of all Oracle results and ultimately registers the SLI in the messenger.

 

:::NEXT DOC:::

Question: (Asked on: 2021-10-26 10:19:03)
following chainlink fulfilling-requests doc doesn&#39;t work
URL: https://stackoverflow.com/questions/69721319/following-chainlink-fulfilling-requests-doc-doesnt-work

Question Body:


We had setup the chainlink node on gcp and following
<https://docs.chain.link/docs/fulfilling-requests/>. The job is not fulfilled
and the currentprice property always returns 0.

Oracle:
[https://remix.ethereum.org/#url=https://docs.chain.link/samples/NodeOperators/Oracle.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.6.6+commit.6c089d02.js](https://remix.ethereum.org/#url=https://docs.chain.link/samples/NodeOperators/Oracle.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.6.6+commit.6c089d02.js)
Consumer:
[https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js)

Thanks



Answers:
(Answered on: 2021-10-28 06:48:56)


Generally, When we create new job on node it assign externalJobId to"
Is it possible for Chainlink VRF to return two same randomnesses in one request?,Chainlink VRF generates one or more random values and cryptographic proof for each request. It is unlikely for Chainlink VRF to return the same randomness in one request.,{'source': 'https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request'},"According to the answer provided in the first question, it is unlikely for Chainlink VRF to return the same randomness in one request.","Question: (Asked on: 2023-01-19 03:22:56)
Possible Chainlink VRF returns two same randomnesses in one request?
URL: https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request

Question Body:


as the title, i am thinking if it's possible that Chainlink VRF returns two
same randomnesses in one request? As of ""random"", i assume the answer is YES.
Thanks.



Answers:
(Answered on: 2023-01-19 08:57:48)


For each request, Chainlink VRF generates one or more random values and
cryptographic proof of how those values were determined. It is unlikely that a
Chainlink VRF would return the same randomness in one request.





:::NEXT DOC:::

>= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
        function letsGo() public {
            bytes32 requestId;
            requestId = getRandomNumber();
            fulfillRandomness(requestId, 123456);
        }
    }
    

Is there a way in blockchain to get the randomResult?

I'm looking specifically at my `letsGo` function.



Answers:
(Answered on: 2021-10-07 12:29:29)


The chainlink VRF is a 2 transaction process.

The first transaction requests the random number, and the second to have the
random number returned. You can't get the random number in 1 go.

You can read more about the [basic request
model](https://docs.chain.link/docs/architecture-request-model/) in the
documentation.

You're `letsgo` function will not work.





:::NEXT DOC:::

could rewrite
the chain's history to put a randomness request from your contract into a
different block, which would result in a different VRF output. Note that this
does not enable a miner to determine the random value in advance. It only
enables them to get a fresh random value that might or might not be to their
advantage. By way of analogy, they can only re-roll the dice, not predetermine
or predict which side it will land on.

You must choose an appropriate confirmation time for the randomness requests
you make. Confirmation time is how many blocks the VRF service waits before
writing a fulfillment to the chain to make potential rewrite attacks
unprofitable in the context of your application and its value-at-risk.

## Do not re-request randomness

Any re-request of randomness is an incorrect use of VRFv2. Doing so would give
the VRF service provider the option to withhold a VRF fulfillment if the
outcome is not favorable to them and wait for the re-request in the hopes that
they get a better outcome, similar to the considerations with block
confirmation time.

Re-requesting randomness is easily detectable on-chain and should be avoided
for use cases that want to be considered as using VRFv2 correctly.

## Don't accept bids/bets/inputs after you have made a randomness request

Consider the example of a contract that mints a random NFT in response to a
user's actions.

The contract should:

  1. Record whatever actions of the user may affect the generated NFT.
  2. **Stop accepting further user actions that might affect the generated NFT** and issue a randomness request.
  3. On randomness fulfillment, mint the NFT.

Generally speaking, whenever an outcome in your contract depends on some user-
supplied inputs and randomness, the contract should not accept any additional
user-supplied inputs after it submits the randomness request.

Otherwise, the cryptoeconomic security properties may

:::NEXT DOC:::

how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation

:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription

:::NEXT DOC:::

judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                          

:::NEXT DOC:::

        VRFConsumerBase(
                0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, // VRF Coordinator
                0xa36085F69e2889c224210F603D836748e7dC0088  // LINK Token
            )
        {
            keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
        }
        function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
        function letsGo() public {
            bytes32 requestId;
            requestId = getRandomNumber();
            fulfillRandomness(requestId, 123456);
        }
  

:::NEXT DOC:::

on: 2022-10-13 13:09:03)


# Summary

For pseudorandomness you can use something like
[EIP-4399](https://eips.ethereum.org/EIPS/eip-4399):

    
    
    uint256 randomness = uint(keccak256(abi.encodePacked(msg.sender, block.difficulty, block.timestamp)));
    

(You don't even need to use assembly, `difficulty` is directly exposed in
solidity)

But for true randomness, you'd need something like [Chainlink
VRF](https://docs.chain.link/docs/vrf/v2/subscription/examples/get-a-random-
number/).

    
    
        function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
            uint256 randomness = _randomWords[0];
        }
    

## Why is `difficulty` or `PREVRANDAO` pseudo-random in a post-merge ETH?

When a validator is due to propose a block, they face a [fairly minimal
penalty](https://ethereum.stackexchange.com/questions/90781/what-is-the-
penalty-of-having-eth2-validator-offline) for failing to do so. Given a smart
contract that is trying to make itself unpredictable/uncontrollable via
`PREVRANDAO`, this option allows them to cheaply bias the behavior of the
contract in the following ways.

### 1\. You always need a validator to propose two blocks in a row

`PREVRANDAO`'s value has no
[entropy](https://en.wikipedia.org/wiki/Entropy_\(computing\)) given

:::NEXT DOC:::

increase the chances of an attacker cheating your application. Imagine you implemented a simple coin flip smart contract using VRF v2. In a bet function, you choose heads or tails and then request a random number. If you have selected heads (0) and the result of the VRF service meant that you would win the bet, it could try to withhold this answer and replace it with your second request if it’s more advantageous.

So you see, we must consider the unique properties of blockchains here to ensure randomness in our smart contracts. While the numbers are always random, we must also look into how our applications and smart contracts deal with them. In the end, it will be a matter of cost if it's worth attacking your application. You must also be aware of the protocol that you are using.

In general, re-organizations on chains are possible. A miner would take your request and try to create a new random number with a different block and do this until they find a block to their advantage. They cannot control the VRF output but can ""re-roll"" the dice. If they manage to produce a valid blockchain with this new block and the network accepts this block instead, they could effectively attack your application by controlling the random input.
While this is a possible attack, it's costly to attack a network like this, as in the proof of network. You need at least 51% of the network to drive such an attack. Depending on your application requirements, you consider a 20-block confirmation time highly secure. You can lower the block confirmation time depending on the value you are trying to protect. You must calculate an attacker's costs and potential reward to decide your confirmation time.


:::NEXT DOC:::

         ""Not enough LINK - fill contract with faucet""
            );
            return requestRandomness(keyHash, fee);
        }
    
        /**
         * Callback function used by VRF Coordinator
         */
        function fulfillRandomness(
            bytes32 requestId,
            uint256 randomness
        ) internal override {
            randomResult = randomness;
            emit RequestFulfilled(requestId, randomness);
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    

Maximum Gas for Callback

If your `fulfillRandomness` function uses more than 200k gas, the transaction
will fail.

## Getting More Randomness

If you are looking for how to turn a single result into multiple random
numbers, check out our guide on [Randomness Expansion](/vrf/v1/best-practices/#getting-multiple-random-numbers).

## Network Congestion and Responsiveness

Network congestion can occur on all blockchains from time to time, which may
result in transactions taking longer to get included in a block. During times
of network congestion, the VRF service will continue responding to randomness
requests, but fulfillment response times will corresponding increase based on
the level of congestion. It is important you account for this in your use case
and set expectations accordingly.

## What's next

  * [› API"
How can I ensure that `performUpkeep` is not called again before it finishes performing work?,"In the given scenario, there is no waiting or asynchronous behavior in the EVM. One suggestion is to use the `block.number` to create an additional entry condition. This can be done by adding a requirement in the `checkUpkeep` function that checks if the current block number is greater than or equal to the last upkeep block number plus a certain value. Another option is to use OpenZeppelin's `nonReentrant` modifier to prevent reentrancy issues. These approaches can help ensure that `performUpkeep` is not called again before it finishes performing work.",{'source': 'https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per'},"One suggestion given in the answers is to use the `block.number` to create an additional entry condition in the `checkUpkeep` function. Another suggestion is to use OpenZeppelin's `nonReentrant` modifier. However, it is noted that in the EVM, there is no waiting or async, so it may not be possible to ensure that `performUpkeep` is not called again before it finishes performing work.","Question: (Asked on: 2021-11-04 03:31:44)
Is there a way to ensure performUpkeep isn&#39;t called again before it finishes performing work?
URL: https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per

Question Body:


I have a keeper that calls checkUpkeep and it returns true, however in
performUpkeep, the condition that would cause checkUpkeep to return false is
not set until data is returned from offchain (this is bc I want to make sure
that if for some reason that fails, the checkUpkeep will return true again to
retry)

How would I handle this so that checkUpkeep is not called again while data is
being retrieved triggering a second performUpkeep?

ex:

    
    
      function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
      }
    
      function performUpkeep(bytes calldata /* performData */)

:::NEXT DOC:::

+ 10 )** //if you can afford artificial constraint
    
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
        
        **uint lastUpkeepBlock = block.number;**
        
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
        requestVolumeData(); // latestDateChecked is updated once requestVolumeData successfully receives data offchain and calls fulfill function
      }
    

or OpenZeppelin's
[nonReentrant](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard)
modifier.

Related Concepts: [Reentrancy](https://swcregistry.io/docs/SWC-107) [Race
condition](https://swcregistry.io/docs/SWC-114)





:::NEXT DOC:::

   view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
        requestVolumeData(); // latestDateChecked is updated once requestVolumeData successfully receives data offchain and calls fulfill function
      }
    



Answers:
(Answered on: 2021-11-09 18:59:39)


I am not sure if what you are concerned about is possible.

In the EVM a transaction either succeeds or fails. There is no waiting or
async. Or maybe there's some chainlink magic (involving transactions that do
not occur in the same block) happening that I have not learned about yet.

My suggestion: use blocknumber (block.number) to create an aditional entry
condition. That's what I'm using for a keeper to call a function approx. once
a day.

    
    
        function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool

:::NEXT DOC:::

on: 2021-11-09 18:59:39)


I am not sure if what you are concerned about is possible.

In the EVM a transaction either succeeds or fails. There is no waiting or
async. Or maybe there's some chainlink magic (involving transactions that do
not occur in the same block) happening that I have not learned about yet.

My suggestion: use blocknumber (block.number) to create an aditional entry
condition. That's what I'm using for a keeper to call a function approx. once
a day.

    
    
        function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        **require(block.number >= lastUpkeepBlock + 10 )** //if you can afford artificial constraint
    
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
        
        **uint lastUpkeepBlock = block.number;**
        
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
 

:::NEXT DOC:::

when the checkUpkeep returns true to execute the upkeep



Answers:
(Answered on: 2022-11-12 04:08:40)


In order to solve the problem like ""Why Chainlink checkUpkeep does not
execute"", I suggest doing the following things to debug your upkeep.

  1. Since `checkUpkeep` and `performUpkeep` are both triggered by [Chainlink automation](https://automation.chain.link/), you need to check your automation subscription first. In the automation app, double check the contract address is correct.
  2. Because the chainlink node has to change the state of blockchain(call `performUpkeep` in your consumer contract), it has to pay the gas fee. It is important to make sure there is a minimum balance of LINK in your subscription.
  3. Test if `checkUpkeep` works as expected. If the pre-defined condition for automation is satisfied in your smart contract, `checkUpkeep` should return true. Chainlink automation only calls `performUpkeep` when `checkUpkeep` returns `true`, so the upkeep does not work if `checkUpkeep` cannot return true. Call `checkUpkeep` by yourself to test if it works properly. If you cannot get `true` as returned value, automation cannot get `true` either.
  4. Test if `performUpkeep` works as expected. The mechanism of Chainlink automation is to call `performUpkeep` when `checkUpkeep` returns `true`, so you must make sure the `performUpkeep` can be called by automation. Try to call the `performUpkeep` manually to see if it works properly.

Hope it helps!





:::NEXT DOC:::

Question: (Asked on: 2023-03-04 17:42:18)
How to avoid another upkeep run my checkUpkeep function Chainlink
URL: https://stackoverflow.com/questions/75637468/how-to-avoid-another-upkeep-run-my-checkupkeep-function-chainlink

Question Body:


I don't know if this is a too simple question but I'm wondering how to avoid
an external Upkeep run my checkUpkeep function of my contract if, at the end,
my contract's address is public and that's the only thing you need to run the
checkUpkeep. I want to avoid that someone can call this function of my
contract and modify the state.

<https://docs.chain.link/chainlink-automation/flexible-upkeeps/>

Thank yoou!!!



Answers:
(Answered on: 2023-03-09 17:00:14)


For those who are facing this problem, I found a solution that could be
applicable for some of you. The caller address for checkUpkeep and
performUpkeep is the registry address you can find in the dashboard to manage
your upkeeps. So, what I've done is to create a modifier that allows only my
registry address to run these functions. I hope this information could be
helpful for any of you!


---
(Answered on: 2023-03-06 14:13:15)


TLDR; Use [revalidation](https://docs.chain.link/chainlink-
automation/compatible-contracts/#revalidate-performupkeep) in `performUpkeep`
prior to running.

The best method for preventing the upkeep functions from being called when
they should be is through revalidating the conditions for calling them. You
could require that the caller be the `Automation Registry`, which would limit
who could execute the function, but this would not prevent someone else

:::NEXT DOC:::

can find in the dashboard to manage
your upkeeps. So, what I've done is to create a modifier that allows only my
registry address to run these functions. I hope this information could be
helpful for any of you!


---
(Answered on: 2023-03-06 14:13:15)


TLDR; Use [revalidation](https://docs.chain.link/chainlink-
automation/compatible-contracts/#revalidate-performupkeep) in `performUpkeep`
prior to running.

The best method for preventing the upkeep functions from being called when
they should be is through revalidating the conditions for calling them. You
could require that the caller be the `Automation Registry`, which would limit
who could execute the function, but this would not prevent someone else from
creating upkeep to call it.

See the [FAQ](https://docs.chain.link/chainlink-automation/faqs/#can-i-
require-that-performupkeep-is-only-callable-by-the-automation-registry) for
more information





:::NEXT DOC:::

actions must be performed only when specific conditions are met. Check
all of the preconditions within `performUpkeep` to ensure that state change
occurs only when necessary.

In this pattern, it is undesirable for the state change to occur until the
next time the Upkeep is checked by the network and the conditions are met. It
is a best practice to stop any state change or effects by performing the same
checks or similar checks that you use in `checkUpkeep`. These checks validate
the conditions before doing the work.

For example, if you have a contract where you create a timer in `checkUpkeep`
that is designed to start a game at a specific time, validate the condition to
ensure third-party calls to your `performUpkeep` function do not start the
game at a different time.

### Perform upkeep ONLY when data is verified via `performData`

Some actions must be performed using data you intend to use. Revalidate that
the `performData` is allowed before execution.

For example, if you have a `performUpkeep` that funds a wallet and the address
of the wallet is received via the `performData` parameter, ensure you have a
list of permissable addresses to compare against to prevent third-party
calling your function to send money to their address.

### When performing actions in Automation-compatible contracts is not harmful

Sometimes actions must be performed when conditions are met, but performing
actions when conditions are not met is still acceptable. Condition checks
within `performUpkeep` might not be required, but it can still be a good
practice to short circuit expensive and unnecessary on-chain processing when
it is not required.

It might be desirable to call `performUpkeep` when the `checkUpkeep`
conditions haven't yet been tested by Chainlink Automation, so any specific
checks that you perform are entirely use case specific.

### Always test your contract

As with all smart contract testing, it is important to test the boundaries of
your smart contract in

:::NEXT DOC:::

   }
        else{
            upkeepNeeded = false;
        }
      }
    
    function **performUpkeep**(bytes calldata /* performData */) external override {
        require(msg.sender == 0x4Cb093f226983713164A62138C3F718A5b595F73);
        lottery_state = LOTTERY_STATE.DRAWING;
        Random(random).getRandomNumber();
      }
    

As I mentioned earlier, this code is being used in another contract which is
currently receiving upkeep so I am puzzled as to why it is not working in the
new contract.



Answers:
(Answered on: 2021-12-13 23:44:27)


If your upkeeps are not being performed make sure to double-check the next
items:

  * Are Chainlink Keepers currently available on the network you are deploying to?
  * Is your smart contract `KeeperCompatible`?
  * Call `checkUpkeep`. Did it return `true` or `false`?
  * Can you `performUpkeep`?
  * Did you register your contract for upkeeps?
  * Did you fund it?





:::NEXT DOC:::

true;
                return (true, performData) ;`//should perform upkeep for the setTime() function`
            } if (roundWinningIndex[coinRound].length != 0) {
                upkeepNeeded = true;
                return (true, performData);`//should perform upkep for the a withdrawal function
            }
    

How do I configure the perform upkeep to know which function to call? How do I
make sure it calls the correct function?



Answers:
(Answered on: 2021-11-24 21:36:27)


There are a number of ways you can have the keepers call the correct function.
One way would be to add information in your `performData` designating which
function to call.

The performUpkeep looks like this:

    
    
    function performUpkeep(bytes calldata performData) external override {
            // conditional to call one function
            // conditional to call a different function
        }
    

## 1\. The Better way

When the Chainlink keepers call `checkUpkeep` they pass the returned
information of `performData` to the input of `performUpkeep`. You can
[encode](https://docs.soliditylang.org/en/v0.8.10/units-and-global-
variables.html?highlight=abi.encode#abi-encoding-and-decoding-functions) just
about anything to pass as inputs to the"
Why is the value of volume always returning 0 in the Chainlink example?,"The value of volume is always returning 0 in the Chainlink example because there is an error in the code. The line `request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");` should be `request.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR"");` (notice the commas instead of dots). Chainlink nodes 1.0.0 and later support this new ""comma based"" format. Chainlink nodes prior to 1.0.0 support the ""dots based"" format. The official docs have been updated to include this change.",{'source': 'https://stackoverflow.com/questions/71619589/chainlink-example-not-updating-value'},"The reason why the value of volume is always returning 0 in the Chainlink example is not clear, but it could be due to an issue with the Chainlink node failing to write the result back to the contract. The asker has tried different oracle addresses and job IDs, and the smart contract seems to be working perfectly. It is suggested to check if the Chainlink node is funded and if it has permission to call the function `fulfillOracleRequest2` in the contract operator.","Question: (Asked on: 2022-03-25 15:38:20)
Chainlink example not updating value
URL: https://stackoverflow.com/questions/71619589/chainlink-example-not-updating-value

Question Body:


I'm following the example within the [Chainlink
documentation](https://docs.chain.link/docs/advanced-tutorial/) (also below),
and have been testing it within remix. I've deployed the contract on the kovan
testnet & sent LINK to it, I'm able to execute the requestVolumeData() and get
the notification that the transaction was completed and I'm able to view it on
etherscan.

However, when checking the value of volume it always returns 0. I'm aware that
it can take some time, but the value hasn't changed after waiting 20 minutes.

I've done tests with the following oracle addresses / job id's. From the
example (0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 &
d5270d1c311941d0b08bead21fea7747) From the accompanying youtube video
(0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e &
29fa9aa13bf1468788b7cc4a500a45b8) And from
[chainlink](https://market.link/jobs/8b2792ab-24a3-4ed7-b7f4-f56f44828d9b)
market (set to kovan network). (0xA1d76ABD287d87d6E1d92262F7D53Cbe4f290505 &
fc3ea215bb9e44e088107b29bb495e2d)

I'm not sure where things go wrong, I don't think it's the code since it's
copy pasted from the example. But non

:::NEXT DOC:::

      using Chainlink for Chainlink.Request;
      
        uint256 public volume;
    
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        constructor() {
            setPublicChainlinkToken();
            oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
            jobId = ""d5270d1c311941d0b08bead21fea7747"";
            fee = 0.1 * 10 ** 18;
        }
        
        function requestVolumeData() public returns (bytes32 requestId) {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");        
            request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");
            int timesAmount = 10**18;
            request.addInt(""times"", timesAmount);
            
            return sendChainlinkRequestTo(oracle, request, fee);
  

:::NEXT DOC:::

From the accompanying youtube video
(0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e &
29fa9aa13bf1468788b7cc4a500a45b8) And from
[chainlink](https://market.link/jobs/8b2792ab-24a3-4ed7-b7f4-f56f44828d9b)
market (set to kovan network). (0xA1d76ABD287d87d6E1d92262F7D53Cbe4f290505 &
fc3ea215bb9e44e088107b29bb495e2d)

I'm not sure where things go wrong, I don't think it's the code since it's
copy pasted from the example. But non of the adreses have worked.

    
    
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public volume;
    
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        constructor() {
            setPublicChainlinkToken();
            oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
            jobId = ""d5270d1c311941d0b08bead21fea7747"";
    

:::NEXT DOC:::

   import ""@chainlink/contracts/src/v0.6/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
      
        uint256 public volume;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Kovan
         * Chainlink - 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e
         * Chainlink - 29fa9aa13bf1468788b7cc4a500a45b8
         * Fee: 0.1 LINK
         */
        constructor() public {
            setPublicChainlinkToken();
            oracle = 0x56dd6586DB0D08c6Ce7B2f2805af28616E082455;
            jobId = ""b6602d14e4734c49a5e1ce19d45a4632"";
            fee = 0.1 * 10 ** 18; // 0.1 LINK
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
        

:::NEXT DOC:::

  const result = await apiConsumer.volume()
        console.log(""API Consumer Volume: %s"", result)
      });
    });
    

In hardhat.config.js, blockNumber is chosen to be just before the first
ChainlinkRequested event, and we can see from the script output that the
contract is funded with sufficient LINK.

    
    
    require(""@nomiclabs/hardhat-waffle"");
    
    /**
     * @type import('hardhat/config').HardhatUserConfig
     */
    module.exports = {
      solidity: ""0.8.7"",
      networks: {
        hardhat: {
          forking: {
            url: ""https://eth-kovan.alchemyapi.io/v2/<API Key>"",
            blockNumber: 31301193
          }
        }
      },
    };
    

Script output

    
    
      API
    name=ChainLink Token
    balanceOf=1000000000000000000
    requestId=0x352988e0ddfe5c4349711ed9787069b1ea55bae562f676a08f6103435a874514
    API Consumer Volume: 0
    

Why doesn't ChainlinkFulfilled seem to get fired from the Hardhat test?



Answers:
(Answered on: 2022-04-30 09:33:48)


Welcome, Peter! There is no oracle listening on your forked network.

:::NEXT DOC:::

      */
        constructor() {
            // setPublicChainlinkToken();
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            oracle = 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7;
            jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
            fee = 0.1 * 10 ** 18; // 0.1 LINK
        }
        
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
            
            request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
            int timesAmount = 10**18;
           

:::NEXT DOC:::

// SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
    
        using Chainlink for Chainlink.Request;
      
        uint256 public volume;
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Goerli
         * Chainlink - 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7
         * Chainlink - ca98366cc7314957b8c012c72f05aeeb
         * Fee: 0.1 LINK
         */
        constructor() {
            // setPublicChainlinkToken();
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            oracle = 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7;
            jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
            fee = 0.1 * 10 ** 18; // 0.1 LINK
        }
   

:::NEXT DOC:::

Question: (Asked on: 2021-05-29 22:10:11)
GET API Chainlink not returning value
URL: https://stackoverflow.com/questions/67756089/get-api-chainlink-not-returning-value

Question Body:


I posted my code below. I tried amending the [basic chainlink
example](https://remix.ethereum.org/#version=soljson-v0.6.7+commit.b8d736ae.js&optimize=false&evmVersion=null&gist=8a173a65099261582a652ba18b7d96c1&runs=200)
to use another API. I used the [dummy
API](http://www.dummy.restapiexample.com/), made sure to change the path so
that I would get a uint and sent LINK to the smart contract, but it does not
end up returning the employee age (I don't think this needs the multiply
action as there are no decimals). Any help would be appreciated!

    
    
    // This example code is designed to quickly deploy an example contract using Remix.
    
    pragma solidity ^0.6.0;
    
    import ""https://raw.githubusercontent.com/smartcontractkit/chainlink/master/evm-contracts/src/v0.6/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
      
        uint256 public volume;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Kovan
         * Chainlink -

:::NEXT DOC:::

using Remix.
    
    pragma solidity ^0.6.0;
    
    import ""https://raw.githubusercontent.com/smartcontractkit/chainlink/master/evm-contracts/src/v0.6/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
      
        uint256 public volume;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        /**
         * Network: Kovan
         * Chainlink - 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e
         * Chainlink - 29fa9aa13bf1468788b7cc4a500a45b8
         * Fee: 0.1 LINK
         */
        constructor() public {
            setPublicChainlinkToken();
            oracle = 0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e;
            jobId = ""29fa9aa13bf1468788b7cc4a500a45b8"";
            fee = 0.1 * 10 ** 18; // 0.1 LINK
        }
        
        /**
         * Create a Chainlink request to

:::NEXT DOC:::

\\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=ethtx to=""0xAf644831B57E5625ac64cDa68248b810bE4D4D01"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> ds_multiply-> encode_data -> encode_tx -> submit_tx
    """"""
    

These are the run logs from the Node. Everything compiled just fine and the
values look good however, they never update in a smart contract, it's always
0.

[](https://i.stack.imgur.com/ZUw17.png)

This is my smart contract for reference.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@openzeppelin/contracts/utils/Strings.sol"";
    
    contract mimifundCO2 is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
       "
Why does Chainlink VRF take a long time to get random numbers?,"Chainlink VRF follows a request and receive cycle to get a random number, which involves two transactions: the requesting transaction and the response transaction. This is necessary to look outside the blockchain and ensure randomness. The speed at which the random number is returned depends on the block time of the blockchain being used. For Ethereum, the fastest time possible is 2 times the block time, which is around 30 seconds. On faster chains like Polygon, the time is significantly lower.",{'source': 'https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers'},"Chainlink VRF takes a long time to get random numbers because it follows a request and receive cycle, which involves looking outside the blockchain to get a response. This means that two transactions take place, the requesting transaction and the response transaction, and the speed at which the random number is returned is dictated by the block time of the blockchain being used. On Ethereum, the fastest time possible for a random number to be returned is 2 * block time, or about 30ish seconds, while on faster chains like Polygon, this is drastically lower. Additionally, there may be downtime issues with specific testnets, such as Rinkeby, which can affect the speed of Chainlink VRF responses.","Question: (Asked on: 2021-06-23 23:02:20)
Chain Link VRF takes a long time to get random numbers
URL: https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers

Question Body:


**Description**

Getting a random number takes a really long time. After executing the
getRandomNumber function, a few minutes go by before I can interact with my
random number.

Basically I click getRandomNumber and have to wait 2-3 minutes until the
random number shows up in the randomResult variable.

**Steps to Reproduce**

  1. Head over to the documentation here : <https://docs.chain.link/docs/get-a-random-number/>
  2. Scroll down and click on ""Deploy this contract using Remix"" (blue outline btn)
  3. Click on one of the folders that looks like 536123b61468ad4442cfc4278e8de577 then RandomNumberConsumer.sol
  4. Replace the LINK Token, VRF Coordinator, and Key Hash to be unique to rinkeby <https://docs.chain.link/docs/vrf-contracts/>
  5. Navigation to the Solidity Compiler Tab and click on Compile RandomNumber.sol.
  6. Deploy the contract on Rinkeby
  7. Copy to contract address and send LINK token to fund the contract.
  8. Click on the orange getRandomNumber btn in remix
  9. Click on randomResult and observe how long it takes for the value in randomResult to change. (Keep clicking until it finally changes)

**Additional Information**

I am not sure if this behavior is intentional or if I need to change up the
code. Ideally I would like to have the value of randomResult once the
getRandomNumber function finishes executing. Right now I don't know when the
value

:::NEXT DOC:::

VRF Coordinator, and Key Hash to be unique to rinkeby <https://docs.chain.link/docs/vrf-contracts/>
  5. Navigation to the Solidity Compiler Tab and click on Compile RandomNumber.sol.
  6. Deploy the contract on Rinkeby
  7. Copy to contract address and send LINK token to fund the contract.
  8. Click on the orange getRandomNumber btn in remix
  9. Click on randomResult and observe how long it takes for the value in randomResult to change. (Keep clicking until it finally changes)

**Additional Information**

I am not sure if this behavior is intentional or if I need to change up the
code. Ideally I would like to have the value of randomResult once the
getRandomNumber function finishes executing. Right now I don't know when the
value of randomResult will show up.



Answers:
(Answered on: 2021-06-23 23:24:42)


Chainlink VRF follows the [request and
receive](https://docs.chain.link/docs/intermediates-tutorial/#1-request--
receive) cycle of getting a number. This means, it has to look outside the
blockchain to get a response.

So, 2 transactions actually take place:

  1. Your requesting transaction
  2. The response transaction

This is necessary to look outside the blockchain like this, otherwise you'll
get a deterministic number as opposed to random. The speed at which the random
number is returned, is dictated by the block time of the blockchain you're
using.

So for Ethereum, the fastest time possible for a Random Number to be returned
is 2 * block time, or about 30ish seconds.

On faster chains like polygon, this is drastically lower.





:::NEXT DOC:::

Question: (Asked on: 2022-01-14 13:25:29)
Chainlink VRF very slow - 20+ minutes for response to fulfillRandomness on Rinkeby
URL: https://stackoverflow.com/questions/70711267/chainlink-vrf-very-slow-20-minutes-for-response-to-fulfillrandomness-on-rinke

Question Body:


I have implemented a basic Chainlink VRF function in Solidity and deployed to
Ethereum test network Rinkeby

    
    
      function getRandomNumber() public returns (bytes32 requestId)
      {
        require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK"");
        return requestRandomness(keyHash, fee);
      }
    
      function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override 
      {
        randomResult = randomness;
        _requestId = requestId;
      }
    

This works fine, deducts the LINK fee from my wallet, and eeeeeventually does
call back `fulfillRandomness` with a random hex value, however it takes
forever!

Just did a test and it took 30 minutes. Could I be doing something wrong or
why is it taking so long? I know it's async and there's lots of stuff going on
to fetch the random number, but at these speeds it's basically unusable right



Answers:
(Answered on: 2022-01-17 16:19:42)


I switched to Kovan and I'm reliably getting ~1 min VRF responses


---
(Answered on:

:::NEXT DOC:::

  randomResult = randomness;
        _requestId = requestId;
      }
    

This works fine, deducts the LINK fee from my wallet, and eeeeeventually does
call back `fulfillRandomness` with a random hex value, however it takes
forever!

Just did a test and it took 30 minutes. Could I be doing something wrong or
why is it taking so long? I know it's async and there's lots of stuff going on
to fetch the random number, but at these speeds it's basically unusable right



Answers:
(Answered on: 2022-01-17 16:19:42)


I switched to Kovan and I'm reliably getting ~1 min VRF responses


---
(Answered on: 2022-01-17 01:21:45)


The Rinkeby testenet has had some downtime issues this weekend. You can use
the Kovan testnet and VRF until Rinkeby is operating normally again.





:::NEXT DOC:::

Question: (Asked on: 2022-01-15 02:15:51)
Chainlink VRFCoordinator taking a long time to respond
URL: https://stackoverflow.com/questions/70718394/chainlink-vrfcoordinator-taking-a-long-time-to-respond

Question Body:


This is a blockchain question. I'm following the tutorial from freecodecamp
and every time we use the vrfcoordinator from chainlink it works perfectly in
the development network, but not when I deploy my smart contract to the
rinkeby test net.

My issue is when I try to get a verified random number from the
VRFcoordinator(0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B) it takes about 40
minutes to get a response back.

Is this normal? or is it because I'm deploying it to a test-net

If so, is this the best way to get a random number considering it takes 40
minutes to get one?



Answers:
(Answered on: 2022-01-15 22:41:51)


Currently, it looks [like Rinkeby is down](https://rinkeby.etherscan.io/) (as
of writing this answer the last Rinekby block was mined almost 9 hours ago.)
You'll have to wait for Rinkeby to come back online.





:::NEXT DOC:::

= randomness;
        }
    }
    



Answers:
(Answered on: 2022-12-11 08:14:05)


You probably using incorrect addresses for the parameters. Chainlink has two
main variations. Since you are using `VRFConsumerBase` this is VRf V1, you can
get addresses from [here](https://docs.chain.link/vrf/v1/supported-networks).
I used those for goerli:

    
    
    link address           = 0x326C977E6efc84E512bB9C30f76E30c160eD06FB
    key hash               = 0x0476f9a745b61ea5c0ab224d3a6e4c99f0b02fce4da01143a4f70aa80ae76e8a
    
    ChainlinkVRFCoordinator= 0x2bce784e69d2Ff36c71edcB9F88358dB0DfB55b4
    

After you deploy the contract, you have to send link token to the contract,
because you need to pay for the `fee` parameter that you set. [link token
faucet](https://faucets.chain.link/)

You press on `getRandomNumber` button and you need to wait a little bit upto a
minute. then your `result` value be set

here is the proof work:

[](https://i.stack.imgur.com/iiwdv.png)





:::NEXT DOC:::

function uses more than 200k gas, the transaction
will fail.

## Getting More Randomness

If you are looking for how to turn a single result into multiple random
numbers, check out our guide on [Randomness Expansion](/vrf/v1/best-practices/#getting-multiple-random-numbers).

## Network Congestion and Responsiveness

Network congestion can occur on all blockchains from time to time, which may
result in transactions taking longer to get included in a block. During times
of network congestion, the VRF service will continue responding to randomness
requests, but fulfillment response times will corresponding increase based on
the level of congestion. It is important you account for this in your use case
and set expectations accordingly.

## What's next

  * [› API Reference](/vrf/v1/api-reference)
  * [› Supported Networks](/vrf/v1/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/examples/get-a-random-number.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation

:::NEXT DOC:::

Question: (Asked on: 2022-04-06 11:31:30)
How to use chainlink VRF v1 in my smart contract?
URL: https://stackoverflow.com/questions/71765980/how-to-use-chainlink-vrf-v1-in-my-smart-contract

Question Body:


I am trying to use getRandomNumber() function from my VRFConsumer smart
contract to get random numbers. Will I get the random number immediately after
I call this or do I also have to call the fulfillRandomness() function? If
yes, how to do that?



Answers:
(Answered on: 2022-04-06 14:40:50)


After you call the `getRandomNumber()` function you will need to wait until
the `fulfillRandomness()` is called by the coordinator. You don't need to do
anything, just check the storage variable where you store the number (if you
used a storage variable) after a minute or two.





:::NEXT DOC:::

increase the chances of an attacker cheating your application. Imagine you implemented a simple coin flip smart contract using VRF v2. In a bet function, you choose heads or tails and then request a random number. If you have selected heads (0) and the result of the VRF service meant that you would win the bet, it could try to withhold this answer and replace it with your second request if it’s more advantageous.

So you see, we must consider the unique properties of blockchains here to ensure randomness in our smart contracts. While the numbers are always random, we must also look into how our applications and smart contracts deal with them. In the end, it will be a matter of cost if it's worth attacking your application. You must also be aware of the protocol that you are using.

In general, re-organizations on chains are possible. A miner would take your request and try to create a new random number with a different block and do this until they find a block to their advantage. They cannot control the VRF output but can ""re-roll"" the dice. If they manage to produce a valid blockchain with this new block and the network accepts this block instead, they could effectively attack your application by controlling the random input.
While this is a possible attack, it's costly to attack a network like this, as in the proof of network. You need at least 51% of the network to drive such an attack. Depending on your application requirements, you consider a 20-block confirmation time highly secure. You can lower the block confirmation time depending on the value you are trying to protect. You must calculate an attacker's costs and potential reward to decide your confirmation time.
"
How can I make my Chainlink node wait longer for a response from an external adapter?,You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by referring to the documentation for Chainlink nodes configuration at https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout.,{'source': 'https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response'},You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration.,"Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

Question: (Asked on: 2022-05-27 03:56:23)
Chainlink node can&#39;t make requests to Chainlink external adapter (on localhost)
URL: https://stackoverflow.com/questions/72400311/chainlink-node-cant-make-requests-to-chainlink-external-adapter-on-localhost

Question Body:


I have a chainlink Node which is running on port 6688. I'm running it with
docker, with the following command:

    
    
    cd ~/.chainlink-rinkeby && docker run -p 6688:6688  \
    -v ~/.chainlink-rinkeby:/chainlink  \
    -it --env-file=.env \
     smartcontract/chainlink:1.4.0-root local n -p /chainlink/.password -a /chainlink/.api
    

And I have an external adapter running on port 8080.

If I request it `{ ""id"": 0, ""data"":{ ""columns"": [""blood"",""heath""],
""linesAmount"":500 } }` it returns me a correct payload, in the format that is
expected from the external adapter:

    
    
    {
        ""jobRunID"": 0,
        ""data"": {
            ""ipfsHash"": ""anIpfshashShouldBeHere"",
            ""providers"": [
                ""0x03996eF07f84fEEe9f1dc18B255A8c01A4986701""
            ],
            ""result"":

:::NEXT DOC:::

Question: (Asked on: 2021-11-24 17:00:49)
Chainlink node external adapter job not returning value
URL: https://stackoverflow.com/questions/70100103/chainlink-node-external-adapter-job-not-returning-value

Question Body:


I am following the ""Chainlink Hackathon | Building and using External
Adapters"" video tutorial (Oct 2021) and have done the following:

-Successfully set up and ran my own Chainlink node (per ""Chainlink Hackathon | Running a Chainlink node, 1.0.0 update"" video tutorial [Oct 2021].

-Created `Oracle.sol` contract and `setFulfillmentPermission` to `true`

-Successfully created Job Run on my node for the `Get > Uint256` example

-Added Eth to my node.

Added the following bridge to my node:

    
    
    URL http://localhost:8080
    Confirmations   0
    Minimum Contract Payment    0
    Outgoing Token  OKKkCQpl84Kiw38WNZ77fg1UKLgyB5+c
    

Added the Job definition:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""soccer-data-ea-2""
    contractAddress = ""0x4664A91f79999fd9DD4587dDf3daA3D01Ec50825""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4

:::NEXT DOC:::

be included in
the external adapter's response back to the Chainlink node.

An example of what the error response payload should look like:


    {
      ""error"": ""The endpoint is under maintenance.""
    }

### Asynchronous callbacks

Some job types support external callbacks. When supported, Chainlink will
provide a non-null `responseURL` alongside the request payload.

If the external adapter wants to return data immediately it can simply respond
with data directly as normal.

If the external adapter wants to use the response URL to send data later, it
may initially return a response like this:


    {
      ""pending"": true
    }

In this case, the job run on Chainlink side will be put into a `pending`
state, awaiting data which can be delivered at a later date.

When the external adapter is ready, it should callback to the node to resume
the JobRun using an HTTP PATCH request to the `responseURL` field. This will
resume the job on the Chainlink side.


    {
      ""data"": {
        ""symbol"": ""ETH-USD"",
        ""last"": {
          ""price"": 467.85,
          ""size"": 0.01816561,
          ""timestamp"": 1528926483463
        }
      }
    }

Or, for the error case:


    {
      ""error"": ""something went wrong""
    }

### Example

Here is a complete example of a simple external adapter written as a
serverless function. This external adapter takes two input fields, inserts the
API key as a header, and returns the resulting payload to the node.


 

:::NEXT DOC:::

   

The problem is, in the chainlink node, specifically in the `fetch` method it
gives me an error: `error making http request: Post ""http://localhost:8080"":
dial tcp 127.0.0.1:8080: connect: connection refused`

Is it related to the docker container? I don't see why it wouldn't be able to
request resuources from another port in the same machine. Am I missing some
configuration maybe? From what I've read from the docs it's possible to run
the adapter locally. Below, a picture with more information:

[](https://i.stack.imgur.com/MnUK7.png)



Answers:
(Answered on: 2022-05-27 07:43:44)


If you're External Adapter (EA) is running on `http://localhost:8080` and
you're trying to reach that EA from a Chainlink node running inside Docker,
then you can't use `localhost`, you need to get out of the Docker container
and onto the host running the Docker engine (your Windows or Mac machine).

To do, so define your bridge to use `http://host.docker.internal:8080`.

Further details can be found in the [Docker
Docs](https://docs.docker.com/desktop/windows/networking/).





:::NEXT DOC:::

   

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node is running or not, check out the oracle address in a
block explorer. [You can see
here](https://kovan.etherscan.io/address/0x56dd6586db0d08c6ce7b2f2805af28616e082455)
that the original node you tried to use hasn't posted a transaction in quite a
long time.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.





:::NEXT DOC:::

Have
been reviewing the tutorial and building it from scratch several times but the
bridge external adapter on my node never runs the job.

Not sure why it's not working?



Answers:
(Answered on: 2021-12-27 02:36:55)


I've found the solution: in your consumer contract: set fee = 1 * 10 ** 18;
not 0.1 or in your .env file:
MINIMUM_CONTRACT_PAYMENT_LINK_JUELS=100000000000000000 set fee = 1


---
(Answered on: 2021-12-27 02:26:00)


Modify the fee to 1 * 10**18 in your consumer contract, or add a line to your
`.env` file and reboot your CL node:

    
    
    MINIMUM_CONTRACT_PAYMENT_LINK_JUELS=100000000000000000
    

which means, change the minimum link payment to 0.1LINK globally.





:::NEXT DOC:::

# Bridges: Adding External Adapters to Nodes

  * Overview
  * Testing External Adapters and Bridges

You can add external adapters to a Chainlink node by creating a bridge in the
Node Operators Interface. Each bridge must have a unique name and a URL for
the external adapter. If a job has a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task), the node searches for a bridge by name and uses
that bridge as your external adapter. Bridge names are case insensitive.

To create a bridge on the node, go to the **Create Bridge** tab in the Node
Operators Interface. Specify a name for the bridge, the URL for your external
adapter, and optionally specify the minimum contract payment and number of
confirmations for the bridge. Minimum contract payment is a fee paid in LINK
for the Chainlink node making a call to the external adapter via the bridge.
This fee is in addition to the fee specified at the global node level for
processing job requests.



The bridge name must be unique to the local node. The bridge URL is the URL of
your external adapter, which can be local or on a separate machine.

To add jobs that use the bridge, add a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task) to your job. The `bridge` task defined in the
example below is defined as `fetch` and the name of the bridge is `soccer-
data`.


    type = ""directrequest""
    schemaVersion = 1
    name = ""Soccer-Data-EA""
    contractAddress = ""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                

:::NEXT DOC:::

the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

   

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node may be inactive or not, check out the oracle address
in a block explorer. [You can see
here](https://kovan.etherscan.io/address/0x9C0383DE842A3A0f403b0021F6F85756524d5599)
that the original node you tried to use hasn't posted a transaction in awhile.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.



"
How can I make my Chainlink node wait longer for a response from an external adapter?,You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by referring to the documentation for Chainlink nodes configuration at https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout.,{'source': 'https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response'},You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration.,"Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

Question: (Asked on: 2022-05-27 03:56:23)
Chainlink node can&#39;t make requests to Chainlink external adapter (on localhost)
URL: https://stackoverflow.com/questions/72400311/chainlink-node-cant-make-requests-to-chainlink-external-adapter-on-localhost

Question Body:


I have a chainlink Node which is running on port 6688. I'm running it with
docker, with the following command:

    
    
    cd ~/.chainlink-rinkeby && docker run -p 6688:6688  \
    -v ~/.chainlink-rinkeby:/chainlink  \
    -it --env-file=.env \
     smartcontract/chainlink:1.4.0-root local n -p /chainlink/.password -a /chainlink/.api
    

And I have an external adapter running on port 8080.

If I request it `{ ""id"": 0, ""data"":{ ""columns"": [""blood"",""heath""],
""linesAmount"":500 } }` it returns me a correct payload, in the format that is
expected from the external adapter:

    
    
    {
        ""jobRunID"": 0,
        ""data"": {
            ""ipfsHash"": ""anIpfshashShouldBeHere"",
            ""providers"": [
                ""0x03996eF07f84fEEe9f1dc18B255A8c01A4986701""
            ],
            ""result"":

:::NEXT DOC:::

Question: (Asked on: 2021-11-24 17:00:49)
Chainlink node external adapter job not returning value
URL: https://stackoverflow.com/questions/70100103/chainlink-node-external-adapter-job-not-returning-value

Question Body:


I am following the ""Chainlink Hackathon | Building and using External
Adapters"" video tutorial (Oct 2021) and have done the following:

-Successfully set up and ran my own Chainlink node (per ""Chainlink Hackathon | Running a Chainlink node, 1.0.0 update"" video tutorial [Oct 2021].

-Created `Oracle.sol` contract and `setFulfillmentPermission` to `true`

-Successfully created Job Run on my node for the `Get > Uint256` example

-Added Eth to my node.

Added the following bridge to my node:

    
    
    URL http://localhost:8080
    Confirmations   0
    Minimum Contract Payment    0
    Outgoing Token  OKKkCQpl84Kiw38WNZ77fg1UKLgyB5+c
    

Added the Job definition:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""soccer-data-ea-2""
    contractAddress = ""0x4664A91f79999fd9DD4587dDf3daA3D01Ec50825""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4

:::NEXT DOC:::

be included in
the external adapter's response back to the Chainlink node.

An example of what the error response payload should look like:


    {
      ""error"": ""The endpoint is under maintenance.""
    }

### Asynchronous callbacks

Some job types support external callbacks. When supported, Chainlink will
provide a non-null `responseURL` alongside the request payload.

If the external adapter wants to return data immediately it can simply respond
with data directly as normal.

If the external adapter wants to use the response URL to send data later, it
may initially return a response like this:


    {
      ""pending"": true
    }

In this case, the job run on Chainlink side will be put into a `pending`
state, awaiting data which can be delivered at a later date.

When the external adapter is ready, it should callback to the node to resume
the JobRun using an HTTP PATCH request to the `responseURL` field. This will
resume the job on the Chainlink side.


    {
      ""data"": {
        ""symbol"": ""ETH-USD"",
        ""last"": {
          ""price"": 467.85,
          ""size"": 0.01816561,
          ""timestamp"": 1528926483463
        }
      }
    }

Or, for the error case:


    {
      ""error"": ""something went wrong""
    }

### Example

Here is a complete example of a simple external adapter written as a
serverless function. This external adapter takes two input fields, inserts the
API key as a header, and returns the resulting payload to the node.


 

:::NEXT DOC:::

   

The problem is, in the chainlink node, specifically in the `fetch` method it
gives me an error: `error making http request: Post ""http://localhost:8080"":
dial tcp 127.0.0.1:8080: connect: connection refused`

Is it related to the docker container? I don't see why it wouldn't be able to
request resuources from another port in the same machine. Am I missing some
configuration maybe? From what I've read from the docs it's possible to run
the adapter locally. Below, a picture with more information:

[](https://i.stack.imgur.com/MnUK7.png)



Answers:
(Answered on: 2022-05-27 07:43:44)


If you're External Adapter (EA) is running on `http://localhost:8080` and
you're trying to reach that EA from a Chainlink node running inside Docker,
then you can't use `localhost`, you need to get out of the Docker container
and onto the host running the Docker engine (your Windows or Mac machine).

To do, so define your bridge to use `http://host.docker.internal:8080`.

Further details can be found in the [Docker
Docs](https://docs.docker.com/desktop/windows/networking/).





:::NEXT DOC:::

   

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node is running or not, check out the oracle address in a
block explorer. [You can see
here](https://kovan.etherscan.io/address/0x56dd6586db0d08c6ce7b2f2805af28616e082455)
that the original node you tried to use hasn't posted a transaction in quite a
long time.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.





:::NEXT DOC:::

Have
been reviewing the tutorial and building it from scratch several times but the
bridge external adapter on my node never runs the job.

Not sure why it's not working?



Answers:
(Answered on: 2021-12-27 02:36:55)


I've found the solution: in your consumer contract: set fee = 1 * 10 ** 18;
not 0.1 or in your .env file:
MINIMUM_CONTRACT_PAYMENT_LINK_JUELS=100000000000000000 set fee = 1


---
(Answered on: 2021-12-27 02:26:00)


Modify the fee to 1 * 10**18 in your consumer contract, or add a line to your
`.env` file and reboot your CL node:

    
    
    MINIMUM_CONTRACT_PAYMENT_LINK_JUELS=100000000000000000
    

which means, change the minimum link payment to 0.1LINK globally.





:::NEXT DOC:::

# Bridges: Adding External Adapters to Nodes

  * Overview
  * Testing External Adapters and Bridges

You can add external adapters to a Chainlink node by creating a bridge in the
Node Operators Interface. Each bridge must have a unique name and a URL for
the external adapter. If a job has a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task), the node searches for a bridge by name and uses
that bridge as your external adapter. Bridge names are case insensitive.

To create a bridge on the node, go to the **Create Bridge** tab in the Node
Operators Interface. Specify a name for the bridge, the URL for your external
adapter, and optionally specify the minimum contract payment and number of
confirmations for the bridge. Minimum contract payment is a fee paid in LINK
for the Chainlink node making a call to the external adapter via the bridge.
This fee is in addition to the fee specified at the global node level for
processing job requests.



The bridge name must be unique to the local node. The bridge URL is the URL of
your external adapter, which can be local or on a separate machine.

To add jobs that use the bridge, add a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task) to your job. The `bridge` task defined in the
example below is defined as `fetch` and the name of the bridge is `soccer-
data`.


    type = ""directrequest""
    schemaVersion = 1
    name = ""Soccer-Data-EA""
    contractAddress = ""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                

:::NEXT DOC:::

the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

   

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node may be inactive or not, check out the oracle address
in a block explorer. [You can see
here](https://kovan.etherscan.io/address/0x9C0383DE842A3A0f403b0021F6F85756524d5599)
that the original node you tried to use hasn't posted a transaction in awhile.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.



"
Why am I unable to create external initiators from the Chainlink CLI?,"To create external initiators from the Chainlink CLI, you need to ensure that the `FEATURE_EXTERNAL_INITIATORS` environment variable is set to true in your .env file. Once this variable is set, you will have access to the `initiators` command in the Chainlink CLI and can proceed with the instructions.",{'source': 'https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli'},"You are unable to create external initiators from the Chainlink CLI because the `initiators` command is not available in the CLI options. This is likely because the `FEATURE_EXTERNAL_INITIATORS` environment variable is not set to true in your .env file, which enables access to the `initiators` command.","Question: (Asked on: 2021-09-22 09:33:38)
Can&#39;t create external initiators from chainlink CLI
URL: https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli

Question Body:


We're trying to set external initiators to our chainlink containers deployed
in GKE cluster according to the docs: <https://docs.chain.link/docs/external-
initiators-in-nodes/>

I log into the the pod:

`kubectl exec -it -n chainlink chainlink-75dd5b6bdf-b4kwr -- /bin/bash`

And there I attempt to create external initiators:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink initiators create xxx xxx
    No help topic for 'initiators'
    

I don’t even see initiators in chainlink cli options:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink
    NAME:
       chainlink - CLI for Chainlink
    
    USAGE:
       chainlink [global options] command [command options] [arguments...]
    
    VERSION:
       0.9.10@7cd042c1a94c57219ed826a6eab46752d63fa67a
    
    COMMANDS:
       admin           Commands for remotely taking admin related actions
       attempts, txas  Commands for managing Ethereum Transaction Attempts
       bridges

:::NEXT DOC:::

      jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json, -j     json output as opposed to table
       --help, -h     show help
       --version, -v  print the version
    

Chainlink version 0.9.10.

Could you please clarify what am I doing wrong?



Answers:
(Answered on: 2021-09-28 21:51:21)


You need to make sure you have the `FEATURE_EXTERNAL_INITIATORS` environment
variable set to true in your .env file as such:

`FEATURE_EXTERNAL_INITIATORS=true`

This will open up access to the `initiators` command in the Chainlink CLI and
you can resume the instructions from there.





:::NEXT DOC:::

   root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink
    NAME:
       chainlink - CLI for Chainlink
    
    USAGE:
       chainlink [global options] command [command options] [arguments...]
    
    VERSION:
       0.9.10@7cd042c1a94c57219ed826a6eab46752d63fa67a
    
    COMMANDS:
       admin           Commands for remotely taking admin related actions
       attempts, txas  Commands for managing Ethereum Transaction Attempts
       bridges         Commands for Bridges communicating with External Adapters
       config          Commands for the node's configuration
       job_specs       Commands for managing Job Specs (jobs V1)
       jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json,

:::NEXT DOC:::

# Adding External Initiators to Nodes

  * Overview
  * Creating an external initiator
  * Deleting an external initiator
  * Listing external initiators

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

## Creating an external initiator

To create an external initiator you must use the remote API. You can do this
yourself, like so:


    POST http://<your chainlink node>/v2/external_initiators -d <PAYLOAD>

where payload is a JSON blob that contains:


    {
      ""name"": <MANDATORY UNIQUE NAME>,
      ""url"": <OPTIONAL EXTERNAL INITIATOR URL>
    }

If a URL is provided, Chainlink will notify this URL of added and deleted jobs
that can be triggered by this external initiator. This allows the external
initiator to program in certain actions e.g. subscribing/unsubscribing to logs
based on the job, etc.

On creation:


    POST <URL> -d {""jobId"": <job external UUID>, ""type"": <name of external initiator>, ""params"": <optional arbitrary JSON specified at job creation time>}

On deletion:


    DELETE <URL>/<job external UUID>

You can use the chainlink client for convenience to access this API.

Enter the [Chainlink nodes CLI](/chainlink-nodes/resources/miscellaneous/#execute-commands-running-docker) and run the
following command


    chainlink initiators create <NAME> <URL>

`NAME`: The name you want to use

:::NEXT DOC:::

external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators to
nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes).

## What's next

  * [› Building External Initiators](/chainlink-nodes/external-initiators/building-external-initiators)
  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Introduction

  * Overview

External initiators allow jobs in a node to be initiated depending on some
external condition. The ability to create and add external initiators to
Chainlink nodes enables blockchain agnostic cross-chain compatibility.

note

At this time of writing, external initiators do not show up in the bridges
tab. However, they act exactly the same as if they did.

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

Initiator Bridges handle the authentication to and from the External Initiator
and where to send the messages. When creating a Bridge two parameters are
required:

Only the [webhook](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) job
type can be initiated using an External Initiator.

The external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators

:::NEXT DOC:::

EI and then checking to see if a sample job kicks off is the best way to
test this.

To try a real-life example, feel free to follow along with the [Conflux EI
demo](https://www.youtube.com/watch?v=J8oJEp4qz5w).

Additional external initiator reference

note

The External Initiator can only initiate [webhook jobs](/chainlink-nodes/oracle-jobs/job-types/webhook) that have been linked to it. Trying to
initiate a job that is not linked will give an unauthorised error.

## Deleting an external initiator

To delete an external initiator you must use the remote API. You can do this
yourself, like so:


    DELETE http://<your chainlink node>/v2/external_initiators/<external initiator name>

You can alternatively use the chainlink client for convenience:


    chainlink initiators destroy <NAME>

## Listing external initiators

To see your installed external initiators:


    GET http://<your chainlink node>/v2/external_initiators?size=100&page=1

Or, using the chainlink client:


    chainlink initiators list

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-in-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2021-11-09 21:05:52)
chainlink external-initiator unsupported metadata version 13
URL: https://stackoverflow.com/questions/69905090/chainlink-external-initiator-unsupported-metadata-version-13

Question Body:


i'm trying to connect the external-initiator with my chainlink node, but here
is the error I get when I try to add a new job in the Chainlink node. This is
the logs of my external-initiator:

    
    
    2021-11-09T15:09:14Z [ERROR] Failed testing subscriber: unsupported metadata version 13 client/web.go:192                stacktrace=github.com/smartcontractkit/external-initiator/client.(HttpService).CreateSubscription
        /external-initiator/client/web.go:192
    github.com/gin-gonic/gin.(Context).Next
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/context.go:152
    github.com/smartcontractkit/external-initiator/client.authenticate.func1
        /external-initiator/client/web.go:120
    github.com/gin-gonic/gin.(Context).Next
        /go/pkg/mod/github.com/gin-gonic/gin@v1.6.0/context.go:152
    github.com/Depado/ginprom.(Prometheus).Instrument.func1
        /go/pkg/mod/github.com/!depado/ginprom@v1.2.1-0.20200115153638-53bbba851bd8/prom.go:215
   

:::NEXT DOC:::

repo for
reference. You can see some examples of existing initiators in the
[blockchain](https://github.com/smartcontractkit/external-initiator/tree/master/blockchain) folder.

External initiators are simple web initiators that can be activated by any job
instead of just one. To set one up, you need to have a service similar to an
external adapter that sends an `HTTPPost` message runs API call to your
chainlink node service. Here is a sample URL for a web job could look like:


    curl -b cookiefile -X POST -H ""Content-Type: application/json"" --data '{""myKey"":""myVal""}' http://localhost:6688/v2/jobs/%s/runs

Where `%s` is the jobId.

External initiators make the same API call, with 2 added headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

These are keys generated when you register your external initiator with your
node.

Triggering a run through an external initiator is as simple as making this API
call to your node. All jobs with this EI configured will then be kicked off in
this way. A simple external initiator in psedo code could look like this:


    while(True):
        send_api_call_with_external_initiator_access_key_headers()
        sleep(4)

And have this job run on the same machine as your node.

## What's next

  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/building-external-initiators.mdx)
  * [ Join

:::NEXT DOC:::

allows the external
initiator to program in certain actions e.g. subscribing/unsubscribing to logs
based on the job, etc.

On creation:


    POST <URL> -d {""jobId"": <job external UUID>, ""type"": <name of external initiator>, ""params"": <optional arbitrary JSON specified at job creation time>}

On deletion:


    DELETE <URL>/<job external UUID>

You can use the chainlink client for convenience to access this API.

Enter the [Chainlink nodes CLI](/chainlink-nodes/resources/miscellaneous/#execute-commands-running-docker) and run the
following command


    chainlink initiators create <NAME> <URL>

`NAME`: The name you want to use for your external initiator. `URL`: The URL
of your jobs endpoint. ie: `http://172.17.0.1:8080/jobs`

This will give you the environment variables you need to run your external
initiator. Copy the output. It will look something like this:


    ║ ei_name  ║ http://localhost:8080/jobs ║ a4846e85727e46b48889c6e28b555696 ║ dnNfNhiiCTm1o6l+hGJVfCtRSSuDfZbj1VO4BkZG3E+b96lminE7yQHj2KALMAIk ║ iWt64+Q9benOf5JuGwJtQnbByN9rtHwSlElOVpHVTvGTP5Zb2Guwzy6w3wflwyYt ║ 56m38YkeCymYU0kr4Yg6x3e98CyAu+37y2+kMO2AL9lRMjA3hRA1ejFdG9UfFCAE

Be sure to save these values, since the"
How can I transfer NFTs using Chainlink's Automation/Keeper (checkUpkeep & performUpKeep)?,"The issue with the `upkeepNeeded` returning false is because the auction end time is set to 0. To transfer NFTs using Chainlink's Automation/Keeper, you need to ensure that the `endTime` is properly set for each auction. Make sure that the `endTime` is a valid timestamp and is greater than the current block timestamp. Additionally, check that the `listed` flag is properly set to `true` when the NFT is listed for auction. Double-check your code to ensure that these conditions are met for the automation to work correctly.",{'source': 'https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu'},"To transfer NFTs using Chainlink's Automation/Keeper (checkUpkeep & performUpKeep), you need to set up the checkUpkeep and performUpkeep functions in your contract. The checkUpkeep function should check if any auctions have ended and return true if upkeep is needed, along with the auction ID as performData. The performUpkeep function should then transfer the NFT to the highest bidder, send the highest bid to the previous owner, and send a small platform cut to the contract owner. You can then register an upkeep on Chainlink's Automation platform using your contract's address and the correct checkData input. Make sure your contract is verified on the block explorer and that the checkData input matches your checkUpkeep function.","Question: (Asked on: 2022-10-29 07:11:58)
How to Transfer NFTs using Chainlink&#39;s Automation/Keeper (checkUpkeep &amp; performUpKeep)
URL: https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu

Question Body:


I'm working on an NFT Auction contract. I'm trying to achieve 1. NFT transfer
to the highest bidder. 2. highest bidder's bid value to the prev NFT owner or
Auction creator. 3. A small platform cut sent to the contract's owner.

All this is working smoothly when I'm doing things manually. But when I'm
trying to achieve this using chainlink automation, It fails.

From my understanding, It is failing because of the `allowance` issue. My Qs
is, is it even possible to achieve this using chainlink automation? if yes,
then how?

When the NFT owner, lists his NFT for Auction, he is giving NFT transfer
allowance to the contract address.

    
    
        function checkUpkeep(bytes calldata /* checkData */) external view override returns(bool upkeepNeeded, bytes memory performData) {
            for(uint i=0; i < auctionIDs.length; i++){
                if(auctions[auctionIDs[i]].endTime != 0 && block.timestamp > auctions[auctionIDs[i]].endTime){
                    upkeepNeeded = true;
                   

:::NEXT DOC:::

Question: (Asked on: 2022-10-28 10:04:53)
Chainlink Automation upKeep not working. checkUpKeep is not calling performUpKeep
URL: https://stackoverflow.com/questions/74233765/chainlink-automation-upkeep-not-working-checkupkeep-is-not-calling-performupkee

Question Body:


Our Dapp will have an NFT Auction functionality, which we are trying to
automate 100% using chainlink. The auction winner will get the NFT and the
Previous owner will get the highest Bid, Platform will get a small cut as
well. To do that, we are using CHainlink Keeper/Automation. I've set the
`checkUpKeep` & `performUpKeep`, both are working fine when I'm doing
everything manually. But when I am registering an upKeep for automaton.

When I input the deployed contract's address into the register upkeep box, it
says `Unable to verify if this is an Automation compatible contract`. Why this
warning? How do I make the contract Automation compatible contract?
[](https://i.stack.imgur.com/nykbp.jpg)

`checkUpKeep` is working good: [](https://i.stack.imgur.com/HFmZ5.jpg)

If I pass this `performData` into `performUpKeep` everything will work fine.

Code/Contracts:
<https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8>

Chainlink upKeep:
<https://automation.chain.link/mumbai/21891159634677518530356555981285976030474691922841692133624884405593696766700>

Pls help, Thanks.



Answers:
(Answered

:::NEXT DOC:::

his NFT for Auction, he is giving NFT transfer
allowance to the contract address.

    
    
        function checkUpkeep(bytes calldata /* checkData */) external view override returns(bool upkeepNeeded, bytes memory performData) {
            for(uint i=0; i < auctionIDs.length; i++){
                if(auctions[auctionIDs[i]].endTime != 0 && block.timestamp > auctions[auctionIDs[i]].endTime){
                    upkeepNeeded = true;
                    performData = abi.encodePacked(uint256(auctionIDs[i]));
                }
            }
            return (upkeepNeeded, performData);
        }
    
        function performUpkeep(bytes calldata performData) external override nonReentrant {
            uint256 auction_id = abi.decode(performData, (uint256));
    
            if(auctions[auction_id].endTime != 0 && block.timestamp > auctions[auction_id].endTime){
    
                auctions[auction_id].listed = false;
    
               

:::NEXT DOC:::

 }
            return (upkeepNeeded, performData);
        }
    
        function performUpkeep(bytes calldata performData) external override nonReentrant {
            uint256 auction_id = abi.decode(performData, (uint256));
    
            if(auctions[auction_id].endTime != 0 && block.timestamp > auctions[auction_id].endTime){
    
                auctions[auction_id].listed = false;
    
                safeTransferFrom(podcastId[auctions[auction_id].podcastId].nftOwner, bidders[auction_id].highestBidder, podcastId[auctions[auction_id].podcastId].tokenId);
    
                uint256 platformCut = (platformFee * bidders[auction_id].highestBid)/100;
                uint256 NftOwnerCut = bidders[auction_id].highestBid - platformCut;
    
                (bool pass, ) = platformFeeRecipient.call{value: platformCut}("""");
                require(pass, ""platformFee Transfer failed"");
                (bool success, ) = (podcastId[auctions[auction_id].podcastId].nftOwner).call{value: NftOwnerCut}("""");
       

:::NEXT DOC:::

    podcastId[auctions[auction_id].podcastId].nftOwner = bidders[auction_id].highestBidder;
                emit AuctionResulted(auction_id, bidders[auction_id].highestBidder, bidders[auction_id].highestBid);
                bidders[auction_id].highestBid = 0;
                auctions[auction_id].endTime = 0;
                
            }
    
        }
    

Full Code/Contracts:
<https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8>

Chainlink upKeep:
<https://automation.chain.link/mumbai/21891159634677518530356555981285976030474691922841692133624884405593696766700>

Pls help, Thanks.



Answers:
(Answered on: 2022-10-31 15:26:20)


I believe the issue is that your `upkeepNeeded` is returning false due to the
auction end time being 0

    
    
     if(auctions[auctionIDs[i]].endTime != 0
    

[](https://i.stack.imgur.com/hdqIM.png)





:::NEXT DOC:::

and click on your recently registered Upkeep under My Upkeeps.

  2. **Click the`Add funds` button**

  3. **Approve the LINK spend allowance**

  4. **Confirm the LINK transfer** by sending funds to the Chainlink Automation Network Registry 

  5. **Receive a success message** and verify that the funds were added to the Upkeep 

## Maintain a Minimum Balance

Each Upkeep has a [minimum balance](/chainlink-automation/automation-economics/#minimum-balance) to ensure that an Upkeeps will still run should a
sudden spike occur. If your Upkeep LINK balance drops below this amount, the
Upkeep will not be performed.

To account for Upkeep execution over time and possible extended gas spikes,
maintain an Upkeep LINK balance that is 3 to 5 times the minimum balance. Note
if you have an upkeep that performs frequently you may want to increase the
buffer to ensure a reasonable interval before you need to fund again.
Developers also have the ability to update `performGasLimit` for an upkeep.

## Withdraw funds

To withdraw funds, the Upkeep administrator have to cancel the Upkeep first.
There is a 50 block delay once an Upkeep has been cancelled before funds can
be withdrawn. Once 50 blocks have passed, select **Withdraw funds**.

## Interacting directly with the Chainlink Automation Registry

After registration, you can interact directly with the [registry
contract](/chainlink-automation/supported-networks/#configurations) functions
such as `cancelUpkeep` and `addFunds` using your **Upkeep ID**. The Registry
Address might change when new contracts are deployed with new functionality.

## What's next

  * [› Automation economics](/chainlink-automation/automation-economics/)

  * [ Edit this page

:::NEXT DOC:::

others that read this post, I will break it down into
detailed steps - perhaps more than you needed for an answer!

**Prerequisites**

  1. [Get some LINK tokens](https://faucets.chain.link/goerli) in your browser wallet
  2. Deploy a Chainlink Keepers-compatible contract -- this is your Upkeep contract; the one that will be automated. [Here is the example Upkeep smart contract](https://docs.chain.link/docs/chainlink-keepers/compatible-contracts/#example-contract) that you can copy and deploy right away. You can use `10` as the `interval` \-- that's 10 seconds. This way you can see the upkeep happen fast. **Note this Upkeep's address**
  3. Next, deploy the `UpkeepIDConsumerExample` from the [example in the docs](https://docs.chain.link/docs/chainlink-keepers/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract), which is the smart contract that programmatically registers your Upkeep Contract. This contract handles registering the Upkeep Contract you deployed in Step #2 with Chainlink's Keepers network, so that the Keepers Network can automate the running of functions in your Upkeep contract. **Note this Contracts Address**

**Making it work**

  1. From your wallet, which should now have LINK in it, send 5 LINK to the deployed `UpkeepIDConsumerExample` address. This is funding it will need to send onwards to your Upkeep (Upkeeps need funding so they can pay the Keepers Network for the compute work they do in performing the automations).

  2. Using Remix, connect to the right network and then connect to your deployed `UpkeepIDConsumerExample` contract by using its address.

  3. When Remix shows your contract and its interactions in the DEPLOYED CONTRACTS section of the UI, fill in the parameters for the

:::NEXT DOC:::

# Managing Upkeeps

  * Overview
  * Fund your Upkeep
  * Maintain a Minimum Balance
  * Withdraw funds
  * Interacting directly with the Chainlink Automation Registry

Manage your Upkeeps to get the best performance.

## Fund your Upkeep

You must monitor the balance of your Upkeep. If the Upkeep LINK balance drops
below the [minimum balance](/chainlink-automation/automation-economics/#minimum-balance), the Chainlink Automation Network will not perform
the Upkeep.

ERC677 Link

For funding on Mainnet, you need ERC-677 LINK. Many token bridges give you
ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be
ERC-677 compatible](https://pegswap.chain.link/). To fund on a supported
testnet, get [LINK](/resources/link-token-contracts) from
[faucets.chain.link](https://faucets.chain.link/).

Follow these steps to fund your Upkeep:

  1. **Click`View Upkeep`** or go to the [Chainlink Automation App](https://automation.chain.link) and click on your recently registered Upkeep under My Upkeeps.

  2. **Click the`Add funds` button**

  3. **Approve the LINK spend allowance**

  4. **Confirm the LINK transfer** by sending funds to the Chainlink Automation Network Registry 

  5. **Receive a success message** and verify that the funds were added to the Upkeep 

## Maintain a Minimum Balance

Each Upkeep has a [minimum balance](/chainlink-automation/automation-economics/#minimum-balance) to ensure that an Upkeeps will still run should a
sudden spike occur. If your Upkeep LINK balance drops below this amount, the
Upkeep will not be performed.

To account for Upkeep execution over time and possible extended gas

:::NEXT DOC:::

deployed contract have to call the Transfer-and-Call function on the respective ERC-677 LINK contract configured on the Registrar and ensure they pass the correct encoded function call and inputs.

## How it works

Automation Nodes follow a turn-taking algorithm to service upkeeps. A turn is
a number of blocks and you can find the block count per turn for your network
in the [configuration](/chainlink-automation/supported-networks/#configurations) section. During a turn a Upkeeps on the registry are
randomly split, ordered into buckets, and assigned to an Automation Node to
service them. Even if an Automation Node goes down, the network has built-in
redundancy and your Upkeep will be performed by the next Automation Node in
line.

During every block, the Automation Node reviews all of the upkeeps in its
bucket to determine which upkeeps are eligible. This check is done off-chain
using a geth simulation. The Automation Node checks both the `checkUpkeep` and
`performUpkeep` conditions independently using simulation. If both are true
(eligible), and the upkeep is funded, the Automation Node proceeds to execute
the transaction on-chain.

While only one Automation Node monitors an upkeep at any point during a turn,
an upkeep can have multiple on-chain transaction executions per turn. This is
accomplished with a buddy-system. After a transaction is confirmed, the next
Automation Node in the line monitors the upkeep. After a new transaction is
confirmed, the previous Automation Node steps in again to monitor the upkeep
until the end of the turn or until another transaction confirmation is
complete. This creates a system that is secure and highly available. If a node
becomes faulty and executes a transaction that is not eligible, the next node
does not execute a transaction, which breaks the process.

Chainlink Automation use the same transaction manager mechanism built and used
by Chainlink Data Feeds. This creates a

:::NEXT DOC:::

the [Automation Economics](/chainlink-automation/automation-economics) page to learn more about the cost of using
Chainlink Automation.

Testing and best practices

Follow the [best practices](/chainlink-automation/compatible-contract-best-practice) when creating a compatible contract and test your upkeep on a
testnet before deploying it to a mainnet.

  6. **Click`Register upkeep`** and confirm the transaction in MetaMask. 

Your upkeeps will be displayed in your list of **Active Upkeeps**. You must
monitor the balance of your upkeep. If the balance drops below the **minimum
balance** , the Chainlink Automation Network will not perform the Upkeep. See
[Managing Upkeeps](/chainlink-automation/manage-upkeeps) to learn how to
manage your upkeeps.

## Register an Upkeep using your own deployed contract

You can dynamically create and manage Upkeeps using your own smart contracts.
The following example displays a smart contract that can create an Upkeep and
determine the Upkeep ID. You can also program your Upkeep to check its own
balance and fund itself by interacting with the registry.

### Prerequisites

Find the following addresses for your network:

  * Correct [LINK token contract](/resources/link-token-contracts)
  * [Registry and registrar addresses for your network](/chainlink-automation/supported-networks/#configurations)

Optionally, you can fetch the LINK address and registrar address from the
intended registry at run-time.

Fund your contract

Make sure your contract has enough [ERC-677 LINK](/resources/link-token-contracts) to fund the Upkeep at creation. _The minimum amount is 0.1 LINK._

Mainnets and testnets use different versions of the Registry and Registrar
interfaces.

  * Mainnets: Use the v1.x registrar and registry interfaces."
Is there a way in blockchain to get the randomResult?,"No, there is no way to get the randomResult in one transaction. The Chainlink VRF process requires two transactions: one to request the random number and another to retrieve the random number. The `letsgo` function in your code will not work.",{'source': 'https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction'},"No, there is no way to get the randomResult in one transaction with Chainlink VRF as it is a two transaction process. The first transaction requests the random number, and the second transaction returns the random number.",">= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
        function letsGo() public {
            bytes32 requestId;
            requestId = getRandomNumber();
            fulfillRandomness(requestId, 123456);
        }
    }
    

Is there a way in blockchain to get the randomResult?

I'm looking specifically at my `letsGo` function.



Answers:
(Answered on: 2021-10-07 12:29:29)


The chainlink VRF is a 2 transaction process.

The first transaction requests the random number, and the second to have the
random number returned. You can't get the random number in 1 go.

You can read more about the [basic request
model](https://docs.chain.link/docs/architecture-request-model/) in the
documentation.

You're `letsgo` function will not work.





:::NEXT DOC:::

#####Chapter 2:

# Randomness and Blockchains

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Upon research, you realize popular languages like Javascript have built-in randomness functions maybe you can use something like that in Solidity? 
    </div>
  </div>
</ContentWrapp>

Blockchains are deterministic, meaning that any computations that use blockchains must have predictable outcomes. This so all of the nodes that run the blockchain can come to an agreement on what the blockchain is. But deterministic runs counter to random. If everyone knows what the next hand of poker will be before it is dealt it wouldn’t be considered random. So if randomness is impossible on a blockchain, how can we bring the awesome powers of smart contracts to any applications that need randomness?

We could get the randomness from an outside resource! But it can’t be a trusted centralized service (as discussed in Chainlink 101), or we would be ruining the decentralized properties of blockchains and smart contracts. And it would be great if it could be verified that the number wasn’t tampered with and is genuinely random. This is a perfect example of where a decentralized oracle network powered by Chainlink could be used!


:::NEXT DOC:::

           addressToId[msg.sender] = requestId;
        }
    
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            IdToRandom[requestId] = randomness;
            getResult();
        }
    
        function getResult() public view returns (uint randomnombre) {
            randomnombre = IdToRandom[addressToId[msg.sender]];
        }
    

When I call getResult() in a solidity function to determine if the address won
or not, it works fine on remix but won't work on JS.

Here is my JS call:

    
    
    contract.methods.getResult().call().then(function(bal) { console.log(bal) })
    

It sends me back 0 and I don't know how to handle it...



Answers:
(Answered on: 2022-02-24 13:48:36)


I think you are running into an issue where the `getRandomNumber()` has been
called and that transaction is complete but the callback to
`fulfillRandomness` hasn't occurred yet.

You will need to listen for the event before calling `getResult()`

One of the methods below should accomplish this

web3: <https://web3js.readthedocs.io/en/v1.2.11/web3-eth-
contract.html#contract-events>

ethers: <https://docs.ethers.io/v5/api/providers/provider/#Provider--event-
methods>





:::NEXT DOC:::

#####Chapter 3:

# Randomness and Blockchains

Blockchains heavily rely on cryptography and randomness for security. The most straightforward example is the creation of key pairs used to do transactions. When you create a new key pair, a random number is needed as the initial input. We have learned in the previous example how to obtain this number from, e.g., the physical world. This number is then used to calculate a seed which is further used to derive all further key pairs.

This works well for key creation, but how to use random numbers on-chain? While the initial number could be completely random, as soon as you add it to a transaction, everyone who observes the mempool can see it. And also, the miners/validators can see it and decide how to deal with your transaction based on the number. This also would mean that someone controls the creation of the random number. So you must trust this source. So the random number cannot be created on-chain and must be provided from the outside. Is there no other way?

You might argue that you can use the content of a block as a source of randomness. But these values can be actively manipulated by miners. They could add or remove transactions to find a result that benefits them. In addition, blocks also have particular properties that could reduce the search space to calculate probabilities that a specific number will be selected. So this is an insecure way of creating random numbers.

So if you cannot trust the miners, you could argue for using Oracles. A trusted third-party system could be used to create random numbers and then provide them to services via an oracle. But depending on the economic incentive, someone could be interested in hacking this system to provide non-random numbers as input. And while they might use a true random number generator, you don’t know for sure and

:::NEXT DOC:::

        VRFConsumerBase(
                0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, // VRF Coordinator
                0xa36085F69e2889c224210F603D836748e7dC0088  // LINK Token
            )
        {
            keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
        }
        function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
        function letsGo() public {
            bytes32 requestId;
            requestId = getRandomNumber();
            fulfillRandomness(requestId, 123456);
        }
  

:::NEXT DOC:::

VRF Coordinator, and Key Hash to be unique to rinkeby <https://docs.chain.link/docs/vrf-contracts/>
  5. Navigation to the Solidity Compiler Tab and click on Compile RandomNumber.sol.
  6. Deploy the contract on Rinkeby
  7. Copy to contract address and send LINK token to fund the contract.
  8. Click on the orange getRandomNumber btn in remix
  9. Click on randomResult and observe how long it takes for the value in randomResult to change. (Keep clicking until it finally changes)

**Additional Information**

I am not sure if this behavior is intentional or if I need to change up the
code. Ideally I would like to have the value of randomResult once the
getRandomNumber function finishes executing. Right now I don't know when the
value of randomResult will show up.



Answers:
(Answered on: 2021-06-23 23:24:42)


Chainlink VRF follows the [request and
receive](https://docs.chain.link/docs/intermediates-tutorial/#1-request--
receive) cycle of getting a number. This means, it has to look outside the
blockchain to get a response.

So, 2 transactions actually take place:

  1. Your requesting transaction
  2. The response transaction

This is necessary to look outside the blockchain like this, otherwise you'll
get a deterministic number as opposed to random. The speed at which the random
number is returned, is dictated by the block time of the blockchain you're
using.

So for Ethereum, the fastest time possible for a Random Number to be returned
is 2 * block time, or about 30ish seconds.

On faster chains like polygon, this is drastically lower.





:::NEXT DOC:::

increase the chances of an attacker cheating your application. Imagine you implemented a simple coin flip smart contract using VRF v2. In a bet function, you choose heads or tails and then request a random number. If you have selected heads (0) and the result of the VRF service meant that you would win the bet, it could try to withhold this answer and replace it with your second request if it’s more advantageous.

So you see, we must consider the unique properties of blockchains here to ensure randomness in our smart contracts. While the numbers are always random, we must also look into how our applications and smart contracts deal with them. In the end, it will be a matter of cost if it's worth attacking your application. You must also be aware of the protocol that you are using.

In general, re-organizations on chains are possible. A miner would take your request and try to create a new random number with a different block and do this until they find a block to their advantage. They cannot control the VRF output but can ""re-roll"" the dice. If they manage to produce a valid blockchain with this new block and the network accepts this block instead, they could effectively attack your application by controlling the random input.
While this is a possible attack, it's costly to attack a network like this, as in the proof of network. You need at least 51% of the network to drive such an attack. Depending on your application requirements, you consider a 20-block confirmation time highly secure. You can lower the block confirmation time depending on the value you are trying to protect. You must calculate an attacker's costs and potential reward to decide your confirmation time.


:::NEXT DOC:::

          0x326C977E6efc84E512bB9C30f76E30c160eD06FB // LINK Token
            )
        {
            keyHash = 0x0476f9a745b61ea5c0ab224d3a6e4c99f0b02fce4da01143a4f70aa80ae76e8a;
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
        }
    
        /**
         * Requests randomness
         */
        function getRandomNumber() public returns (bytes32 requestId) {
            require(
                LINK.balanceOf(address(this)) >= fee,
                ""Not enough LINK - fill contract with faucet""
            );
            return requestRandomness(keyHash, fee);
        }
    
        /**
         * Callback function used by VRF Coordinator
         */
        function fulfillRandomness(
            bytes32 requestId,
            uint256 randomness
        ) internal override {
            randomResult = randomness;
            emit

:::NEXT DOC:::

#####Chapter 1:

# Randomness

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      With your newfound power, understanding of what smart contracts are you want to develop a smart contract to raffle an NFT to your friends. But how will you get randomness into your raffle smart contract?
    </div>
  </div>
</ContentWrapp>

Randomness is essential for many types of applications. Think about how many games have randomness built-in. Rolling dice in dungeons and dragons, a random starting hand of poker, or a random next block in Tetris, randomness is an essential component of a majority of games. As we learned in Chainlink 101, smart contracts are a powerful tool for decentralized applications (dapps). But what if you want to build a game, raffle or any other type of application that utilizes randomness on the blockchain? Let's learn about randomness on the blockchain in the next lesson!


:::NEXT DOC:::

blockhash (just infeasible to compute for anyone who
doesn't know the secret key.)

### 2\. Validators can choose to not post if a number is unfavorable

Once again, you still run into this issue from pre-merge. The penalty of not
posting a block is almost negligible, so a node might be financially
incentivized not to propose blocks in a lottery-type smart contract if the
`PREVRAND` value isn't what they want. Enough nodes do this and you run into
issues.

Just taking the current `PREVRANDAO` value without looking at recent history
gives a validator some control over the output the contract will use, even if
it doesn't want to abort, because the validator can decide whether or not the
block it proposes contains a transaction which will trigger the use of
PREVRANDAO. The only cost involved there is the transaction fee/tip.

### 3\. If all applications use `PREVRANDAO` as their seed

If all applications use `PREVRANDAO` as their seed, in a way, you could
""chain"" together wins or hacks based on this.

### More information

There is also an interesting thread on this in the [Ethereum
Magicians](https://ethereum-magicians.org/t/eip-4399-supplant-difficulty-
opcode-with-random/7368/48) forum.



"
What is a gas lane in chainlink and blockchain?,"A gas lane in chainlink and blockchain is a concept used to set a limit on how much to spend on each request. It is important for setting the ceiling limit of each request, similar to an entry into a bet.",{'source': 'https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain'},A gas lane in blockchain is a concept used in Chainlink to set a limit on how much to spend on each request. It is important for setting the ceiling limit of each request and is similar to an entry into a bet.,"Question: (Asked on: 2022-03-09 20:02:05)
What is a gas lane in chainlink and blockchain?
URL: https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain

Question Body:


I do understand the concept of gas in the ethereum blockchain and why gas is
needed to compensate miners for providing computing power to the network.
However, when I was reading up on the chainlink vrf get a random number
documentation it says that the keyhash tells you the gas lane to use. It would
be really helpful if someone could further explain what a gas lane in
blockchain is.

Any help would be appreciated :)



Answers:
(Answered on: 2022-03-10 06:17:54)


So we know that Eth gas is always subject to change and with chainlink vrf
there will be random values with your request, so you need to set a limit to
how much to spend on each request. The reason chainlink uses a Gas lane is
because the lanes are important for setting the ceiling limit of each
request... think of it as your entry into the bet.





:::NEXT DOC:::

estimation error` is a common error meaning that you don't have enough of
""something"" to send your transaction, maybe it's layer 1 (ETH) gas, or an
ERC20 token like LINK (technically, erc677, but I digress...)

Whenever you work with a Chainlink feature that uses the [request and
receive](https://docs.chain.link/docs/architecture-request-model/) method of
using chainlink, you need to [fund the consumer contract with LINK
token](https://docs.chain.link/docs/make-a-http-get-request/).

The issue here is you sent LINK to the oracle address and not the address of
your deployed contract.

[](https://i.stack.imgur.com/1ga4n.png)

If you copy the address of your deployed contract and send the LINK there, it
should work for you.





:::NEXT DOC:::

authorization for crypto transactions using phone push notifications.               | Go       |
| Flyt 🥉                   | Flight insurance.                                                                              | Go       |
| Link Total Return Swap    | A Defi platform which enables Chainlink Node Operators to hedge against LINK price volatility. | Go       |
| Smart Marketing Campaigns | Use Google Analytics data to make payments to marketing agencies.                              | Go       |
| Steam Trader              | Trustless trading of digital items.                                                            | Go       |
| Contractor                | Constructor of smart contracts.                                                                | Go       |
| Fiat Gateway              | Crypto Fiat Gateway on Ethereum using Chainlink Oracles           

:::NEXT DOC:::

your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

### Ethereum

#### Ethereum Mainnet

| Item                        | Value                                      |
|:----------------------------|:-------------------------------------------|
| Registry Address            | 0x02777053d6764996e594c3E88AF1D58D5363a2e6 |
| Registrar Address           | 0xDb8e8e2ccb5C033938736aa89Fe4fa1eDfD15a1d |
| Payment Premium %           | 20                                         |
| Block Count Per Turn        | 10                                         |
| Check Gas Limit             | 6500000                                    |
| Perform Gas Limit           | 5000000                                    |
| Gas Ceiling Multiplier      | 2               

:::NEXT DOC:::

help reduce gas costs on chains that support it. This is supported only on
official Ethereum mainnet and testnets. It is not recommended to enable this
setting on Polygon because the EIP-1559 fee market appears to be broken on all
Polygon chains and EIP-1559 transactions are less likely to be included than
legacy transactions.

#### Technical details

Chainlink nodes include experimental support for submitting transactions using
type 0x2 (EIP-1559) envelope.

EIP-1559 mode is enabled by default on the Ethereum Mainnet, but can be
enabled on a per-chain basis or globally.

This might help to save gas on spikes. Chainlink nodes should react faster on
the upleg and avoid overpaying on the downleg. It might also be possible to
set `EVM.GasEstimator.BlockHistory.BatchSize` to a smaller value such as 12 or
even 6 because tip cap should be a more consistent indicator of inclusion time
than total gas price. This would make Chainlink nodes more responsive and
should reduce response time variance. Some experimentation is required to find
optimum settings.

Set with caution, if you set this on a chain that does not actually support
EIP-1559 your node will be broken.

In EIP-1559 mode, the total price for the transaction is the minimum of base
fee + tip cap and fee cap. More information can be found on the [official
EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).

Chainlink's implementation of EIP-1559 works as follows:

If you are using FixedPriceEstimator:

  * With gas bumping disabled, it will submit all transactions with `feecap=PriceMax` and `tipcap=GasTipCapDefault`
  * With gas bumping enabled, it will submit all transactions initially with `feecap=GasFeeCapDefault` and

:::NEXT DOC:::

with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! 

:::NEXT DOC:::

# Making flexible, secure, and low-cost contracts

  * Overview
  * Prerequisites
  * Problem: On-chain computation leads to high gas fees
  * Solution: Perform complex computations with no gas fees
  * Conclusion

In this guide, you will learn how the flexibility of [Chainlink
Automation](https://chain.link/automation) enables important design patterns
that reduce gas fees, enhance the resilience of dApps, and improve end-user
experience. Smart contracts themselves cannot self-trigger their functions at
arbitrary times or under arbitrary conditions. Transactions can only be
initiated by another account.

Start by integrating an example contract to Chainlink Automation that has not
yet been optimized. Then, deploy a comparison contract that shows you how to
properly use the flexibility of Chainlink Automation to perform complex
computations without paying high gas fees.

## Prerequisites

This guide assumes you have a basic understanding of [Chainlink
Automation](https://chain.link/keepers). If you are new to Keepers, complete
the following guides first:

  * Know how to [deploy solidity contracts using Remix and Metamask](/getting-started/deploy-your-first-contract)
  * Learn how to make [compatible contracts](/chainlink-automation/compatible-contracts)
  * [Register UpKeep for a Contract](/chainlink-automation/register-upkeep)

Chainlink Automation is supported on several [networks](/chainlink-automation/supported-networks).

ERC677 Link

  * Get [LINK](/resources/link-token-contracts) on the supported testnet that you want to use.
  * For funding on Mainnet, you need ERC-677 LINK. Many token bridges give you ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be ERC-677

:::NEXT DOC:::

it. This is supported only on
official Ethereum mainnet and testnets. It is not recommended to enable this
setting on Polygon because the EIP-1559 fee market appears to be broken on all
Polygon chains and EIP-1559 transactions are less likely to be included than
legacy transactions.

#### Technical details

Chainlink nodes include experimental support for submitting transactions using
type 0x2 (EIP-1559) envelope.

EIP-1559 mode is enabled by default on the Ethereum Mainnet, but can be
enabled on a per-chain basis or globally.

This might help to save gas on spikes. Chainlink nodes should react faster on
the upleg and avoid overpaying on the downleg. It might also be possible to
set `BLOCK_HISTORY_ESTIMATOR_BATCH_SIZE` to a smaller value such as 12 or even
6 because tip cap should be a more consistent indicator of inclusion time than
total gas price. This would make Chainlink nodes more responsive and should
reduce response time variance. Some experimentation is required to find
optimum settings.

To enable globally, set `EVM_EIP1559_DYNAMIC_FEES=true`. Set with caution, if
you set this on a chain that does not actually support EIP-1559 your node will
be broken.

In EIP-1559 mode, the total price for the transaction is the minimum of base
fee + tip cap and fee cap. More information can be found on the [official
EIP](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).

Chainlink's implementation of EIP-1559 works as follows:

If you are using FixedPriceEstimator:

  * With gas bumping disabled, it will submit all transactions with `feecap=ETH_MAX_GAS_PRICE_WEI` and

:::NEXT DOC:::

counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible

:::NEXT DOC:::

Question: (Asked on: 2022-05-29 15:54:32)
What is the use of Check gas limit in Chainlink Keepers?
URL: https://stackoverflow.com/questions/72425156/what-is-the-use-of-check-gas-limit-in-chainlink-keepers

Question Body:


In chainlink keepers document [here](https://docs.chain.link/docs/chainlink-
keepers/compatible-contracts/). There is a conf called `checkGasLimit` with
6,500,000 as the default value.

Since the computation in `checkUpKeep` is expected to be outsourced off-chain,
why there is a configuration called `checkGasLimit` where computation is off-
chain?

Or `checkGasLimit` is for the situation where function `checkUpKeep` is
supposed to modify some state.



Answers:
(Answered on: 2022-06-01 13:39:47)


You got it!

`checkUpkeep` can be used to change the state of the blockchain. The Chainlink
nodes will call the `checkUpkeep` function when it returns true - and if it
costs gas, it will use gas.

The use of the `checkGasLimit` then, is to make sure they don't use too much
gas. Per the docs:

`The maximum amount of gas that can be used by your checkUpkeep for off-chain
computation.`



"
What could be causing the 'File not exist Solc' error when trying to import a data feed into a contract?,One possible cause of the 'File not exist Solc' error is if the yaml file is located in the tests folder instead of the top level directory. Moving the file to the top level directory may resolve the issue.,{'source': 'https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract'},The error could be caused by the file path being outside of the allowed directories or the brownie-config.yaml file being located inside the test folder instead of being kept separately. It could also be caused by using the wrong version of the Chainlink contracts or the wrong solidity version.,"Question: (Asked on: 2022-03-15 07:39:01)
File not exist Solc error when trying to import data feed into my contract
URL: https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract

Question Body:


[](https://i.stack.imgur.com/fUE5J.png)

[](https://i.stack.imgur.com/lAkYb.png)

[](https://i.stack.imgur.com/b50Pt.png)

I have tried changing different versions of solc, solidity, and chainlink
contracts but it doesn't work.

Error:

    
    
    contracts/Lottery.sol:4:1: ParserError: Source ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    



Answers:
(Answered on: 2022-05-11 18:24:04)


Perhaps the yaml file being in the tests folder is the problem. I would move
that file to live in your top level directory.





:::NEXT DOC:::

Question: (Asked on: 2023-01-06 09:55:44)
ParserError: Source &quot;@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol&quot; not found: File outside of allowed directories
URL: https://stackoverflow.com/questions/75029401/parsererror-source-chainlink-contracts-src-v0-8-interfaces-aggregatorv3interf

Question Body:


I'm trying to compile a ""FundMe.sol"" contract: the issue is that when I try to
compile it I keep getting the following Compiler Error:

    
    
    Brownie v1.19.2 - Python development framework for Ethereum
    
    New compatible solc version available: 0.8.0
    Compiling contracts...
      Solc version: 0.8.0
      Optimizer: Enabled  Runs: 200
      EVM Version: Istanbul
    CompilerError: solc returned the following errors:
    
    ParserError: Source ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
      --> contracts/FundMe.sol:15:1:
       |
    15 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    

The contract is included inside of the ""contracts"" folder (initted by
brownie), moreover I have created the ""brownie-config.yaml"" file which should
remap

:::NEXT DOC:::

solc returned the following errors:
    
    ParserError: Source ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
      --> contracts/FundMe.sol:15:1:
       |
    15 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    

The contract is included inside of the ""contracts"" folder (initted by
brownie), moreover I have created the ""brownie-config.yaml"" file which should
remap @chainlink - I feel as it might have contain some kind of error aswell.

I'm including all the mentioned files down below:

**Project Folder** : [brownie_fund_me](https://i.stack.imgur.com/HEeeo.png)

**FundMe.sol** :

    
    
    //SPDX-License-Identifier: MIT
    //Last update: 25/12/2022
    
    /* ***** ABI = Application Binary Interface *****
     * Interfaces compile down to an ABI. 
     *
     * ABI tells Solidity and other coding languages
     * how it can interact with other contracts. 
     *
     * Anytime you want to interact with another
     * deployed contract, you will need that contracts' ABI.
     */
    
    pragma solidity >=0.6.0 <0.9.0;
    
    // *****

:::NEXT DOC:::

  address funder = funders[funderIndex];
                addressToAmountFunded[funder] = 0;
            }
            funders = new address[](0);
        }
    }
    

Errror: not found ""@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol""

I use same code FundMe.sol via Patrick Collins github lesson3 [here is the
error](https://i.stack.imgur.com/PNors.png)



Answers:
(Answered on: 2022-07-02 22:32:29)


Simple Suggestion: create a new contract file undername ""SafeMathChainlink.sol
and given code below in contract folder, and put a code import
""./SafeMathChainlink.sol"" in FundMe.sol instead of giving chainlink;


---
(Answered on: 2022-03-28 13:03:36)


pragma solidity >=0.6.0 <0.9.0;

import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
import ""@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol"";

COMPILER👇

0.6.6+commit.6c089d02


---
(Answered on: 2022-02-10 11:40:14)


If you came here following the "" **Solidity, Blockchain, and Smart Contract
Course – Beginner to Expert Python Tutorial** "" course by **Patrick Collins**
; here's what you need to change to make this work:

If you get this error:

    
    
    ParserError: Source file

:::NEXT DOC:::

not found: File not found.
     --> contracts/Lottery.sol:4:1:
      |
    4 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    

I tried changing compiler: solc: remappings: \-
'@chainlink=smartcontractkit/chainlink-brownie-contracts@1.1.1' to @0.2.1 I
also tried changing solidity version to a newer version and it's not working
Thanks in advance!



Answers:
(Answered on: 2022-07-03 13:39:43)


Hi I was also stuck in a similar problem. Make sure that the brownie-
config.yaml file is not inside the test folder and is kept seperately. Hope
this helps. [check the below image to see how I saved my brownie-config.yaml
file](https://i.stack.imgur.com/7NqEF.png)


---
(Answered on: 2022-01-20 10:55:07)

    
    
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    

**use v0.6 instead of v0.8**


---
(Answered on: 2022-01-12 19:39:39)


**I solved it by doing:** npm install @chainlink/contracts --save

[**and in the yaml file doing:**](https://i.stack.imgur.com/axYng.png)


---
(Answered on: 2022-01-12 14:37:57)


I solved it by replacing

:::NEXT DOC:::

  - smartcontractkit/chainlink-brownie-contracts@1.1.1
    
    compiler:
      solc:
        remappings:
        - '@chainlink=smartcontractkit/chainlink-brownie-contracts@1.1.1'
    

**here is the error:**

    
    
    (base) marc@Marcs-MacBook-Pro smartcontract-lottery % brownie compile
    Brownie v1.17.2 - Python development framework for Ethereum
    
    Compiling contracts...
      Solc version: 0.8.11
      Optimizer: Enabled  Runs: 200
      EVM Version: Istanbul
    CompilerError: solc returned the following errors:
    
    ParserError: Source ""/Users/marc/.brownie/packages/smartcontractkit/chainlink-brownie-contracts@1.1.1/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"" not found: File not found.
     --> contracts/Lottery.sol:4:1:
      |
    4 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    

I tried changing compiler: solc: remappings: \-
'@chainlink=smartcontractkit/chainlink-brownie-contracts@1.1.1' to @0.2.1 I
also tried changing solidity version to a newer version and it's not working
Thanks in advance!



Answers:
(Answered on: 2022-07-03

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

Question: (Asked on: 2022-01-08 22:14:53)
Can&#39;t import chainlink contracts
URL: https://stackoverflow.com/questions/70636875/cant-import-chainlink-contracts

Question Body:


I've looked though all the other questions on this topic and no answers seem
to work, I have run npm i @chainlink/contracts. But still I can not import
these contracts. It works perfectly on remix but in vscode with hardhat,
nothing seems to fix it.

    
    
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    



Answers:
(Answered on: 2022-11-09 14:14:04)


I had the same problem, red lines under the imports.

The solution was to change the VSCode Extension - Solidity by Juan Blanco - to
Solidity by Nomic Foundation

Solidity by Nomic Foundation [](https://i.stack.imgur.com/hdpXo.png)

<https://marketplace.visualstudio.com/items?itemName=NomicFoundation.hardhat-
solidity>

Before

[](https://i.stack.imgur.com/ggH5H.png)

After [](https://i.stack.imgur.com/LlOuF.png)





:::NEXT DOC:::

not
found: File not found. \--> contracts/Lottery.sol:4:1: | 4 | import
""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol""; |
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ERROR: Unable to load project



Answers:
(Answered on: 2023-03-05 22:55:12)


More elegant solution.

> 1.`yarn add @chainlink/contracts`  
>  `yarn add @openzeppelin/contracts` #I use it for the SafeMath

>   2.
> `import""node_modules/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol""`;
> `import""node_modules/@openzeppelin/contracts/utils/math/SafeMath.sol""`;
>


---
(Answered on: 2022-05-01 12:39:29)


STEP 1: change the @chainlink/contacts version from
@chainlink=smartcontractkit/chainlink-brownie-contracts@1.1.1 to
@chainlink=smartcontractkit/chainlink-brownie-contracts@0.2.1 in the config
file of your project

STEP 2: compile your project using brownie compile

STEP 3: go to <https://github.com/StarBlockDAO/SBox-VRF-
Random/commit/dbbe6a7933cef13dc905965ceb6d1cfe57818fc2> and get the
VRFCoordinatorV2Interface.sol and save it to your v.08/interfaces directory

STEP 4: compile your project using brownie compile


---
(Answered on: 2021-11-03 19:19:21)


""As of 1.2.0 and onward

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

 "
What command is used to configure user management in Chainlink Node instance?,The admin `chainlink admin users` command is used to configure user management in Chainlink Node instance.,{'source': 'https://docs.chain.link/chainlink-nodes/v1/roles-and-access/'},"The command used to configure user management in Chainlink Node instance is ""chainlink admin users"".","For additional context, see the following issues:

    * [hyperledger/besu/issues/4212](https://github.com/hyperledger/besu/issues/4212)
    * [hyperledger/besu/issues/4192](https://github.com/hyperledger/besu/issues/4192)
    * [hyperledger/besu/issues/4114](https://github.com/hyperledger/besu/issues/4114)
  * Added [Multi-user and Role Based Access Control](/chainlink-nodes/resources/miscellaneous/#multi-user-and-role-based-access-control-rbac) functionality. This allows the root admin CLI user and additional admin users to create and assign tiers of role-based access to new users. These new API users are able to log in to the Operator UI independently and can each have specific roles tied to their account. There are four roles: `admin`, `edit`, `run`, and `view`.

    * User management can be configured through the use of the new admin CLI command `chainlink admin users`. Be sure to run `chainlink admin login`. For example, a readonly user can be created with: `chainlink admin users create --email=operator-ui-read-only@test.com --role=view`.
    * Updated documentation repo with a break down of actions to required role level
  * Added gas limit control for individual job specs and individual job types. The following rule of precedence is applied:

    1. The task-specific parameter `gasLimit` overrides anything else when specified. For example, the `ethtx` task has a `gasLimit` parameter that overrides the other defaults for this specific task.

    2. The job-spec attribute `gasLimit` applies only to a specific job spec.

    3. The job-type limits affect any jobs of the corresponding type. The following environment variables are available:

      *

:::NEXT DOC:::

# Role-Based Access Control (RBAC)

  * Overview

Chainlink Nodes allow the root admin CLI user and any additional admin users
to create and assign tiers of role-based access to new users. These new API
users can able to log in to the Operator UI independently.

Each user has a specific role assigned to their account. There are four roles:
`admin`, `edit`, `run`, and `view`.

If there are multiple users who need specific access to manage the Chainlink
Node instance, permissions and level of access can be set here.

User management is configured through the use of the admin `chainlink admin
users` command. Run `chainlink admin login` before you set user roles for
other accounts. For example, a read-only user can be created with the
following command:


    chainlink admin users create --email=operator-ui-read-only@test.com --role=view

Specific actions are enabled to check role-based access before they execute.
The following table lists the actions that have role-based access and the role
that is required to run that action:

| Action                                        | Read   | Run   | Edit   | Admin   |
|:----------------------------------------------|:-------|:------|:-------|:--------|
| Update password                               | X      | X     | X      | X       |
| Create self API token                         | X      | X     | X      | X       |
| Delete self API token              

:::NEXT DOC:::

to change your password, you first need to log into the CLI by
running:


    chainlink admin login

Use your API email and old password in order to authenticate.

Then run the following in order to update the password:


    chainlink admin chpass

It will ask for your old password first, then ask for the new password and a
confirmation.

Once complete, you should see a message ""Password updated.""

## Multi-user and Role Based Access Control (RBAC)

See the [Roles and Access Control](/chainlink-nodes/v1/roles-and-access) page.

## Key management

In this section, ensure you log into the CLI by executing the following
command:


    chainlink admin login

Authenticate using your API email and password.

### List ETH keys

To list available Ethereum accounts along with their ETH & LINK balances,
nonces, and other metadata, execute the following command:


    chainlink keys eth list

Example:


    🔑 ETH keys
    -------------------------------------------------------------------------------------------------
    Address:           0x2d4f5FBD00E5A4fD53D162cE7EDFdb5b7664C542
    EVM Chain ID:      11155111
    Next Nonce:        0
    ETH:               0.000000000000000000
    LINK:              0
    Disabled:          false
    Created:           2023-04-26 08:12:51.340348 +0000 UTC
    Updated:           2023-04-26 08:12:51.340348 +0000 UTC

### Create a new ETH Key

To create a key

:::NEXT DOC:::

                              | nan    | nan   | nan    | X       |
| List users                                    | nan    | nan   | nan    | X       |
The run command allows for minimal interaction and only enables the ability to
replay a specific block number and kick off a job run.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/v1/roles-and-access.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

list of added jobs will be returned:


    ╔ Jobs
    ╬════╬════════════╬════════════╬═══════╬
    ║ ID ║ CREATED AT ║ INITIATORS ║ TASKS ║
    ╬════╬════════════╬════════════╬═══════╬

## Transfer funds from node wallet.

Note for Docker

If using Docker, you will first need to follow the Execute Commands Running
Docker guide to enter the running container.

To transfer funds from the node wallet to another address, use the following
CLI command:


    chainlink txs create <amount> <your-cl-node-address> <send-to-address>

This method is the preferred way to interact with your node wallet. Using
other methods to manually interact with the node wallet can cause nonce
issues.

## Change your API password

Note for Docker

If using Docker, you will first need to follow the Execute Commands Running
Docker guide to enter the running container.

In order to change your password, you first need to log into the CLI by
running:


    chainlink admin login

Use your API email and old password in order to authenticate.

Then run the following in order to update the password:


    chainlink admin chpass

It will ask for your old password first, then ask for the new password and a
confirmation.

Once complete, you should see a message ""Password updated.""

## Multi-user and Role Based Access Control (RBAC)

See the [Roles and Access Control](/chainlink-nodes/v1/roles-and-access) page.

## Key management

In this section, ensure you log into the CLI by executing the following
command:


    chainlink admin login

Authenticate using your API email and password.

### List

:::NEXT DOC:::

                       | Read   | Run   | Edit   | Admin   |
|:----------------------------------------------|:-------|:------|:-------|:--------|
| Update password                               | X      | X     | X      | X       |
| Create self API token                         | X      | X     | X      | X       |
| Delete self API token                         | X      | X     | X      | X       |
| List external initiators                      | X      | X     | X      | X       |
| Create external initiator                     | nan    | nan   | X      | X       |
| Delete external initiator                     | nan    | nan   | X      | X       |
| List bridges                                  | X      | X     | X      | X       |
| View bridge             

:::NEXT DOC:::

chain --address ""0xEXAMPLE"" --evmChainID 99 --setEnabled true`
    * Disable a key for a particular chain: `chainlink evm keys chain --address ""0xEXAMPLE"" --evmChainID 99 --setEnabled false`
  * It is now possible to use the same key across multiple chains.

### Changed

  * The `chainlink admin users update` command is replaced with `chainlink admin users chrole`. Only the role can be changed for a user.
  * Keypath now supports paths with any depth, instead of limiting it to 2.
  * `Arbitrum` chains are no longer restricted to only `FixedPrice` `GAS_ESTIMATOR_MODE`.
  * Updated `Arbitrum Rinkeby & Mainnet` configurations for Nitro.

### Removed

  * The `setnextnonce` local client command is removed and is replaced by the more general `evm keys chain` command client command.

## Changes in v1.7.1 nodes

**[v1.7.1 release
notes](https://github.com/smartcontractkit/chainlink/releases/tag/v1.7.1)**

### Fixed

  * Arbitrum Nitro client error support

## Changes in v1.7.0 nodes

**[v1.7.0 release
notes](https://github.com/smartcontractkit/chainlink/releases/tag/v1.7.0)**

### Added

  * `p2pv2Bootstrappers` is added as a new optional property of OCR1 job specs. The default can still be specified with the [`P2PV2_BOOTSTRAPPERS` environment variable](/chainlink-nodes/v1/configuration/#p2pv2_bootstrappers).

  * Added official support for the [Sepolia testnet](https://sepolia.dev) on Chainlink nodes.

  * Added [`hexdecode`

:::NEXT DOC:::

   root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink
    NAME:
       chainlink - CLI for Chainlink
    
    USAGE:
       chainlink [global options] command [command options] [arguments...]
    
    VERSION:
       0.9.10@7cd042c1a94c57219ed826a6eab46752d63fa67a
    
    COMMANDS:
       admin           Commands for remotely taking admin related actions
       attempts, txas  Commands for managing Ethereum Transaction Attempts
       bridges         Commands for Bridges communicating with External Adapters
       config          Commands for the node's configuration
       job_specs       Commands for managing Job Specs (jobs V1)
       jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json,

:::NEXT DOC:::

# Miscellaneous

  * Overview
  * Execute Commands Running Docker
  * Transfer funds from node wallet.
  * Change your API password
  * Multi-user and Role Based Access Control (RBAC)
  * Key management
  * List ETH keys
  * Create a new ETH Key
  * Export an ETH key
  * Delete an ETH key
  * Import an ETH key
  * Full example in detached mode

## Execute Commands Running Docker

In order to interact with the node's CLI commands, you need to be
authenticated. This means that you need to access a shell within the Chainlink
node's running container first. You can obtain the running container's `NAME`
by running:


    docker ps

The output will look similar to:


    CONTAINER ID        IMAGE                     COMMAND                  CREATED             STATUS              PORTS                              NAMES
    436882efd51d        smartcontract/chainlink   ""./chainlink-launche…""   33 minutes ago      Up 21 minutes       6688/tcp, 0.0.0.0:6688->6688/tcp   chainlink

The last item, `chainlink`, is the name of the running container (using
`--name chainlink` in your `docker run` command will give you a common name).
Accessing a shell for this container is accomplished by running:


    docker exec -it chainlink /bin/bash

This changes the prompt to something similar to:


    root@436882efd51d:~#

You can now log in by

:::NEXT DOC:::

 cd /home/ec2-user/.chainlink/ && ./create-password.sh \
    $(aws secretsmanager get-secret-value --secret-id WalletSecret --query ""SecretString"" --output text)

### Generating the `.api` file


    cd /home/ec2-user/.chainlink/ && ./create-api.sh \
    ${apiUser} \
    $(aws secretsmanager get-secret-value --secret-id ApiSecret --query ""SecretString"" --output text)

### Stopping and removing the existing Chainlink node container

This process is required when you update the container to a newer release.


    docker stop chainlink && docker rm chainlink

### Starting the Chainlink node container in Docker


    latestimage=$(curl -s -S ""https://registry.hub.docker.com/v2/repositories/smartcontract/chainlink/tags/"" | jq -r '.""results""[][""name""]' | head -n 1)
    cd /home/ec2-user/.chainlink && docker run -d \
    --log-driver=awslogs \
    --log-opt awslogs-group=ChainlinkLogs \
    --restart unless-stopped \
    --name chainlink \
    -p 6688:6688 \
    -v /home/ec2-user/.chainlink:/chainlink \
    --env-file=/home/ec2-user/.chainlink/.env  smartcontract/chainlink:$latestimage local n \
    -p /chainlink/.password
    -a /chainlink/.api

You can find more details with maintenance and examples in the [Performing
System Maintenance](/chainlink-nodes/resources/performing-system-maintenance)
guide.

Additionally, follow the directions in the [User Guide for"
What is the purpose of the 'fulfill' function in this contract?,The 'fulfill' function is used to record the fulfillment of a Chainlink request and update the 'volume' state variable with the provided volume.,{'source': 'https://docs.chain.link/any-api/get-request/examples/single-word-response/'},"The context information provided does not include any mention of a 'fulfill' function in the contract. Therefore, it is not possible to determine the purpose of such a function.","    * Receive the response in the form of uint256
         */
        function fulfill(
            bytes32 _requestId,
            uint256 _volume
        ) public recordChainlinkFulfillment(_requestId) {
            emit RequestVolume(_requestId, _volume);
            volume = _volume;
        }
    
        /**
         * Allow withdraw of Link tokens from the contract
         */
        function withdrawLink() public onlyOwner {
            LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
            require(
                link.transfer(msg.sender, link.balanceOf(address(this))),
                ""Unable to transfer""
            );
        }
    }
    

To use this contract:

  1. Open the [contract in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/APIConsumer.sol).

  2. Compile and deploy the contract using the Injected Provider environment. The contract includes all the configuration variables for the _Sepolia_ testnet. Make sure your wallet is set to use _Sepolia_. The _constructor_ sets the following parameters:

    * The Chainlink Token address for _Sepolia_ by calling the

:::NEXT DOC:::

       // ...
        // { constructor }
        // ...
    
        // rollDice function
        function rollDice(address roller) public onlyOwner returns (uint256 requestId) {
            require(s_results[roller] == 0, ""Already rolled"");
            // Will revert if subscription is not set and funded.
            requestId = COORDINATOR.requestRandomWords(
            s_keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
           );
    
            s_rollers[requestId] = roller;
            s_results[roller] = ROLL_IN_PROGRESS;
            emit DiceRolled(requestId, roller);
        }
    }

### `fulfillRandomWords` function

`fulfillRandomWords` is a special function defined within the
`VRFConsumerBaseV2` contract that our contract extends from. The coordinator
sends the result of our generated `randomWords` back to `fulfillRandomWords`.
You will implement some functionality here to deal with the result:

  1. Change the result to a number between 1 and 20 inclusively. Note that `randomWords` is an array that could contain several random values. In this example, request 1 random value.
  2. Assign the transformed value to the address in the `s_results` mapping variable.


:::NEXT DOC:::

contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates with the _Functions Billing Registry_ , which
assigns a unique identifier (aka _Subscription ID_ ).

### Fund Subscription

You must fund your subscription accounts with enough LINK tokens:

  1. Connect your EOA to the _Subscription App_.
  2. Fund your subscription account. The _Subscriptions App_ abstracts the following: 


:::NEXT DOC:::

 latestRequestId = assignedReqID;

`fulfillRequest` is invoked by Chainlink Functions during the callback. This
function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest`
[API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must
override the function to implement the callback. The implementation of the
callback is straightforward: the contract stores the latest response and error
in `latestResponse` and `latestError` and increments `responseCounter` before
emitting the `OCRResponse` event.


    latestResponse = response;
    latestError = err;
    responseCounter = responseCounter + 1;
    emit OCRResponse(requestId, response, err);

### config.js

See the [explanation](/chainlink-functions/tutorials/api-multiple-calls#configjs) for the Call Multiple Data Sources tutorial.

### source.js

See the [explanation](/chainlink-functions/tutorials/api-multiple-calls#sourcejs) for the Call Multiple Data Sources tutorial.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/tutorials/automate-functions.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

      }
        }
    
        function fulfillA(uint256 requestId, uint256 randomWord) private {
            // execution path A
            variableA = randomWord;
            emit FulfilledA(requestId, randomWord);
        }
    
        function fulfillB(uint256 requestId, uint256 randomWord) private {
            // execution path B
            variableB = randomWord;
            emit FulfilledB(requestId, randomWord);
        }
    
        function fulfillC(uint256 requestId, uint256 randomWord) private {
            // execution path C
            variableC = randomWord;
            emit FulfilledC(requestId, randomWord);
        }
    }
    

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/best-practices.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

= ROLL_IN_PROGRESS;
            emit DiceRolled(requestId, roller);
        }
    }

### `fulfillRandomWords` function

`fulfillRandomWords` is a special function defined within the
`VRFConsumerBaseV2` contract that our contract extends from. The coordinator
sends the result of our generated `randomWords` back to `fulfillRandomWords`.
You will implement some functionality here to deal with the result:

  1. Change the result to a number between 1 and 20 inclusively. Note that `randomWords` is an array that could contain several random values. In this example, request 1 random value.
  2. Assign the transformed value to the address in the `s_results` mapping variable.
  3. Emit a `DiceLanded` event.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
        // ...
        // { variables }
        // ...
    
        // events
        // ...
        event DiceLanded(uint256 indexed requestId, uint256 indexed result);
    
        // ...
        // { constructor }
        // ...
    
        // ...
        // { rollDice function }
      

:::NEXT DOC:::

  import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    contract RealEstateBonus is ChainlinkClient, Ownable {
        using Chainlink for Chainlink.Request;
    
        bytes32 private jobId;
        uint256 private fee;
        string public url;
        string public urlresult;
        string public lastselldate;
        string public lastapn;
        bytes32 public lastrequestid;
    
        event RequestMultipleFulfilled(bytes32 indexed requestId, string selldate, string apn);
    
        constructor() {
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            setChainlinkOracle(0xCC79157eb46F5624204f47AB42b3906cAA40eaB7);
            jobId = ""53f9755920cd451a8fe46f5087468395"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
           

:::NEXT DOC:::

and `times` parameters. These are read by the Tasks in the job to perform correctly. `get` is used by [HTTP](/chainlink-nodes/oracle-jobs/all-tasks/#http-task), `path` is used by [JSON Parse](/chainlink-nodes/oracle-jobs/all-tasks/#json-parse-task) and `times` is used by [Multiply](/chainlink-nodes/oracle-jobs/all-tasks/#multiply-task).
  3. `fulfill` function: This is where the result is sent upon the Oracle Job's completion.

**Note:** The calling contract should own enough LINK to pay the fee, which by
default is 0.1 LINK. You can use [this tutorial](/resources/fund-your-contract) to learn how to fund your contract.

This is an example of a basic HTTP GET request. However, it requires defining
the API URL directly in the smart contract. This can, in fact, be extracted
and configured on the Job level inside the Oracle node. You can follow the
_APIConsumer_ tutorial [here](/any-api/get-request/examples/single-word-response).

### External adapters

If all the parameters are defined within the Oracle job, the only things a
smart contract needs to define to consume are:

  * JobId
  * Oracle address
  * LINK fee
  * Fulfillment function

This will make your smart contract much more succinct. The `requestVolumeData`
function from the code example above would look more like this:


    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
        // Extra parameters don't need to be defined here because they are already defined in the job
    
        return sendChainlinkRequest(req, fee);


:::NEXT DOC:::

the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

      }
    
        function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {
            console.log(""fulfill"");
            NFTInfo memory requestNFTInfo = _requestIdToNFTInfo[_requestId];
            require(requestNFTInfo.userAddress != address(0), ""Request not found"");
    
            _safeMint(requestNFTInfo.userAddress, requestNFTInfo.cardId);
            console.log(""_safeMint"");
    
            _nfts[requestNFTInfo.cardId] = NFTData(block.timestamp, requestNFTInfo.initialPower);
            emit RequestFulfilled(_requestId, _randomWords);
        }
    }
    
    

Below is my `nft.test.js` file:

    
    
    const { expect } = require(""chai"");
    
    describe(""Contract deployment"", () => {
      let nft, vrfCoordinatorV2Mock, hardhatVrfCoordinatorV2Mock, owner;
    
      before(async () => {
        nftFactory = await ethers.getContractFactory(""NFT"");
        vrfCoordinatorV2Mock = await ethers.getContractFactory(""VRFCoordinatorV2Mock"");
      });
    
     "
What can you expect to stay up to date on by subscribing to the Chainlink Developer mailing list?,"You can expect to stay up to date on releases, package updates, new features, breaking changes, events, and connecting with other developers.",{'source': 'https://docs.chain.link/resources/developer-communications?parent=anyApi/'},"By subscribing to the Chainlink Developer mailing list, you can expect to stay up to date on releases, package updates, new features, breaking changes, events, and connecting with other developers.","# Developer Communications

  * Overview

The Chainlink Developer mailing list is the best place to stay up to date on

  * Releases
  * Package Updates
  * New Features
  * Breaking Changes
  * Events
  * Connecting with other developers

## Subscribe to the latest Chainlink Developer news

### 微信中文开发者社区

### (WeChat Chinese Developer Community)

[
https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE](https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/developer-communications.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually

:::NEXT DOC:::

in our
previous hackathons. There is also a link to the Marketplace where you can
find the latest data provider nodes and explore the network.

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past Hackathon Winning Projects](/resources/example-projects)

## Outreach

The Chainlink community is an inviting group of engineers that is always
looking to help users expand their knowledge on Chainlink and solve related
issues. Refer back to the [Getting Help](/resources/getting-help) page for the
latest information about how to get support.

### Get support

  * [Stack Overflow](https://stackoverflow.com/questions/tagged/chainlink)
  * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

### Join the community

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/other-tutorials.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed

:::NEXT DOC:::

videos etc)
  * Becoming a developer expert
  * Becoming a community advocate
  * Running a Chainlink focused developer Bootcamp (in person or online)
  * Running an in-person meetup or watch party
  * Participate in a hackathon
  * Applying for a grant

# Why Should You Contribute

[Open source software](https://en.wikipedia.org/wiki/Open-source_software) is
a model that brings multiple benefits for both the project and the
contributors. As a developer or community member, contributing to Chainlink
helps you to gain valuable skills and experience, improve the software that
you use, and grow your personal brand in the community which can lead to
future employment opportunities. On top of these awesome things, contributing
to open source is fun. It can give you a sense of community involvement, and
gives you a personal sense of satisfaction knowing that you're part of an
effort to build something that will enable a fairer, more transparent, and
efficient new world.

# Ways to Contribute

## Contributing to Software and Tooling

The most direct way you can contribute to Chainlink is to contribute to the
core code or the various tooling found in our [GitHub
repository](https://github.com/smartcontractkit/). Contributing to code or
code-based tools can generally be split into a few different categories:

  * Raising an issue
  * Requesting a new feature
  * Submitting a Pull Request (PR) for a fix, improvement, or new tool

### Raising an Issue

During the course of using Chainlink software or tools, you might encounter
errors or unexpected behavior that leads you to believe the software isn't
behaving correctly. You can bring this to the attention of the Chainlink Labs
team as well as the wider developer community by raising an issue in the
project’s GitHub repository. The 'Issues' tab lists all of the open issues

:::NEXT DOC:::

errors
  * Adding new guides or tutorials that you would find useful
  * Translating the documentation into other languages

The process for contributing to the documentation follows the process defined
earlier in the Submitting a Pull Request section. Each page also has a
'Suggest Edits' link on the top right, and will directly take you to the page
in the [documentation
repository](https://github.com/smartcontractkit/documentation), where you can
create a new PR with the suggested changes. Before you create a PR for the
documentation, read the [contributing
guidelines](https://github.com/smartcontractkit/documentation/blob/main/CONTRIBUTING.md).

If you want to translate the documentation into a new language that is not yet
supported, feel free to [reach out to the
team](mailto:devrel@smartcontract.com) beforehand, so we can make sure you get
the support you need.

## Creating Community Content

Chainlink has a strong and vibrant community of developers and community
advocates. Community members often create Chainlink-focused content in various
forms and publish it for the wider community on various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to

:::NEXT DOC:::

# Contributing to Chainlink

  * Overview
  * Contributing to Software and Tooling
  * Raising an Issue
  * Requesting a new Feature
  * Submitting a Pull Request
  * Contributing to the documentation
  * Creating Community Content
  * Becoming a Developer Expert
  * Joining the Chainlink Community Advocate program
  * Running a Chainlink Focused Developer Bootcamp
  * Running an In-Person Meetup or Watch Party
  * Participate in a Hackathon
  * Applying for a Grant

Chainlink is an open-source project licensed [under the MIT
license](https://github.com/smartcontractkit/chainlink/blob/master/LICENSE),
and we encourage contributions from all developers and community members.

# What It Means to Contribute

When you contribute to the Chainlink project, you as a developer or community
member contribute your time and effort to help improve and grow Chainlink.
Your contribution can be from various methods:

  * Building and maintaining the Chainlink software and tools
  * Improving and maintaining the documentation, including translations into other languages
  * Creating Chainlink focused content (blog posts, tutorials, videos etc)
  * Becoming a developer expert
  * Becoming a community advocate
  * Running a Chainlink focused developer Bootcamp (in person or online)
  * Running an in-person meetup or watch party
  * Participate in a hackathon
  * Applying for a grant

# Why Should You Contribute

[Open source software](https://en.wikipedia.org/wiki/Open-source_software) is
a model that brings multiple benefits for both the project and the
contributors. As a developer or community member, contributing to Chainlink
helps you to gain valuable skills and experience, improve the software that
you use, and grow your personal brand in the community which can lead to
future employment opportunities. On top of these awesome things, contributing
to open source is fun. It can give

:::NEXT DOC:::

you have questions, read the [Chainlink Automation Frequently Asked
Questions](/chainlink-automation/faqs) page. You can also ask questions in the
[#automation
channel](https://discord.com/channels/592041321326182401/821350860302581771)
in our [Discord server](https://discord.gg/qj9qarT), or [contact
us](https://forms.gle/WadxnzzjHPtta5Zd9) for assistance with registration.

## What's next

  * [› Register a time-based upkeep](/chainlink-automation/job-scheduler/)
  * [› Register a Custom Logic Upkeep](/chainlink-automation/register-upkeep/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/automation-release-notes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

 * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

## Tutorials

If you are new to Smart Contracts, read the [Getting Started Guide](/getting-started/conceptual-overview).

  * [Learning Resources](/getting-started/other-tutorials)
  * [Video Tutorials](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J)
  * [@Chain_Dev Video Tutorials](https://www.youtube.com/@Chain_Dev/videos)
  * [What is Ethereum?](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J)
  * [Developer Blog (many tutorials)](https://blog.chain.link/tag/developers/)
  * [Testing Chainlink Smart Contracts](https://blog.chain.link/testing-chainlink-smart-contracts/)
  * [NFTs and Chainlink](https://blog.chain.link/build-deploy-and-sell-your-own-dynamic-nft/)
  * [Build an external adapter](/chainlink-nodes/external-adapters/developers)

## Inspiration

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past winners & code](/resources/example-projects)

## Join the community

The Chainlink community is some of the most inviting groups of engineers
always looking to help you grow to the next stage.

  * [Twitter](https://mobile.twitter.com/chainlink)
"
What is the benefit of using Off-Chain Reporting (OCR) for Chainlink oracle networks?,"Submitting only one transaction per round reduces overall network congestion, individual node operators spend less on gas costs, node networks are more scalable, and data feeds can be updated in a more timely manner.",{'source': 'https://docs.chain.link/architecture-overview/off-chain-reporting/'},"The benefit of using Off-Chain Reporting (OCR) for Chainlink oracle networks is that it reduces overall network congestion, individual node operators spend less on gas costs, node networks are more scalable, and data feeds can be updated in a more timely manner since each round needn't wait for multiple transactions to be confirmed before a price is confirmed on-chain. OCR allows nodes to aggregate their observations into a single report off-chain using a secure P2P network, which saves a significant amount of gas.","# Off-Chain Reporting

  * Overview
  * What is OCR?
  * How does OCR work?

Off-Chain Reporting (OCR) is a significant step towards increasing the
decentralization and scalability of Chainlink networks. See the [OCR Protocol
Paper](https://research.chain.link/ocr.pdf) for a technical deep dive.

For Off-Chain Reporting aggregators, all nodes communicate using a peer to
peer network. During the communication process, a lightweight consensus
algorithm runs where each node reports its data observation and signs it. A
single aggregate transaction is then transmitted, which saves a significant
amount of gas.

The report contained in the aggregate transaction is signed by a quorum of
oracles and contains all oracles' observations. By validating the report on-
chain and checking the quorum's signatures on-chain, we preserve the
trustlessness properties of Chainlink oracle networks.

## What is OCR?

A simple analogy

Imagine ordering 10 items from an online store. Each item is packaged
separately and posted separately, meaning postage and packaging costs must be
applied to each one, and the carrier has to transport 10 different boxes.

OCR, on the other hand, packages all of these items into a single box and
posts that. This saves postage and packaging fees and all effort the carrier
associates with transporting 9 fewer boxes.

The OCR protocol allows nodes to aggregate their observations into a single
report off-chain using a secure P2P network. A single node then submits a
transaction with the aggregated report to the chain. Each report consists of
many nodes' observations and has to be signed by a quorum of nodes. These
signatures are verified on-chain.

Submitting only one transaction per round achieves the following benefits:

  * Overall network congestion from Chainlink oracle networks is reduced dramatically
  * Individual node operators

:::NEXT DOC:::

and the carrier has to transport 10 different boxes.

OCR, on the other hand, packages all of these items into a single box and
posts that. This saves postage and packaging fees and all effort the carrier
associates with transporting 9 fewer boxes.

The OCR protocol allows nodes to aggregate their observations into a single
report off-chain using a secure P2P network. A single node then submits a
transaction with the aggregated report to the chain. Each report consists of
many nodes' observations and has to be signed by a quorum of nodes. These
signatures are verified on-chain.

Submitting only one transaction per round achieves the following benefits:

  * Overall network congestion from Chainlink oracle networks is reduced dramatically
  * Individual node operators spend far less on gas costs
  * Node networks are more scalable because data feeds can accommodate more nodes
  * Data feeds can be updated in a more timely manner since each round needn't wait for multiple transactions to be confirmed before a price is confirmed on-chain.

## How does OCR work?

Protocol execution happens mostly off-chain over a peer to peer network
between Chainlink nodes. The nodes regularly elect a new leader node that
drives the rest of the protocol.

The leader regularly requests followers to provide freshly signed observations
and aggregates them into a report. It then sends this report back to the
followers and asks them to verify the report's validity. If a quorum of
followers approves the report by sending a signed copy back to the leader, the
leader assembles a final report with the quorum's signatures and broadcasts it
to all followers.

The nodes attempt to transmit the final report to the aggregator contract
according to a randomized schedule. The aggregator verifies that a quorum of
nodes signed the report and exposes the median value to consumers as an answer
with

:::NEXT DOC:::

aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

2021-11-02 22:54:01)


The current version of aggregation used is called ""OCR"" or ""Off-Chain
Reporting"". FluxAggregator was the previous aggregation method. The code and
contracts for OCR can be found in this repo:

<https://github.com/smartcontractkit/libocr>

Running your own feeds isn't officially supported _yet_ (this is being worked
on), so there isn't any documentation, but it is possible to run your own feed
using that code if you really need to. You could also aggregate a couple of
""[Chainlink AnyAPI](https://docs.chain.link/docs/make-a-http-get-request/)""
requests in your contract to simulate a feed.

If this is for a hackathon (or just to demo your app) and there's no existing
data feed for the data you need, I'd suggest using the ""AnyAPI"" feature and a
single Chainlink node, so you can focus on your application and not on
building an oracle network. Once it's time to go to production/mainnet, the
Chainlink Labs team can assist you in making a decentralized oracle network.
You can reach them here on the [Chainlink website](https://chain.link/data-
feeds).

Reference: [OCR Announcement Blog](https://blog.chain.link/off-chain-
reporting-live-on-mainnet/)





:::NEXT DOC:::

# Data Feeds Architecture

  * Overview
  * Basic Request Model
  * Decentralized Data Model
  * Off-Chain Reporting

## Basic Request Model

Chainlink connects smart contracts with external data using its decentralized
oracle network. Chainlink API requests are handled 1:1 by an oracle.

The [Basic Request Model](/architecture-overview/architecture-request-model)
describes the on-chain architecture of requesting data from a single oracle
source.

To learn how to make a GET request using a single oracle, see [Make a GET
Request](/any-api/get-request/introduction).

## Decentralized Data Model

For a more robust and trustworthy answer, you can aggregate data from many
oracles. With on-chain aggregation, data is aggregated from a decentralized
network of independent oracle nodes. This architecture is applied to Chainlink
Data Feeds, which can aggregate data such as asset price data.

The [Decentralized Data Model](/architecture-overview/architecture-decentralized-model) describes how data is aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  *

:::NEXT DOC:::

run the computation off-chain. Finally, oracle nodes use the [Chainlink
OCR](/architecture-overview/off-chain-reporting) protocol to aggregate all the
responses before passing the aggregated responses to the consumer contracts in
callbacks. Note: As long as you use vanilla Node.js (no modules imports), you
can decentralize any computation you want such as API calls, computing maths
operations, etc.

## Decentralized Oracle Network (DON)

_Chainlink Functions_ are powered by a [Decentralized Oracle
Network](https://chain.link/education/blockchain-oracles#decentralized-oracles). The oracle nodes are independent of each other and are responsible
for running the same function such as API calls, computing maths operations,
etc. The nodes use the [Chainlink OCR](/architecture-overview/off-chain-reporting) protocol to aggregate all the nodes' responses. Finally, a DON's
oracle sends the aggregate response to the consumer contract in a callback.

## Subscriptions

  * Subscriptions App: A user interface that interacts with the _Subscriptions Contract_. **Note** : The _Subscriptions App_ is not available now, we recommend using the [functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to interact with the _Subscriptions Contract_.
  * Subscriptions Contract (aka [Functions Billing Registry Contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol)): The contract that holds user funds to pay for _Chainlink Functions_ requests.
  * subscription account: An account that holds LINK tokens and makes them available to fund requests to Chainlink DON. A _Subscription ID_ uniquely IDentifies each account.
  * Subscription ID: 64-bit unsigned integer

:::NEXT DOC:::

Question: (Asked on: 2022-05-20 12:03:27)
Chainlink newbie doubts
URL: https://stackoverflow.com/questions/72318627/chainlink-newbie-doubts

Question Body:


I'm starting my studies about Chainlink this week and right now I'm trying to
fit all together before I continue my exploration of Chainlink docs. May be
you could help me in this task.

Could you confirm this understanding?

As I've already read, there are 3 models in Chainlink:

  * Decentralized Data Model with Flux Aggregator where the oracle smart contract receives prices report of crypto assets and aggregate them to offer this information to consumers. However, this model is being deprecated in favor of OCR, right?
  * The Off-Chain Reporting that aggregates the prices of crypto assets off-chain and send a single transaction to the oracle smart contract and this smart contract offer the median of prices to the consumers.
  * Basic Request Model where it is possible to call any Chainlink job. Typically, this job is a API calling with some transformations before the result is sent to the smart contract consumer.

If I'm not misunderstanding this basics concepts, I have some doubts:

  * The first two models, DDM and OCR, are only for assets' prices or they could be used for other kinds of data since exists oracles providing that data? If true, are there real examples of this kind of usage?
  * About the Basic Request Model, I feel like it is a centralized solution, I haven't seen any step of aggregation/conciliation, only one node responds and that is it. Is this understanding right or I'm missing something?
  * Another concept not clear yet: what is a Data Provider? I found out this page <https://market.link/search/data-providers> and seems like centralized providers of data, is that right?



Answers:
(Answered on:

:::NEXT DOC:::

# Decentralized Data Model

  * Overview
  * Data Aggregation
  * Shared Data Resource
  * Decentralized Oracle Network
  * Components of a Decentralized Oracle Network
  * Consumer
  * Proxy
  * Aggregator

This page describes how data aggregation is applied to produce Chainlink Data
Feeds and provides more insight as to how Data Feeds are updated.

## Data Aggregation

Each data feed is updated by multiple, independent Chainlink oracle operators.
The
[AccessControlledOffchainAggregator](https://github.com/smartcontractkit/libocr/blob/master/contract/AccessControlledOffchainAggregator.sol)
aggregates the data on-chain.

Off-Chain Reporting (OCR) further enhances the aggregation process. To learn
more about OCR and how it works, see the [Off-Chain Reporting](/architecture-overview/off-chain-reporting) page.

## Shared Data Resource

Each data feed is built and funded by the community of users who rely on
accurate, up-to-date data in their smart contracts. As more users rely on and
contribute to a data feed, the quality of the data feed improves. For this
reason, each data feed has its own properties depending on the needs of its
community of users.

## Decentralized Oracle Network

Each data feed is updated by a decentralized oracle network. Each oracle
operator is rewarded for publishing data. The number of oracles contributing
to each feed varies. In order for an update to take place, the data feed
aggregator contract must receive responses from a minimum number of oracles or
the latest answer will not be updated. You can see the minimum number of
oracles for the corresponding feed at
[data.chain.link](https://data.chain.link).

Each oracle in the set publishes data during an aggregation round. That data
is validated and aggregated by a smart contract, which forms the feed's

:::NEXT DOC:::

mostly off-chain over a peer to peer network
between Chainlink nodes. The nodes regularly elect a new leader node that
drives the rest of the protocol.

The leader regularly requests followers to provide freshly signed observations
and aggregates them into a report. It then sends this report back to the
followers and asks them to verify the report's validity. If a quorum of
followers approves the report by sending a signed copy back to the leader, the
leader assembles a final report with the quorum's signatures and broadcasts it
to all followers.

The nodes attempt to transmit the final report to the aggregator contract
according to a randomized schedule. The aggregator verifies that a quorum of
nodes signed the report and exposes the median value to consumers as an answer
with a block timestamp and a round ID.

All nodes watch the blockchain for the final report to remove any single point
of failure during transmission. If the designated node fails to get their
transmission confirmed within a determined period, a round-robin protocol
kicks in so other nodes can also transmit the final report until one of them
is confirmed.

## What's next

  * [› Using Data Feeds](/data-feeds/price-feeds/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/off-chain-reporting.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

   evmChainID      = 1
    name            = ""example keeper spec""
    contractAddress = ""0x7b3EC232b08BD7b4b3305BE0C044D907B2DF960B""
    fromAddress     = ""0xa8037A20989AFcBC51798de9762b351D63ff462e""

### Shared fields

See [shared fields](/chainlink-nodes/oracle-jobs/jobs/#shared-fields).

### Unique fields

  * `evmChainID`: The numeric chain ID of the chain on which Chainlink Automation Registry is deployed
  * `contractAddress`: The address of the Chainlink Automation Registry contract to poll and update
  * `fromAddress`: The Oracle node address from which to send updates
  * `externalJobID`: This is an optional field. When omitted it will be generated

## Off-chain reporting jobs

OCR jobs (off-chain reporting jobs) are used very similarly to Flux Monitor
jobs. They update data feeds with aggregated data from many Chainlink oracle
nodes. However, they do this aggregation using a cryptographically-secure off-
chain protocol that makes it possible for only a single node to submit all
answers from all participating nodes during each round (with proofs that the
other nodes' answers were legitimately provided by those nodes), which saves a
significant amount of gas.

Off-chain reporting jobs require the `FEATURE_OFFCHAIN_REPORTING=true`
environment variable.

### Bootstrap node

Every OCR cluster requires at least one bootstrap node as a kind of ""rallying
point"" that enables the other nodes to find one another. Bootstrap nodes do
not participate in the aggregation protocol and do not submit answers to the
feed.

#### Spec format


    type        "
What are external initiators and how do they enable blockchain agnostic cross-chain compatibility?,External initiators allow jobs in a node to be initiated depending on some external condition. The ability to create and add external initiators to Chainlink nodes enables blockchain agnostic cross-chain compatibility.,{'source': 'https://docs.chain.link/chainlink-nodes/external-initiators/external-initiators-introduction/'},"External initiators are a feature in Chainlink nodes that allow jobs to be initiated based on some external condition. They enable blockchain agnostic cross-chain compatibility by allowing for the creation and addition of external initiators to Chainlink nodes. This means that jobs can be triggered across different blockchains, not just within a single blockchain. External initiators are simple web initiators that can be activated by any job instead of just one, and they make API calls with two added headers to authenticate messages sent from the External Initiator to the Core.","# Introduction

  * Overview

External initiators allow jobs in a node to be initiated depending on some
external condition. The ability to create and add external initiators to
Chainlink nodes enables blockchain agnostic cross-chain compatibility.

note

At this time of writing, external initiators do not show up in the bridges
tab. However, they act exactly the same as if they did.

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

Initiator Bridges handle the authentication to and from the External Initiator
and where to send the messages. When creating a Bridge two parameters are
required:

Only the [webhook](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) job
type can be initiated using an External Initiator.

The external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators

:::NEXT DOC:::

external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators to
nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes).

## What's next

  * [› Building External Initiators](/chainlink-nodes/external-initiators/building-external-initiators)
  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

repo for
reference. You can see some examples of existing initiators in the
[blockchain](https://github.com/smartcontractkit/external-initiator/tree/master/blockchain) folder.

External initiators are simple web initiators that can be activated by any job
instead of just one. To set one up, you need to have a service similar to an
external adapter that sends an `HTTPPost` message runs API call to your
chainlink node service. Here is a sample URL for a web job could look like:


    curl -b cookiefile -X POST -H ""Content-Type: application/json"" --data '{""myKey"":""myVal""}' http://localhost:6688/v2/jobs/%s/runs

Where `%s` is the jobId.

External initiators make the same API call, with 2 added headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

These are keys generated when you register your external initiator with your
node.

Triggering a run through an external initiator is as simple as making this API
call to your node. All jobs with this EI configured will then be kicked off in
this way. A simple external initiator in psedo code could look like this:


    while(True):
        send_api_call_with_external_initiator_access_key_headers()
        sleep(4)

And have this job run on the same machine as your node.

## What's next

  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/building-external-initiators.mdx)
  * [ Join

:::NEXT DOC:::

      jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json, -j     json output as opposed to table
       --help, -h     show help
       --version, -v  print the version
    

Chainlink version 0.9.10.

Could you please clarify what am I doing wrong?



Answers:
(Answered on: 2021-09-28 21:51:21)


You need to make sure you have the `FEATURE_EXTERNAL_INITIATORS` environment
variable set to true in your .env file as such:

`FEATURE_EXTERNAL_INITIATORS=true`

This will open up access to the `initiators` command in the Chainlink CLI and
you can resume the instructions from there.





:::NEXT DOC:::

# Adding External Initiators to Nodes

  * Overview
  * Creating an external initiator
  * Deleting an external initiator
  * Listing external initiators

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

## Creating an external initiator

To create an external initiator you must use the remote API. You can do this
yourself, like so:


    POST http://<your chainlink node>/v2/external_initiators -d <PAYLOAD>

where payload is a JSON blob that contains:


    {
      ""name"": <MANDATORY UNIQUE NAME>,
      ""url"": <OPTIONAL EXTERNAL INITIATOR URL>
    }

If a URL is provided, Chainlink will notify this URL of added and deleted jobs
that can be triggered by this external initiator. This allows the external
initiator to program in certain actions e.g. subscribing/unsubscribing to logs
based on the job, etc.

On creation:


    POST <URL> -d {""jobId"": <job external UUID>, ""type"": <name of external initiator>, ""params"": <optional arbitrary JSON specified at job creation time>}

On deletion:


    DELETE <URL>/<job external UUID>

You can use the chainlink client for convenience to access this API.

Enter the [Chainlink nodes CLI](/chainlink-nodes/resources/miscellaneous/#execute-commands-running-docker) and run the
following command


    chainlink initiators create <NAME> <URL>

`NAME`: The name you want to use

:::NEXT DOC:::

EI and then checking to see if a sample job kicks off is the best way to
test this.

To try a real-life example, feel free to follow along with the [Conflux EI
demo](https://www.youtube.com/watch?v=J8oJEp4qz5w).

Additional external initiator reference

note

The External Initiator can only initiate [webhook jobs](/chainlink-nodes/oracle-jobs/job-types/webhook) that have been linked to it. Trying to
initiate a job that is not linked will give an unauthorised error.

## Deleting an external initiator

To delete an external initiator you must use the remote API. You can do this
yourself, like so:


    DELETE http://<your chainlink node>/v2/external_initiators/<external initiator name>

You can alternatively use the chainlink client for convenience:


    chainlink initiators destroy <NAME>

## Listing external initiators

To see your installed external initiators:


    GET http://<your chainlink node>/v2/external_initiators?size=100&page=1

Or, using the chainlink client:


    chainlink initiators list

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-in-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

chain controlled
by the user.

Web2 verification can be fairly convenient for personal transactions and
requires less technical expertise. However, it is limited only to swapping and
bridging tokens which requires trust in a centralized custodian.

#### External verification

External verification is where a group of validator nodes are responsible for
verifying transactions. These validators do not belong to either of the two
blockchains’ validator sets and they also have their trust assumptions
irrespective of the underlying blockchains.

External verification typically requires an honest majority assumption, where
a majority of the external validator nodes must behave honestly for the
integrity of the cross-chain interaction to be upheld. However, additional
techniques can be used to increase trust-minimization, such as:

  * optimistic bridge verification.
  * anti-fraud networks.
  * cryptoeconomic staking.

Despite an additional trust assumption, external verification is currently the
only practical way to perform cross-chain contract calls between certain types
of blockchains while still providing trust-minimized guarantees. It’s also a
highly generalized and extensible form of cross-chain computation that is
capable of supporting more complex cross-chain applications.

Cryptography risk

Some externally verified bridges are secured by multisig wallets.
[Ronin](https://whitepaper.axieinfinity.com/technology/ronin-ethereum-sidechain) is one example. Multisig wallets are also referred to as m-of-n
multisigs, with M being the required number of signatures or keys and N being
the total number of signatures or keys (m≤n). This means that an attacker only
needs to exploit M keys to be able to hack the whole system. In this case,
users must trust that the third party is decentralized enough, signers are
independent of each other, and that each signer has proper key management in
place. Read this [detailed

:::NEXT DOC:::

# Building External Initiators

  * Overview
  * JSON jobs (REMOVED)

An external initiator can trigger a run for any webhook job that it has been
linked to.

The URL for triggering a run is such:


    curl -X POST -H ""Content-Type: application/json"" --data '{""myKey"": ""myVal""}' http://localhost:6688/v2/jobs/<job external UUID>/runs

You will need to specify two headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

## JSON jobs (REMOVED)

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

We will be using the [Chainlink external
initiator](https://github.com/smartcontractkit/external-initiator) repo for
reference. You can see some examples of existing initiators in the
[blockchain](https://github.com/smartcontractkit/external-initiator/tree/master/blockchain) folder.

External initiators are simple web initiators that can be activated by any job
instead of just one. To set one up, you need to have a service similar to an
external adapter that sends an `HTTPPost` message runs API call to your
chainlink node service. Here is a sample URL for a web job could look like:


    curl -b cookiefile -X POST -H ""Content-Type: application/json"" --data '{""myKey"":""myVal""}' http://localhost:6688/v2/jobs/%s/runs

Where

:::NEXT DOC:::

   root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink
    NAME:
       chainlink - CLI for Chainlink
    
    USAGE:
       chainlink [global options] command [command options] [arguments...]
    
    VERSION:
       0.9.10@7cd042c1a94c57219ed826a6eab46752d63fa67a
    
    COMMANDS:
       admin           Commands for remotely taking admin related actions
       attempts, txas  Commands for managing Ethereum Transaction Attempts
       bridges         Commands for Bridges communicating with External Adapters
       config          Commands for the node's configuration
       job_specs       Commands for managing Job Specs (jobs V1)
       jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json,

:::NEXT DOC:::

All jobs with this EI configured will then be kicked off in
this way. A simple external initiator in psedo code could look like this:


    while(True):
        send_api_call_with_external_initiator_access_key_headers()
        sleep(4)

And have this job run on the same machine as your node.

## What's next

  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/building-external-initiators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the GET>bool function in the given text?,"To perform an HTTP GET request to any public API, parse the response, and return a boolean value.",{'source': 'https://docs.chain.link/any-api/testnet-oracles/'},"The given text does not mention a ""GET>bool function.""","GET to any public API parse the response return a boolean bool. The job specs can be found here                                                     | Http JsonParse Ethabiencode          | c1c5e92880894eb6b27d3cae19670aa3 | get: stringpath: JSONPath expression with comma(,) delimited string           |
| GET>string: HTTP GET to any public API parse the response return a sequence of characters string. The job specs can be found here                                  | Http JsonParse Ethabiencode          | 7d80a6386ef543a3abb52817f6707e3b | get: stringpath: JSONPath expression with comma(,) delimited string           |
### Examples

#### Get > bytes

A full example can be found [here](/any-api/get-request/examples/large-responses).

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('7da2702f37fd48e5b1b9a5715e3509b6', address(this), this.fulfill.selector);
      req.add(
          'get',
          'https://ipfs.io/ipfs/QmZgsvrA1o1C8BGCrx6mHTqR1Ui1XqbCrtbMVrRLHtuPVD?filename=big-api-response.json'
      );
     

:::NEXT DOC:::

Question: (Asked on: 2022-09-12 20:50:02)
Convert uint value from chainlink VRF to boolean SOLIDITY
URL: https://stackoverflow.com/questions/73695116/convert-uint-value-from-chainlink-vrf-to-boolean-solidity

Question Body:


I am writing a coin toss contract using Chainlink VRF to request a random
number. When using chainlink, the random number generated is a uint. I am
trying to convert such uint into a boolean value to obtain whether 0 for heads
or 1 for tails.

I have already managed to obtain the random number and transform it into 0 or
1 using modulo (%). But the number I get is still a uint. How can I convert it
to a boolean value?

    
    
            struct round {
               uint roundId;
               uint betAmount;
               bool playerChoice; // 0 = heads; 1 = tails
               bool draw;
               bool win; 
            }
        
            function fulfillRandomWords(
                uint256, /* requestId */
                uint256[] memory randomWords
            ) internal override {
    
    // this where I get the error ""TypeError: Type uint256 is not implicitly convertible to expected type bool.""
               

:::NEXT DOC:::

a value. For nested mappings, we have boxes with labels (the addresses); inside each box, there are more little boxes using a uint as a label. If we open one of them, we will find a boolean.

To set the value of a nested array, we must provide the address and the uint which works like an index.

<Highlight class=""language-javascript"">
function set(address \_address, uint \_index, bool \_foo) public {
  nestedMapping[\_address][\_index] = \_foo;
}
</Highlight>

Retrieving a value works just as easy. We only need to provide the two keys (\_address and \_index):

<Highlight class=""language-javascript"">
function get(address \_address, uint \_index) public view returns (bool) {
  return nestedMapping[\_address][\_index];
}
</Highlight>

The same rules as for non-nested mappings apply here. We do not need to define a get function for nested functions. Solidity does this for us. And if the value does exist, we will simply get a default value.


:::NEXT DOC:::

                  | Http JsonParse Ethabiencode          | 7da2702f37fd48e5b1b9a5715e3509b6 | get: stringpath: JSONPath expression with comma(,) delimited string           |
| GET>uint256: HTTP GET to any public API parse the reponse multiply the result by a multiplier return an unsigned integer uint256 . The job specs can be found here | Http JsonParse Multiply Ethabiencode | ca98366cc7314957b8c012c72f05aeeb | get: stringpath: JSONPath expression with comma(,) delimited stringtimes: int |
| GET>int256: HTTP GET to any public API parse the response multiply the result by a multiplier return a signed integer int256. The job specs can be found here      | Http JsonParse Multiply Ethabiencode | fcf4140d696d44b687012232948bdd5d | get: stringpath: JSONPath expression with comma(,) delimited stringtimes: int |
| GET>bool: HTTP GET to any public API parse the response return a boolean bool. The job specs can be found here                                                     | Http JsonParse Ethabiencode          | c1c5e92880894eb6b27d3cae19670aa3 | get: stringpath: JSONPath expression with comma(,) delimited string           |
| GET>string: HTTP GET to any public API parse the response return a sequence of characters string. The job specs can be found here                        

:::NEXT DOC:::

on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>

This creates a variable called “myFavNum” and assigns it the type uint, or unsigned integer. Now we can use myFavoriteNumber to store numbers like 0,1,2,3,4…etc. in our contract. 


:::NEXT DOC:::

                                                                                                   | Tasks                                | Job ID                           | Required Parameters                                                           |
|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------|:---------------------------------|:------------------------------------------------------------------------------|
| GET>bytes: HTTP GET to any public API parse the response return arbitrary-length raw byte data bytes. The job specs can be found here                              | Http JsonParse Ethabiencode          | 7da2702f37fd48e5b1b9a5715e3509b6 | get: stringpath: JSONPath expression with comma(,) delimited string           |
| GET>uint256: HTTP GET to any public API parse the reponse multiply the result by a multiplier return an unsigned integer uint256 . The job specs can be found here | Http JsonParse Multiply Ethabiencode | ca98366cc7314957b8c012c72f05aeeb | get: stringpath: JSONPath expression with comma(,) delimited stringtimes: int |
| GET>int256: HTTP GET to any public API parse the response

:::NEXT DOC:::

bool playerChoice; // 0 = heads; 1 = tails
               bool draw;
               bool win; 
            }
        
            function fulfillRandomWords(
                uint256, /* requestId */
                uint256[] memory randomWords
            ) internal override {
    
    // this where I get the error ""TypeError: Type uint256 is not implicitly convertible to expected type bool.""
                myRound.draw = (randomWords[0] % 2); 
            }
    

Thanks for the help guys!



Answers:
(Answered on: 2022-09-12 21:46:36)


You can compare the resulting value with 0 or 1.

    
    
    // comparison returns a bool
    myRound.draw = (randomWords[0] % 2) == 1;
    





:::NEXT DOC:::

how
to make an HTTP GET request and parse the _json_ response to retrieve the
value of one single attribute.

### Multi-Variable Responses

This [guide](/any-api/get-request/examples/multi-variable-responses) explains
how to make an HTTP GET request and parse the _json_ response to retrieve the
values of multiple attributes.

### Fetch data from an Array

This [guide](/any-api/get-request/examples/array-response) explains how to
make an HTTP GET request that returns a _json_ array and parse it to retrieve
the target element's value.

### Large Responses

This [guide](/any-api/get-request/examples/large-responses) explains how to
make an HTTP Get request that returns a _json_ containing an arbitrary-length
raw byte data and parse it to return the data as _bytes_ data type.

### Make an Existing Job Request

This [guide](/any-api/get-request/examples/existing-job-request) explains how
to call a job that leverages [External adapters](/chainlink-nodes/external-adapters/external-adapters/) and returns the relevant data to the smart
contract. This allows building succinct smart contracts that do not need to
comprehend the URL or the response format of the target API.

## What's next

  * [› Single Word Response](/any-api/get-request/examples/single-word-response/)
  * [› Multi-Variable Responses](/any-api/get-request/examples/multi-variable-responses/)
  * [› Fetch data from an Array](/any-api/get-request/examples/array-response/)
  * [› Large Responses](/any-api/get-request/examples/large-responses/)
  * [› Make an Existing Job Request](/any-api/get-request/examples/existing-job-request/)
  * [›

:::NEXT DOC:::

value of `market` should be a `byets32` reprsenting ""CCCAGG"" as shown in
the API. But what I got was just `0x0...00` all the time, which means `market`
has not been modified yet. I've checked this various ways and found out that
the `fulfill` function never get rans. Then same thing happens when I changed
the `jobId` and `oracle` to handle `get-> int256`, `get -> bool` (of course I
did change the return type of the variable such that it's consistent with the
returning form of API). I also noticed that only the job `get -> uint256`
works well (the example from documentation also used this job). Does anyon
know why? Was my code wrong or the problem came from the node/job? Since I was
able the get the example right, I don't think the problem cam from my wallet.

Any help would be appreciated!



Answers:
(Answered on: 2022-08-10 09:12:51)


You can test with a GET>STRING JOB

  1. Go to this link: <https://docs.chain.link/docs/any-api-testnet-oracles/>
  2. Take the Oracle contract address relevant to your network. For instance: 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 for Goerli
  3. Use a Get>String job: 7d80a6386ef543a3abb52817f6707e3b

Make sure that your callback function expects to receive a string. (see a full
example here: <https://docs.chain.link/docs/api-array-response/>)





:::NEXT DOC:::

         |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                                                                             |
| HTTP GET Element in Array Response | This guide explains how to make an HTTP GET request that returns a json array and parse it to retrieve the target element's value.                                                                                                                         |
| HTTP GET Large Reponses            | This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.                                                                                   |
| Existing Job Request              "
What is the purpose of this contract?,This is an example contract which uses hardcoded values for clarity. It uses un-audited code. Do not use this code in production.,{'source': 'https://docs.chain.link/getting-started/advanced-tutorial/'},"There is no specific contract mentioned in the given context information. The first chapter discusses agreements and contracts in general, while the fourth chapter discusses the benefits of smart contracts.","fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as

:::NEXT DOC:::

as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting

:::NEXT DOC:::

#####Chapter 4:

# Smart Contracts - The Future

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Check out this video on what smart contracts are and how they are changing the nature of agreements and the Internet. 
    </div>
  </div>
</ContentWrapp>

<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/Un7-hW6GAec"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>

Smart contracts result from the evolution of digital agreements. A smart contract is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract

:::NEXT DOC:::

is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract isn’t immediately executed after the conditions have been met. Rather, a lengthy review process is initiated and it could take months, even years before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial

:::NEXT DOC:::

before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial crisis were programmed as smart contracts, they would be completely transparent and any member of the public would have had the ability to audit them.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>


:::NEXT DOC:::

#####Chapter 4:

# Naming a Contract

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     There is a better way where you do not need to trust anyone and you can get full control and ownership. Emphasize freedom (sharing, exhibitions and owning). 
    </div>
  </div>
</ContentWrapp> -->

Now we will give our smart contract a name. The classic first programming exercise is called “HelloWorld” but this is Web3 so lets call it “HelloWeb3”. To name a contract, you type the keyword <Highlight class=""language-javascript"">contract</Highlight> followed by the name. You then put a set of curly braces beside it. Here’s an example: 

<Highlight class=""language-javascript"">
contract HelloWeb3{

}

</Highlight>

Everything within the curly braces is considered part of the HelloWeb3 smart contract. Try completing the contract on the right with the name “HelloWeb3”.




:::NEXT DOC:::

Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!


:::NEXT DOC:::

or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

   </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Trust Minimization</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.
          <b>Example</b>: Robinhood can no longer stop people from trading Gamestop, unless it is coded into the agreement.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label"">Efficiency:</p>
    <ul class=""list__items"">
      <li class=""list__item"">
    "
What is the purpose of OpenSSL in generating self-signed certificates for Chainlink node?,OpenSSL is needed to generate self-signed certificates for Chainlink node.,{'source': 'https://docs.chain.link/chainlink-nodes/resources/enabling-https-connections/'},The purpose of OpenSSL in generating self-signed certificates for Chainlink node is to enable HTTPS connections.,"# Enabling HTTPS Connections

  * Overview

This guide will walk you through how to generate your own self-signed
certificates for use by the Chainlink node. You can also substitute self-
signed certificates with certificates of your own, like those created by
[Let's Encrypt](https://letsencrypt.org/).

TLS

You will need [OpenSSL](https://www.openssl.org) in order to generate your own
self-signed certificates.

Create a directory `tls/` within your local Chainlink directory:


    mkdir ~/.chainlink-sepolia/tls


    mkdir ~/.chainlink-goerli/tls


    mkdir ~/.chainlink/tls

Run this command to create a `server.crt` and `server.key` file in the
previously created directory:


    openssl req -x509 -out  ~/.chainlink-sepolia/tls/server.crt  -keyout ~/.chainlink-sepolia/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink-goerli/tls/server.crt  -keyout ~/.chainlink-goerli/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf

:::NEXT DOC:::

-nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink-goerli/tls/server.crt  -keyout ~/.chainlink-goerli/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink/tls/server.crt  -keyout ~/.chainlink/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")

Next, add the `TLS_CERT_PATH` and `TLS_KEY_PATH` environment variables to your
`.env` file.


    echo ""TLS_CERT_PATH=/chainlink/tls/server.crt
   

:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.





:::NEXT DOC:::

 -keyout ~/.chainlink/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")

Next, add the `TLS_CERT_PATH` and `TLS_KEY_PATH` environment variables to your
`.env` file.


    echo ""TLS_CERT_PATH=/chainlink/tls/server.crt
    TLS_KEY_PATH=/chainlink/tls/server.key"" >> .env

If `CHAINLINK_TLS_PORT=0` is present in your `.env` file, remove it by
running:


    sed -i '/CHAINLINK_TLS_PORT=0/d' .env

Also remove the line that disables `SECURE_COOKIES` by running:


    code"": ""sed -i '/SECURE_COOKIES=false/d' .env

Finally, update your run command to forward port 6689 to the container instead
of 6688:


    cd ~/.chainlink-sepolia && docker run -p 6689:6689 -v ~/.chainlink-sepolia:/chainlink -it
    --env-file=.env smartcontract/chainlink local n


    cd ~/.chainlink-goerli && docker run -p 6689:6689 -v ~/.chainlink-goerli:/chainlink -it
    --env-file=.env smartcontract/chainlink local n


    cd ~/.chainlink && docker run -p 6689:6689 -v ~/.chainlink:/chainlink -it

:::NEXT DOC:::

have SSL enabled, you can specify `disable` so that you don't need to go through the process of configuring SSL on your database. On a production node, set this value to `require` or `verify-full`. This requires an encrypted connection between your Chainlink node and the database. See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/libpq-ssl.html#LIBPQ-SSL-PROTECTION) to learn about the available SSL modes.

## What's next

  * [› Configuring Chainlink](/chainlink-nodes/v1/configuration)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/resources/connecting-to-a-remote-database.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

  | X      | X     | X      | X       |
| Create keys (CSA,ETH,OCR(2),P2P,Solana,Terra) | nan    | nan   | X      | X       |
| Delete keys (CSA,ETH,OCR(2),P2P,Solana,Terra) | nan    | nan   | nan    | X       |
| Import keys (CSA,ETH,OCR(2),P2P,Solana,Terra) | nan    | nan   | nan    | X       |
| Export keys (CSA,ETH,OCR(2),P2P,Solana,Terra) | nan    | nan   | nan    | X       |
| List jobs                                     | X      | X     | X      | X       |
| View job                                      | X      | X     | X      | X       |
| Create job                                    | nan    | nan   | X      | X       |
| Delete job                                    | nan    | nan   | X      |

:::NEXT DOC:::

     |
| validateChainlinkCallback    | Secures the fulfillment callback to make sure it is only called by permissioned senders                                        |
| addChainlinkExternalRequest  | Allows a Chainlinked contract to track unfulfilled requests that it hasn't created itself                                      |
| cancelChainlinkRequest       | Cancels Chainlink requests attempting to contact an unresponsive node                                                          |
| useChainlinkWithENS          | Looks up the addresses of the LINK token and Oracle contract through ENS                                                       |
| updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS                                                 |
| chainlinkTokenAddress        | Returns the stored address of the LINK token                                                                           

:::NEXT DOC:::

Question: (Asked on: 2021-11-17 16:19:51)
authorization for chainlink node v2 api
URL: https://stackoverflow.com/questions/70008002/authorization-for-chainlink-node-v2-api

Question Body:


i'd like to work with the chainlink v2 api to automatically adding jobs after
creating a chainlink node. using curl this works well for health

    
    
    curl localhost:6688/health
    

but not for protected endpoints like

    
    
    curl localhost:6688/v2/jobs
    

which returns {""errors"":[{""detail"":""Authentication failed""}]}

what is the auth implemented for the chainlink node? tried basic auth with
curl using the node admin credentials which didn't help...



Answers:
(Answered on: 2021-11-17 17:37:19)


chainlink node auth can be done via sessions.

  1. use curl with session endpoint to create cookie
  2. use the cookie to authorize endpoint access

to create a cookie in file ./cookie

    
    
    export USERNAME=<chainlink admin user name>
    export PASSWORD=<chainlink admin user password>
    curl -c ./cookie -H 'Content-Type: application/json' -d '{""email"":""'${USERNAME}'"", ""PASSWORD"":""'${PASSWORD}'""}' localhost:6688/sessions
    

the cookie can now be used to access protected api endpoints

    
    
    curl -b ./cookie -c ./cookie localhost:6688/v2/jobs
    





:::NEXT DOC:::

#####Chapter 2:

# Randomness and Blockchains

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Upon research, you realize popular languages like Javascript have built-in randomness functions maybe you can use something like that in Solidity? 
    </div>
  </div>
</ContentWrapp>

Blockchains are deterministic, meaning that any computations that use blockchains must have predictable outcomes. This so all of the nodes that run the blockchain can come to an agreement on what the blockchain is. But deterministic runs counter to random. If everyone knows what the next hand of poker will be before it is dealt it wouldn’t be considered random. So if randomness is impossible on a blockchain, how can we bring the awesome powers of smart contracts to any applications that need randomness?

We could get the randomness from an outside resource! But it can’t be a trusted centralized service (as discussed in Chainlink 101), or we would be ruining the decentralized properties of blockchains and smart contracts. And it would be great if it could be verified that the number wasn’t tampered with and is genuinely random. This is a perfect example of where a decentralized oracle network powered by Chainlink could be used!


:::NEXT DOC:::

capability. I'm not sure why
they didn't do this after their Town Crier acquisition, seemed like the
natural thing to do.


---
(Answered on: 2021-10-28 20:46:24)


Ideally, you'd not want to put your API keys on-chain at all, but here are
your options for working with sensitive data with a Chainlink oracle.

## 1\. Pass your API key to a node operator

This of course, this a trusted operation since you'll have to trust the node
operator with your key. However, this will prevent the world from seeing your
key, and the node operator can just use it on the backend.

## 2\. Encrypt your key before you use it

You'll will still need to give the Chainlink node operators a way to decrypt
the data on the back end, and this is considered less safe because you're
still giving people a way to access your data, and you're putting it on-chain.

## 3\. Make a protected API that can only be called by node operators.

So you'd run an API that wraps around another API.

## 4\. DECO (not live yet)

There are plans to have DECO come out at some time which will help keep
private data safe even from Chainlink node operators.



"
What are some improvements and changes introduced in Chainlink VRF v2?,"Chainlink VRF v2 includes improvements such as subscription management, variable callback gas limit, more configuration capability, multiple random outputs in a single request, and unified billing.",{'source': 'https://docs.chain.link/vrf/v2/subscription/migration-from-v1/'},"Chainlink VRF v2 introduces improvements such as a Subscription Manager for pre-funding multiple requests for randomness, variable callback gas limit, more configuration capability, multiple random outputs in a single request, and unified billing. It also allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance. The VRF Wrapper contracts in VRF v2 allow requesting multiple random numbers in a single on-chain transaction, which reduces gas costs. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain used. The range of block confirmations before verifiable randomness is generated and delivered on-chain can be defined from 3 to 200 blocks.","# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered

:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparison between VRF v1 and VRF v2 (Direct funding method)
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparison between VRF v1 and VRF v2 (Direct funding method)

The main similarity between VRF v1 and VRF v2 Direct funding method is that
consuming contracts must be funded with LINK to pay for requests. However,
Chainlink VRF v2 includes several improvements.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper

:::NEXT DOC:::

page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)



:::NEXT DOC:::

subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a

:::NEXT DOC:::

The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper contracts](/vrf/v2/direct-funding/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

## Updating your applications to use VRF v2

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) guide for an example.

  1. Import and inherit the new [`VRFV2WrapperConsumerBase.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  2. Add a `VRFV2WrapperConsumerBase` constructor as shown in the [Get a Random

:::NEXT DOC:::

                           | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

                                                                 | No refunds for overpayment after requests are completed                                                                                                                                                     |
| Flexible funding method first introduced in VRF v2. Compare the VRF v2 subscription method to VRF v1.                                                                  | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)


:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription

:::NEXT DOC:::

your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  2. Import the new [`VRFConsumerBaseV2.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  3. Import the [`VRFCoordinatorV2Interface.sol` interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol). This interface includes the new `requestRandomWords` function.

  4. Add a `VRFConsumerBaseV2` constructor as shown in the [Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number) example.

  5. Change `requestRandomness` function calls to `requestRandomWords`. The `requestRandomWords` function requires several additional parameters.

  6. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the

:::NEXT DOC:::

                                       |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4                         |
| VRF Coordinator       | 0x41034678D6C633D8a95c75e1138A360a28bA15d1                         |
| 2 gwei Key Hash       | 0x08ba8f62ff6c40a58877a106147661db43bc58dabfb814793847a839aa03367f |
| 30 gwei Key Hash      | 0x72d2b016bb5b62912afea355ebf33b91319f828738b111b723b78696b9847b63 |
| 150 gwei Key Hash     | 0x68d24f9a037a649944964c2a1ebd0b2918f4a243d2a99701cc22b548cf2daff0 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                           "
What are some improvements in Chainlink VRF v2 compared to VRF v1 Direct funding method?,"Chainlink VRF v2 includes improvements such as variable callback gas limit, more configuration capability, and multiple random outputs in a single request.",{'source': 'https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/'},"Chainlink VRF v2 Direct funding method includes improvements such as variable callback gas limit, more configuration capability, and the ability to request multiple random outputs in a single transaction, which reduces gas costs and latency of responses.","# Migrating from VRF v1

  * Overview
  * Comparison between VRF v1 and VRF v2 (Direct funding method)
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparison between VRF v1 and VRF v2 (Direct funding method)

The main similarity between VRF v1 and VRF v2 Direct funding method is that
consuming contracts must be funded with LINK to pay for requests. However,
Chainlink VRF v2 includes several improvements.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper

:::NEXT DOC:::

                           | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered

:::NEXT DOC:::

                                                                 | No refunds for overpayment after requests are completed                                                                                                                                                     |
| Flexible funding method first introduced in VRF v2. Compare the VRF v2 subscription method to VRF v1.                                                                  | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)


:::NEXT DOC:::

# Direct Funding Method

  * Overview
  * VRF direct funding
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to generate random numbers using the _direct funding_
method. This method doesn't require a subscription and is optimal for one-off
requests for randomness. This method also works best for applications where
your end-users must pay the fees for VRF because the cost of the request is
determined at request time.

## VRF direct funding

Unlike the [subscription method](/vrf/v2/subscription), the direct funding
method does not require you to create subscriptions and pre-fund them.
Instead, you must directly fund consuming contracts with LINK tokens before
they request randomness. Because the consuming contract directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed

:::NEXT DOC:::

directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Wrapper (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was

:::NEXT DOC:::

judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                          

:::NEXT DOC:::

page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)



:::NEXT DOC:::

The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper contracts](/vrf/v2/direct-funding/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

## Updating your applications to use VRF v2

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) guide for an example.

  1. Import and inherit the new [`VRFV2WrapperConsumerBase.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  2. Add a `VRFV2WrapperConsumerBase` constructor as shown in the [Get a Random

:::NEXT DOC:::

subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a"
What is Chainlink Functions and what are some use cases for it?,"Chainlink Functions is a platform that enables users to connect to public data sources, transform data, connect to password-protected data sources, connect to external decentralized databases, and fetch data from almost any Web2 system. Some use cases for it include connecting smart contracts to weather statistics for parametric insurance, calculating Twitter sentiment, and fetching data from AWS S3, Firebase, or Google Cloud Storage.",{'source': 'https://docs.chain.link/chainlink-functions/'},"Chainlink Functions is a platform that provides smart contracts with access to a trust-minimized compute infrastructure. It allows smart contracts to send code to a Decentralized Oracle Network (DON), where each DON's oracle runs the same code in a serverless environment. The DON aggregates all the independent runs and returns the final result to the smart contract. Chainlink Functions provides access to off-chain computation without having to run and configure your own Chainlink Node. Some use cases for Chainlink Functions include connecting to any public data, transforming public data before consumption, connecting to password-protected data sources, connecting to external decentralized databases, fetching data from almost any Web2 system, and building low-cost governance voting systems.","# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties

:::NEXT DOC:::

and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to

:::NEXT DOC:::

the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature improvements
along with interface and contract changes. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and add your EVM account address to the allow list.

## Supported networks

See the [Supported Networks](/chainlink-functions/supported-networks) page to
find a list of supported networks and contract

:::NEXT DOC:::

BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature improvements
along with interface and contract changes. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and add your EVM account address to the allow list.

## Supported networks

See the [Supported Networks](/chainlink-functions/supported-networks) page to
find a list of supported networks and contract addresses.

## What's next

  * [› Learn the basics in the Getting Started guide.](/chainlink-functions/getting-started)
  * [› Learn how to use more advanced capabilities in one of the Tutorials.](/chainlink-functions/tutorials)
  * [› Learn about core concepts, the Chainlink Functions architecture, and billing.](/chainlink-functions/resources)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

## Welcome to the Chainlink Documentation

##### New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide.

## Explore our products

#### [Data Feeds](data-feeds)

Decentralized and high-quality data feeds for DeFi, Reserves, NFTs, sports,
weather, and more

###### Available on:

#### [Chainlink Functions](chainlink-functions)

Connect smart contracts to a trust-minimized compute infrastructure running on
a decentralized oracle network

###### Available on:

#### [Automate Contracts](chainlink-automation/introduction)

Decentralized, highly reliable, cost-efficient and highly secure automation
for smart contracts

###### Available on:

#### [VRF v2](/vrf/v2/introduction)

Verifiable, tamper-proof random number generator for blockchain gaming and NFT
projects

###### Available on:

#### [External API Calls](/any-api/introduction)

Request and receive data from any API using the Chainlink contract library

###### Available on:

## Useful resources

### Need to run your own Chainlink Node?

See the Node Operator’s Guide to learn about starting and maintaining
Chainlink Nodes.

#### Watch tutorials

Learn more about the technology we are building. We're constantly uploading
new videos to our YouTube channel.

##### Need integration support?

##### Discord

##### Stack overflow



:::NEXT DOC:::

that may be helpful if you're starting your Chainlink
learning journey or if you're looking for interesting ways to apply Chainlink
to your project:

  * [Two-Minute Explainers](https://www.youtube.com/playlist?list=PLVP9aGDn-X0Q3qBME3T9sBMw66xPsglMA)
  * [Chainlink Developer Workshops](https://www.youtube.com/playlist?list=PLVP9aGDn-X0SPHromvpiGvoNDpH7YErmf)
  * [Chainlink Engineering Tutorials](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J)
  * [Solidity, Blockchain, and Smart Contract Python Course](https://www.youtube.com/watch?v=M576WGiDBdQ)
  * [Chainlink Engineering YouTube](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J)
  * [Dapp University](https://www.youtube.com/watch?v=YLmMNocc1ys)
  * [Austin Griffith](https://www.youtube.com/watch?v=ffU96UhlA0A)
  * [Patrick Collins](https://www.youtube.com/watch?v=p36tXHX1JD8)
  * [Nader Dabit](https://www.youtube.com/watch?v=nS9xP1hxg3w)
  * [Alchemy University](https://university.alchemy.com/)

### Applications

Below is a list of applications of Chainlink's products and services sorted by
difficulty and type to help you navigate and search for projects that you
might find interesting. See the [Chainlink Blog](https://blog.chain.link/) to
stay up to date with new ways to use Chainlink.

#### Data

:::NEXT DOC:::

 * [Austin Griffith](https://www.youtube.com/watch?v=ffU96UhlA0A)
  * [Patrick Collins](https://www.youtube.com/watch?v=p36tXHX1JD8)
  * [Nader Dabit](https://www.youtube.com/watch?v=nS9xP1hxg3w)
  * [Alchemy University](https://university.alchemy.com/)

### Applications

Below is a list of applications of Chainlink's products and services sorted by
difficulty and type to help you navigate and search for projects that you
might find interesting. See the [Chainlink Blog](https://blog.chain.link/) to
stay up to date with new ways to use Chainlink.

#### Data feeds

| Name                                                                                   | Type     | Difficulty   |
|:---------------------------------------------------------------------------------------|:---------|:-------------|
| How to Calculate Price Volatility for DeFi Variance Swaps                              | DeFi     | Advanced     |
| Build a dApp on Gnosis Chain (xDai) with Secure Data Feeds                             | DeFi     | Medium       |
| Craft Whiskey Crypto Payments With Chainlink Oracles                                   | Payments | Advanced     |
| Convert a Vending

:::NEXT DOC:::

# Chainlink Functions Concepts

  * Overview
  * Request and Receive Data
  * Decentralized Oracle Network (DON)
  * Subscriptions

_Chainlink Functions_ do not require your consumer contracts to hold LINK
tokens and send them to oracles when making requests. Instead, you must create
a subscription account and fund it to pre-pay for your _Chainlink Functions_
requests, so your consumer contracts don't need to hold LINK when calling
_Chainlink Functions_.

Before you explore how Chainlink Functions works in the
[Architecture](/chainlink-functions/resources/architecture) guide, it is best
to understand the core concepts in this guide.

## Request and Receive Data

This model is similar to the [Basic Request Model](/architecture-overview/architecture-request-model): Consumer contracts initiate the cycle by
creating requests to Functions Oracle contracts. Oracle nodes watch for events
emitted by the [Functions Oracle
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsOracle.sol)
and run the computation off-chain. Finally, oracle nodes use the [Chainlink
OCR](/architecture-overview/off-chain-reporting) protocol to aggregate all the
responses before passing the aggregated responses to the consumer contracts in
callbacks. Note: As long as you use vanilla Node.js (no modules imports), you
can decentralize any computation you want such as API calls, computing maths
operations, etc.

## Decentralized Oracle Network (DON)

_Chainlink Functions_ are powered by a [Decentralized Oracle
Network](https://chain.link/education/blockchain-oracles#decentralized-oracles). The oracle nodes are independent of each other and are responsible
for running the same function such as API calls, computing maths

:::NEXT DOC:::

in our
previous hackathons. There is also a link to the Marketplace where you can
find the latest data provider nodes and explore the network.

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past Hackathon Winning Projects](/resources/example-projects)

## Outreach

The Chainlink community is an inviting group of engineers that is always
looking to help users expand their knowledge on Chainlink and solve related
issues. Refer back to the [Getting Help](/resources/getting-help) page for the
latest information about how to get support.

### Get support

  * [Stack Overflow](https://stackoverflow.com/questions/tagged/chainlink)
  * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

### Join the community

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/other-tutorials.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform. Finally, with Chainlink, developers can build smart contracts that can interact with the outside world to preserve the decentralized nature of smart contracts.

<Spacer>

## How Chainlink Works

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      Curious how Chainlink works? Read below! With Chainlink, any type of data the exists can be brought on chain, and the conditions on which that data is delivered can be customized! 
    </div>
  </div>
</ContentWrapp>

Chainlink allows developers to build and customize DONs. Chainlink allows DONs to work and assures that node operators are incentivized not to collude or act"
What is the purpose of the AggregatorV3Interface contract?,"The AggregatorV3Interface contract is used to get data from a specific round or the latest round of an aggregator, and to get the number of decimals and description of the aggregator.",{'source': 'https://docs.chain.link/data-feeds/api-reference/'},The purpose of the AggregatorV3Interface contract is to retrieve data feeds through the proxy address and to run functions in the proxy contract. It is used to get information about the aggregator behind the proxy.,"# Data Feeds API Reference

  * Overview
  * AggregatorV3Interface
  * Functions in AggregatorV3Interface
  * AccessControlledOffchainAggregator
  * Variables and functions in AccessControlledOffchainAggregator

When you use data feeds, retrieve the feeds through the
`AggregatorV3Interface` and the proxy address. Optionally, you can call
variables and functions in the `AccessControlledOffchainAggregator` contract
to get information about the aggregator behind the proxy.

## AggregatorV3Interface

Import this interface to your contract and use it to run functions in the
proxy contract. Create the interface object by pointing to the proxy address.
For example, on Sepolia you could create the interface object in the
constructor of your contract using the following example:


    /**
     * Network: Sepolia
     * Data Feed: ETH/USD
     * Address: 0x694AA1769357215DE4FAC081bf1f309aDC325306
     */
    constructor() {
      priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
    }
    

To see examples for how to use this interface, read the [Using Data
Feeds](/data-feeds/price-feeds) guide.

You can see the code for the [`AggregatorV3Interface`
contract](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
on GitHub.

### Functions in AggregatorV3Interface

| Name            | Description                                          

:::NEXT DOC:::

so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility Feeds](/data-feeds/rates-feeds)
documentation.

See the [Rate and Volatility Contract Addresses](/data-feeds/rates-feeds/addresses) page for a list of available networks and addresses.

### L2 sequencer uptime feeds

L2 sequencer feeds track the last known status of the sequencer on an L2
network at a given point in time. This helps you prevent mass liquidations by
providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds feeds, see the [L2 Sequencer
Uptime Feeds](/data-feeds/l2-sequencer-feeds) documentation.

## Components of a data feed

Data Feeds are an example of a decentralized oracle network and include the
following components:

  * **Consumer** : A consumer is an on-chain or off-chain application that uses Data Feeds. Consumer contracts use the [`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) to call functions on the proxy contract and retrieve information from the

:::NEXT DOC:::

are on-chain proxies that point to the aggregator for a
particular data feed. Using proxies enables the underlying aggregator to be
upgraded without any service interruption to consuming contracts.

Proxy contracts can vary from one data feed to another, but the
[`AggregatorProxy.sol`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol)
on Github is a common example.

### Aggregator

An aggregator is the contract that receives periodic data updates from the
oracle network. Aggregators store aggregated data on-chain so that consumers
can retrieve it and act upon it within the same transaction.

You can access this data using the Data Feed address and the
[`AggregatorV3Interface`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol).

Aggregators receive updates from the oracle network only when the **Deviation
Threshold** or **Heartbeat Threshold** triggers an update during an
aggregation round. The first condition that is met triggers an update to the
data.

  * Deviation Threshold: A new aggregation round starts when a node identifies that the off-chain values deviate by more than the defined deviation threshold from the on-chain value. Individual nodes monitor one or more data providers for each feed.
  * Heartbeat Threshold: A new aggregation round starts after a specified amount of time from the last update.

## What's next

  * [› Using Data Feeds](/data-feeds/price-feeds/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page

:::NEXT DOC:::

contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First

:::NEXT DOC:::

contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First

:::NEXT DOC:::

   }
    

To see examples for how to use this interface, read the [Using Data
Feeds](/data-feeds/price-feeds) guide.

You can see the code for the [`AggregatorV3Interface`
contract](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
on GitHub.

### Functions in AggregatorV3Interface

| Name            | Description                                                          |
|:----------------|:---------------------------------------------------------------------|
| decimals        | The number of decimals in the response.                              |
| description     | The description of the aggregator that the proxy points to.          |
| getRoundData    | Get data from a specific round.                                      |
| latestRoundData | Get data from the latest round.                                      |
| version         | The version representing the type of aggregator the proxy points to. |
#### decimals

Get the number of decimals present in the response value.


    function decimals() external view returns (uint8);

  * `RETURN`: The number of decimals.

#### description

Get the description of the underlying

:::NEXT DOC:::

Question: (Asked on: 2022-01-12 14:26:52)
How can I import AggregatorV3Interface
URL: https://stackoverflow.com/questions/70683276/how-can-i-import-aggregatorv3interface

Question Body:


**I'm trying to import AggregatorV3 but the file is nowhere to be found here
is my code; I'm sorry in advance i'm still a beginner programmer.**

    
    
    //SPDX-License-Identifier: MIT
    pragma solidity ^0.8.9;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract Lottery {
        address payable[] public players; //to keep track of all players, payable array
        uint256 public usdEntryFee;
        AggregatorV3Intefrace internal ethUsdPriceFeed;
    
        constructor(address _priceFeedAddress) public {
            usdEntryFree = 50 * (10**18);
            ethUsdPriceFeed = AggregatorV3Interface(_priceFeedAddress); //we need to pass the address of aggv3 in constructor
        }
    
        function enter() public payable {
            //payable since we want them to pay in eth
            //50 $ minimum
            players.push(msg.sender);
        }
    
        function getEntranceFee() public view returns (uint256)

:::NEXT DOC:::

provides. Depending on the feed you selected, this answer provides asset prices, reserves, NFT floor prices, and other types of data.
  * `startedAt`: Timestamp of when the round started.
  * `updatedAt`: Timestamp of when the round was updated.
  * `answeredInRound`: The round ID of the round in which the answer was computed.

#### version

The version representing the type of aggregator the proxy points to.


    function version() external view returns (uint256)

  * `RETURN`: The version number.

## AccessControlledOffchainAggregator

This is the contract for the aggregator. You can call functions on the
aggregator directly, but it is a best practice to use the
AggregatorV3Interface to run functions on the proxy instead so that changes to
the aggregator do not affect your application. Read the aggregator contract
only if you need functions that are not available in the proxy.

The aggregator contract has several variables and functions that might be
useful for your application. Although aggregator contracts are similar for
each data feed, some aggregators have different variables. Use the
`typeAndVersion()` function on the aggregator to identify what type of
aggregator it is and what version it is running.

Always check the contract source code and configuration to understand how
specific data feeds operate. For example, the [aggregator contract for BTC/USD
on
Arbitrum](https://arbiscan.io/address/0x942d00008d658dbb40745bbec89a93c253f9b882#code)
is different from the aggregators on other networks.

For examples of the contracts that are typically used in aggregator
deployments, see the [libocr
repository](https://github.com/smartcontractkit/libocr/blob/master/contract/)
on GitHub.

### Variables and functions in AccessControlledOffchainAggregator

This contract

:::NEXT DOC:::

Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
    

:::NEXT DOC:::

within the smart
contract of a new token. Before deployment, there is no way of knowing the new
token's address. I would like to change the address using the OpenZeppelin
upgradable contract under the UUPS proxy pattern.

Is there any example online to update

> priceFeed =
> AggregatorV3Interface(0x9326BFA02ADD2366b30bacB125260Af641031331); // Kovan
> Testnet

on version 2 of the smart contract?

Thank you!

Important Links:  
[OpenZeppelin Contracts Wizard](https://wizard.openzeppelin.com/)  
[get-the-latest-price using Chainlink's
AggregatorV3Interface](https://docs.chain.link/docs/consuming-data-feeds/)  
[Deploying an UUPS Upgradable
Contract](https://www.youtube.com/watch?v=kWUDTZhxKZI)  

I have no idea how to work on version 2 of an UUPS Upgradable Contract.

This is where I got stuck using Chainlink's AggregatorV3Interface.sol with
every feature selected on OpenZeppelin Contracts Wizard:

> // SPDX-License-Identifier: MIT pragma solidity ^0.8.4;
>
> import ""./@openzeppelin/contracts-
> upgradeable/token/ERC20/ERC20Upgradeable.sol""; import
> ""./@openzeppelin/contracts-
> upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol""; import
> ""./@openzeppelin/contracts-
> upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol""; import
> ""./@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
> import ""./@openzeppelin/contracts-
> upgradeable/security/PausableUpgradeable.sol"";"
What is the purpose of the HTTPGet adapter?,The HTTPGet adapter is used to make a GET request to a specified URL and return the response body.,{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/'},"The context information does not provide a clear answer to this question as it mentions multiple guides and tutorials related to HTTP GET requests and external adapters. It is possible that the HTTPGet adapter is used to make HTTP GET requests and retrieve data from external APIs, but more information is needed to confirm this.","is a RunLog. This means
that the spec can only be started when a specific event log is emitted from a
specified address. The specified address will be the address of the oracle
contract on Ropsten, which manages requests from contracts and responses from
Chainlink nodes.

The five tasks (referred to as [core adapters](/chainlink-nodes/oracle-jobs/v1/adapters)) in the example above follow a common pattern for requesting
data from the Chainlink network, and returning a single result. Each task
takes three fields: `type`, `confirmations`, and `params`. The `type` is the
adapter or [bridge](/resources/glossary/#bridge) name and is required.
`confirmations` is optional, and will default to 0. `params` is also optional,
and will default to an empty object if not specified. See the [core
adapters](/chainlink-nodes/oracle-jobs/v1/adapters) page for a complete list
of `params` for each adapter.

  1. The **HTTPGet** adapter uses the value in the `get` field to perform a standard HTTP GET request at the value specified. The body of that result is passed on to the next task, JSONParse.
  2. The **JSONParse** adapter takes a dot-delimited string or an array of strings, and will walk the given path to store the value at the end. In this case, there is only one field to save, ""last"". JSONParse will then pass the value stored in the ""last"" field to the Multiply adapter.
  3. The **Multiply** adapter will, as its name describes, multiply the given value by the value of the `times` field, in this case, 100.
  4. The multiplied value will be passed to the **EthUint256** adapter, which will format it specifically for the `uint256` data type on Ethereum. Notice there are no parameters supplied to the EthUint256 adapter, as it

:::NEXT DOC:::

         |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                                                                             |
| HTTP GET Element in Array Response | This guide explains how to make an HTTP GET request that returns a json array and parse it to retrieve the target element's value.                                                                                                                         |
| HTTP GET Large Reponses            | This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.                                                                                   |
| Existing Job Request              

:::NEXT DOC:::

how
to make an HTTP GET request and parse the _json_ response to retrieve the
value of one single attribute.

### Multi-Variable Responses

This [guide](/any-api/get-request/examples/multi-variable-responses) explains
how to make an HTTP GET request and parse the _json_ response to retrieve the
values of multiple attributes.

### Fetch data from an Array

This [guide](/any-api/get-request/examples/array-response) explains how to
make an HTTP GET request that returns a _json_ array and parse it to retrieve
the target element's value.

### Large Responses

This [guide](/any-api/get-request/examples/large-responses) explains how to
make an HTTP Get request that returns a _json_ containing an arbitrary-length
raw byte data and parse it to return the data as _bytes_ data type.

### Make an Existing Job Request

This [guide](/any-api/get-request/examples/existing-job-request) explains how
to call a job that leverages [External adapters](/chainlink-nodes/external-adapters/external-adapters/) and returns the relevant data to the smart
contract. This allows building succinct smart contracts that do not need to
comprehend the URL or the response format of the target API.

## What's next

  * [› Single Word Response](/any-api/get-request/examples/single-word-response/)
  * [› Multi-Variable Responses](/any-api/get-request/examples/multi-variable-responses/)
  * [› Fetch data from an Array](/any-api/get-request/examples/array-response/)
  * [› Large Responses](/any-api/get-request/examples/large-responses/)
  * [› Make an Existing Job Request](/any-api/get-request/examples/existing-job-request/)
  * [›

:::NEXT DOC:::

                                      |
| HTTP GET Large Reponses            | This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.                                                                                   |
| Existing Job Request               | This guide explains how to call a job that leverages External adapters and returns the relevant data to the smart contract. This allows building succinct smart contracts that do not need to comprehend the URL or the response format of the target API. |
### Building external adapters

To learn more about building external adapters and adding them to nodes, refer
to the [External Adapters](/chainlink-nodes/external-adapters/external-adapters) documentation.

To understand different use cases for using any API, refer to [Other
Tutorials](/getting-started/other-tutorials).

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› API Reference](/any-api/api-reference/)
  * [› Find Existing Jobs](/any-api/find-oracle/)
  * [› Testnet Oracles](/any-api/testnet-oracles/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/introduction.mdx)
  * [ Join our community

:::NEXT DOC:::

                                                                                                                             |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                                                                                                                             |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                                                                             |
| HTTP GET Element in Array Response | This guide explains how to make an HTTP GET request that returns a json array and

:::NEXT DOC:::

and `times` parameters. These are read by the Tasks in the job to perform correctly. `get` is used by [HTTP](/chainlink-nodes/oracle-jobs/all-tasks/#http-task), `path` is used by [JSON Parse](/chainlink-nodes/oracle-jobs/all-tasks/#json-parse-task) and `times` is used by [Multiply](/chainlink-nodes/oracle-jobs/all-tasks/#multiply-task).
  3. `fulfill` function: This is where the result is sent upon the Oracle Job's completion.

**Note:** The calling contract should own enough LINK to pay the fee, which by
default is 0.1 LINK. You can use [this tutorial](/resources/fund-your-contract) to learn how to fund your contract.

This is an example of a basic HTTP GET request. However, it requires defining
the API URL directly in the smart contract. This can, in fact, be extracted
and configured on the Job level inside the Oracle node. You can follow the
_APIConsumer_ tutorial [here](/any-api/get-request/examples/single-word-response).

### External adapters

If all the parameters are defined within the Oracle job, the only things a
smart contract needs to define to consume are:

  * JobId
  * Oracle address
  * LINK fee
  * Fulfillment function

This will make your smart contract much more succinct. The `requestVolumeData`
function from the code example above would look more like this:


    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
        // Extra parameters don't need to be defined here because they are already defined in the job
    
        return sendChainlinkRequest(req, fee);


:::NEXT DOC:::

Question: (Asked on: 2022-01-02 16:18:48)
Ethereum Chainlink HTTP Get not pinging my HTTP endpoint
URL: https://stackoverflow.com/questions/70557627/ethereum-chainlink-http-get-not-pinging-my-http-endpoint

Question Body:


I am attempting to have my Ethereum smart contract connect to an external HTTP
endpoint using Chainlink. Following along with Chainlink's documentation
(<https://docs.chain.link/docs/advanced-tutorial/>) I deployed this contract
onto the Rinkeby testnet.

    
    
    pragma solidity ^0.8.7;
    
    import ""github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ChainlinkClient.sol"";
    
    // MyContract inherits the ChainlinkClient contract to gain the
    // functionality of creating Chainlink requests
    
    
    contract getHTTP is ChainlinkClient {
      using Chainlink for Chainlink.Request;
    
      bytes32 private thisDoesNotWork;
      address private owner;
      address private ORACLE_ADDRESS = 0x718Cc73722a2621De5F2f0Cb47A5180875f62D60;
      bytes32 private JOBID = stringToBytes32(""86b489ec4d84439c96181a8df7b22223"");
      string private url = ""<myHTTPAddressAsString>""; 
    
    // This endpoint URL is hard coded in my contract, and stored as a string (as in the example code). 
    // I control it and can have it reply with whatever I want, which

:::NEXT DOC:::

input in the data field of the transaction.
  * `dataPrefix`: **(optional)** data which will be prepended before the adapter's input, but after the `functionSelector` in the transaction's data field.
  * `value`: **(optional)** data to send to the function, will append after the `dataPrefix` payload if it's included. Will automatically come from the previous task.

## EthUint256

The core adapter formats its input into an integer and then converts it into
Solidity's `uint256` format.

#### Parameters

_None taken._

## HttpGet

The core adapter will report the body of a successful `GET` request to the
specified `get`, or return an error if the response status code is greater
than or equal to 400.

#### Parameters

  * `get`: takes a string containing the URL to make a `GET` request to.
  * `queryParams`: takes a string or array of strings for the URL's query parameters.
  * `extPath`: takes a slash-delimited string or array of strings to be appended to the job's URL.
  * `headers`: takes a object containing keys as strings and values as arrays of strings.

Headers

Currently not available on-chain. Available for job specs only.

#### Solidity Example


    req.add(""get"", ""http://example.com"");
    req.add(""queryParams"", ""firstKey=firstVal&secondKey=secondVal"");
    req.add(""extPath"", ""price/BTC/USD"");

#### Job Specification Example


    {
      ""type"": ""HttpGet"",
      ""params"": {
        ""get"": ""https://example.com/some-endpoint"",
        ""headers"": {
          ""X-API-Key"":

:::NEXT DOC:::

""1"",
                        ""points"": ""25"",
                        ""Driver"": {
                            ""driverId"": ""max_verstappen"",
                            ""permanentNumber"": ""33"",
                            ""code"": ""VER"",
                            ""url"": ""http://en.wikipedia.org/wiki/Max_Verstappen"",
                            ""givenName"": ""Max"",
                            ""familyName"": ""Verstappen"",
                            ""dateOfBirth"": ""1997-09-30"",
                            ""nationality"": ""Dutch""
                        },.....
    

The full results can be found here.
<http://ergast.com/api/f1/current/last/results.json>

Should I be able to do something like this? Is there a better way to go about
this? Should I edit the adapter instead?

    


:::NEXT DOC:::

IPs are disallowed by default and attempting to connect will result
in an error.

If you really must access one of these IPs, you can use the
`HTTPGetWithUnrestrictedNetworkAccess` adapter instead.

## HttpPost

The core adapter will report the body of a successful `POST` request to the
specified `post`, or return an error if the response status code is greater
than or equal to 400.

#### Parameters

  * `post`: takes a string containing the URL to make a `POST` request to.
  * `headers`: takes a object containing keys as strings and values as arrays of strings.
  * `queryParams`: takes a string or array of strings for the URL's query parameters.
  * `extPath`: takes a slash-delimited string or array of strings to be appended to the job's URL.
  * `body`: the JSON body (as a string) that will be used as the data in the request.

note

#### Solidity Example


    req.add(""post"", ""http://post.example.com"");
    req.add(""queryParams"", ""firstKey=firstVal&secondKey=secondVal"");
    req.add(""extPath"", ""price/BTC/USD"");

#### Job Specification Example


    {
        ""type"": ""HttpPost"",
        ""params"": {
            ""post"": ""https://example.com/some-endpoint"",
            ""headers"": {
                ""X-API-Key"": [
                    ""abc123abc123abc123abc123""
                ]
            }
        }
  "
What is the purpose of the `oracleRequest` function in the `AuthorizedReceiver` contract?,The `oracleRequest` function creates a Chainlink request and assumes that the `callbackAddress` is the same as the request sender.,{'source': 'https://docs.chain.link/chainlink-nodes/contracts/operator/'},"The `oracleRequest` function in the `AuthorizedReceiver` contract creates a Chainlink request and is a legacy API that is backwards compatible with the `Oracle.sol` contracts. It takes in parameters such as the sender of the request, payment amount, job specification ID, callback address, callback function ID, nonce, data version, and extra request parameters.","     requestId,
                payment,
                sender,
                callbackFunctionId,
                expiration,
                dataVersion,
                data
            );
        }
    
    

I removed the `oracleRequest()` function because it exceeds stack size by
adding more modifiers to it and since I can use `operatorRequest()` to fulfill
both multi-word and single-word requests I will make that method deprecated by
reverting everytime it's called.

The modifier that sets the authorized consumer is basically the following:

    
    
        /**
         * @dev function used to change the authorized consumer. Can only be set once
         */
        function setAuthorizedConsumer(address _consumer) public onlyOwner {
            require(
                authorizedConsumer == address(0),
                ""authorized consumer is already set""
            );
            authorizedConsumer = _consumer;
        }
    
        /**
         * @notice validates the consumer is an authorized consumer
         */
       

:::NEXT DOC:::

a secure wallet such as hardware or a multisig wallet as the operator's owner account.

## API Reference

The operator contract inherits
[AuthorizedReceiver](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/AuthorizedReceiver.sol)
and
[ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/edit/develop/contracts/src/v0.7/ConfirmedOwnerWithProposal.sol).
Read [AuthorizedReceiver](/chainlink-nodes/contracts/receiver) and
[ConfirmedOwnerWithProposal](/chainlink-nodes/contracts/ownership) API
references.

### Methods

#### oracleRequest

Legacy

Use `operatorRequest` function instead.


    function oracleRequest(address sender, uint256 payment, bytes32 specId, address callbackAddress, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. This is backwards compatible API with
[Oracle.sol
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol),
but the behavior changes because `callbackAddress` is assumed to be the same
as the request sender.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId       

:::NEXT DOC:::

               uint256 expiration
            ) = _verifyAndProcessOracleRequest(
                    sender,
                    payment,
                    sender,
                    callbackFunctionId,
                    nonce,
                    dataVersion
                );
            emit OracleRequest(
                specId,
                sender,
                requestId,
                payment,
                sender,
                callbackFunctionId,
                expiration,
                dataVersion,
                data
            );
        }
    
    

I removed the `oracleRequest()` function because it exceeds stack size by
adding more modifiers to it and since I can use `operatorRequest()` to fulfill
both multi-word and single-word

:::NEXT DOC:::

sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### fulfillOracleRequest

Legacy

Use `fulfillOracleRequest2` function instead.


    function fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data) external returns (bool)

Called by the Chainlink node to fulfill requests. Given params must hash back
to the commitment stored from `oracleRequest`. Will call the callback address'
callback function without bubbling up error checking in a `require` so that
the node can get paid. Emits OracleResponse event.

##### Parameters

| Name               | Type    | Description                                               

:::NEXT DOC:::

:)

Whilst developing the contract I am working on, I noticed this and wanted to
gain a better understanding as to why the documentation validates a given
request exists before fulfilling it.



Answers:
(Answered on: 2023-05-07 09:49:35)


When the a randomness request is sent from VRFConsumer contract, a new
requestId is generated:

    
    
            requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
    

The contract has a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`.

After the oracle returns the random values to your contract, the mapping
`s_requests` is supposed to be updated, and the `RequestStatus` of a specific
request can be found by a specific `requestId`.

require statement in the fulfillment function is used to check if the
requestId is indeed sent from the vrfConsumer contract.





:::NEXT DOC:::

items:

  * The oracle address.
  * The job ID, so the oracle knows which tasks to perform.
  * The callback function, which the oracle sends the response to.

To learn about how to find oracles to suit your needs, see [Find Existing
Jobs](/any-api/find-oracle).

Oracle contracts are responsible for handling on-chain requests made through
the LINK token, by implementing `onTokenTransfer` as a
[`LinkTokenReceiver`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/LinkTokenReceiver.sol).
Upon execution of this function, the oracle contract **emits an`OracleRequest`
event** containing information about the request. This event is crucial, as it
is monitored by the off-chain oracle node which acts upon it.

#### Fulfillment

For fulfillment, the oracle contract has a `fulfillOracleRequest` function
which is used by the node to fulfill a request once it has the result of the
job. This function returns the result to the `ChainlinkClient` using the
callback function defined in the original request.

### Off-Chain Oracle Node

The off-chain oracle node is responsible for listening for events emitted by
its corresponding on-chain smart contract. Once it detects an `OracleRequest`
event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API,
retrieve some data from it, parse the response, convert the result into
blockchain compatible data, then submit it in a transaction back to the oracle
contract, using the `fulfillOracleRequest` function.

For more information on how to become a node operator, learn how to [run a
Chainlink node](/chainlink-nodes/v1/running-a-chainlink-node).

## Consumer UML

Below is a UML diagram describing the contract structure

:::NEXT DOC:::

function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I am guessing you are currently using the `oracle.sol` and
`ChainlinkClient.sol` in version v0.6. In version v0.6, AFAIK, ChainlinkClient
doesn't not help users to add function selector `oracleRequest` in the users'
Chainlink request, which means you will get the error if you doesn't manually
add the function selector in your request. In v0.7, ChainlinkClient helps you
add the selector in the request. Just check the function
`sendChainlinkRequestTo` in [ChainlinkClient
v0.6](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/ChainlinkClient.sol)
and [ChainlinkClient
v0.7](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/ChainlinkClient.sol)
by yourself.

Solutions:

  1. Use the v0.7 ChainlinkClient and [operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)(smart contract

:::NEXT DOC:::

cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
    
        const encodeRequestId = web3.eth.abi.encodeParameters(
            ['bytes32'],
            [requestId])
            
        await mockOracle.connect(mockNode).fulfillOracleRequest2(requestIdfirst, payment, callbackAddr, callbackFunctionId, cancelExpiration, encodeMwr)

To improve on this you could then look to add an API http GET call into your
test script for getting the rest of the callback data for fulfillOracleRequest
or fulfillOracleRequest2 function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I

:::NEXT DOC:::

the original request.

### Off-Chain Oracle Node

The off-chain oracle node is responsible for listening for events emitted by
its corresponding on-chain smart contract. Once it detects an `OracleRequest`
event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API,
retrieve some data from it, parse the response, convert the result into
blockchain compatible data, then submit it in a transaction back to the oracle
contract, using the `fulfillOracleRequest` function.

For more information on how to become a node operator, learn how to [run a
Chainlink node](/chainlink-nodes/v1/running-a-chainlink-node).

## Consumer UML

Below is a UML diagram describing the contract structure of
`ATestnetConsumer`, a deployed example contract implementing
`ChainlinkClient`.

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-request-model.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

for the response
         * @param nonce The nonce sent by the requester
         * @param dataVersion The specified data version
         * @param data The extra request parameters
         */
        function operatorRequest(
            address sender,
            uint256 payment,
            bytes32 specId,
            bytes4 callbackFunctionId,
            uint256 nonce,
            uint256 dataVersion,
            bytes calldata data
        ) external override validateIsAuthorizedConsumer(sender) validateFromLINK {
            (
                bytes32 requestId,
                uint256 expiration
            ) = _verifyAndProcessOracleRequest(
                    sender,
                    payment,
                    sender,
                    callbackFunctionId,
                    nonce,
                    dataVersion
                );
  "
What is the Chainlink Solana Crate and how can it be used?,The Chainlink Solana Crate is a library that can be imported into an existing project to read Chainlink Data Feed data on-chain. It can be used to query price data by specifying the feed account and the Chainlink Data Feeds OCR2 Program for the network.,{'source': 'https://docs.chain.link/data-feeds/solana/using-data-feeds-solana/'},"The Chainlink Solana Crate is a dependency that can be added to a Rust project's `Cargo.toml` file to enable querying of price data from Chainlink Data Feeds on the Solana network. It can be used by including the Crate in the project's dependencies and using the provided code sample to query price data, passing in the desired feed account and the Chainlink Data Feeds OCR2 Program for the network as parameters.","is the program ID that you use to retrieve Chainlink Price Data on-chain
in your program. The source code for this program is available in the
[smartcontractkit/chainlink-
solana](https://github.com/smartcontractkit/chainlink-solana/tree/develop/contracts/programs/ocr2) repository on GitHub.

You can add data feeds to an existing project or use the Solana Starter Kit.

## Adding Data Feeds On-Chain In An Existing Project

You can read Chainlink Data Feed data on-chain in your existing project using
the [Chainlink Solana Crate](https://crates.io/crates/chainlink_solana).

Reading feed data

Although you can directly query the data feed accounts, you should not rely on
the memory layout always being the same as it currently is. Based on this, the
recommendation is to always use the consumer library queries below.

Import the Chainlink Solana Crate into your project and use the code sample to
make function calls.

  1. Add the Chainlink Solana Crate as an entry in your `Cargo.toml` file dependencies section, as shown in the [starter kit Cargo.toml example](https://github.com/smartcontractkit/solana-starter-kit/blob/main/programs/chainlink_solana_demo/Cargo.toml).
    
        [dependencies]
    chainlink_solana = ""1.0.0""

  2. Use the following code sample to query price data. Each function call to the Chainlink Solana library takes two parameters:

    * The [feed account](/data-feeds/price-feeds/addresses?network=solana) that you want to query.
    * The Chainlink Data Feeds OCR2 Program for the network. This is a static value that never changes.

The code sample has the following components:

    * `latest_round_data`: Returns the latest

:::NEXT DOC:::

 * [Chainlink Solana Starter Kit](https://github.com/smartcontractkit/solana-starter-kit): An Anchor based program and client that shows developers how to use and interact with Chainlink Data Feeds on Solana
  * [Solana CLI](https://docs.solana.com/cli): The Solana command line interface
  * [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git): Used to clone the example code repository

When developing applications to use Chainlink products on Solana, always use a
[Mainnet release](https://github.com/solana-labs/solana/releases) version of
the Solana CLI that is equal to or greater than the version currently running
on your target cluster. Use `solana --version` and `solana cluster-version` to
check CLI and cluster versions:


    solana --version
    solana-cli 1.9.28 (src:b576e9cc; feat:320703611)
    
    solana cluster-version --url devnet
    1.9.25
    
    solana cluster-version --url mainnet-beta
    1.9.28

The examples in this documentation use Solana programs in
[Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust),
but you can also write Solana programs in
[C](https://docs.solana.com/developing/on-chain-programs/developing-c). To
learn more about the Solana programming model, see the [Solana
Documentation](https://docs.solana.com/developing/programming-model/overview).

## Solana Wallets

When you use Chainlink on Solana, you need a [Solana
wallet](https://docs.solana.com/wallet-guide/). The Chainlink documentation
uses [file system

:::NEXT DOC:::

However,
to use Chainlink products on Solana, you must deploy your contract on-chain to
one of the supported Solana clusters.

Note

Please note that Price Feeds performance relies on the chains they are
deployed on. Periods of high network congestion may impact the frequency of
Chainlink Price Feeds. Subscribe to [Solana
status](https://status.solana.com/) notifications to stay updated on system
performance.

To learn how to mitigate risk to your applications, read the [Selecting
Quality Data Feeds](/data-feeds/selecting-data-feeds) page.

## Chainlink products and Solana clusters

[Price Feeds](/data-feeds/price-feeds/addresses?network=solana) are available
on the following Solana clusters:

  * [Solana Mainnet](https://solscan.io/)
  * [Solana Devnet](https://solscan.io/?cluster=devnet)

Solana provides a [Testnet cluster](https://docs.solana.com/clusters#testnet)
that runs newer [Solana releases](https://github.com/solana-labs/solana/releases), but Chainlink Data Feeds are not available on this
cluster.

See the [Solana Data Feeds](/data-feeds/price-feeds/addresses?network=solana)
page for a full list of Chainlink data feeds that are available on Solana.

To learn when more Chainlink services become available, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=dataFeeds).

## Languages, tools, and frameworks

The examples in the Chainlink documentation use the following languages,
tools, and frameworks:

  * [Node.js 14 or higher](https://nodejs.org/en/download/): Used to run client code
  *

:::NEXT DOC:::

# Data Feeds on Solana

  * Overview
  * Chainlink products and Solana clusters
  * Languages, tools, and frameworks
  * Solana Wallets

Chainlink provides data feeds on the [Solana](https://solana.com/) network.
Chainlink data feeds on Solana employ [Off-Chain Reporting
(OCR)](/architecture-overview/off-chain-reporting?parent=dataFeeds) to
aggregate data from data providers who pull from both centralized and
decentralized exchanges. Chainlink’s Solana deployment has no dependencies on
external blockchain networks such as Ethereum. In Solana, storage and smart
contract logic are separate. Programs store all the logic similar to an EVM
(Ethereum) smart contract. The accounts store all the data. Compared to
Solidity, the combination of an account and a program is equivalent to a smart
contract on an EVM chain. State and logic are separate in Solana.

Solana programs are stateless, so you don't always need to deploy your program
to the network to test it. You can deploy and test your programs on a [Solana
Test Validator](https://docs.solana.com/developing/test-validator). However,
to use Chainlink products on Solana, you must deploy your contract on-chain to
one of the supported Solana clusters.

Note

Please note that Price Feeds performance relies on the chains they are
deployed on. Periods of high network congestion may impact the frequency of
Chainlink Price Feeds. Subscribe to [Solana
status](https://status.solana.com/) notifications to stay updated on system
performance.

To learn how to mitigate risk to your applications, read the [Selecting
Quality Data Feeds](/data-feeds/selecting-data-feeds) page.

## Chainlink products and Solana clusters

[Price Feeds](/data-feeds/price-feeds/addresses?network=solana) are available
on the

:::NEXT DOC:::

but Chainlink Data Feeds are not available on this
cluster.

See the [Solana Data Feeds](/data-feeds/price-feeds/addresses?network=solana)
page for a full list of Chainlink data feeds that are available on Solana.

To learn when more Chainlink services become available, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=dataFeeds).

## Languages, tools, and frameworks

The examples in the Chainlink documentation use the following languages,
tools, and frameworks:

  * [Node.js 14 or higher](https://nodejs.org/en/download/): Used to run client code
  * [Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust): A general-purpose programming language designed for performance and memory safety
  * [Anchor](https://project-serum.github.io/anchor/getting-started/introduction.html): A framework for the [Solana Sealevel runtime](https://github.com/solana-labs/sealevel) that provides several developer tools
  * [Chainlink Solana Starter Kit](https://github.com/smartcontractkit/solana-starter-kit): An Anchor based program and client that shows developers how to use and interact with Chainlink Data Feeds on Solana
  * [Solana CLI](https://docs.solana.com/cli): The Solana command line interface
  * [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git): Used to clone the example code repository

When developing applications to use Chainlink products on Solana, always use a
[Mainnet release](https://github.com/solana-labs/solana/releases) version of
the Solana CLI that is equal to or greater than the version currently running
on your target cluster. Use `solana

:::NEXT DOC:::

[Anchor
Documentation](https://project-serum.github.io/anchor/).

## Using the Solana Starter Kit

This guide demonstrates the following tasks:

  * Write and deploy programs to the [Solana Devnet](https://solscan.io/?cluster=devnet) cluster using Anchor.
  * Retrieve price data data using the [Solana Web3 JavaScript API](https://www.npmjs.com/package/@solana/web3.js) with Node.js.

This example shows a full end to end example of using Chainlink Price Feeds on
Solana. It includes an on-chain program written in rust, as well as an off-
chain client written in JavaScript. The client passes in an account to the
program, the program then looks up the latest price of the specified price
feed account, and then stores the result in the passed in account. The off-
chain client then reads the value stored in the account.

### Install the required tools

Before you begin, set up your environment for development on Solana:

  1. Install [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if it is not already configured on your system.

  2. Install [Node.js 14 or higher](https://nodejs.org/en/download/). Run `node --version` to verify which version you have installed:
    
        node --version

  3. Install [Yarn](https://classic.yarnpkg.com/lang/en/docs/install/) to simplify package management and run code samples.

  4. Install a C compiler such as the one included in [GCC](https://gcc.gnu.org/install/). Some of the dependencies require a C compiler.

  5. Install [Rust](https://www.rust-lang.org/tools/install):
    
        curl --proto

:::NEXT DOC:::

# Using Data Feeds On-Chain (Solana)

  * Overview
  * The Chainlink Data Feeds OCR2 Program
  * Adding Data Feeds On-Chain In An Existing Project
  * Using the Solana Starter Kit
  * Install the required tools
  * Deploy the example program
  * Call the deployed program
  * Clean up

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world market prices of assets. This guide demonstrates how to deploy
a program to the Solana Devnet cluster and access Data Feeds on-chain using
the [Chainlink Solana Starter Kit](https://github.com/smartcontractkit/solana-starter-kit). To learn how to read price feed data using off-chain
applications, see the [Using Data Feeds Off-Chain](/solana/using-data-feeds-off-chain) guide.

To get the full list of available Chainlink Data Feeds on Solana, see the
[Solana Feeds](/data-feeds/price-feeds/addresses?network=solana) page. View
the program that owns the Chainlink Data Feeds in the [Solana Devnet
Explorer](https://solscan.io/account/HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny?cluster=devnet),
or the [Solana Mainnet
Explorer](https://solscan.io/account/HEvSKofvBgfaexv23kMabbYqxasxU3mQ4ibBMEmJWHny).

Select quality data feeds

Be aware of the quality of the data that you use. [Learn more about making
responsible data quality decisions](/data-feeds/selecting-data-feeds).

## The Chainlink Data Feeds OCR2 Program

The program that owns the data feeds on both Devnet and Mainnet

:::NEXT DOC:::

 
    solana cluster-version --url mainnet-beta
    1.9.28

The examples in this documentation use Solana programs in
[Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust),
but you can also write Solana programs in
[C](https://docs.solana.com/developing/on-chain-programs/developing-c). To
learn more about the Solana programming model, see the [Solana
Documentation](https://docs.solana.com/developing/programming-model/overview).

## Solana Wallets

When you use Chainlink on Solana, you need a [Solana
wallet](https://docs.solana.com/wallet-guide/). The Chainlink documentation
uses [file system wallets](https://docs.solana.com/wallet-guide/file-system-wallet) and free Devnet SOL tokens to demonstrate examples. When you deploy
your programs to the Solana Mainnet, you must use wallets with mainnet
lamports.

If you have existing wallets that you want to use for the guides in the
Chainlink documentation, find your wallet keypair and make it available in
your development environment as a file. You can point
[Anchor](https://project-serum.github.io/anchor/getting-started/introduction.html) and the [Solana CLI](https://docs.solana.com/cli)
to a specific keypair when you deploy or manage your Solana programs.


    anchor build
    ⋮
    
    anchor deploy --provider.wallet ~/.config/solana/id.json --provider.cluster devnet
    ⋮
    
    solana program show --programs --keypair ~/.config/solana/id.json --url devnet
    
    Program Id                

:::NEXT DOC:::

# Using Data Feeds Off-Chain (Solana)

  * Overview
  * The Chainlink Data Feeds Store Program
  * Adding Data Feeds to an existing off-chain project
  * Using the Solana Starter Kit
  * Install the required tools
  * Run the example program

Chainlink Data Feeds are the quickest way to access market prices for real-
world assets. This guide demonstrates how to read Chainlink Data Feeds on the
Solana Devnet using off-chain examples in the [Chainlink Solana Starter
Kit](https://github.com/smartcontractkit/solana-starter-kit). To learn how to
use Data Feeds in your on-chain Solana programs, see the [Using Data Feeds On-
Chain](/data-feeds/solana/using-data-feeds-solana) guide.

To get the full list of Chainlink Data Feeds on Solana, see the [Solana
Feeds](/data-feeds/price-feeds/addresses?network=solana) page.

Select quality data feeds

Be aware of the quality of the data that you use. [Learn more about making
responsible data quality decisions](/data-feeds/selecting-data-feeds).

## The Chainlink Data Feeds Store Program

The program that contains the logic required for the storing and retrieval of
Chainlink Data Feeds data on both Devnet and Mainnet is
[cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ](https://solscan.io/account/cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ?cluster=devnet).
This is the program ID that you use to read price data from off-chain. You can
find the source code for this program in the

:::NEXT DOC:::

| 109609728 | E6gKKToCJPgf4zEL1GRLL6T99g2WcfAzJAMvtma1KijT | 2.57751768 SOL

When you build your production applications and deploy Solana programs to the
Mainnet cluster, always follow the security best practices in the [Solana
Wallet Guide](https://docs.solana.com/wallet-guide) for managing your wallets
and keypairs.

## What's next

  * [› Use data feeds off-chain](/data-feeds/solana/using-data-feeds-off-chain)
  * [› Use data feeds on-chain](/data-feeds/solana/using-data-feeds-solana)
  * [› See the available data feeds on Solana](/data-feeds/price-feeds/addresses?network=solana)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/solana/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Why is it important to assess the liquidity and reliability of a specific exchange when obtaining pricing data for a smart contract?,Assessing the liquidity and reliability of a specific exchange is important to avoid price manipulation and ensure that prices are accurately reported throughout a liquidity migration.,{'source': 'https://docs.chain.link/data-feeds/selecting-data-feeds/'},It is important to assess the liquidity and reliability of a specific exchange when obtaining pricing data for a smart contract to avoid price manipulation and ensure that the asset has sufficient liquidity in the market. Assets with low liquidity can be volatile and negatively impact the application and its users. Malicious actors might try to exploit volatility to take advantage of the logic in a smart contract and cause it to execute in a way that was not intended.,"sufficient liquidity in the market to avoid price
manipulation. Assets with low liquidity can be volatile, which might
negatively impact your application and its users. Malicious actors might try
to exploit volatility to take advantage of the logic in a smart contract and
cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather
than from aggregated price tracking services that gather their data from
multiple exchanges. These are marked as such in the docs page for that feed.
Assess the liquidity and reliability of that specific exchange.

_Liquidity migrations_ occur when a project moves its tokens from one
liquidity provider (such as a DEX, a CEX, or a new DeFi application) to
another. When liquidity migrations occur, it can result in low liquidity in
the original pool, making the asset susceptible to market manipulation. If
your project is considering a liquidity migration, you should coordinate with
relevant stakeholders, including liquidity providers, exchanges, oracle node
operators, and users, to ensure prices are accurately reported throughout the
migration.

Feeds for assets with low market liquidity where data providers exhibit an
abnormal price spread may, on occasion, see a price oscillate between two or
more price points within regular intervals. To mitigate risk associated with
such price oscillation, users must regularly monitor & assess the quality of
an asset’s liquidity. Similarly, assets with low market liquidity may
experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk
management measures to protect your assets. For example, create mock tests
that return various oracle responses.

### Single Source Data Providers

Some data providers use a single data source, which might be necessary if only
one source exists off-chain for a specific type of data. Evaluate data
providers to make sure

:::NEXT DOC:::

ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Fast Gas Reliability

### Liquidity and its Distribution

If your smart contract relies on pricing data for a specific asset, make sure
that the asset has sufficient liquidity in the market to avoid price
manipulation. Assets with low liquidity can be volatile, which might
negatively impact your application and its users. Malicious actors might try
to exploit volatility to take advantage of the logic in a smart contract and
cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather
than from aggregated price tracking services that gather their data from
multiple exchanges. These are marked as such in the docs page for that feed.
Assess the liquidity and reliability of that specific exchange.

_Liquidity migrations_ occur when a project moves its tokens from one
liquidity provider (such as a DEX, a CEX, or a new DeFi application) to
another. When liquidity migrations occur, it

:::NEXT DOC:::

for assets with low market liquidity where data providers exhibit an
abnormal price spread may, on occasion, see a price oscillate between two or
more price points within regular intervals. To mitigate risk associated with
such price oscillation, users must regularly monitor & assess the quality of
an asset’s liquidity. Similarly, assets with low market liquidity may
experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk
management measures to protect your assets. For example, create mock tests
that return various oracle responses.

### Single Source Data Providers

Some data providers use a single data source, which might be necessary if only
one source exists off-chain for a specific type of data. Evaluate data
providers to make sure they provide high-quality data that your smart
contracts can rely on. Any error or omission in the provider's data might
negatively impact your application and its users.

### Crypto and Blockchain Actions

Price data quality is subject to crypto actions by the crypto and blockchain
project teams. Crypto actions are similar to [corporate
actions](https://en.wikipedia.org/wiki/Corporate_action) but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or

:::NEXT DOC:::

but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on.

:::NEXT DOC:::

high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible for reviewing the quality of the data that you integrate into your
smart contracts.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/selecting-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
 

:::NEXT DOC:::

aggregated by a smart contract, which forms the feed's latest
and trusted answer.

Each oracle operator is rewarded for publishing data. On mainnet, [sponsors
are paying the LINK
associated](https://ethereum.stackexchange.com/questions/90728/what-is-the-
cost-of-using-a-chainlink-oracle/90752#90752) to keep those feeds live,
decentralized, and secure, so they are not free. This allows the network to be
a shared resource where everyone chips in a tiny bit and makes them even
cheaper than running even your own centralized feed.

That being said, the price feeds are currently a simple `view` function, and
anyone can technically use them as access controls are on the roadmap to be
built at some point. It’s not really economical or fair for those backers who
are paying to support them for everyone else. Until access controls are built,
please reach out if you are using them on mainnet and learn how you can
contribute to keep them reliable honest, and secure.

**With API calls** , Chainlink enables your contracts to access any external
data source, through their decentralized oracle network. Making a HTTP GET
request will fail unless your deployed contract has enough LINK to pay for it,
therefore one needs to fund that smart contract.

If your contract is calling a public API endpoint, an Oracle job may already
exist for it. To check available jobs and GET request prices, visit
<https://market.link/>





:::NEXT DOC:::

give up control of their crypto assets, so trust is involved as they rely on the bridge operator's reputation.
  * Trustless (non-custodial) bridges leverage smart contracts to store and release funds on either side of the bridge. These bridges are trust-minimized because they don't make new trust assumptions beyond the underlying blockchains.

Trustlessness in bridges does not exist in an absolute form (trusted vs.
trustless). As explained in the blockchain-interoperability
[blog](https://blog.chain.link/blockchain-interoperability/), there are four
general interoperability solutions for validating the state of a source
blockchain and relaying the subsequent transaction to the destination
blockchain:

#### Web2 Verification

Web2 verification is when someone uses a web2 service to execute a cross-chain
transaction. The most common example in practice is when users leverage
centralized exchanges to swap or bridge their own tokens. The user simply
deposits their assets into an address on the source chain that's under the
control of the exchange and then withdraws the same tokens or different tokens
(via a swap on the exchange) to an address on a destination chain controlled
by the user.

Web2 verification can be fairly convenient for personal transactions and
requires less technical expertise. However, it is limited only to swapping and
bridging tokens which requires trust in a centralized custodian.

#### External verification

External verification is where a group of validator nodes are responsible for
verifying transactions. These validators do not belong to either of the two
blockchains’ validator sets and they also have their trust assumptions
irrespective of the underlying blockchains.

External verification typically requires an honest majority assumption, where
a majority of the external validator nodes must behave honestly for the
integrity of the cross-chain interaction to be upheld. However, additional
techniques can be used to increase trust-minimization, such as:



:::NEXT DOC:::

basis considering the liquidity,
depth, and trading volatility of the underlying asset compared to its
derivative. In addition, users must consider the security mechanism that is
designed to keep the wrapped or bridged asset coupled to its underlying asset.
Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets

Chainlink Price Feeds are designed to provide the market-wide price of various
assets, as determined by a volume-weighted average across a wide range of
exchanges. On blockchain networks where assets are wrapped and/or bridged from
another environment using a cross-chain token bridge, Chainlink Price Feeds
built for the underlying asset will continue to report the market-wide price
of the underlying asset as opposed to the price of the wrapped/bridged asset.
This methodology reduces risks around market manipulation because
wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price
deviations between the wrapped/bridged asset and its underlying counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a

:::NEXT DOC:::

financial risks

To transfer tokens cross-chain, many bridges lock tokens on the source chain
and mint derivative or wrapped tokens on the destination chain representing
the locked tokens. A hack of the locked tokens or an infinite mint attack on
the wrapped tokens can make all wrapped tokens worthless and expose entire
blockchains to risk.

### Early stage

Given that bridges are relatively new, there are many unanswered questions
related to how bridges will perform in different market conditions.

### Trust-minimization (Counterparty risk)

To overcome cross-chain interoperability challenges, some bridges use off-
chain actors or validators. These actors introduce new trust assumptions in
addition to the underlying blockchain trust assumptions. These bridges act as
a custodian and are, therefore, trust-based. In contrast, some bridge designs
rely on underlying blockchains' validators and, therefore, do not add any
trust assumptions. To summarize:

  * Trusted (custodial) bridges require a third party to validate movements over the bridge. Users are required to give up control of their crypto assets, so trust is involved as they rely on the bridge operator's reputation.
  * Trustless (non-custodial) bridges leverage smart contracts to store and release funds on either side of the bridge. These bridges are trust-minimized because they don't make new trust assumptions beyond the underlying blockchains.

Trustlessness in bridges does not exist in an absolute form (trusted vs.
trustless). As explained in the blockchain-interoperability
[blog](https://blog.chain.link/blockchain-interoperability/), there are four
general interoperability solutions for validating the state of a source
blockchain and relaying the subsequent transaction to the destination
blockchain:

#### Web2 Verification

Web2 verification is when someone uses a web2 service to execute a"
What is the purpose of the VRFv2SubscriptionManager contract?,The VRFv2SubscriptionManager contract is an example contract that uses hardcoded values for clarity and uses un-audited code. It should not be used in production.,{'source': 'https://docs.chain.link/vrf/v2/subscription/examples/programmatic-subscription/'},"The purpose of the VRFv2SubscriptionManager contract is to create and manage subscriptions for requesting random values using Chainlink VRF v2. It includes functions for creating new subscriptions, adding or removing consumers, funding the subscription with LINK tokens, and requesting random words.","#####Chapter 5: VRF Subscriptions

# Subscription Manager Contract

Now that we learned more about the theoretical background, let’s get practical. We want to create and manage a subscription contract. We will use the example contract that you can find here on [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js). It shows an example implementation of a VRF v2 Subscription manager for the Goerli network. But you can also adjust it to work with other networks by changing the code's hardcoded addresses. You can find a complete list of available networks [here](https://docs.chain.link/docs/vrf-contracts/#configurations).

Hint: This course assumes you are already familiar with the Architecture of Chainlink VRF from [VRFv2 Introduction Chapter 4](https://www.chainlink.education/vrfIntroduction/chapter-4).

Generally, consumer contracts must implement the requestRandomWords() function providing coordinator parameters and subscription ID. This function is used to create random values. A second function, fulfillRandomWords(), must be implemented to receive the random values. Learn about how to implement the basics of such a contract in [chapters 6-12](https://www.chainlink.education/vrfIntroduction/chapter-6) from the introduction course.

We want to focus on the mentioned functions here and show how to manage subscriptions in this contract. So let’s start by creating a new subscription:

<Highlight class=""language-javascript"">
uint64 public s_subscriptionId;
 function

:::NEXT DOC:::

and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Sepolia coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    
        // Sepolia LINK token contract. For other networks, see
       

:::NEXT DOC:::

different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends

:::NEXT DOC:::

# Programmatic Subscription

  * Overview
  * Modifying subscriptions and configurations
  * Subscription manager contract
  * Funding and requesting simultaneously

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

How you manage the subscription depends on your randomness needs. You can
configure your subscriptions using the [Subscription
Manager](/vrf/v2/subscription/ui), but these examples demonstrate how to
create your subscription and add your consumer contracts programmatically. For
these examples, the contract owns and manages the subscription. Any wallet can
provide funding to those subscriptions.

You can view and monitor your subscriptions in the [Subscription
Manager](/vrf/v2/subscription/ui) even if you create them programmatically. Go
to [vrf.chain.link](https://vrf.chain.link) to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    *

:::NEXT DOC:::

#####Chapter 12: Subscribing to the VRF

# Subscribing

Congrats you have completed the contract! Your final contract should look like this:

<Highlight class=""language-javascript"">
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;


  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address linkTokenContract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
   

:::NEXT DOC:::

# Subscription Method

  * Overview
  * Subscriptions
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits
  * Subscription limits
  * Coordinator contract limits

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This section explains how to generate random numbers using the subscription
method.

## Subscriptions

VRF v2 requests receive funding from subscription accounts. The [Subscription
Manager](/vrf/v2/subscription/ui) lets you create an account and pre-pay for
VRF v2, so you don't provide funding each time your application requests
randomness. This reduces the total gas cost to use VRF v2. It also provides a
simple way to fund your use of Chainlink products from a single location, so
you don't have to manage multiple wallets across several different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that

:::NEXT DOC:::

to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    * `acceptSubscriptionOwnerTransfer(uint64 subId)`.
  * View the subscription with `getSubscription(uint64 subId)`.
  * Cancel the subscription with `cancelSubscription(uint64 subId)`.

To send LINK to the subscription balance, use the LINK token interface with
`LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(subId))`.
Any wallet can fund a subscription.

See the example in the Subscription manager contract section to learn how to
create a contract that can change your subscription configuration.

## Subscription manager contract

In this example, the contract operates as a subscription owner and can run
functions to add consuming contracts to the subscription. The consuming
contracts must include the `requestRandomWords()` function with the correct
coordinator parameters and the correct subscription ID to request random
values and use the subscription balance. The consuming contracts must also
include the `fulfillRandomWords()` function to receive the random values.

Subscription owners and consumers do not have to be separate. This contract
not only allows adding consumers with `addConsumer(address consumerAddress)`
but can also act as a consumer by running its

:::NEXT DOC:::

# Subscription Manager User Interface

  * Overview
  * Actions menu
  * Consumers
  * Pending
  * History
  * Recent fulfillments
  * Events
  * Failed requests

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

The VRF v2 Subscription Manager is available at
[vrf.chain.link](https://vrf.chain.link/). The Subscription Manager lets you
create a subscription and pre-pay for VRF v2 so you don't need to provide
funding each time your application requests randomness. This guide walks you
through the main sections of the UI.

Troubleshooting

Read the pending and failed requests sections to learn how to troubleshoot
your VRF requests.



Subscription components:

  * **Status** : Indicates if the subscription is still active or not.
  * **ID** : The unique subscription identifier. Approved consuming contracts use LINK from this subscription to pay for each randomness request.
  * **Admin** : The account address that owns this subscription ID.
  * **Consumers** : The number of consuming contracts that are approved to make VRF requests using this subscription.
  * **Fulfillment** : The number of successful randomness requests that are already completed.
  * **Balance** : The amount of LINK remaining to be used for requests that use this subscription.

## Actions menu

Expand the **Actions** menu to display actions you can take for any
subscription that you own:



  * **Fund subscription** : Displays a field allowing you to fund your subscription from your connected wallet. Specify how much LINK you'd like to send to your subscription.
  *

:::NEXT DOC:::

page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)



:::NEXT DOC:::

amount, abi.encode(subId))`.
Any wallet can fund a subscription.

See the example in the Subscription manager contract section to learn how to
create a contract that can change your subscription configuration.

## Subscription manager contract

In this example, the contract operates as a subscription owner and can run
functions to add consuming contracts to the subscription. The consuming
contracts must include the `requestRandomWords()` function with the correct
coordinator parameters and the correct subscription ID to request random
values and use the subscription balance. The consuming contracts must also
include the `fulfillRandomWords()` function to receive the random values.

Subscription owners and consumers do not have to be separate. This contract
not only allows adding consumers with `addConsumer(address consumerAddress)`
but can also act as a consumer by running its own `requestRandomWords()`
function. This example contract includes a `createNewSubscription()` function
in the `constructor()` that creates the subscription and adds itself as a
consumer automatically when you deploy it.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that also owns and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 "
What are the two methods offered by Chainlink VRF v2 for requesting randomness?,Chainlink VRF v2 offers two methods for requesting randomness: Subscription and Direct funding.,{'source': 'https://docs.chain.link/vrf/'},The two methods offered by Chainlink VRF v2 for requesting randomness are Subscription and Direct funding.,"judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                          

:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription

:::NEXT DOC:::

how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation

:::NEXT DOC:::

# Random Numbers: Using Chainlink VRF

  * Overview
  * How is randomness generated on blockchains? What is Chainlink VRF?
  * What is the Request and Receive cycle?
  * What is the payment process for generating a random number?
  * How can I use Chainlink VRF?
  * Create and fund a subscription
  * Importing VRFConsumerBaseV2 and VRFCoordinatorV2Interface
  * Contract variables
  * Initializing the contract
  * rollDice function
  * fulfillRandomWords function
  * house function
  * How do I deploy to testnet?
  * How do I add my contract to my subscription account?
  * How do I test rollDice?
  * Further Reading

Requirements

This guide assumes that you have basic knowledge about writing and deploying
smart contracts. If you are new to smart contract development, read the
[Consuming Data Feeds](/getting-started/consuming-data-feeds) guide before you
begin.

VRF v2 - Developer Walkthrough

In this guide, you will learn about generating randomness on blockchains. This
includes learning how to implement a Request and Receive cycle with Chainlink
oracles and how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted

:::NEXT DOC:::

Question: (Asked on: 2023-01-19 03:22:56)
Possible Chainlink VRF returns two same randomnesses in one request?
URL: https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request

Question Body:


as the title, i am thinking if it's possible that Chainlink VRF returns two
same randomnesses in one request? As of ""random"", i assume the answer is YES.
Thanks.



Answers:
(Answered on: 2023-01-19 08:57:48)


For each request, Chainlink VRF generates one or more random values and
cryptographic proof of how those values were determined. It is unlikely that a
Chainlink VRF would return the same randomness in one request.





:::NEXT DOC:::

# Introduction to Chainlink VRF [v1]

  * Overview
  * Generate Random Numbers in your Smart Contracts
  * On-chain Verification of Randomness

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

## Generate Random Numbers in your Smart Contracts

Chainlink VRF (Verifiable Random Function) is a provably-fair and verifiable
source of randomness designed for smart contracts. Smart contract developers
can use Chainlink VRF as a tamper-proof random number generator (RNG) to build
reliable smart contracts for any applications which rely on unpredictable
outcomes:

  * Blockchain games and NFTs
  * Random assignment of duties and resources (e.g. randomly assigning judges to cases)
  * Choosing a representative sample for consensus mechanisms

Learn how to write smart contracts that consume random numbers: [Get a Random
Number](/vrf/v1/examples/get-a-random-number).

## On-chain Verification of Randomness

Chainlink VRF enables smart contracts to access randomness without
compromising on security or usability. With every new request for randomness,
Chainlink VRF generates a random number and cryptographic proof of how that
number was determined. The proof is published and verified on-chain before it
can be used by any consuming applications. This process ensures that the
results cannot be tampered with nor manipulated by anyone, including oracle
operators, miners, users and even smart contract developers.

Read more about Chainlink VRF in [our announcement
post](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/).

## What's next

  * [› Get a Random Number](/vrf/v1/examples/get-a-random-number)
  * [› API

:::NEXT DOC:::

                           | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

to access randomness without
compromising on security or usability. With every new request for randomness,
Chainlink VRF generates a random number and cryptographic proof of how that
number was determined. The proof is published and verified on-chain before it
can be used by any consuming applications. This process ensures that the
results cannot be tampered with nor manipulated by anyone, including oracle
operators, miners, users and even smart contract developers.

Read more about Chainlink VRF in [our announcement
post](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/).

## What's next

  * [› Get a Random Number](/vrf/v1/examples/get-a-random-number)
  * [› API Reference](/vrf/v1/api-reference)
  * [› Supported Networks](/vrf/v1/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Direct Funding Method

  * Overview
  * VRF direct funding
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to generate random numbers using the _direct funding_
method. This method doesn't require a subscription and is optimal for one-off
requests for randomness. This method also works best for applications where
your end-users must pay the fees for VRF because the cost of the request is
determined at request time.

## VRF direct funding

Unlike the [subscription method](/vrf/v2/subscription), the direct funding
method does not require you to create subscriptions and pre-fund them.
Instead, you must directly fund consuming contracts with LINK tokens before
they request randomness. Because the consuming contract directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed

:::NEXT DOC:::

directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Wrapper (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was"
What is the purpose of the `functions-simulate` command in the Chainlink Functions hardhat starter kit?,"The `functions-simulate` command executes your code in a local runtime environment and simulates an end-to-end fulfillment, helping you fix any issues before submitting your functions to a Decentralized Oracle Network.",{'source': 'https://docs.chain.link/chainlink-functions/tutorials/simple-computation/'},"The purpose of the `functions-simulate` command in the Chainlink Functions hardhat starter kit is to execute the Functions code in a local runtime environment and simulate an end-to-end fulfillment, which helps to fix any issues before submitting requests to the Decentralized Oracle Network.","for details. For more information about the request, read the request config section.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation of the request source file.

### Simulation

The [Chainlink Functions Hardhat Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command executes your code in a local runtime environment
and simulates an end-to-end fulfillment. This helps you to fix issues before
you submit functions to the Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/6-multiple-apis/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    Median Bitcoin price: $28347.05
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b4111
    Decoded as a uint256: 2834705
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b4111
  

:::NEXT DOC:::

to test your Functions code on your local machine. The
`functions-simulate` command will execute your code in a local runtime
environment and simulate an end-to-end fulfillment. Simulation can help you to
fix any issues before you submit your requests to the Decentralized Oracle
Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `Functions-request-source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/3-custom-response/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    HTTP GET Request to https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD
    ETH price is: 1810.29 USD. 24h Volume is 113255.87 USD. Market: Coinbase
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x7b227072696365223a22313831302e3239222c22766f6c756d65223a223131333235352e3837222c226c6173744d61726b6574223a22436f696e62617365227d
    Decoded as a string: {""price"":""1810.29"",""volume"":""113255.87"",""lastMarket"":""Coinbase""}
    
    __Simulated

:::NEXT DOC:::

for details. For more information about the request, read the request config section.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation of the request source file.

### Simulation

The [Chainlink Functions Hardhat Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command executes your code in a local runtime environment
and simulates an end-to-end fulfillment. This helps you to fix issues before
you submit functions to the Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/6-multiple-apis/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    Median Bitcoin price: $28354.00
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b43c8
    Decoded as a uint256: 2835400
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b43c8


:::NEXT DOC:::

request config file.
  * Open `source.js` to analyze the JavaScript source code. Read the source code section for more details about the source code file.

### Simulation

The [Chainlink Functions Hardhat Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test Functions code on your local machine. The
`functions-simulate` command executes your code in a local runtime environment
and simulate an end-to-end fulfillment. This helps you fix issues before you
submit functions to a Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/5-use-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    Price: 28272.77 USD
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b240d
    Decoded as a uint256: 2827277
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b240d
    Decoded as a uint256: 2827277
    
    Gas used by

:::NEXT DOC:::

includes the capability to simulate transactions so you can quickly test
your code before you send it to the DON.


    npx hardhat functions-simulate

If the simulation is successful, the output includes the simulated on-chain
response:


    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000000f50ed
    Decoded as a uint256: 1003757
    
    Gas used by sendRequest: 360602
    Gas used by client callback function: 75029

## Configure your on-chain resources

After you configure your local environment, configure some on-chain resources
to process your requests, receive the responses, and pay for the work done by
the DON.

Deploy an on-chain
[FunctionsConsumer.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/FunctionsConsumer.sol) contract, create a
[subscription](/chainlink-functions/resources/subscriptions), and fund the
subscription with LINK to pay for requests after they are fulfilled.

  1. Deploy the consumer contract and record the contract address. For now, you can skip on-chain contract verification with the `--verify false` flag. If you do need to [verify](https://blog.chain.link/how-to-verify-a-smart-contract-on-etherscan) your contract on-chain, sign up for a [free Polygonscan API key](https://polygonscan.com/login) and include the key in your `.env.enc` file by running `npx env-enc set` and set `POLYGONSCAN_API_KEY`.
    
        npx hardhat functions-deploy-client --network polygonMumbai --verify false

Find the contract address in the output:

    
        FunctionsConsumer contract deployed to

:::NEXT DOC:::

to get the `ETH/USD` price. For a detailed
explanation of the code example, read the Explanation section.

  * Open `config.js`. The `args` value is `[""ETH"", ""USD""]`, which fetches the current `ETH/USD` price. You can adapt `args` to fetch another asset price. See the [CryptoCompare API docs](https://min-api.cryptocompare.com/documentation?key=Price&cat=multipleSymbolsFullPriceEndpoint) to get the list of supported symbols. Read the request config explanation for a more detailed explanation about the request config file.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation.

### Simulation

The [Chainlink Functions Hardhat Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command executes your code in a local runtime environment
and simulates an end-to-end fulfillment. This helps you to fix any issues
before you submit your functions to a Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/2-call-api/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code

:::NEXT DOC:::

Set this in the `.env` file. **Note** : The Chainlink Functions hardhat starter kit uses your private key to sign any transactions you make such as deploying your consumer contract, creating subscriptions, and making requests.
        
                npx env-enc set

  5. Compile the contracts in the repository. You will see several compile warnings, but no errors.
    
        npx hardhat compile

Simulate a request to test your environment and make sure everything is
configured correctly. Run the `npx hardhat functions-simulate` command. The
simulation runs on a local Hardhat network (a local Ethereum network node
designed for development) and executes a request defined in the default
[Functions-request-config.js](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/Functions-request-config.js) file. The starter
kit includes the capability to simulate transactions so you can quickly test
your code before you send it to the DON.


    npx hardhat functions-simulate

If the simulation is successful, the output includes the simulated on-chain
response:


    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000000f50ed
    Decoded as a uint256: 1003757
    
    Gas used by sendRequest: 360602
    Gas used by client callback function: 75029

## Configure your on-chain resources

After you configure your local environment, configure some on-chain resources
to process your requests, receive the responses, and pay for the work done by
the DON.

Deploy an

:::NEXT DOC:::

information about other countries as well. Read the [Trevorblades API docs](https://github.com/trevorblades/countries) to get the list of supported countries. For more information about the request config file, read the request config explanation.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation of the source code file.

### Simulation

The [Chainlink Functions Hardhat Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command executes your code in a local runtime environment
and simulates an end-to-end fulfillment. This helps you to fix issues before
you submit your functions to a Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/4-post-data/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    Get name, capital and currency for country code: JP
    HTTP POST Request to https://countries.trevorblades.com/
    country response { country: { name: 'Japan', capital: 'Tokyo', currency: 'JPY' } }
  

:::NEXT DOC:::

   
        git checkout tutorials

## Tutorial

This tutorial is configured to get the `ETH/USD`, daily volume, and market in
a single request. For a detailed explanation of the code example, read the
Explanation section.

  * Open `config.js`. Note the `args` value is `[""ETH"", ""USD""]`: We want to fetch the current `ETH/USD` price and daily volume. You can adapt `args` to get the list of supported symbols. Read the [API docs](https://min-api.cryptocompare.com/documentation?key=Price&cat=multipleSymbolsFullPriceEndpoint) to learn more about these configuration variables. For a more detailed explanation about the configuration in this example, read the request config explanation section.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation section for a more detailed explanation of how the source file is written.

### Simulation

The [Chainlink Functions hardhat starter
kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command will execute your code in a local runtime
environment and simulate an end-to-end fulfillment. Simulation can help you to
fix any issues before you submit your requests to the Decentralized Oracle
Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `Functions-request-source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/3-custom-response/config.js
    secp256k1 unavailable, reverting to browser version
    
   

:::NEXT DOC:::

mean) from a list of
numbers. For a detailed explanation of the code example, read the Explanation
section.

  * Open `config.js`. Note that the `args` value is `[""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""10""]`, so the source code will calculate the average (geometric mean) of ""1,2,3,4,5,6,7,8,9,10"". You can change the `args` value to compute another set's average. Read the request config explanation for more information about the request config file.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed description of the source code.

### Simulation

The [Chainlink Functions hardhat starter
kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command will execute your code in a local runtime
environment and simulate an end-to-end fulfillment, helping you fix any issues
before submitting your functions to a Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/1-simple-computation/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
"
What is the purpose of disallowing local network and multicast IPs by default in HTTPGet?,"For security, because the URL can come from an untrusted source, HTTPGet imposes some restrictions on which IPs may be fetched. Local network and multicast IPs are disallowed by default and attempting to connect will result in an error.",{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/'},The purpose of disallowing local network and multicast IPs by default in HTTPGet is for security reasons.,"Question: (Asked on: 2021-11-18 14:56:42)
how to enable local bridge/httpget/task api connection to chainlink node?
URL: https://stackoverflow.com/questions/70022029/how-to-enable-local-bridge-httpget-task-api-connection-to-chainlink-node

Question Body:


I have a custom API running on <http://127.0.0.1:8080> and I have my own
chainlink node running on <http://127.0.0.1:6688>. I get the error saying
""Connections to local/private and multicast networks are disabled by default
for security reasons: disallowed IP"" when sending requests.

I guess maybe we can enable it by modifying the env file, but I don't know
which configuration should I change. Does anyone know if we can enable these
local/private connections? and how to do that?



Answers:
(Answered on: 2021-11-20 17:32:25)


Per the [chainlink docs on the http
task](https://docs.chain.link/docs/jobs/task-types/http/):

> allowUnrestrictedNetworkAccess (optional): permits the task to access a URL
> at localhost, which could present a security risk. Note that Bridge tasks
> allow this by default.

ie:

    
    
    my_http_task [type=""http""
                  method=PUT
                  url=""http://chain.link""
                  requestData=""{\\""foo\\"": $(foo), \\""bar\\"": $(bar), \\""jobID\\"": 123}""
                 

:::NEXT DOC:::

allowUnrestrictedNetworkAccess (optional): permits the task to access a URL
> at localhost, which could present a security risk. Note that Bridge tasks
> allow this by default.

ie:

    
    
    my_http_task [type=""http""
                  method=PUT
                  url=""http://chain.link""
                  requestData=""{\\""foo\\"": $(foo), \\""bar\\"": $(bar), \\""jobID\\"": 123}""
                  allowUnrestrictedNetworkAccess=true
                  ]
    

You can also use this flag in JSON





:::NEXT DOC:::

Question: (Asked on: 2022-01-02 16:18:48)
Ethereum Chainlink HTTP Get not pinging my HTTP endpoint
URL: https://stackoverflow.com/questions/70557627/ethereum-chainlink-http-get-not-pinging-my-http-endpoint

Question Body:


I am attempting to have my Ethereum smart contract connect to an external HTTP
endpoint using Chainlink. Following along with Chainlink's documentation
(<https://docs.chain.link/docs/advanced-tutorial/>) I deployed this contract
onto the Rinkeby testnet.

    
    
    pragma solidity ^0.8.7;
    
    import ""github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ChainlinkClient.sol"";
    
    // MyContract inherits the ChainlinkClient contract to gain the
    // functionality of creating Chainlink requests
    
    
    contract getHTTP is ChainlinkClient {
      using Chainlink for Chainlink.Request;
    
      bytes32 private thisDoesNotWork;
      address private owner;
      address private ORACLE_ADDRESS = 0x718Cc73722a2621De5F2f0Cb47A5180875f62D60;
      bytes32 private JOBID = stringToBytes32(""86b489ec4d84439c96181a8df7b22223"");
      string private url = ""<myHTTPAddressAsString>""; 
    
    // This endpoint URL is hard coded in my contract, and stored as a string (as in the example code). 
    // I control it and can have it reply with whatever I want, which

:::NEXT DOC:::

         |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                                                                             |
| HTTP GET Element in Array Response | This guide explains how to make an HTTP GET request that returns a json array and parse it to retrieve the target element's value.                                                                                                                         |
| HTTP GET Large Reponses            | This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.                                                                                   |
| Existing Job Request              

:::NEXT DOC:::

# Security and Operation Best Practices

  * Overview
  * Restricting Access
  * Failover Capabilities
  * Disaster Recovery
  * Active Monitoring
  * Frequent Updates
  * Jobs and Config
  * Addresses
  * Infrastructure as Code (IaC)

The following information provides a set of security and operation best
practices that node operators need to use at a minimum to enhance the security
and reliability of their infrastructure.

## Restricting Access

To run a Chainlink node, the Operator UI port does not need to be open on the
internet for it to correctly function. Due to this, we strongly recommend
restricting access to all of the services required over the internet.

**Minimum Requirements:**

  * SSH (port 22 or changed from the default) is open, and access to the node is granted via SSH tunnelling. This is done typically by adding `-L 6688:localhost:6688` to your SSH command.
  * Access to the Ethereum client that the Chainlink node uses is restricted to solely the Chainlink node. This includes ports 8545 and 8546, but excludes 30303 for P2P traffic.

**Recommended:**

  * The use of a VPN restricts access to only those who are signed into the VPN in order to access internal resources. For example, this can be achieved by using something like [OpenVPN Access Server](https://openvpn.net/vpn-server/).
  * With the use of the VPN, all traffic between Chainlink nodes and Ethereum clients is routed internally rather than over the internet. For example, all servers are placed in an internal subnet range such as `10.0.0.0/16` and use these IP addresses for communicating.
  * Chainlink nodes have the potential to send arbitrary HTTP GET and POST requests, exposing internal network resources. We recommend deploying with a DMZ which has strong outbound network restrictions.

## Failover Capabilities

To ensure there is very minimal downtime,

:::NEXT DOC:::

how
to make an HTTP GET request and parse the _json_ response to retrieve the
value of one single attribute.

### Multi-Variable Responses

This [guide](/any-api/get-request/examples/multi-variable-responses) explains
how to make an HTTP GET request and parse the _json_ response to retrieve the
values of multiple attributes.

### Fetch data from an Array

This [guide](/any-api/get-request/examples/array-response) explains how to
make an HTTP GET request that returns a _json_ array and parse it to retrieve
the target element's value.

### Large Responses

This [guide](/any-api/get-request/examples/large-responses) explains how to
make an HTTP Get request that returns a _json_ containing an arbitrary-length
raw byte data and parse it to return the data as _bytes_ data type.

### Make an Existing Job Request

This [guide](/any-api/get-request/examples/existing-job-request) explains how
to call a job that leverages [External adapters](/chainlink-nodes/external-adapters/external-adapters/) and returns the relevant data to the smart
contract. This allows building succinct smart contracts that do not need to
comprehend the URL or the response format of the target API.

## What's next

  * [› Single Word Response](/any-api/get-request/examples/single-word-response/)
  * [› Multi-Variable Responses](/any-api/get-request/examples/multi-variable-responses/)
  * [› Fetch data from an Array](/any-api/get-request/examples/array-response/)
  * [› Large Responses](/any-api/get-request/examples/large-responses/)
  * [› Make an Existing Job Request](/any-api/get-request/examples/existing-job-request/)
  * [›

:::NEXT DOC:::

   

The problem is, in the chainlink node, specifically in the `fetch` method it
gives me an error: `error making http request: Post ""http://localhost:8080"":
dial tcp 127.0.0.1:8080: connect: connection refused`

Is it related to the docker container? I don't see why it wouldn't be able to
request resuources from another port in the same machine. Am I missing some
configuration maybe? From what I've read from the docs it's possible to run
the adapter locally. Below, a picture with more information:

[](https://i.stack.imgur.com/MnUK7.png)



Answers:
(Answered on: 2022-05-27 07:43:44)


If you're External Adapter (EA) is running on `http://localhost:8080` and
you're trying to reach that EA from a Chainlink node running inside Docker,
then you can't use `localhost`, you need to get out of the Docker container
and onto the host running the Docker engine (your Windows or Mac machine).

To do, so define your bridge to use `http://host.docker.internal:8080`.

Further details can be found in the [Docker
Docs](https://docs.docker.com/desktop/windows/networking/).





:::NEXT DOC:::

 * The use of a VPN restricts access to only those who are signed into the VPN in order to access internal resources. For example, this can be achieved by using something like [OpenVPN Access Server](https://openvpn.net/vpn-server/).
  * With the use of the VPN, all traffic between Chainlink nodes and Ethereum clients is routed internally rather than over the internet. For example, all servers are placed in an internal subnet range such as `10.0.0.0/16` and use these IP addresses for communicating.
  * Chainlink nodes have the potential to send arbitrary HTTP GET and POST requests, exposing internal network resources. We recommend deploying with a DMZ which has strong outbound network restrictions.

## Failover Capabilities

To ensure there is very minimal downtime, failover capabilities are required
on both the Chainlink and Ethereum clients so that if any one server fails,
the service is still online.

**Minimum Requirements:**

  * Chainlink nodes are using a PostgreSQL database that are not on the same servers as the Chainlink nodes.
  * At least two Chainlink nodes are running at any one time, with both of them pointing to the same database to ensure failover if one fails.

**Ethereum-specific:**

  * Ethereum client websocket connectivity is fronted by a load balancer, used by the Chainlink nodes. [Here is an example on how to set up a load balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/tutorial-target-ecs-containers.html). 
    * If a VPN and internal routing is configured, SSL is not needed but still recommended, as all traffic is purely internal.
    * If both Ethereum and Chainlink nodes are public facing without a VPN, SSL is required to ensure that no communication between both can be intercepted.

## Disaster Recovery

Problems occur and when they do, the right processes

:::NEXT DOC:::

increase the chances of an attacker cheating your application. Imagine you implemented a simple coin flip smart contract using VRF v2. In a bet function, you choose heads or tails and then request a random number. If you have selected heads (0) and the result of the VRF service meant that you would win the bet, it could try to withhold this answer and replace it with your second request if it’s more advantageous.

So you see, we must consider the unique properties of blockchains here to ensure randomness in our smart contracts. While the numbers are always random, we must also look into how our applications and smart contracts deal with them. In the end, it will be a matter of cost if it's worth attacking your application. You must also be aware of the protocol that you are using.

In general, re-organizations on chains are possible. A miner would take your request and try to create a new random number with a different block and do this until they find a block to their advantage. They cannot control the VRF output but can ""re-roll"" the dice. If they manage to produce a valid blockchain with this new block and the network accepts this block instead, they could effectively attack your application by controlling the random input.
While this is a possible attack, it's costly to attack a network like this, as in the proof of network. You need at least 51% of the network to drive such an attack. Depending on your application requirements, you consider a 20-block confirmation time highly secure. You can lower the block confirmation time depending on the value you are trying to protect. You must calculate an attacker's costs and potential reward to decide your confirmation time.


:::NEXT DOC:::

Question: (Asked on: 2022-11-24 17:28:36)
Is there a possibility to determine/restrict smart-contract addresses that can use the Chainlink Oracle Node I created?
URL: https://stackoverflow.com/questions/74564433/is-there-a-possibility-to-determine-restrict-smart-contract-addresses-that-can-u

Question Body:


Is there a possibility to determine/restrict smart-contract addresses that can
use the Chainlink Oracle Node I created? How can I ensure that only Smart
Contract addresses that I set use my Oracle node?



Answers:
(Answered on: 2022-11-26 11:35:07)


For ease of convenience, you can restrict/whitelist by requesting smart
contract addresses in the form of an array within the job-spec.toml found
within the Chainlink GUI (localhost:6688). Below is from the docs
[[here]](https://docs.chain.link/chainlink-nodes/oracle-jobs/job-
types/direct_request).

    
    
    requesters = [
       ""0xaaaa1F8ee20f5565510B84f9353F1E333E753B7a"",
       ""0xbbbb70F0e81C6F3430dfdC9fa02fB22BdD818C4e""
    ]
    



"
What is the purpose of the Proof of Reserve feeds mentioned in the text?,"The Proof of Reserve feeds are used to attest to the reserves held by various assets, including US Dollar, Gold, Staked ETH, Bitcoin, and Wrapped Filecoin, among others.",{'source': 'https://docs.chain.link/data-feeds/proof-of-reserve/addresses/'},"The purpose of the Proof of Reserve feeds mentioned in the text is to provide the status of reserves for several assets and to prove the reserves for these assets through several different methods, including off-chain and cross-chain reserves. These feeds can be read the same way as other Data Feeds and are used to make responsible data quality decisions in smart contracts.","# Proof of Reserve Feeds

  * Overview
  * Types of Proof of Reserve Feeds
  * Off-chain reserves
  * Cross-chain reserves
  * Using Proof of Reserve Feeds

Chainlink Proof of Reserve Feeds provide the status of the reserves for
several assets. You can read these feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

To find a list of available Proof of Reserve Feeds, see the [Proof of Reserve
Feed Addresses](/data-feeds/proof-of-reserve/addresses) page.

## Types of Proof of Reserve Feeds

Reserves are available for both cross-chain assets and off-chain assets. This
categorization describes the data attestation variations of Proof of Reserve
feeds and helps highlight some of the inherent market risks surrounding the
data quality of these feeds.

Reserves are available for both off-chain assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no

:::NEXT DOC:::

       ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility

:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use

:::NEXT DOC:::

assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
  * ⚠️ Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

### Cross-chain reserves

Cross-chain reserves are sourced from the network where the reserves are held.
Chainlink node operators can report cross-chain reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read

:::NEXT DOC:::

                                         |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions.

:::NEXT DOC:::

1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
      

:::NEXT DOC:::

🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                    

:::NEXT DOC:::

the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify"
What is the purpose of funding smart contracts with LINK or ETH?,Some smart contracts require funding at their addresses so they can operate without you having to call functions manually and pay for the transactions through MetaMask.,{'source': 'https://docs.chain.link/resources/fund-your-contract/'},The purpose of funding smart contracts with LINK or ETH is to allow them to operate without the need for manual function calls and transaction payments through MetaMask.,"# Fund Your Contracts

  * Overview
  * Retrieve the contract address
  * Send funds to your contract

Some smart contracts require funding at their addresses so they can operate
without you having to call functions manually and pay for the transactions
through MetaMask. This guide explains how to fund Solidity contracts with LINK
or ETH.

## Retrieve the contract address

  1. In Remix, deploy your contract and wait until you see a new contract in the **Deployed Contracts** section.
  2. On the left side panel, use the **Copy** button located near the contract title to copy the contract address to your clipboard.

## Send funds to your contract

  1. Open MetaMask.
  2. Select the network that you want to send funds on. For example, select the Sepolia testnet.
  3. Click the **Send** button to initiate a transaction.
  4. Paste your contract address in the address field.
  5. In the **Asset** drop down menu, select the type of asset that you need to send to your contract. For example, you can send LINK. If LINK is not listed, follow the guide to [Acquire testnet LINK](/resources/acquire-link).
  6. In the **Amount** field, enter the amount of LINK that you want to send.
  7. Click **Next** to review the transaction details and the Gas cost.
  8. If the transaction details are correct, click **Confirm** and wait for the transaction to process.

Transaction fee didn't update?

You may need to click **Fastest** , **Fast** , **Slow** , or **Advanced
Options** after entering the **Amount** to update the gas limit for the token
transfer to be successful.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/fund-your-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

of my contract to purchase LINK themselves.

Thanks!



Answers:
(Answered on: 2021-05-09 12:37:13)


A contract itself can't 'automatically have LINK transferred to it', because
to transfer LINK from one account to another, the owner of the LINK must be
the one that signs the transaction, however, there are a few other ways to
achieve the end result you're looking for.

1 - Rather than a straight transfer, you can do a swap on a DEX like Uniswap
programatically, ie <https://docs.uniswap.org/protocol/V2/guides/smart-
contract-integration/trading-from-a-smart-contract>

2 - If you know how much LINK will be required for the contract, you can
simply pre-fund it beforehand, or when it's created. Am guessing this isn't
the case for you though.

3 - Do it external to the blockchain. ie you can have a process running that
funds the contract with link every so often, checking if its empty or near
empty

4 - You can make use of meta-transactions so that the people playing the game
don't need any LINK. See [this example](https://github.com/pappas999/Link-Gas-
Station). Take note this still uses an external relayer like I mentioned in
the last point

5 - I've seen examples where others just pay an upfront cost to ensure the
coordinator contracts are well funded with LINK, and then they manually just
top them up as needed, using users deposited eth/funds as a kind of payment to
offset them having to send LINK to the contract.





:::NEXT DOC:::

contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
   

:::NEXT DOC:::

Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                  

:::NEXT DOC:::

can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  *

:::NEXT DOC:::

like the costs would be
non-trivial / hard to predict)?

Alternatively, if you wanted your NFT consumer to fund it, would you have to
build in some logic that converts Ether to Link and then sends it to the
oracle contract? (or make them go buy Link token?)

I could be looking at this the wrong way, but the scalability just doesn't
seem well described in the documentation and only looked at from a testing /
test network standpoint. Thank you.



Answers:
(Answered on: 2021-11-08 05:04:46)


My suggestion is, maybe a little awkward, but for the sake of
decentralization, could work.

  * You charge your Contract1 with a sufficient link to get started

  * Charge every minter the equivalent link transaction cost in eth (+ the % that covers the costs of the trade to link and transfer between contracts)

  * As they mint, it is incorporated into the price and the eth is sent to Contract2.

  * In Contract2 simply exists a public callable function to initiate a swap for the link via routerV2 or a similar contract.

  * By placing a call to this function and contract, you can then just let any minter activate the swap contract function

  * The eth in Contract2 will be sent back to Contract1 as a link.

  * You could have a counter go and then call Contract2 every time the link fund is low and refill it automatically.

  * If you build it into the mint, then the inter will cover the fees.


---
(Answered on: 2021-04-16 11:20:22)


You can:

  1. Move the costs directly to the caller

_Require`LINK` payment, or some other form of payment that will cover the
costs of oracle request_

  2. Request the oracle data in a smaller frequency (if your use case allows it)

_Are you receiving some price info from

:::NEXT DOC:::

here](https://docs.chain.link/data-feeds/price-feeds/addresses/) get the
`ETH/USD` goerli testnet address:""0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e""

  * Now in order to call chainlink oracle you have to have `LINK` token in your contract. Get some link token to your conract address [from the faucet](https://faucets.chain.link/)

  * Import the token in metamask. you will see the amount

  * send link token from your metamask to your contract

  * deploy your contract. if you are using `Remix IDE` chose the `injected provider` to connect to metamask. Because chainlink contract is on goerli, so you need to be on Goerli testnet. Once deployment goes through you can call the `fund` function.

  * Since the `fund` function has no argument, you need to send the value alongside the transaction. That is why inside the function you have `msg.value` to access to the sent amount.

  * In `Remix` ide, under ""GAS LIMIT`input there is`VALUE`input. you need to pass the amount in there before you call the`fund` function.





:::NEXT DOC:::

with, and what external APIs it might call.

  2. **Compile:** Pass your smart contract code through a compiler to translate the contract into byte code that the blockchain can understand. For example, [Solidity](https://soliditylang.org) code must be compiled before it can run in the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/).

  3. **Deploy:** Send the compiled smart contract to the blockchain. From that point forward, the contract cannot be altered. However, you can still interact with the contract in several ways.

  4. **Run functions:** When you run the functions that you defined for the contract, the network processes those functions and modifies the state of your contract. For some functions, the network charges a small fee to complete the work. Your contract can also have functions that transfer funds to other contracts or wallets.

This guide walks you through each step, but you must install and fund your
MetaMask wallet first.

## Install and fund your MetaMask wallet

Deploying smart contracts on-chain requires a wallet and ETH. The ETH pays for
the work required by the Ethereum network to add the contract to the
blockchain and store the variables. The wallet holds the ETH that you need to
pay for the transaction. Install MetaMask, configure it to use the [Sepolia
testnet](https://sepolia.dev/), and fund your wallet with free testnet ETH.

  1. [Install and configure the MetaMask extension](https://metamask.io/download) in your browser.

  2. After you install the extension, open your browser extension list and click MetaMask to open MetaMask.

  3. Follow the instructions in MetaMask to create a new MetaMask wallet. The new wallet includes a 12-word mnemonic phrase. This phrase is the key to your wallet. Copy that phrase down in a very secure location that only you can access. You can use this phrase to retrieve your wallet later or add it to another browser.

  4. Set MetaMask to use

:::NEXT DOC:::

 * By placing a call to this function and contract, you can then just let any minter activate the swap contract function

  * The eth in Contract2 will be sent back to Contract1 as a link.

  * You could have a counter go and then call Contract2 every time the link fund is low and refill it automatically.

  * If you build it into the mint, then the inter will cover the fees.


---
(Answered on: 2021-04-16 11:20:22)


You can:

  1. Move the costs directly to the caller

_Require`LINK` payment, or some other form of payment that will cover the
costs of oracle request_

  2. Request the oracle data in a smaller frequency (if your use case allows it)

_Are you receiving some price info from an oracle? Is it sufficient to update
the price info once a day instead of once an hour?_

  3. Change your contract logic to not require (that much) oracle data

_Does your factory really need off-chain random number generation? Wouldn't be
sufficient to generate ""random"" number from the blockhash, difficulty, etc.?_





:::NEXT DOC:::

address are regularly confused):

`0x6a61789194260F0BE95a18d0116d883A4b5284ed` is the address of your Chainlink
node (you can see in the key tab of the GUI), which needs to be funded with
ETH in order to send transactions on-chain. The Chainlink node listens to
event logs emitted by the oracle smart contract used in the job spec, the
oracle address is not the account you used to deploy it, but the address of
the newly deployed oracle smart contract, make sure to follow these steps:
<https://docs.chain.link/docs/fulfilling-requests/#deploy-your-own-oracle-
contract>

You can find the oracle contract address in Remix and the block explorer of
the underlying network, that's what you need to use in your consumer contract
in order to make successful requests, the LINK rewards can then be withdrawn
from the oracle contract.



"
What is the purpose of the `fulfillOracleRequest` function in the Oracle contract?,The `fulfillOracleRequest` function is used by the node to fulfill a request once it has the result of the job. This function returns the result to the `ChainlinkClient` using the callback function defined in the original request.,{'source': 'https://docs.chain.link/architecture-overview/architecture-request-model/'},The purpose of the `fulfillOracleRequest` function in the Oracle contract is to receive the response from the external API call and fulfill the Chainlink request with the requested data.,"sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### fulfillOracleRequest

Legacy

Use `fulfillOracleRequest2` function instead.


    function fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data) external returns (bool)

Called by the Chainlink node to fulfill requests. Given params must hash back
to the commitment stored from `oracleRequest`. Will call the callback address'
callback function without bubbling up error checking in a `require` so that
the node can get paid. Emits OracleResponse event.

##### Parameters

| Name               | Type    | Description                                               

:::NEXT DOC:::

items:

  * The oracle address.
  * The job ID, so the oracle knows which tasks to perform.
  * The callback function, which the oracle sends the response to.

To learn about how to find oracles to suit your needs, see [Find Existing
Jobs](/any-api/find-oracle).

Oracle contracts are responsible for handling on-chain requests made through
the LINK token, by implementing `onTokenTransfer` as a
[`LinkTokenReceiver`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/LinkTokenReceiver.sol).
Upon execution of this function, the oracle contract **emits an`OracleRequest`
event** containing information about the request. This event is crucial, as it
is monitored by the off-chain oracle node which acts upon it.

#### Fulfillment

For fulfillment, the oracle contract has a `fulfillOracleRequest` function
which is used by the node to fulfill a request once it has the result of the
job. This function returns the result to the `ChainlinkClient` using the
callback function defined in the original request.

### Off-Chain Oracle Node

The off-chain oracle node is responsible for listening for events emitted by
its corresponding on-chain smart contract. Once it detects an `OracleRequest`
event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API,
retrieve some data from it, parse the response, convert the result into
blockchain compatible data, then submit it in a transaction back to the oracle
contract, using the `fulfillOracleRequest` function.

For more information on how to become a node operator, learn how to [run a
Chainlink node](/chainlink-nodes/v1/running-a-chainlink-node).

## Consumer UML

Below is a UML diagram describing the contract structure

:::NEXT DOC:::

 jobId,
                address(this),
                this.fulfill.selector
            );
            request.add(""orgAddress"", ""2021-11-02"");
            request.add(""senderAddress"", ""12111"");
            request.add(""receiverAddress"", ""FL"");
            request.add(""jwtToken"", _jwtToken);
            sendChainlinkRequestTo(oracle, request, fee);
        }
    
        /**
         * Callback function
         */
        function fulfill(
            bytes32 _requestId,
            uint256 _allInSystem,
            uint256 _isProject,
            uint256 _senderAuthority,
            uint256 _receiverAuthority
        ) public recordChainlinkFulfillment(_requestId) {
            allInSystem = _allInSystem;
            isProject = _isProject;
            senderAuthority = _senderAuthority;
            receiverAuthority = _receiverAuthority;
            emit requestFulfilled(
      

:::NEXT DOC:::

`fulfillOracleRequest2` function instead.


    function fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data) external returns (bool)

Called by the Chainlink node to fulfill requests. Given params must hash back
to the commitment stored from `oracleRequest`. Will call the callback address'
callback function without bubbling up error checking in a `require` so that
the node can get paid. Emits OracleResponse event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes32 | The data to return to

:::NEXT DOC:::

   nan | bool   | Status if the external call was successful |
#### fulfillOracleRequest2


    function fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data) external returns (bool)

Called by the Chainlink node to fulfill requests with multi-word support.
Given params must hash back to the commitment stored from `oracleRequest`.
Will call the callback address' callback function without bubbling up error
checking in a `require` so that the node can get paid. Emits OracleResponse
event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data   

:::NEXT DOC:::

          | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes32 | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### fulfillOracleRequest2


    function fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data) external returns (bool)

Called by the Chainlink node to fulfill requests with multi-word support.
Given params must hash back to the commitment stored from `oracleRequest`.
Will call the callback address' callback function without bubbling up error
checking in a `require` so that the node can get paid. Emits OracleResponse
event.

##### Parameters

| Name               | Type    | Description               

:::NEXT DOC:::

contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription

:::NEXT DOC:::

Chainlink.

  2. The `Messenger` smart contract sends the request the `PreCoordinator` smart contract .

  3. The `PreCoordinator` forwards the request to the Oracles defined in a Service Agreement (proxy of Oracles).

  4. Upon receiving LINK, each Oracle sends the request to the Chainlink node, by emitting an `OracleRequest` event with the id of the job to be executed.

  5. The Chainlink node captures such event, and executes the corresponding job.

  6. Once the job is executed, the Chainlink node calls the `fulfillOracleRequest2` function to return the result from the external adapter to the PreCoordinator.

  7. The PreCoordinator takes the mean of all Oracle results and ultimately registers the SLI in the messenger.

  8. The SLA is verified (real vs goal) by comparing the SLI (real) and the SLO (goal).

## Fulfillment Issue

It appears our node doesn't pick the OracleRequest event of our PreCoordinator
v0.6 / Operator v0.7 setup.

The request is never fulfilled so we've been wondering if our job id syntax is
correct in the PreCoordinator service agreements (among other things) and if,
perhaps, there's a peculiar configuration to apply to the node / v2 job specs.

## AnyAPI Stack

  * PreCoordinator.sol: a proxy for using multiple Chainlink oracles using service agreements

  * v0.6 Chainlink contracts:

    
    
    import '@chainlink/contracts/src/v0.6/ChainlinkClient.sol';
    import '@chainlink/contracts/src/v0.6/LinkTokenReceiver.sol';
    import '@chainlink/contracts/src/v0.6/Median.sol';
  

:::NEXT DOC:::

Question: (Asked on: 2022-01-03 22:58:46)
Chainlink fulfillOracleRequest with Large bytes data
URL: https://stackoverflow.com/questions/70572337/chainlink-fulfilloraclerequest-with-large-bytes-data

Question Body:


In order to receive a full url trough a chainlink Oracle I would like to pass
bytes to my fulfillment method.

`fulfillOracleRequest` are sent by the node but my Oracle contract rejects
them. [I suspect it can only accept byte32
data](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Oracle.sol#L125).
According to [Chainlink's documentation](https://docs.chain.link/docs/large-
responses/) it should be possible.



Answers:
(Answered on: 2022-01-03 23:01:26)


Deploy Operator.sol from 0.7 instead of Oracle.sol





:::NEXT DOC:::

 // {""player"": {
            //            ""id"": ""4291820"",
            //            ""score"": 560
            //        }
            //  }
            request.add(""path"", ""player.score"");
            
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, uint256 _score) public recordChainlinkFulfillment(_requestId)
        {
            playerScore = _score;
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    



Answers:
(Answered on: 2022-07-22 23:02:38)


I succeed to implement an external API call from a smart-contract by using
[Frensprotocol oracle](https://www.frensprotocol.com). The
[documentation](https://docs.frensprotocol.com/) helped. And to get the tokens
to make the Oracle work you can"
What is the purpose of the 'proposedFeed' function?,The 'proposedFeed' function is used to propose a new price feed for a given base and quote currency pair.,{'source': 'https://docs.chain.link/data-feeds/feed-registry/'},The 'proposedFeed' function is not mentioned in the given context information.,"type: ""uint80"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""getProposedFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""proposedAggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" },
        ],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
  

:::NEXT DOC:::

name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""address"", name: ""aggregator"", type: ""address"" },
        ],
        name: ""proposeFeed"",
        outputs: [],
        stateMutability: ""nonpayable"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""proposedGetRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""id"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
    

:::NEXT DOC:::

[
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""getRoundFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""aggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint256"", name: ""roundId"", type: ""uint256"" },
        ],
        name: ""getTimestamp"",
        outputs: [{ internalType: ""uint256"", name: ""timestamp"", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""address"", name: ""aggregator"", type: ""address"" }],
        name: ""isFeedEnabled"",
        outputs: [{ internalType: ""bool"", name: """", type: ""bool"" }],
        stateMutability: ""view"",
  

:::NEXT DOC:::

       { internalType: ""uint80"", name: ""id"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""proposedLatestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""id"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
   

:::NEXT DOC:::

mass liquidations by
providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds feeds, see the [L2 Sequencer
Uptime Feeds](/data-feeds/l2-sequencer-feeds) documentation.

## Components of a data feed

Data Feeds are an example of a decentralized oracle network and include the
following components:

  * **Consumer** : A consumer is an on-chain or off-chain application that uses Data Feeds. Consumer contracts use the [`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) to call functions on the proxy contract and retrieve information from the aggregator contract. For a complete list of functions available in the `AggregatorV3Interface`, see the [Data Feeds API Reference](/data-feeds/api-reference/#aggregatorv3interface).
  * **Proxy contract** : Proxy contracts are on-chain proxies that point to the aggregator for a particular data feed. Using proxies enables the underlying aggregator to be upgraded without any service interruption to consuming contracts. Proxy contracts can vary from one data feed to another, but the [`AggregatorProxy.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol) on Github is a common example.
  * **Aggregator contract** : An aggregator is a contract that receives periodic data updates from the oracle network. Aggregators store aggregated data on-chain so that consumers can retrieve it and act upon it within the same transaction. For a complete list of functions and variables available on most aggregator contracts, see the [Data Feeds API Reference](/data-feeds/api-reference/#accesscontrolledoffchainaggregator).

To learn how to create a consumer contract

:::NEXT DOC:::

   inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""latestTimestamp"",
        outputs: [{ internalType: ""uint256"", name: ""timestamp"", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""owner"",
        outputs: [{ internalType: ""address"", name: """", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""address"", name: ""aggregator"", type: ""address"" },
        ],
        name: ""proposeFeed"",
        outputs: [],
        stateMutability: ""nonpayable"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
         

:::NEXT DOC:::

do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds

:::NEXT DOC:::

name: ""currentPhaseId"", type: ""uint16"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""getFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""aggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""getNextRoundId"",
        outputs: [{ internalType: ""uint80"", name: ""nextRoundId"", type: ""uint80"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"",

:::NEXT DOC:::

    name: ""getPhaseRange"",
        outputs: [
          { internalType: ""uint80"", name: ""startingRoundId"", type: ""uint80"" },
          { internalType: ""uint80"", name: ""endingRoundId"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""getPreviousRoundId"",
        outputs: [{ internalType: ""uint80"", name: ""previousRoundId"", type: ""uint80"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""getProposedFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""proposedAggregator"", type: ""address"" }],
        stateMutability:

:::NEXT DOC:::

},
        ],
        name: ""getTimestamp"",
        outputs: [{ internalType: ""uint256"", name: ""timestamp"", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""address"", name: ""aggregator"", type: ""address"" }],
        name: ""isFeedEnabled"",
        outputs: [{ internalType: ""bool"", name: """", type: ""bool"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""latestAnswer"",
        outputs: [{ internalType: ""int256"", name: ""answer"", type: ""int256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""latestRound"",
        outputs:"
What is Chainlink VRF and how can it be used in smart contracts?,Chainlink VRF is a provably-fair and verifiable source of randomness designed for smart contracts. Smart contract developers can use Chainlink VRF as a tamper-proof random number generator (RNG) to build reliable smart contracts for any applications which rely on unpredictable outcomes.,{'source': 'https://docs.chain.link/vrf/v1/introduction/'},"Chainlink VRF (Verifiable Randomness Function) is a service that provides cryptographic proof alongside every random number generated, ensuring that the random number wasn't tampered with and generated in a random way. It consists of the computers running the Chainlink nodes and two main smart contracts: the Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2). The Client Contract allows a contract to send requests and receive answers from the Chainlink VRF, while the Coordinator contract manages subscriptions to the Chainlink VRF and verifies every random number alongside its proof. Smart contracts can use Chainlink VRF to generate verifiably random and decentralized randomness.","how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation

:::NEXT DOC:::

#####Chapter 3:

# Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson randomness provided by an outside service needs to be verifiable and decentralized, and that’s exactly what Chainlink VRF is! VRF stands for Verifiable Randomness Function. Essentially Chainlink VRF provides cryptographic proof alongside every random number generated, that the random number wasn’t tampered with (and indeed generated in a random way).

How does this cryptographic proof work? It’s quite mathematically complicated and outside the scope of this lesson, but you can read more about it in the “Technical Walkthrough” section of this [blog post](https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/). The cryptographic proof is then verified by a smart contract on-chain, which means it is verified by every node on the blockchain! This completes our verifiable and decentralized criteria. So now we understand that Chainlink VRF is verifiably random and decentralized how do we use it?


:::NEXT DOC:::

understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.


:::NEXT DOC:::

# Random Numbers: Using Chainlink VRF

  * Overview
  * How is randomness generated on blockchains? What is Chainlink VRF?
  * What is the Request and Receive cycle?
  * What is the payment process for generating a random number?
  * How can I use Chainlink VRF?
  * Create and fund a subscription
  * Importing VRFConsumerBaseV2 and VRFCoordinatorV2Interface
  * Contract variables
  * Initializing the contract
  * rollDice function
  * fulfillRandomWords function
  * house function
  * How do I deploy to testnet?
  * How do I add my contract to my subscription account?
  * How do I test rollDice?
  * Further Reading

Requirements

This guide assumes that you have basic knowledge about writing and deploying
smart contracts. If you are new to smart contract development, read the
[Consuming Data Feeds](/getting-started/consuming-data-feeds) guide before you
begin.

VRF v2 - Developer Walkthrough

In this guide, you will learn about generating randomness on blockchains. This
includes learning how to implement a Request and Receive cycle with Chainlink
oracles and how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted

:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription

:::NEXT DOC:::

# Introduction to Chainlink VRF [v1]

  * Overview
  * Generate Random Numbers in your Smart Contracts
  * On-chain Verification of Randomness

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

## Generate Random Numbers in your Smart Contracts

Chainlink VRF (Verifiable Random Function) is a provably-fair and verifiable
source of randomness designed for smart contracts. Smart contract developers
can use Chainlink VRF as a tamper-proof random number generator (RNG) to build
reliable smart contracts for any applications which rely on unpredictable
outcomes:

  * Blockchain games and NFTs
  * Random assignment of duties and resources (e.g. randomly assigning judges to cases)
  * Choosing a representative sample for consensus mechanisms

Learn how to write smart contracts that consume random numbers: [Get a Random
Number](/vrf/v1/examples/get-a-random-number).

## On-chain Verification of Randomness

Chainlink VRF enables smart contracts to access randomness without
compromising on security or usability. With every new request for randomness,
Chainlink VRF generates a random number and cryptographic proof of how that
number was determined. The proof is published and verified on-chain before it
can be used by any consuming applications. This process ensures that the
results cannot be tampered with nor manipulated by anyone, including oracle
operators, miners, users and even smart contract developers.

Read more about Chainlink VRF in [our announcement
post](https://blog.chain.link/verifiable-random-functions-vrf-random-number-generation-rng-feature/).

## What's next

  * [› Get a Random Number](/vrf/v1/examples/get-a-random-number)
  * [› API

:::NEXT DOC:::

#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is

:::NEXT DOC:::

Question: (Asked on: 2021-10-04 21:59:28)
What it is the VRF coordinator contract on Chainlink?
URL: https://stackoverflow.com/questions/69442819/what-it-is-the-vrf-coordinator-contract-on-chainlink

Question Body:


Im learning Chainlink with solidity but i cant find information about what it
is the coordinator contract that is needed to create an instance of
VRFConsumerBase



Answers:
(Answered on: 2021-10-06 02:32:49)


The [Chainlink VRF
Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/VRFCoordinator.sol)
is a contract that is deployed to a blockchain that will check the randomness
of each random number returned from a random node.

You can find the addresses of these contracts on each chain in the [Chainlink
documentation under ""Contract Addresses""](https://docs.chain.link/docs/vrf-
contracts/)

[](https://i.stack.imgur.com/Pce2Q.png)





:::NEXT DOC:::

based on something (could be user input or on-chain data, it doesn't
matter) before the call to the oracle is made (the call passes the seed to the
oracle). Once the oracle generates a random number, the VRF function can then
use math and cryptography to actually verify that the random number was
created based from the initial seed, and that it's not just some random number
plucked from the air (and potentially malicious). This is the magic of VRF,
being able to verify a random number was created with a previously committed
seed. So combining a VRF function with an oracle is the best possible way for
a safe and secure source of randomness in a smart contract.

[Chainlink VRF](https://chain.link/chainlink-vrf) is the industry standard for
randomness on blockchains, and I highly suggest you look into it. If it's cost
you're worried about, I think its cheaper to use on other chains like Polygon
or BSC. Also if you speak to the Chainlink Labs team, they can possibly work
out some agreement that is more feasible for bootstrapped projects





:::NEXT DOC:::

Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!
"
What is the purpose of the useChainlinkWithENS function?,"The useChainlinkWithENS function allows a Chainlink contract to store the addresses of the LINK token and oracle contract addresses without supplying the addresses themselves, using ENS where available to resolve these addresses.",{'source': 'https://docs.chain.link/any-api/api-reference/'},"The useChainlinkWithENS function allows a Chainlink contract to store the addresses of the LINK token and oracle contract addresses without supplying the addresses themselves, using ENS where available to resolve these addresses. It requires the address of the ENS contract and the node for the domain. This function is used for updating oracle addresses and is part of the Chainlink API.","_payment, _callbackFunc, _expiration);
    }

### useChainlinkWithENS


    function useChainlinkWithENS(
      address _ens,
      bytes32 _node
    )

Allows a Chainlink contract to store the addresses of the LINK token and
oracle contract addresses without supplying the addresses themselves. We use
ENS where available to resolve these addresses. It requires the address of the
ENS contract and the node (which is a hash) for the domain.

If your Oracle provider supports using ENS for rolling upgrades to their
oracle contract, once you've pointed your Chainlinked contract to the ENS
records then you can update the records using updateChainlinkOracleWithENS.


    address constant ROPSTEN_ENS = 0x112234455C3a32FD11230C42E7Bccd4A84e02010;
    bytes32 constant ROPSTEN_CHAINLINK_ENS = 0xead9c0180f6d685e43522fcfe277c2f0465fe930fb32b5b415826eacf9803727;
    
    constructor(){
      useChainlinkWithENS(ROPSTEN_ENS, ROPSTEN_CHAINLINK_ENS);
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Oracle.sol)
or trust whoever can update the records.

### updateChainlinkOracleWithENS


   

:::NEXT DOC:::

     useChainlinkWithENS(ROPSTEN_ENS, ROPSTEN_CHAINLINK_ENS);
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Oracle.sol)
or trust whoever can update the records.

### updateChainlinkOracleWithENS


    function updateChainlinkOracleWithENS()

Updates the stored oracle contract address with the latest address resolved
through the ENS contract. This requires the oracle provider to support listing
their address on ENS.

This method only works after useChainlinkWithENS has been called on the
contract.


    function updateOracleAddressToLatest() public {
      updateChainlinkOracleWithENS();
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or trust whoever can update the records.

### chainlinkTokenAddress


    function chainlinkTokenAddress() returns (address)

The `chainlinkTokenAddress` function is a helper used to return the stored
address

:::NEXT DOC:::

                          |
| updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS                                                 |
| chainlinkTokenAddress        | Returns the stored address of the LINK token                                                                                   |
| chainlinkOracleAddress       | Returns the stored address of the oracle contract                                                                              |
### Events

| Name               | Description                                                                  |
|:-------------------|:-----------------------------------------------------------------------------|
| ChainlinkRequested | Emitted from a Chainlinked contract when a request is sent to an oracle      |
| ChainlinkFulfilled | Emitted from a Chainlinked contract when a request is fulfilled by an oracle |
| ChainlinkCancelled | Emitted from a Chainlinked contract when a request is cancelled       

:::NEXT DOC:::

     |
| validateChainlinkCallback    | Secures the fulfillment callback to make sure it is only called by permissioned senders                                        |
| addChainlinkExternalRequest  | Allows a Chainlinked contract to track unfulfilled requests that it hasn't created itself                                      |
| cancelChainlinkRequest       | Cancels Chainlink requests attempting to contact an unresponsive node                                                          |
| useChainlinkWithENS          | Looks up the addresses of the LINK token and Oracle contract through ENS                                                       |
| updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS                                                 |
| chainlinkTokenAddress        | Returns the stored address of the LINK token                                                                           

:::NEXT DOC:::

`cancelChainlinkRequest`
will send the cancel request to the address used for the request, which
transfers the amount of LINK back to the requesting contract, and delete it
from the tracked requests.

The default expiration for a request is five minutes, after which it can be
cancelled. The cancellation must be sent by the address which was specified as
the callback location of the contract.

For the sake of efficient gas usage, only a hash of the request's parameters
are stored on-chain. In order to validate the terms of the request and that it
can be calculated, the request parameters must be provided. Additionally,
cancellation must be called by the address which the callback would otherwise
have been called on.

`cancelChainlinkRequest` emits a ChainlinkCancelled event.


    function cancelRequest(
        bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunc,
        uint256 _expiration
    ) public {
      cancelChainlinkRequest(_requestId, _payment, _callbackFunc, _expiration);
    }

### useChainlinkWithENS


    function useChainlinkWithENS(
      address _ens,
      bytes32 _node
    )

Allows a Chainlink contract to store the addresses of the LINK token and
oracle contract addresses without supplying the addresses themselves. We use
ENS where available to resolve these addresses. It requires the address of the
ENS contract and the node (which is a hash) for the domain.

If your Oracle provider supports using ENS for rolling upgrades to their
oracle contract, once you've pointed your Chainlinked contract to the ENS
records then you can update the records using updateChainlinkOracleWithENS.


    address constant ROPSTEN_ENS =

:::NEXT DOC:::

   }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    

Javascript Script To Deploy:

    
    
    const APIConsumer = artifacts.require(""APIConsumer"");
    module.exports = async (deployer, network, [defaultAccount]) => {
      try {
        await deployer.deploy(APIConsumer);
      } catch (err) {
        console.error(err);
      }
    };
    



Answers:
(Answered on: 2021-10-11 19:45:39)


[`setChainlinkToken`](https://github.com/smartcontractkit/chainlink/blob/d8982d45739a2157c3c5d73d2462b8b449165308/contracts/src/v0.8/ChainlinkClient.sol#L219)
is a function that tells the oracle contract what it should use to accept LINK
payments. It points to an ERC677 token for the contracts to use.

You have to know what the LINK token address is to use this function.

The
[`setPublicChainlinkToken()`](https://github.com/smartcontractkit/chainlink/blob/d8982d45739a2157c3c5d73d2462b8b449165308/contracts/src/v0.8/ChainlinkClient.sol#L227)
is a way to set the LINK token address without knowing it's address. There is
an on-chain contract (on specific chains) that has a pointer to a ""link token
contract"" registry that points to the address of the LINK token on different
chains. So this

:::NEXT DOC:::

   }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or trust whoever can update the records.

### chainlinkTokenAddress


    function chainlinkTokenAddress() returns (address)

The `chainlinkTokenAddress` function is a helper used to return the stored
address of the Chainlink token. This variable is protected and so only made
available through getters and setters.


    function withdrawLink() public {
      LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
    
      require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
    }

### chainlinkOracleAddress

The `chainlinkOracleAddress` function is a helper used to return the stored
address of the oracle contract.


    function getOracle() public view returns (address) {
      return chainlinkOracleAddress();
    }
    

## Events

### ChainlinkRequested


    event ChainlinkRequested(
      bytes32 indexed id
    )

Emitted when sendChainlinkRequest and sendChainlinkRequestTo are called.
Includes the request ID as an event topic.

### ChainlinkFulfilled


    event ChainlinkFulfilled(
      bytes32 indexed id
    )

Emitted when validateChainlinkCallback or recordChainlinkFulfillment are
called.

:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties

:::NEXT DOC:::

and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to

:::NEXT DOC:::

the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature improvements
along with interface and contract changes. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and add your EVM account address to the allow list.

## Supported networks

See the [Supported Networks](/chainlink-functions/supported-networks) page to
find a list of supported networks and contract"
What is the minimum spend requirement for each registered upkeep in the Keepers Registry v1.2?,"Each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam.",{'source': 'https://docs.chain.link/chainlink-automation/automation-release-notes/'},"The minimum spend requirement for each registered upkeep in the Keepers Registry v1.2 is 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam.","compute sequence is improved for higher-fidelity representation of the gas and logic before transactions are submitted on-chain. This helps to reduce reverts and reduce fees.

  * **Minimum spend requirement** : As part of the mission to continuously enhance the security of the Chainlink Network for all participants, each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam. Note that an _upkeep_ is the automation job itself. It is not a transaction. Each upkeep can have thousands of transactions. If an upkeep has not spent more than 0.1 LINK across all transactions at the time of cancellation, then 0.1 LINK will be retained for the network. If more than 0.1 LINK has been spent by an upkeep, the full remaining balance of the upkeep will be withdrawable when the upkeep is canceled.

### Manually migrating upkeeps from v1.1 to v1.2

If your upkeep ID has 77 digits, it is already migrated to v1.2 and no further
action is required. If your upkeep ID has less than 4 digits, your upkeep is
on the v1.1 registry. To migrate your upkeep from Keepers v1.1 to Keepers
v1.2, you can cancel it in the Keepers App, and register an exact copy of the
upkeep in the Keepers App. While you can see upkeeps from both v1.1 and v1.2
in the [Keepers App](https://automation.chain.link), all new upkeeps in the
Keepers App will be automatically created on Keepers v1.2.

## 2022-07-21 - Underfunded upkeep notifications

You will now receive notifications to the email address you register in your
upkeep when your upkeep is underfunded. We are limiting notifications on the
same upkeep to once per week.

##

:::NEXT DOC:::

your upkeep ID has less than 4 digits, your upkeep is
on the v1.1 registry. To migrate your upkeep from Keepers v1.1 to Keepers
v1.2, you can cancel it in the Keepers App, and register an exact copy of the
upkeep in the Keepers App. While you can see upkeeps from both v1.1 and v1.2
in the [Keepers App](https://automation.chain.link), all new upkeeps in the
Keepers App will be automatically created on Keepers v1.2.

## 2022-07-21 - Underfunded upkeep notifications

You will now receive notifications to the email address you register in your
upkeep when your upkeep is underfunded. We are limiting notifications on the
same upkeep to once per week.

## 2022-06-29 - Keepers on Fantom

Chainlink Keepers is live on the Fantom Network,
[Mainnet](https://automation.chain.link/fantom) and
[Testnet](https://automation.chain.link/fantom-testnet).

## 2022-06-09 - Keepers on Avalanche

Chainlink Keepers is live on the Avalanche Network,
[Mainnet](https://automation.chain.link/avalanche) and
[Testnet](https://automation.chain.link/fuji).

## 2022-03-01 - Keepers on Ethereum Rinkeby

Chainlink Keepers is live on [Ethereum
Rinkeby](https://automation.chain.link/rinkeby).

## 2021-11-18 - Keepers on Binance Smart Chain and Polygon

Chainlink Keepers is live on the both Binance Smart Chain
[Mainnet](https://automation.chain.link/bsc) and
[Testnet](https://automation.chain.link/chapel), and Polygon
[Mainnet](https://automation.chain.link/polygon)

:::NEXT DOC:::

and click on your recently registered Upkeep under My Upkeeps.

  2. **Click the`Add funds` button**

  3. **Approve the LINK spend allowance**

  4. **Confirm the LINK transfer** by sending funds to the Chainlink Automation Network Registry 

  5. **Receive a success message** and verify that the funds were added to the Upkeep 

## Maintain a Minimum Balance

Each Upkeep has a [minimum balance](/chainlink-automation/automation-economics/#minimum-balance) to ensure that an Upkeeps will still run should a
sudden spike occur. If your Upkeep LINK balance drops below this amount, the
Upkeep will not be performed.

To account for Upkeep execution over time and possible extended gas spikes,
maintain an Upkeep LINK balance that is 3 to 5 times the minimum balance. Note
if you have an upkeep that performs frequently you may want to increase the
buffer to ensure a reasonable interval before you need to fund again.
Developers also have the ability to update `performGasLimit` for an upkeep.

## Withdraw funds

To withdraw funds, the Upkeep administrator have to cancel the Upkeep first.
There is a 50 block delay once an Upkeep has been cancelled before funds can
be withdrawn. Once 50 blocks have passed, select **Withdraw funds**.

## Interacting directly with the Chainlink Automation Registry

After registration, you can interact directly with the [registry
contract](/chainlink-automation/supported-networks/#configurations) functions
such as `cancelUpkeep` and `addFunds` using your **Upkeep ID**. The Registry
Address might change when new contracts are deployed with new functionality.

## What's next

  * [› Automation economics](/chainlink-automation/automation-economics/)

  * [ Edit this page

:::NEXT DOC:::

supported mainnets are now automatically approved.

  * **Programmatic control** : With automatic approval, you can now dynamically create, manage, and fund upkeeps from within your dApps and even have an upkeep fund itself. Learn more [here](/chainlink-automation/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract).

  * **Advanced turn-taking algorithm** : Our turn taking algorithm now supports upkeeps that require high-frequency execution.

  * **Durable ID and user-triggered migration** : All upkeeps created in versions v1.2 and later will have durable IDs. v1.2 also supports user-triggered migration to future registry versions to make it easier to migrate to a new Keepers Registry and benefit from new features. Future migrations can still retain the existing ID. The ID is now a hash in format of a 77 digit integer.

  * **Configurable upkeeps** : You can now edit the gas limit of your upkeep to easily customize your upkeep to fit your needs without having to create a new upkeep.

  * **Off-chain compute improvements** : The off-chain compute sequence is improved for higher-fidelity representation of the gas and logic before transactions are submitted on-chain. This helps to reduce reverts and reduce fees.

  * **Minimum spend requirement** : As part of the mission to continuously enhance the security of the Chainlink Network for all participants, each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam. Note that an _upkeep_ is the automation job itself. It is not a transaction. Each upkeep can have thousands of transactions. If an upkeep has not spent more than 0.1 LINK across all transactions at the time of cancellation, then 0.1 LINK will be retained for the network. If more than 0.1 LINK has

:::NEXT DOC:::

                                         |
|:---------------|:----------------------------------------------------------------------------------------------------------------------------------------|
| name           | Name of Upkeep                                                                                                                          |
| encryptedEmail | Not in use in programmatic registration. Please specify with 0x                                                                         |
| upkeepContract | Address of Keepers-compatible contract that will be automated                                                                           |
| gasLimit       | The maximum amount of gas that will be used to execute your function on-chain                                                           |
| adminAddress   | Address for Upkeep administrator. Upkeep administrator can fund contract. 

:::NEXT DOC:::

the [Automation Economics](/chainlink-automation/automation-economics) page to learn more about the cost of using
Chainlink Automation.

Testing and best practices

Follow the [best practices](/chainlink-automation/compatible-contract-best-practice) when creating a compatible contract and test your upkeep on a
testnet before deploying it to a mainnet.

  6. **Click`Register upkeep`** and confirm the transaction in MetaMask. 

Your upkeeps will be displayed in your list of **Active Upkeeps**. You must
monitor the balance of your upkeep. If the balance drops below the **minimum
balance** , the Chainlink Automation Network will not perform the Upkeep. See
[Managing Upkeeps](/chainlink-automation/manage-upkeeps) to learn how to
manage your upkeeps.

## Register an Upkeep using your own deployed contract

You can dynamically create and manage Upkeeps using your own smart contracts.
The following example displays a smart contract that can create an Upkeep and
determine the Upkeep ID. You can also program your Upkeep to check its own
balance and fund itself by interacting with the registry.

### Prerequisites

Find the following addresses for your network:

  * Correct [LINK token contract](/resources/link-token-contracts)
  * [Registry and registrar addresses for your network](/chainlink-automation/supported-networks/#configurations)

Optionally, you can fetch the LINK address and registrar address from the
intended registry at run-time.

Fund your contract

Make sure your contract has enough [ERC-677 LINK](/resources/link-token-contracts) to fund the Upkeep at creation. _The minimum amount is 0.1 LINK._

Mainnets and testnets use different versions of the Registry and Registrar
interfaces.

  * Mainnets: Use the v1.x registrar and registry interfaces.

:::NEXT DOC:::

           |
|:---------------|:----------------------------------------------------------------------------------------------------------------------------------------|
| name           | Name of Upkeep                                                                                                                          |
| encryptedEmail | Not in use in programmatic registration. Please specify with 0x                                                                         |
| upkeepContract | Address of Keepers-compatible contract that will be automated                                                                           |
| gasLimit       | The maximum amount of gas that will be used to execute your function on-chain                                                           |
| adminAddress   | Address for Upkeep administrator. Upkeep administrator can fund contract.                               

:::NEXT DOC:::

# Managing Upkeeps

  * Overview
  * Fund your Upkeep
  * Maintain a Minimum Balance
  * Withdraw funds
  * Interacting directly with the Chainlink Automation Registry

Manage your Upkeeps to get the best performance.

## Fund your Upkeep

You must monitor the balance of your Upkeep. If the Upkeep LINK balance drops
below the [minimum balance](/chainlink-automation/automation-economics/#minimum-balance), the Chainlink Automation Network will not perform
the Upkeep.

ERC677 Link

For funding on Mainnet, you need ERC-677 LINK. Many token bridges give you
ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be
ERC-677 compatible](https://pegswap.chain.link/). To fund on a supported
testnet, get [LINK](/resources/link-token-contracts) from
[faucets.chain.link](https://faucets.chain.link/).

Follow these steps to fund your Upkeep:

  1. **Click`View Upkeep`** or go to the [Chainlink Automation App](https://automation.chain.link) and click on your recently registered Upkeep under My Upkeeps.

  2. **Click the`Add funds` button**

  3. **Approve the LINK spend allowance**

  4. **Confirm the LINK transfer** by sending funds to the Chainlink Automation Network Registry 

  5. **Receive a success message** and verify that the funds were added to the Upkeep 

## Maintain a Minimum Balance

Each Upkeep has a [minimum balance](/chainlink-automation/automation-economics/#minimum-balance) to ensure that an Upkeeps will still run should a
sudden spike occur. If your Upkeep LINK balance drops below this amount, the
Upkeep will not be performed.

To account for Upkeep execution over time and possible extended gas

:::NEXT DOC:::

click **Next**.



### Entering Upkeep Details

To complete the upkeep registration process, you must enter some information
about your upkeep including its name, gas limit, starting balance LINK, and
contact information.

Job Scheduler Gas requirements

When you create an upkeep through the Job Scheduler, Chainlink Automation
deploys a new `CronUpkeep` contract from the
[CronUpkeepFactory](https://github.com/smartcontractkit/chainlink/blob/d5a253fb6959104844eda8479c08909a76a6fea7/contracts/src/v0.8/automation/upkeeps/CronUpkeepFactory.sol)
to manage your time schedule and ensure that it is compatible. This contract
uses roughly 110K gas per call, so it is recommended to add 150K additional
gas to the gas limit of the function you are automating.



ERC677 Link

For registration you must use ERC-677 LINK. Read our [LINK](/resources/link-token-contracts) page to determine where to acquire mainnet LINK, or visit
[faucets.chain.link](https://faucets.chain.link/) to request testnet LINK.

## What's next

  * [› Register a Custom Logic Upkeep](/chainlink-automation/register-upkeep/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/job-scheduler.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Keepers Job                   | Automation Job                    |
| Keepers Registry/Registrar    | Automation Registry/Registrar     |
| KeeperCompatible.sol          | AutomationCompatible.sol          |
| KeeperBase.sol                | AutomationBase.sol                |
| KeeperCompatibleInterface.sol | AutomationCompatibleInterface.sol |
## 2022-09-23 - v1.3 Release

Keepers Registry v1.3 [launched on Arbitrum Mainnet](/chainlink-automation/supported-networks/#arbitrum).

## 2022-08-04 - v1.2 Release

Keepers Registry v1.2 launched on Ethereum, Binance Smart Chain, Polygon,
Avalanche, and Fantom

  * **Automatic upkeep registration approval** : All upkeeps on supported mainnets are now automatically approved.

  * **Programmatic control** : With automatic approval, you can now dynamically create, manage, and fund upkeeps from within your dApps and even have an upkeep fund itself. Learn more [here](/chainlink-automation/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract).

  * **Advanced turn-taking algorithm** : Our turn taking algorithm now supports upkeeps that require high-frequency execution.

  * **Durable ID and user-triggered migration** : All upkeeps created in versions v1.2 and later will have durable IDs. v1.2 also supports user-triggered migration to future registry versions to make it easier to migrate to a new Keepers Registry and benefit from new features. Future"
What is the purpose of setting the `const consumerAddress` in the `request.js` script?,To set the deployed consumer address,{'source': 'https://docs.chain.link/chainlink-functions/resources/add-functions-to-projects/'},The purpose of setting the `const consumerAddress` in the `request.js` script is not mentioned in the given context information.," 3. Edit the `request.js` script and set your deployed consumer address in `const consumerAddress`:
    
        const consumerAddress = 0x5484e266c2cd379800e6f27eab097bb806647cbf

  4. Set `const subscriptionId` to your Chainlink Functions subscription ID. This must be the same ID that your consumer contract is authorized to use. You can [add a consumer contract to a subscription](/chainlink-functions/resources/subscriptions#add-a-consumer-contract-to-a-subscription) later if you need to.
    
        const subscriptionId = 917

  5. Set `const consumerAbiPath` to the ABI file that you created when you ran `npx hardhat compile`. The ABI tells Ethers how to interact with your deployed contract. If you compiled and deployed `FunctionsConsumer.sol`, set a path like the following example:
    
        const consumerAbiPath = ""./artifacts/contracts/FunctionsConsumer.sol/FunctionsConsumer.json""

  6. Set `const source` with the path to the request source code that you downloaded earlier:
    
        const source = ./Functions-request-source.js

  7. Set `const args` with an array of arguments for the DON to use when it runs your source. If you look at the `Functions-request-source.js` file, you can see that it requires two arguments. The args define which assets to retrieve from the data source URL.
    
        const args = [""ETH"", ""USD""]

  8. Set `const oracleAddress` to the oracle address on the network that you want to use. Each network has a unique DON with a unique oracle address. See the [Supported Networks](/chainlink-functions/supported-networks) page for a list of supported networks and oracle

:::NEXT DOC:::

     requestId,
                payment,
                sender,
                callbackFunctionId,
                expiration,
                dataVersion,
                data
            );
        }
    
    

I removed the `oracleRequest()` function because it exceeds stack size by
adding more modifiers to it and since I can use `operatorRequest()` to fulfill
both multi-word and single-word requests I will make that method deprecated by
reverting everytime it's called.

The modifier that sets the authorized consumer is basically the following:

    
    
        /**
         * @dev function used to change the authorized consumer. Can only be set once
         */
        function setAuthorizedConsumer(address _consumer) public onlyOwner {
            require(
                authorizedConsumer == address(0),
                ""authorized consumer is already set""
            );
            authorizedConsumer = _consumer;
        }
    
        /**
         * @notice validates the consumer is an authorized consumer
         */
       

:::NEXT DOC:::

* @dev function used to change the authorized consumer. Can only be set once
         */
        function setAuthorizedConsumer(address _consumer) public onlyOwner {
            require(
                authorizedConsumer == address(0),
                ""authorized consumer is already set""
            );
            authorizedConsumer = _consumer;
        }
    
        /**
         * @notice validates the consumer is an authorized consumer
         */
        function _validateIsAuthorizedConsumer(address _consumer) internal view {
            require(_consumer == authorizedConsumer, ""Not authorized sender"");
        }
    
        /**
         * @notice prevents non-authorized addresses from calling this method
         */
        modifier validateIsAuthorizedConsumer(address _consumer) {
            _validateIsAuthorizedConsumer(_consumer);
            _;
        }
    
    
    


---
(Answered on: 2021-12-29 08:59:47)


You can restrict the access by adding whitelisted requesters (authorized smart
contract addresses) to the database of the Chainlink node that is picking up
your requests and running the job calling your external adapter.

We wrote a short guide on how to do

:::NEXT DOC:::

You can retrieve extra funds later when you cancel the subscription.
    
        const linkAmount = ""1""

  5. Set `const consumer` to the address of the consumer contract that you deployed:
    
        const consumer = ""0x5484e266c2cD379800e6F27EaB097Bb806647CbF""

  6. Save the file and run the script. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run scripts/functions-sub.js --network your_network

Example:

    
        npx hardhat run scripts/functions-sub.js --network polygonMumbai

  7. If the script is successful, you the terminal prints your subscription ID. Record this ID to use for Chainlink Functions requests. You should see output similar to the following example:
    
        Subscription created with ID: 917
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Subscription 917 funded with 1000000000000000000 Juels (1 LINK = 10^18 Juels)
    Adding consumer contract address 0x5484e266c2cD379800e6F27EaB097Bb806647CbF to subscription 917
    Authorized consumer contract: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Now that the consumer contract is deployed and the subscription is created and
funded with LINK, the on-chain resources are ready to handle your requests.
Next, create JavaScript code that you want to run on the DON,

:::NEXT DOC:::

from the db, and it's of type string in the config file, but when
I console log the args from the custom JS side, the prompt is no longer a
string ""invent me a new sandwich...."" and is now undefined.

Any help would be appreciated. Thanks!

[Code execution output](https://i.stack.imgur.com/dVavh.png)



Answers:
(Answered on: 2023-05-18 12:41:31)


I think this is because your prompt variable will be undefined when the
request object gets assigned to `requestConfig` because prompt gets given a
value asynchronously.

The tooling reads your request config statically. What you need to do is to
find the bit in the tasks where the request config is read and just before i
gets passed to the ConsumerContract's executeRequest function. Intercept the
requestObject there and (by using async await first to get the value of
`prompt` set) set the value of args once the `prompt` value has been set.





:::NEXT DOC:::

to the `deploy()` function
        const contract = await factory.deploy(process.env.AGGREGATOR_ADDRESS);
        await contract.deployed();
    }
    
    main().catch((error) => {
        console.error(error);
        process.exitCode = 1;
    });
    

_Solidity contract_

    
    
    pragma solidity ^0.8;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract Example {
        AggregatorV3Interface internal priceFeed;
    
        constructor(address _aggregator) {
            priceFeed = AggregatorV3Interface(_aggregator);
        }
    }
    





:::NEXT DOC:::

Question: (Asked on: 2021-11-26 22:23:13)
Purpose of &quot;memory path&quot; variable in ATestnetConsumer.sol example
URL: https://stackoverflow.com/questions/70130560/purpose-of-memory-path-variable-in-atestnetconsumer-sol-example

Question Body:


Hello I'm working to create my own custom chainlink job and associated
consumer.sol contract. I am using the example ""ATestnetConsumer.sol"" contract
as a guide.
(<https://github.com/smartcontractkit/documentation/blob/main/_includes/samples/APIRequests/ATestnetConsumer.sol>)
I am confused regarding the purpose of the req variable and the path string
array. What is the purpose of these when the chainlink node executes the job?

    
    
    function requestEthereumLastMarket(address _oracle, string memory _jobId)
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(_jobId), address(this), this.fulfillEthereumLastMarket.selector);
        req.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        string[] memory path = new string[](4);
        path[0] = ""RAW"";
        path[1] = ""ETH"";
        path[2] = ""USD"";
        path[3] = ""LASTMARKET"";
        req.addStringArray(""path"", path);
        sendChainlinkRequestTo(_oracle, req,

:::NEXT DOC:::

= AggregatorV3Interface(
                0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
            );
            owner = msg.sender;
        }
    
    }
    

And if you see, the parameter that I need to send to `AggregatorV3Interface`
is static `0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e`. To me, that doesn't
look optimized enough. Because right now, I'm playing with this function for
`Goerli`, but if I were to deploy this contract to Etherium mainnet, I would
have to change that address manually. Even if you go to chainlink website,
they have it like this. <https://docs.chain.link/data-feeds/price-
feeds/#solidity>

Is there a better way? I would like to have some variable that I would set,
and read from it? Or maybe some custom variable setting from hardhat, that I'm
using.

`priceFeed = AggregatorV3Interface(env.proccess.address);` Would be desired,
or anything dynamic.



Answers:
(Answered on: 2022-12-31 14:52:17)


Usual approach is to pass the address to Solidity constructor from a JS (or
any other offchain language) script that reads from the environment variable.

_.env_

    
    
    AGGREGATOR_ADDRESS=0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
    

_JS deployer script_

    
    
   

:::NEXT DOC:::

pass in the deploy script?

APIConsumer contract

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.0;
    
    import ""@chainlink/contracts/src/v0.6/ChainlinkClient.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * PLEASE DO NOT USE THIS CODE IN PRODUCTION.
     */
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public temperature;
        
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
        
        constructor () public {
            setPublicChainlinkToken(); // Do I need to pass any params for this?
            // if (_link == address(0)) {
            //     setPublicChainlinkToken();
            // } else {
            //     setChainlinkToken(_link);
            // }
            // setPublicChainlinkToken();
            oracle = <oracle id>; // Removed oracle id and jobid values for post
            jobId = <job id>;
  

:::NEXT DOC:::

+ await link.balanceOf(apiConsumer.address));
    
        //Make request
        const transaction = await apiConsumer.requestVolumeData()
        const tx_receipt = await transaction.wait()
        const requestId = tx_receipt.events[0].topics[1]
        console.log(""requestId=%s"", requestId)
    
        //Optionally subscribe to events
        // apiConsumer.on(""ChainlinkFulfilled"", id => {
        //  console.log(""ChainlinkFulfilled: %s"", id);
        // })
    
        //Wait 30 secs for oracle to callback
        await new Promise(resolve => setTimeout(resolve, 30000))
    
        //Now check the result
        const result = await apiConsumer.volume()
        console.log(""API Consumer Volume: %s"", result)
      });
    });
    

In hardhat.config.js, blockNumber is chosen to be just before the first
ChainlinkRequested event, and we can see from the script output that the
contract is funded with sufficient LINK.

    
    
    require(""@nomiclabs/hardhat-waffle"");
    
    /**
     * @type import('hardhat/config').HardhatUserConfig
     */
    module.exports = {
      solidity: ""0.8.7"",
      networks: {
       "
What is the purpose of the Subscription Manager in Chainlink VRF?,"The Subscription Manager lets you create an account and pre-pay for VRF requests, so that funding of all your application requests are managed in a single location.",{'source': 'https://docs.chain.link/getting-started/intermediates-tutorial/'},"The purpose of the Subscription Manager in Chainlink VRF is to create and manage a subscription contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. It allows consumer contracts to have much more flexibility in requesting random numbers, such as specifying how many random numbers they want to request, how much they are willing to pay for gas, and setting a limit to how much gas will be spent by the VRF when submitting the random number. The amount of LINK token to be paid to the VRF can be dynamic based on network conditions.","different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends

:::NEXT DOC:::

#####Chapter 5: VRF Subscriptions

# Subscription Manager Contract

Now that we learned more about the theoretical background, let’s get practical. We want to create and manage a subscription contract. We will use the example contract that you can find here on [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js). It shows an example implementation of a VRF v2 Subscription manager for the Goerli network. But you can also adjust it to work with other networks by changing the code's hardcoded addresses. You can find a complete list of available networks [here](https://docs.chain.link/docs/vrf-contracts/#configurations).

Hint: This course assumes you are already familiar with the Architecture of Chainlink VRF from [VRFv2 Introduction Chapter 4](https://www.chainlink.education/vrfIntroduction/chapter-4).

Generally, consumer contracts must implement the requestRandomWords() function providing coordinator parameters and subscription ID. This function is used to create random values. A second function, fulfillRandomWords(), must be implemented to receive the random values. Learn about how to implement the basics of such a contract in [chapters 6-12](https://www.chainlink.education/vrfIntroduction/chapter-6) from the introduction course.

We want to focus on the mentioned functions here and show how to manage subscriptions in this contract. So let’s start by creating a new subscription:

<Highlight class=""language-javascript"">
uint64 public s_subscriptionId;
 function

:::NEXT DOC:::

# Subscription Method

  * Overview
  * Subscriptions
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits
  * Subscription limits
  * Coordinator contract limits

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This section explains how to generate random numbers using the subscription
method.

## Subscriptions

VRF v2 requests receive funding from subscription accounts. The [Subscription
Manager](/vrf/v2/subscription/ui) lets you create an account and pre-pay for
VRF v2, so you don't provide funding each time your application requests
randomness. This reduces the total gas cost to use VRF v2. It also provides a
simple way to fund your use of Chainlink products from a single location, so
you don't have to manage multiple wallets across several different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that

:::NEXT DOC:::

# Subscription Manager User Interface

  * Overview
  * Actions menu
  * Consumers
  * Pending
  * History
  * Recent fulfillments
  * Events
  * Failed requests

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

The VRF v2 Subscription Manager is available at
[vrf.chain.link](https://vrf.chain.link/). The Subscription Manager lets you
create a subscription and pre-pay for VRF v2 so you don't need to provide
funding each time your application requests randomness. This guide walks you
through the main sections of the UI.

Troubleshooting

Read the pending and failed requests sections to learn how to troubleshoot
your VRF requests.



Subscription components:

  * **Status** : Indicates if the subscription is still active or not.
  * **ID** : The unique subscription identifier. Approved consuming contracts use LINK from this subscription to pay for each randomness request.
  * **Admin** : The account address that owns this subscription ID.
  * **Consumers** : The number of consuming contracts that are approved to make VRF requests using this subscription.
  * **Fulfillment** : The number of successful randomness requests that are already completed.
  * **Balance** : The amount of LINK remaining to be used for requests that use this subscription.

## Actions menu

Expand the **Actions** menu to display actions you can take for any
subscription that you own:



  * **Fund subscription** : Displays a field allowing you to fund your subscription from your connected wallet. Specify how much LINK you'd like to send to your subscription.
  *

:::NEXT DOC:::

and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Sepolia coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    
        // Sepolia LINK token contract. For other networks, see
       

:::NEXT DOC:::

to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    * `acceptSubscriptionOwnerTransfer(uint64 subId)`.
  * View the subscription with `getSubscription(uint64 subId)`.
  * Cancel the subscription with `cancelSubscription(uint64 subId)`.

To send LINK to the subscription balance, use the LINK token interface with
`LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(subId))`.
Any wallet can fund a subscription.

See the example in the Subscription manager contract section to learn how to
create a contract that can change your subscription configuration.

## Subscription manager contract

In this example, the contract operates as a subscription owner and can run
functions to add consuming contracts to the subscription. The consuming
contracts must include the `requestRandomWords()` function with the correct
coordinator parameters and the correct subscription ID to request random
values and use the subscription balance. The consuming contracts must also
include the `fulfillRandomWords()` function to receive the random values.

Subscription owners and consumers do not have to be separate. This contract
not only allows adding consumers with `addConsumer(address consumerAddress)`
but can also act as a consumer by running its

:::NEXT DOC:::

page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)



:::NEXT DOC:::

#####Chapter 5: VRF Subscriptions

# Subscribing to the VRF
Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number. 

## VRFv2
In VRFv2, the most recent version of the VRF, the concept of a subscription was added. What is a subscription? Essentially, it's an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. Once a subscription is set-up a consumer contract can then request randomness, the VRF respondes with a random number and proof, and then after the random number is included on-chain the VRF is paid with some of the LINK prepaid in the subscription.

The power that comes from this subscription model is that now consumer contracts have much more flexibility in requesting random numbers. Before subscriptions it was a static price, and the VRF always returned a single random number. 
 
But what if the consumer contract needs more than one random number? The consumer contract can now specify how many random numbers it wants to request.  
 
What if the consumer contract needs the random number to be included very fast by paying a higher gas price? The consumer contract can now request how much it's willing to pay for gas. This is called the **gas lane**. 
 
What if the consumer contract needs to run some heavy calculations after recieving the random number? It can set a limit to how much gas will be spent by the VRF when submitting the random number. This is called the

:::NEXT DOC:::

# Programmatic Subscription

  * Overview
  * Modifying subscriptions and configurations
  * Subscription manager contract
  * Funding and requesting simultaneously

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

How you manage the subscription depends on your randomness needs. You can
configure your subscriptions using the [Subscription
Manager](/vrf/v2/subscription/ui), but these examples demonstrate how to
create your subscription and add your consumer contracts programmatically. For
these examples, the contract owns and manages the subscription. Any wallet can
provide funding to those subscriptions.

You can view and monitor your subscriptions in the [Subscription
Manager](/vrf/v2/subscription/ui) even if you create them programmatically. Go
to [vrf.chain.link](https://vrf.chain.link) to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    *

:::NEXT DOC:::

page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

## Requirements

This guide assumes that you know how to create and deploy smart contracts on
Ethereum testnets using the following tools:

  * [The Remix IDE](https://remix.ethereum.org/)
  * [MetaMask](https://metamask.io/)
  * [Sepolia testnet ETH](/resources/link-token-contracts/#sepolia-testnet)

If you are new to developing smart contracts on Ethereum, see the [Getting
Started](/getting-started/conceptual-overview) guide to learn the basics.

## Create and fund a subscription

For this example, create a new subscription on the Sepolia testnet.

  1. Open MetaMask and set it to use the Sepolia testnet. The [Subscription Manager](/vrf/v2/subscription/ui) detects your network based on the active network in MetaMask.

  2. Check MetaMask to make sure you have testnet ETH and LINK on Sepolia. You can get testnet ETH and LINK at [faucets.chain.link](https://faucets.chain.link/sepolia/).

  3. Open the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  4. Click **Create Subscription** and follow the instructions to create a new subscription account. MetaMask opens and asks you to confirm payment to create the account on-chain. After you approve the transaction, the network"
What is the purpose of operating a Chainlink node?,"Operating a Chainlink node allows you to be part of the Chainlink Network, helping developers build hybrid smart contracts, giving them access to real-world data and services.",{'source': 'https://docs.chain.link/chainlink-nodes/'},The purpose of operating a Chainlink node is to be part of the Chainlink Network and help developers build hybrid smart contracts by giving them access to real-world data and services.,"# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Fulfilling Requests

  * Overview
  * Requirements
  * Address Types
  * Setup your Operator contract
  * Deploy your own Operator contract
  * Whitelist your node address in the Operator contract
  * Add a job to the node
  * Create a request to your node
  * Withdrawing LINK

Run a Chainlink node

This guide assumes you have a running Chainlink node. To learn how to run a
node, see the [Running a Chainlink Node locally](/chainlink-nodes/v1/running-a-chainlink-node) guide.

You can use your Chainlink nodes to fulfill requests. This guide shows you how
to deploy your own operator contract and add jobs to your node so that it can
provide data to smart contracts.

Chainlink nodes can fulfill requests from open or unauthenticated APIs without
the need for [External Adapters](/chainlink-nodes/external-adapters/external-adapters) as long as you've added the jobs to the node. For these requests,
requesters supply the URL to the open API that they want each node to
retrieve. The Chainlink node will use [tasks](/chainlink-nodes/oracle-jobs/tasks) to fulfill the request.

Some APIs require authentication by providing request headers for the
operator's API key, which the Chainlink node supports. If you would like to
provide access to an API that requires authentication, you must create a job
that is specific for that API either using an [external adapter](/chainlink-nodes/external-adapters/external-adapters) or by using the parameters of the
[HTTP task](/chainlink-nodes/oracle-jobs/all-tasks/#http-task).

## Requirements

Before you begin this guide, complete the following tasks to make sure you
have all of the tools that you need:

  * [Set up

:::NEXT DOC:::

   

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node is running or not, check out the oracle address in a
block explorer. [You can see
here](https://kovan.etherscan.io/address/0x56dd6586db0d08c6ce7b2f2805af28616e082455)
that the original node you tried to use hasn't posted a transaction in quite a
long time.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.





:::NEXT DOC:::

# Security and Operation Best Practices

  * Overview
  * Restricting Access
  * Failover Capabilities
  * Disaster Recovery
  * Active Monitoring
  * Frequent Updates
  * Jobs and Config
  * Addresses
  * Infrastructure as Code (IaC)

The following information provides a set of security and operation best
practices that node operators need to use at a minimum to enhance the security
and reliability of their infrastructure.

## Restricting Access

To run a Chainlink node, the Operator UI port does not need to be open on the
internet for it to correctly function. Due to this, we strongly recommend
restricting access to all of the services required over the internet.

**Minimum Requirements:**

  * SSH (port 22 or changed from the default) is open, and access to the node is granted via SSH tunnelling. This is done typically by adding `-L 6688:localhost:6688` to your SSH command.
  * Access to the Ethereum client that the Chainlink node uses is restricted to solely the Chainlink node. This includes ports 8545 and 8546, but excludes 30303 for P2P traffic.

**Recommended:**

  * The use of a VPN restricts access to only those who are signed into the VPN in order to access internal resources. For example, this can be achieved by using something like [OpenVPN Access Server](https://openvpn.net/vpn-server/).
  * With the use of the VPN, all traffic between Chainlink nodes and Ethereum clients is routed internally rather than over the internet. For example, all servers are placed in an internal subnet range such as `10.0.0.0/16` and use these IP addresses for communicating.
  * Chainlink nodes have the potential to send arbitrary HTTP GET and POST requests, exposing internal network resources. We recommend deploying with a DMZ which has strong outbound network restrictions.

## Failover Capabilities

To ensure there is very minimal downtime,

:::NEXT DOC:::

special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform. Finally, with Chainlink, developers can build smart contracts that can interact with the outside world to preserve the decentralized nature of smart contracts.

<Spacer>

## How Chainlink Works

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      Curious how Chainlink works? Read below! With Chainlink, any type of data the exists can be brought on chain, and the conditions on which that data is delivered can be customized! 
    </div>
  </div>
</ContentWrapp>

Chainlink allows developers to build and customize DONs. Chainlink allows DONs to work and assures that node operators are incentivized not to collude or act

:::NEXT DOC:::

# Optimizing EVM Performance

  * Overview
  * Using multiple nodes
  * Automatic load balancing and failover
  * Configuring websocket and HTTP URLs
  * Increasing transaction throughput
  * Increase ETH_MAX_QUEUED_TRANSACTIONS
  * Increase ETH_MAX_IN_FLIGHT_TRANSACTIONS
  * Optimizing RPC nodes
  * Remove rejections on expensive transactions
  * Arbitrum differences
  * Adjusting minimum outgoing confirmations for high throughput jobs
  * Increase ORM_MAX_OPEN_CONNS and ORM_MAX_IDLE_CONNS

The most basic Chainlink node deployment uses the default configuration on
only a single primary node with a websocket URL. This configuration is
appropriate for small or simple workloads with only a few jobs that execute
infrequently. If you need to run hundreds of jobs and thousands of
transactions per hour, your Chainlink and RPC nodes will require a more
advanced configuration. This guide explains how to configure Chainlink and
your EVM nodes for high reliability and throughput.

Note on Ethereum clients

Ethereum clients have bugs. Much work is done on the Chainlink node software
to mitigate bugs in various different RPC implementations. This guide helps
you understand how to mitigate and work around these bugs.

## Using multiple nodes

Use multiple nodes

Providing multiple primary nodes can improve performance and reliability.

Chainlink node version 1.3.0 and later support configurations with multiple
primary nodes and send-only nodes with automatic liveness detection and
failover. It is no longer necessary to run a load balancing failover RPC proxy
between Chainlink and its EVM RPC nodes.

If you are using a failover proxy transparently for commercial node provider
services, it will continue to work properly as long as the RPC you are talking
to acts just like a standard RPC node.

You can have as many primary nodes

:::NEXT DOC:::

 * The use of a VPN restricts access to only those who are signed into the VPN in order to access internal resources. For example, this can be achieved by using something like [OpenVPN Access Server](https://openvpn.net/vpn-server/).
  * With the use of the VPN, all traffic between Chainlink nodes and Ethereum clients is routed internally rather than over the internet. For example, all servers are placed in an internal subnet range such as `10.0.0.0/16` and use these IP addresses for communicating.
  * Chainlink nodes have the potential to send arbitrary HTTP GET and POST requests, exposing internal network resources. We recommend deploying with a DMZ which has strong outbound network restrictions.

## Failover Capabilities

To ensure there is very minimal downtime, failover capabilities are required
on both the Chainlink and Ethereum clients so that if any one server fails,
the service is still online.

**Minimum Requirements:**

  * Chainlink nodes are using a PostgreSQL database that are not on the same servers as the Chainlink nodes.
  * At least two Chainlink nodes are running at any one time, with both of them pointing to the same database to ensure failover if one fails.

**Ethereum-specific:**

  * Ethereum client websocket connectivity is fronted by a load balancer, used by the Chainlink nodes. [Here is an example on how to set up a load balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/tutorial-target-ecs-containers.html). 
    * If a VPN and internal routing is configured, SSL is not needed but still recommended, as all traffic is purely internal.
    * If both Ethereum and Chainlink nodes are public facing without a VPN, SSL is required to ensure that no communication between both can be intercepted.

## Disaster Recovery

Problems occur and when they do, the right processes

:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties

:::NEXT DOC:::

address are regularly confused):

`0x6a61789194260F0BE95a18d0116d883A4b5284ed` is the address of your Chainlink
node (you can see in the key tab of the GUI), which needs to be funded with
ETH in order to send transactions on-chain. The Chainlink node listens to
event logs emitted by the oracle smart contract used in the job spec, the
oracle address is not the account you used to deploy it, but the address of
the newly deployed oracle smart contract, make sure to follow these steps:
<https://docs.chain.link/docs/fulfilling-requests/#deploy-your-own-oracle-
contract>

You can find the oracle contract address in Remix and the block explorer of
the underlying network, that's what you need to use in your consumer contract
in order to make successful requests, the LINK rewards can then be withdrawn
from the oracle contract.





:::NEXT DOC:::

to the open API that they want each node to
retrieve. The Chainlink node will use [tasks](/chainlink-nodes/oracle-jobs/tasks) to fulfill the request.

Some APIs require authentication by providing request headers for the
operator's API key, which the Chainlink node supports. If you would like to
provide access to an API that requires authentication, you must create a job
that is specific for that API either using an [external adapter](/chainlink-nodes/external-adapters/external-adapters) or by using the parameters of the
[HTTP task](/chainlink-nodes/oracle-jobs/all-tasks/#http-task).

## Requirements

Before you begin this guide, complete the following tasks to make sure you
have all of the tools that you need:

  * [Set up MetaMask](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) and [obtain testnet LINK](/resources/acquire-link).

  * [Run a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node).

  * Fund the Ethereum address that your Chainlink node uses. You can find the address in the node Operator GUI under the **Key Management** configuration. The address of the node is the `Regular` type. You can obtain test ETH from several [faucets](/resources/link-token-contracts). For this tutorial to work, you will have to fund the node's Ethereum address with Sepolia ETH. Here is an example:

## Address Types

Your node works with several different types of addresses. Each address type
has a specific function:

  * **Node address:** This is the address for your Chainlink node wallet. The node requires native blockchain tokens at all times to respond to requests. For this example, the node uses Sepolia ETH. When you start a Chainlink node, it automatically generates this address. You can find this address on the Node Operator GUI under **Key Management"
Why is randomness important in many types of applications?,Randomness is important in many types of applications because it is an essential component of a majority of games.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-1/course.md'},Randomness is important in many types of applications because it is an essential component of a majority of games and is necessary for applications such as raffles and other types of applications that utilize randomness.,"#####Chapter 1:

# Randomness

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      With your newfound power, understanding of what smart contracts are you want to develop a smart contract to raffle an NFT to your friends. But how will you get randomness into your raffle smart contract?
    </div>
  </div>
</ContentWrapp>

Randomness is essential for many types of applications. Think about how many games have randomness built-in. Rolling dice in dungeons and dragons, a random starting hand of poker, or a random next block in Tetris, randomness is an essential component of a majority of games. As we learned in Chainlink 101, smart contracts are a powerful tool for decentralized applications (dapps). But what if you want to build a game, raffle or any other type of application that utilizes randomness on the blockchain? Let's learn about randomness on the blockchain in the next lesson!


:::NEXT DOC:::

only the private key could decrypt it. The private key needs to be created at some point. Public key cryptography uses random numbers as input to calculate and create key pairs. If your source of randomness is something like Math.random(), it will be far more feasible for an attacker to guess your private key by brute-forcing the “random” numbers which is produced by this function. In other words, it drastically reduces the search space for the attacker. And the more they know about your conditions, the easier it is for them to find the correct private key as they have to search through fewer options.

Luckily, there are also true random number generators that we can use. They usually rely on measuring physical phenomena like atmospheric noise. It uses a natural source of entropy to avoid any brute-force attacks. This is critical to generating random numbers. Unpredictability is an essential requirement for true random number generators. Unpredictable means no one can reproduce the result by taking the same system as an input. So you cannot simply measure the same atmospheric noise to produce similar results. They will be completely different. So the quality of entropy becomes a fundamental metric. Once this is given, there are different tools to translate this into random numbers.


:::NEXT DOC:::

#####Chapter 2:

# Randomness and Deterministic Machines

Computers are deterministic machines. Per definition, they cannot produce randomness without any external inputs. Once this external input is given, Computer Science has found different methods to generate random numbers. We distinguish between true random number generators (RNG) and pseudo-random number generators (PRNG). You can use a PRNG if your random generator does not need any security guarantees. For example, if you are programming a simple coin-flipping game that you want to use daily to decide between two options, you can use a PRNG like JavaScripts Math.random(). It uses computational algorithms to produce apparently random results. These results are entirely depending on an initial seed. So if the seed is known, the same result can be reproduced.

This might work for prototypes and many practical applications. But imagine you want to encrypt a message. You would use a public key to encrypt the message and only the private key could decrypt it. The private key needs to be created at some point. Public key cryptography uses random numbers as input to calculate and create key pairs. If your source of randomness is something like Math.random(), it will be far more feasible for an attacker to guess your private key by brute-forcing the “random” numbers which is produced by this function. In other words, it drastically reduces the search space for the attacker. And the more they know about your conditions, the easier it is for them to find the correct private key as they have to search through fewer options.

Luckily, there are also true random number generators that we can use. They usually rely on measuring physical phenomena like atmospheric noise. It uses a natural source of entropy to avoid any brute-force attacks. This is critical to generating random

:::NEXT DOC:::

#####Chapter 2:

# Randomness and Blockchains

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Upon research, you realize popular languages like Javascript have built-in randomness functions maybe you can use something like that in Solidity? 
    </div>
  </div>
</ContentWrapp>

Blockchains are deterministic, meaning that any computations that use blockchains must have predictable outcomes. This so all of the nodes that run the blockchain can come to an agreement on what the blockchain is. But deterministic runs counter to random. If everyone knows what the next hand of poker will be before it is dealt it wouldn’t be considered random. So if randomness is impossible on a blockchain, how can we bring the awesome powers of smart contracts to any applications that need randomness?

We could get the randomness from an outside resource! But it can’t be a trusted centralized service (as discussed in Chainlink 101), or we would be ruining the decentralized properties of blockchains and smart contracts. And it would be great if it could be verified that the number wasn’t tampered with and is genuinely random. This is a perfect example of where a decentralized oracle network powered by Chainlink could be used!


:::NEXT DOC:::

#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let’s take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random

:::NEXT DOC:::

in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.


:::NEXT DOC:::

#####Chapter 3:

# Randomness and Blockchains

Blockchains heavily rely on cryptography and randomness for security. The most straightforward example is the creation of key pairs used to do transactions. When you create a new key pair, a random number is needed as the initial input. We have learned in the previous example how to obtain this number from, e.g., the physical world. This number is then used to calculate a seed which is further used to derive all further key pairs.

This works well for key creation, but how to use random numbers on-chain? While the initial number could be completely random, as soon as you add it to a transaction, everyone who observes the mempool can see it. And also, the miners/validators can see it and decide how to deal with your transaction based on the number. This also would mean that someone controls the creation of the random number. So you must trust this source. So the random number cannot be created on-chain and must be provided from the outside. Is there no other way?

You might argue that you can use the content of a block as a source of randomness. But these values can be actively manipulated by miners. They could add or remove transactions to find a result that benefits them. In addition, blocks also have particular properties that could reduce the search space to calculate probabilities that a specific number will be selected. So this is an insecure way of creating random numbers.

So if you cannot trust the miners, you could argue for using Oracles. A trusted third-party system could be used to create random numbers and then provide them to services via an oracle. But depending on the economic incentive, someone could be interested in hacking this system to provide non-random numbers as input. And while they might use a true random number generator, you don’t know for sure and

:::NEXT DOC:::

Is there no other way?

You might argue that you can use the content of a block as a source of randomness. But these values can be actively manipulated by miners. They could add or remove transactions to find a result that benefits them. In addition, blocks also have particular properties that could reduce the search space to calculate probabilities that a specific number will be selected. So this is an insecure way of creating random numbers.

So if you cannot trust the miners, you could argue for using Oracles. A trusted third-party system could be used to create random numbers and then provide them to services via an oracle. But depending on the economic incentive, someone could be interested in hacking this system to provide non-random numbers as input. And while they might use a true random number generator, you don’t know for sure and do not have any way to check the validity of such a statement once the number was generated.

So we must address two further issues here. The single point of failure (single oracle) and validating that the number was generated with a particular function. For the first issue, you could argue that you could use decentralized oracle network (DON). So it wouldn’t be a single oracle that we need to trust.
But how do we know this DON is not generating numbers based on certain conditions? For this reason, Verifiable Random Functions are used. They allow everyone to verify that a specific VRF was used and that the number was produced by a particular VRF and no other function. This allows us to generate verifiable random numbers for on-chain usage in a decentralized way.


:::NEXT DOC:::

increase the chances of an attacker cheating your application. Imagine you implemented a simple coin flip smart contract using VRF v2. In a bet function, you choose heads or tails and then request a random number. If you have selected heads (0) and the result of the VRF service meant that you would win the bet, it could try to withhold this answer and replace it with your second request if it’s more advantageous.

So you see, we must consider the unique properties of blockchains here to ensure randomness in our smart contracts. While the numbers are always random, we must also look into how our applications and smart contracts deal with them. In the end, it will be a matter of cost if it's worth attacking your application. You must also be aware of the protocol that you are using.

In general, re-organizations on chains are possible. A miner would take your request and try to create a new random number with a different block and do this until they find a block to their advantage. They cannot control the VRF output but can ""re-roll"" the dice. If they manage to produce a valid blockchain with this new block and the network accepts this block instead, they could effectively attack your application by controlling the random input.
While this is a possible attack, it's costly to attack a network like this, as in the proof of network. You need at least 51% of the network to drive such an attack. Depending on your application requirements, you consider a 20-block confirmation time highly secure. You can lower the block confirmation time depending on the value you are trying to protect. You must calculate an attacker's costs and potential reward to decide your confirmation time.


:::NEXT DOC:::

due to the fact a
blockchain is deterministic. This means you should not rely on any on-chain
values for a source of randomness (like block hashes or timestamps etc), as
they can be manipulated or pre-determined by miners and used to game your
contract that relies on randomness.

In addition to this, just using an oracle to get a source of randomness from
an external API is also strongly discouraged, because there's no real way of
knowing if the returned number is _actually_ random, of it's been sent back by
a malicious actor wanting to game your contract that relies on it. Ie if your
oracle returned **123456789** , how do you know if its a truly random number,
or if its returning that because it knows it can then call your contract and
take funds if that random number is used?

This is where a _verifiable random number_ comes into play. With a verifiable
random number, an oracle is used, however there is a
[seed](https://en.wikipedia.org/wiki/Random_seed#:%7E:text=A%20random%20seed%20)
generated based on something (could be user input or on-chain data, it doesn't
matter) before the call to the oracle is made (the call passes the seed to the
oracle). Once the oracle generates a random number, the VRF function can then
use math and cryptography to actually verify that the random number was
created based from the initial seed, and that it's not just some random number
plucked from the air (and potentially malicious). This is the magic of VRF,
being able to verify a random number was created with a previously committed
seed. So combining a VRF function with an oracle is the best possible way for
a safe and secure source of randomness in a smart contract.

[Chainlink VRF](https://chain.link/chainlink-vrf) is the industry standard"
What is the Monte Carlo fallacy?,The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md'},The Monte Carlo fallacy describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,"#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let’s take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random

:::NEXT DOC:::

in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.


:::NEXT DOC:::

Is there no other way?

You might argue that you can use the content of a block as a source of randomness. But these values can be actively manipulated by miners. They could add or remove transactions to find a result that benefits them. In addition, blocks also have particular properties that could reduce the search space to calculate probabilities that a specific number will be selected. So this is an insecure way of creating random numbers.

So if you cannot trust the miners, you could argue for using Oracles. A trusted third-party system could be used to create random numbers and then provide them to services via an oracle. But depending on the economic incentive, someone could be interested in hacking this system to provide non-random numbers as input. And while they might use a true random number generator, you don’t know for sure and do not have any way to check the validity of such a statement once the number was generated.

So we must address two further issues here. The single point of failure (single oracle) and validating that the number was generated with a particular function. For the first issue, you could argue that you could use decentralized oracle network (DON). So it wouldn’t be a single oracle that we need to trust.
But how do we know this DON is not generating numbers based on certain conditions? For this reason, Verifiable Random Functions are used. They allow everyone to verify that a specific VRF was used and that the number was produced by a particular VRF and no other function. This allows us to generate verifiable random numbers for on-chain usage in a decentralized way.


:::NEXT DOC:::

increase the chances of an attacker cheating your application. Imagine you implemented a simple coin flip smart contract using VRF v2. In a bet function, you choose heads or tails and then request a random number. If you have selected heads (0) and the result of the VRF service meant that you would win the bet, it could try to withhold this answer and replace it with your second request if it’s more advantageous.

So you see, we must consider the unique properties of blockchains here to ensure randomness in our smart contracts. While the numbers are always random, we must also look into how our applications and smart contracts deal with them. In the end, it will be a matter of cost if it's worth attacking your application. You must also be aware of the protocol that you are using.

In general, re-organizations on chains are possible. A miner would take your request and try to create a new random number with a different block and do this until they find a block to their advantage. They cannot control the VRF output but can ""re-roll"" the dice. If they manage to produce a valid blockchain with this new block and the network accepts this block instead, they could effectively attack your application by controlling the random input.
While this is a possible attack, it's costly to attack a network like this, as in the proof of network. You need at least 51% of the network to drive such an attack. Depending on your application requirements, you consider a 20-block confirmation time highly secure. You can lower the block confirmation time depending on the value you are trying to protect. You must calculate an attacker's costs and potential reward to decide your confirmation time.


:::NEXT DOC:::

#####Chapter 2:

# Randomness and Blockchains

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Upon research, you realize popular languages like Javascript have built-in randomness functions maybe you can use something like that in Solidity? 
    </div>
  </div>
</ContentWrapp>

Blockchains are deterministic, meaning that any computations that use blockchains must have predictable outcomes. This so all of the nodes that run the blockchain can come to an agreement on what the blockchain is. But deterministic runs counter to random. If everyone knows what the next hand of poker will be before it is dealt it wouldn’t be considered random. So if randomness is impossible on a blockchain, how can we bring the awesome powers of smart contracts to any applications that need randomness?

We could get the randomness from an outside resource! But it can’t be a trusted centralized service (as discussed in Chainlink 101), or we would be ruining the decentralized properties of blockchains and smart contracts. And it would be great if it could be verified that the number wasn’t tampered with and is genuinely random. This is a perfect example of where a decentralized oracle network powered by Chainlink could be used!


:::NEXT DOC:::

          randomResult = (randomResult % 100) + 1;
            if (randomResult <= winProbability) {
                ownerHistory[msg.sender].winCount++;
                ownerHistory[_opponent].lossCount++;
                ownersToDeposits[_opponent] -= 1 ether;
                if (ownersToDeposits[_opponent] < 1 ether) {
                    _removeFromLineupSet(_opponent);
                }
                ownersToDeposits[msg.sender] += 0.5 ether;
            } else {
                ownerHistory[msg.sender].lossCount++;
                ownerHistory[_opponent].winCount++;
                ownersToDeposits[msg.sender] -= 1 ether;
                if (ownersToDeposits[msg.sender] < 1 ether) {
                    _removeFromLineupSet(msg.sender);
                }
                ownersToDeposits[_opponent] += 0.5 ether;
  

:::NEXT DOC:::

pseudo-random in a post-merge ETH?

When a validator is due to propose a block, they face a [fairly minimal
penalty](https://ethereum.stackexchange.com/questions/90781/what-is-the-
penalty-of-having-eth2-validator-offline) for failing to do so. Given a smart
contract that is trying to make itself unpredictable/uncontrollable via
`PREVRANDAO`, this option allows them to cheaply bias the behavior of the
contract in the following ways.

### 1\. You always need a validator to propose two blocks in a row

`PREVRANDAO`'s value has no
[entropy](https://en.wikipedia.org/wiki/Entropy_\(computing\)) given the
`PREVRANDAO` value from the previous block if no block is proposed. When you
propose a block, that's a piece of the math equation that `PREVRANDAO` uses to
make a random number. So if you don't propose a block, you get a ""less"" random
number.

So users of `PREVRANDAO` would need to check that a validator has provided a
block since the last time they called `PREVRANDAO`. Otherwise, they won't
necessarily be drawing statistically independent random outputs on successive
calls to PREVRANDAO.

This means that the validator committed to proposing a particular block can
effectively set the PREVRANDAO value for the next block to two possible
values:

  * the one which results from its mandated `PREVRANDAO` input value
  * whatever `PREVRANDAO` gets deterministically set to if no block is proposed

This choice alone allows validators to influence the random number, no longer
making the number random.

Even if the contract does something cleverer, like taking the `PREVRANDAO`
output from the first block to

:::NEXT DOC:::

only the private key could decrypt it. The private key needs to be created at some point. Public key cryptography uses random numbers as input to calculate and create key pairs. If your source of randomness is something like Math.random(), it will be far more feasible for an attacker to guess your private key by brute-forcing the “random” numbers which is produced by this function. In other words, it drastically reduces the search space for the attacker. And the more they know about your conditions, the easier it is for them to find the correct private key as they have to search through fewer options.

Luckily, there are also true random number generators that we can use. They usually rely on measuring physical phenomena like atmospheric noise. It uses a natural source of entropy to avoid any brute-force attacks. This is critical to generating random numbers. Unpredictability is an essential requirement for true random number generators. Unpredictable means no one can reproduce the result by taking the same system as an input. So you cannot simply measure the same atmospheric noise to produce similar results. They will be completely different. So the quality of entropy becomes a fundamental metric. Once this is given, there are different tools to translate this into random numbers.


:::NEXT DOC:::

blockhash (just infeasible to compute for anyone who
doesn't know the secret key.)

### 2\. Validators can choose to not post if a number is unfavorable

Once again, you still run into this issue from pre-merge. The penalty of not
posting a block is almost negligible, so a node might be financially
incentivized not to propose blocks in a lottery-type smart contract if the
`PREVRAND` value isn't what they want. Enough nodes do this and you run into
issues.

Just taking the current `PREVRANDAO` value without looking at recent history
gives a validator some control over the output the contract will use, even if
it doesn't want to abort, because the validator can decide whether or not the
block it proposes contains a transaction which will trigger the use of
PREVRANDAO. The only cost involved there is the transaction fee/tip.

### 3\. If all applications use `PREVRANDAO` as their seed

If all applications use `PREVRANDAO` as their seed, in a way, you could
""chain"" together wins or hacks based on this.

### More information

There is also an interesting thread on this in the [Ethereum
Magicians](https://ethereum-magicians.org/t/eip-4399-supplant-difficulty-
opcode-with-random/7368/48) forum.





:::NEXT DOC:::

enable the transition to the new state. If the verification was successful, Alice has 3 ETH and Bob has 2 ETH. This is our new state. And everyone can repeat this transition by looking at the previous state and applying the pre-defined transition rules.

Ethereum provides the Ethereum Virtual Machine (EVM) to allow custom implementation of transition rules (see Solidity101, [chapter 1](https://www.chainlink.education/solidityIntroduction/chapter-1)). So we can use Smart Contracts to model the state of the system. But there is an important limitation here. EVM is just quasi Turing Complete. Let’s understand what this means.

A Turing Complete system can solve any computational problem. A problem can be as simple as adding two numbers together. Or it can be as complex as calculating an optimal route between two points on a map. Ethereum could be considered Turing Complete because it can execute any program a Turing machine can run. But Ethereum has some unique properties that make it just quasi Turing Complete. Because blocks have a finite memory space, executing a program that is too large to fit in memory is impossible. This is the first limitation.
The second limitation is that Ethereum is a decentralized world computer that must always be online. So it must be ensured that a program is not running forever. As there is no algorithm to determine if a program would halt and not run into an infinite loop (known as the halting problem), Ethereum uses gas to limit the number of computations that can be performed. So every instruction is executed with a cost. It provides a practical solution to the halting problem. Otherwise, bad actors could spam the network and cause a denial of service.
"
What does VRF stand for in Chainlink VRF?,VRF stands for Verifiable Randomness Function.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-3/course.md'},VRF stands for Verifiable Randomness Function in Chainlink VRF.,"#####Chapter 3:

# Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson randomness provided by an outside service needs to be verifiable and decentralized, and that’s exactly what Chainlink VRF is! VRF stands for Verifiable Randomness Function. Essentially Chainlink VRF provides cryptographic proof alongside every random number generated, that the random number wasn’t tampered with (and indeed generated in a random way).

How does this cryptographic proof work? It’s quite mathematically complicated and outside the scope of this lesson, but you can read more about it in the “Technical Walkthrough” section of this [blog post](https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/). The cryptographic proof is then verified by a smart contract on-chain, which means it is verified by every node on the blockchain! This completes our verifiable and decentralized criteria. So now we understand that Chainlink VRF is verifiably random and decentralized how do we use it?


:::NEXT DOC:::

understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.


:::NEXT DOC:::

#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is

:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription

:::NEXT DOC:::

how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation

:::NEXT DOC:::

#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed

:::NEXT DOC:::

                                                                                                                               |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                                                                                                          | Suitable for infrequent one-off requests                                                                                                                                                                    |
| Supports multiple VRF consuming contracts connected to one subscription account                   

:::NEXT DOC:::

                              |
|:---------------------------|:-------------------------------------------|
| LINK Token                 | 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846 |
| VRF Wrapper                | 0x9345AC54dA4D0B5Cda8CB749d8ef37e5F02BBb21 |
| VRF Coordinator            | 0x2eD832Ba664535e5886b75D64C46EB9a228C2610 |
| Wrapper Premium Percentage | 0                                          |
| Coordinator Flat Fee       | 0.005 LINK                                 |
| Minimum Confirmations      | 1                                          |
| Maximum Confirmations      | 200                                        |
| Maximum Random Values      | 10                                         |
| Wrapper Gas overhead       | 40000        

:::NEXT DOC:::

  |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x514910771AF9Ca656af840dff83E8264EcF986CA                         |
| VRF Coordinator       | 0x271682DEB8C4E0901D1a1550aD2e64D568E69909                         |
| 200 gwei Key Hash     | 0x8af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef |
| 500 gwei Key Hash     | 0xff8dedfbfa60af186cf3c830acbc32c05aae823045ae5ea7da1e45fbfaba4f92 |
| 1000 gwei Key Hash    | 0x9fe0eebf5e446e3c998ec9bb19951541aee00bb90ea201ae456421a2ded86805 |
| Premium               | 0.25 LINK                                                          |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                          

:::NEXT DOC:::

 | 0x5947BB275c521040051D82396192181b413227A3 |
| VRF Wrapper                | 0x721DFbc5Cfe53d32ab00A9bdFa605d3b8E1f3f42 |
| VRF Coordinator            | 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634 |
| Wrapper Premium Percentage | 0                                          |
| Coordinator Flat Fee       | 0.005 LINK                                 |
| Minimum Confirmations      | 1                                          |
| Maximum Confirmations      | 200                                        |
| Maximum Random Values      | 10                                         |
| Wrapper Gas overhead       | 40000                                      |
| Coordinator Gas Overhead   | 90000                           "
What is Solidity?,"Solidity is a smart contract programming language created by Ethereum developers to work with Ethereum, the first major smart contract blockchain.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-1/course.md'},"Solidity is a programming language used for writing smart contracts, particularly on the Ethereum blockchain. It is an object-oriented programming language and is the most popular language for writing smart contracts.","#####Chapter 1:

# Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Inspired by the power of smart contracts and blockchain, it’s time to dive in.
    </div>
  </div>
</ContentWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent. If you are familiar with some programming, it may help to know that Solidity is an **object-oriented programming language**. If you are not familiar with what that means, don’t worry, we’ll cover it in a future course.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!




:::NEXT DOC:::

popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
       

:::NEXT DOC:::

contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
   

:::NEXT DOC:::

with the use of cryptography and game theory (a combination of math and sociology).

You may have heard of a cryptocurrency called Bitcoin. Bitcoin is built on a blockchain (referred to as the <i>Bitcoin blockchain</i>)! No one entity controls Bitcoin so it can be thought of as a sort of “proto-smartcontract”. It has all the properties of smart contracts listed before, but only has one use: transferring value between individuals.

Today, there are blockchains where <i>any</i> code or applications can be built from. The code deployed to a blockchain is indeed a Smart Contract. This ability was truly pioneered by the Ethereum blockchain, but there are many other blockchains such as Polygon, Avalanche, Solana, Terra, and many others have the same capability. Smart contracts are often written in a programming language called <ColorWord>Solidity</ColorWord>, but others such as Rust are gaining popularity.

<MissionContainer>
  <div className=""title"">Activities:</div>
  <ul className=""mission-goals"">
    <li>
      Watch <a target=""__blank"" href=""https://www.youtube.com/watch?v=_160oMzblY8""> Anders Brownsworth video walkthrough </a> of his blockchain demo.
    </li>
    <li>
      Interact with the <a target=""__blank"" href=""https://andersbrownworth.com/blockchain/hash""> blockchain demo </a> yourself until you have a good understanding of the basics of how blockchains operate.
    </li>
  </ul>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 13:

# Conclusion

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

Congrats for making it this far! That’s a lot of Solidity concepts! The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions). In future courses, we will go into more detail on more complex variables such as storing structs within arrays and more special functions such as the constructor and events. And as always, you know the best way to learn is by doing! Feel free to go to https://remix.ethereum.org/, and just mess around with writing code there. It may feel overwhelming at first, but don’t worry it’s just to get a feel for what’s to come!


:::NEXT DOC:::

on. When a smart contract is deployed to Ethereum, its bytecode lives there forever; always accessible. Any language other than Solidity that can compile to EVM bytecode can also be used to write smart contracts on blockchains that utilize the EVM. Another language that compiles to EVM bytecode is Vyper. Examples of blockchains that run the EVM are Ethereum, Polygon, and Avalanche (among many others). Many blockchains now use the EVM making Solidity an even more powerful smart contract language! 

Some blockchains have virtual machines other than the EVM and thus have different programming languages and bytecode compilation targets, but for this course, we’ll stick with Solidity and the EVM.

<!-- <MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact legal contracts have become so notorousily difficult to enforce, more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a style=""color:green"" href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the american bar association </a>.
    </div>
</MissionContainer> -->


:::NEXT DOC:::

smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines

:::NEXT DOC:::

enable the transition to the new state. If the verification was successful, Alice has 3 ETH and Bob has 2 ETH. This is our new state. And everyone can repeat this transition by looking at the previous state and applying the pre-defined transition rules.

Ethereum provides the Ethereum Virtual Machine (EVM) to allow custom implementation of transition rules (see Solidity101, [chapter 1](https://www.chainlink.education/solidityIntroduction/chapter-1)). So we can use Smart Contracts to model the state of the system. But there is an important limitation here. EVM is just quasi Turing Complete. Let’s understand what this means.

A Turing Complete system can solve any computational problem. A problem can be as simple as adding two numbers together. Or it can be as complex as calculating an optimal route between two points on a map. Ethereum could be considered Turing Complete because it can execute any program a Turing machine can run. But Ethereum has some unique properties that make it just quasi Turing Complete. Because blocks have a finite memory space, executing a program that is too large to fit in memory is impossible. This is the first limitation.
The second limitation is that Ethereum is a decentralized world computer that must always be online. So it must be ensured that a program is not running forever. As there is no algorithm to determine if a program would halt and not run into an infinite loop (known as the halting problem), Ethereum uses gas to limit the number of computations that can be performed. So every instruction is executed with a cost. It provides a practical solution to the halting problem. Otherwise, bad actors could spam the network and cause a denial of service.


:::NEXT DOC:::

#####Chapter 10:

# Conclusion

That’s a lot of Solidity concepts! Congrats for making it this far. You know the best way to learn is by getting your hands dirty. So head over to https://remix.ethereum.org/ and mess around with writing code there. It may feel overwhelming with all the new concepts in mind, but it’s a great way to explore the freshly learned concepts further.
Future courses will look into specific use cases from DeFi, NFTs and DAOs. We will also cover developing a dApp interacting with the deployed contracts.


:::NEXT DOC:::

# Deploy Your First Smart Contract

  * Overview
  * Install and fund your MetaMask wallet
  * Write, compile, and deploy your first smart contract
  * Run functions in your contract

You can write your first smart contract and run it in your browser without any
knowledge about Ethereum or blockchains. This guide shows you how easy it is
to develop smart contracts using the [Solidity
language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io)
and the [Remix Development Environment](https://remix.ethereum.org/). You can
use all of these tools in your browser for free with no signup required.

Already know Solidity and have MetaMask configured?

If you are already familiar with how to deploy Smart Contracts and use
MetaMask, you can skip to the [Consuming Data Feeds](/getting-started/consuming-data-feeds) guide to learn how to connect your smart
contracts to Chainlink data feeds.

In general, you create and deploy your smart contracts operate using the
following process:

  1. **Write:** Write a contract to define how the contract functions, what data it can store, what other contracts it interacts with, and what external APIs it might call.

  2. **Compile:** Pass your smart contract code through a compiler to translate the contract into byte code that the blockchain can understand. For example, [Solidity](https://soliditylang.org) code must be compiled before it can run in the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/).

  3. **Deploy:** Send the compiled smart contract to the blockchain. From that point forward, the contract cannot be altered. However, you can still interact with the contract in several ways.

  4. **Run functions:** When you run the functions that you defined for the contract, the network processes those functions and modifies the state of your contract. For some functions, the network charges a small fee to complete the work. Your"
What are the four types of variable access modifiers in Solidity?,"The four types of variable access modifiers in Solidity are Public, Private, Internal, and External.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-7/course.md'},"The four types of variable access modifiers in Solidity are Public, Private, Internal, and External.","deploy code to a blockchain like Ethereum, that code can access any other code anyone has deployed to that blockchain. This is like how programs downloaded to your computer can access other programs on your computer. This allows smart contracts to interact in many unique and interesting ways that regular web application back ends may not be able to do so easily. However, this can also open risks of other code using our code in unintended ways.

To help prevent this we can declare “access modifiers” when declaring our variables, which limit what code on the blockchain can access and change those variables. The four types of variable access modifiers are:


* Public 
    * The variable/function can be accessed or changed by any other code or wallet on the blockchain.
* Private
    * The variable/function can only be accessed or changed within the current contract
* Internal
    * The variable/function can only be accessed or changed within the current contract or any other contract that inherits the current contract (we’ll discuss inheritance in another lesson)
* External
    * The variable/function can only be accessed/changed from outside code or blockchain wallets

To declare the access modifier of a variable we put it inbetween the function type and name like this:

<Highlight class=""language-javascript"">
uint public myFavNum;
</Highlight>

If no access modifier is declared then the variable is automatically assigned the private modifier. For example

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>
 
Is equivalent to 

<Highlight class=""language-javascript"">
uint private myFavNum;
</Highlight>


:::NEXT DOC:::

#####Chapter 7:

# Access Modifiers

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

We can actually give more information to the Solidity compiler on how we want to use our variables (and later functions). We can tell the compiler how we want our variables to be accessed. Many blockchains, such as Ethereum, act as one monolithic computer. While Ethereum is a network of computers distributed around the world, when you deploy code to a blockchain like Ethereum, that code can access any other code anyone has deployed to that blockchain. This is like how programs downloaded to your computer can access other programs on your computer. This allows smart contracts to interact in many unique and interesting ways that regular web application back ends may not be able to do so easily. However, this can also open risks of other code using our code in unintended ways.

To help prevent this we can declare “access modifiers” when declaring our variables, which limit what code on the blockchain can access and change those variables. The four types of variable access modifiers are:


* Public 
    * The variable/function can be accessed or changed by any other code or wallet on the blockchain.
* Private
    * The variable/function can only be accessed or changed within

:::NEXT DOC:::


    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use

:::NEXT DOC:::

on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>

This creates a variable called “myFavNum” and assigns it the type uint, or unsigned integer. Now we can use myFavoriteNumber to store numbers like 0,1,2,3,4…etc. in our contract. 


:::NEXT DOC:::

file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal

:::NEXT DOC:::

give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
    * These are phrases that meant to be read. You can store numbers in a string but you can’t do math on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint

:::NEXT DOC:::

+ value;
   }
}
 </Highlight>
 
Modifiers are defined using the **modifier** keyword followed by a function name. In the body of the function, we can run any Solidity code. Usually, we want to do some checks and if they are not met, we want to revert the transaction. If everything is alright, we can use the special keyword **_** to tell solidity to execute the called function. Once the function has finished, we could execute further code inside the modifier to do further checks before the transaction completes. In this example, if someone calls the inc function, it must be the contract owner and we do not allow x to be greater than 42.

The same modifier can be used for other functions by adding it to the header. We can also define multiple modifiers and run them in successive order for the given function.

 <Highlight class=""language-javascript"">
contract ContractA {
  uint public x = 0;
  address public owner;
  constructor() {
      owner = msg.sender;
  }
  modifier onlyOwner() {
      require(msg.sender == owner, ""Only owner allowed."");
      _;
      require(x < 42);
  }
 
  modifier maxValue(uint value) {
      require(value <= x, ""Value must be smaller or equal to x."");
      _;
  }
  
  function inc(uint value) public onlyOwner {
      x = x + value;
  }
 
  function dec(uint value) public onlyOwner maxValue(value) {
      x = x - value;
  }
}
 </Highlight>

See how we defined a new function called dec and added a new modifier

:::NEXT DOC:::

#####Chapter 5:

# Function Modifiers

Now that we have learned how to execute code based on given conditions and our contracts grow in complexity, we will find ourselves in situations where we need to run some checks before we allow the execution of a function. Introducing function modifiers. Modifiers can be run before and/or after function calls. They can be used for example to restrict access or validate input.

<Highlight class=""language-javascript"">
contract ContractA {
   uint public x = 0;
   address public owner;
 
   constructor() {
       owner = msg.sender;
   }
 
   modifier onlyOwner() {
       require(msg.sender == owner, ""Only owner allowed."");
       _;
       require(x < 42);
   } 
 
   function inc(uint value) public onlyOwner{
       x = x + value;
   }
}
 </Highlight>
 
Modifiers are defined using the **modifier** keyword followed by a function name. In the body of the function, we can run any Solidity code. Usually, we want to do some checks and if they are not met, we want to revert the transaction. If everything is alright, we can use the special keyword **_** to tell solidity to execute the called function. Once the function has finished, we could execute further code inside the modifier to do further checks before the transaction completes. In this example, if someone calls the inc function, it must be the contract owner and we do not allow x to be greater than 42.

The same modifier can be used for other functions by adding it to the header. We can also define multiple modifiers and run them in successive order for the given function.



:::NEXT DOC:::

#####Chapter 5:

# Contract State, Variables and Data Types

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now you want to connect your artwork to the physical (off-chain) world. Tell your artwork how to behave. 
    </div>
  </div>
</ContentWrapp> -->

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing **variables** and change data by defining logic in **functions**. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time. When defining a variable, you must give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
  

:::NEXT DOC:::

how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function calls. As block space is very valuable, storage variables are arranged in a compact way into storage slots into blocks of 32 bytes. Variables that take less than 32 bytes are combined into the same slot. Taking the least amount of space. Data is stored in order of the declaration in the contract in successive order. So we have slot 0x0, slot 0x1, slot 0x2, and so on.

```Solidity
contract StorageExample {
    uint256 nubmerOne = 1; // slot 0x0
    string customGreeting = ""Hello Chainlink""; // slot 0x1
    uint256 numberTwo; // slot 0x2

    string constant greeting = ""Hello World""; // no storage

    bool active; // slot 0x3
    bool admin; // slot 0x3
    bytes16 foo; // slot 0x3
    bytes16 bar; // slot 0x4
}
```

As you can see"
What are some important data types in Solidity?,"Some important data types in Solidity are int, uint, string, bool, and address.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-5/course.md'},"Some important data types in Solidity are: int, uint, string, bool, and address.","give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
    * These are phrases that meant to be read. You can store numbers in a string but you can’t do math on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint

:::NEXT DOC:::

#####Chapter 5:

# Contract State, Variables and Data Types

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now you want to connect your artwork to the physical (off-chain) world. Tell your artwork how to behave. 
    </div>
  </div>
</ContentWrapp> -->

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing **variables** and change data by defining logic in **functions**. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time. When defining a variable, you must give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
  

:::NEXT DOC:::

on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>

This creates a variable called “myFavNum” and assigns it the type uint, or unsigned integer. Now we can use myFavoriteNumber to store numbers like 0,1,2,3,4…etc. in our contract. 


:::NEXT DOC:::

how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function calls. As block space is very valuable, storage variables are arranged in a compact way into storage slots into blocks of 32 bytes. Variables that take less than 32 bytes are combined into the same slot. Taking the least amount of space. Data is stored in order of the declaration in the contract in successive order. So we have slot 0x0, slot 0x1, slot 0x2, and so on.

```Solidity
contract StorageExample {
    uint256 nubmerOne = 1; // slot 0x0
    string customGreeting = ""Hello Chainlink""; // slot 0x1
    uint256 numberTwo; // slot 0x2

    string constant greeting = ""Hello World""; // no storage

    bool active; // slot 0x3
    bool admin; // slot 0x3
    bytes16 foo; // slot 0x3
    bytes16 bar; // slot 0x4
}
```

As you can see

:::NEXT DOC:::

#####Chapter 2:

# Storage

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When someone says the data is stored on the blockchain, what does it actually mean from a perspective of a smart contract? Where is the data stored? How is it stored?
    </div>
  </div>
</ContentWrapp>

As we learned in the previous chapter, Ethereum could be described as a state machine. Transactions are then used to transition from one state to another state. The transactions are stored into individual blocks. These blocks are linked to each other creating the Ethereum blockchain. Everyone can take these transactions and follow the transition rules resulting in the same state for everyone.
But how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function

:::NEXT DOC:::

#####Chapter 10:

# Structs

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

We’ve gone over storing data as variables, some of the significant fundamental variable types, and how to store data in arrays. But what if we want to create a custom type? That type could be composed of several other fundamental types. For instance, we could have our custom type store a string and a number. We can create these custom, complex types, and they are called **structs**.

You can define a struct by declaring the struct keyword, naming the struct, then putting the structure of the struct within curly braces. For example, we could define a struct called “Car” composed of three fundamental types: a string for the make, a string for the model, and a uint for the VIN. This is how we would define this struct:

<Highlight class=""language-javascript"">
struct car {
  string make,
  string model,
  uint VIN
}
</Highlight>

And boom, we have created a new type called “Car” we can use throughout our code. Now to assign a variable to this type is a little different from one of the fundamental data types. We must use syntax like this:

<Highlight class=""language-javascript"">
car myNewCar =

:::NEXT DOC:::

constant variables (greeting) are not stored in storage slots. When a constant state variable is read the EVM uses the assigned value instead. the booleans active and admin just take 1 bit each and bytes16 takes 16 bits, so a total of 18 bits. That’s why they are all stored in slot 0x3. The last bytes16 variables bar takes another 16 bits but cannot be stored in slot 0x3 because the max size is 32 bytes. So a new slot is occupied.

Dynamic-sized arrays and structs are handled a little differently though as the size is unknown at the point of declaration. They always start with a slot that takes 32 bytes and their elements are stored in a different storage slot. The beginning of this storage slot is computed using a Keccack-256 hash.

**Memory** variables live only in memory and exist in the scope of a function. They are mutable inside that scope but cannot be called outside of the function. Once a function execution is completed, all variables in memory are released.

```Solidity
function add(uint256 a, uint256 b) pure returns(uint256) {
    uint256 result = a + b;
    return result;
}
```

Any manipulations done to memory variables is not written into the blockchain resulting in less gas consumption. So this is why we always need to ask if we need persistence.

There is an exception though as arrays, structs and mappings are stored in storage. This is important to remember as it might introduce critical bugs into your code when not considered. We will learn more about these data types in the upcoming chapters.


:::NEXT DOC:::

can define a struct by declaring the struct keyword, naming the struct, then putting the structure of the struct within curly braces. For example, we could define a struct called “Car” composed of three fundamental types: a string for the make, a string for the model, and a uint for the VIN. This is how we would define this struct:

<Highlight class=""language-javascript"">
struct car {
  string make,
  string model,
  uint VIN
}
</Highlight>

And boom, we have created a new type called “Car” we can use throughout our code. Now to assign a variable to this type is a little different from one of the fundamental data types. We must use syntax like this:

<Highlight class=""language-javascript"">
car myNewCar = car(“Tesla”, “Model 3”, 31223);
</Highlight>

To access information from a struct, you need to use “dot” notation. For example, to get the Model of the myNewCar variable, the syntax will look like this:

<Highlight class=""language-javascript"">
myNewCar.model;
</Highlight>

So, if we wanted to assign the value inside the model element of the myNewCar struct to another variable it could look like this:

<Highlight class=""language-javascript"">
string myNewCarModel = myNewCar.model;
</Highlight>



:::NEXT DOC:::


    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use

:::NEXT DOC:::

popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
       "
Why do customers tend not to read digital agreements?,"Customers tend not to read digital agreements due to lengthy, complex legalese and the fact that these agreements give consumers very little recourse.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-3/course.md'},"Customers tend not to read digital agreements due to lengthy, complex legalese and the fact that these agreements give consumers very little recourse.","or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue""

:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as

:::NEXT DOC:::

as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting

:::NEXT DOC:::

before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial crisis were programmed as smart contracts, they would be completely transparent and any member of the public would have had the ability to audit them.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>


:::NEXT DOC:::

is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract isn’t immediately executed after the conditions have been met. Rather, a lengthy review process is initiated and it could take months, even years before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial

:::NEXT DOC:::

#####Chapter 4:

# Smart Contracts - The Future

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Check out this video on what smart contracts are and how they are changing the nature of agreements and the Internet. 
    </div>
  </div>
</ContentWrapp>

<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/Un7-hW6GAec"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>

Smart contracts result from the evolution of digital agreements. A smart contract is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract

:::NEXT DOC:::

fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

   </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Trust Minimization</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.
          <b>Example</b>: Robinhood can no longer stop people from trading Gamestop, unless it is coded into the agreement.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label"">Efficiency:</p>
    <ul class=""list__items"">
      <li class=""list__item"">
    

:::NEXT DOC:::

   <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.
          <b>Example</b>: Robinhood can no longer stop people from trading Gamestop, unless it is coded into the agreement.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label"">Efficiency:</p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
         The characteristics of smart contracts outlined earlier can create more efficient, automated processes that save business cost. 
         <b>Example:</b> Businesses could use a smart contract to settle inter-company transactions without needing to spend time and money on complicated systems of trusted neutral third parties to hold both sides accountable.
          </p>
      </li>
    </ul>
  </div>
</ListItemsContainer>

<MissionContainer>  
  <div className=""title"">Activities:</div>
  <ul className=""mission-goals"">
    <li>
      Think about an industry where agreements and contracts play a crucial role in ensuring its success. 
    </li>
    <li>
      Brainstorm ways smart contracts"
What do you need to do after completing the contract in order to use the VRFCoordinator?,You need to subscribe your contract to the VRFCoordinator.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-12/course.md'},"After completing the contract, you need to subscribe your contract to the VRFCoordinator using the Subscription Manager at vrf.chain.link and follow the steps to set up a subscription.","{
    s_requestId = COORDINATOR.requestRandomWords(
      keyHash,
      s_subscriptionId,
      requestConfirmations,
      callbackGasLimit,
      numWords
    );
  }

  function fulfillRandomWords(
    uint256, // requestId
    uint256[] memory randomWords
  ) internal override {
    s_randomWords = randomWords;
  }
}
</Highlight>

Now that the contract is complete you need to subscribe your contract to the VRFCoordinator. You can do so via the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/). Go to the website and follow the steps to see what it would be like to set up a subscription.

:::NEXT DOC:::

This contract is a mock of the [VRFCoordinatorV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) contract.
  2. Call the VRFCoordinatorV2Mock [createSubscription function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L176) to create a new subscription.
  3. Call the VRFCoordinatorV2Mock [fundSubscription function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L138) to fund your newly created subscription. **Note** : You can fund with an arbitrary amount.
  4. Deploy your VRF consumer contract.
  5. Call the the VRFCoordinatorV2Mock [addConsumer function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L229) to add your consumer contract to your subscription.
  6. Request random words from your consumer contract.
  7. Call the VRFCoordinatorV2Mock [fulfillRandomWords function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L88) to fulfill your consumer contract

:::NEXT DOC:::

0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
    LINKTOKEN = LinkTokenInterface(linkTokenContract);
    s_owner = msg.sender;
  }

  function requestRandomWords() external {
    s_requestId = COORDINATOR.requestRandomWords(
      keyHash,
      s_subscriptionId,
      requestConfirmations,
      callbackGasLimit,
      numWords
    );
  }

  function fulfillRandomWords(
    uint256, // requestId
    uint256[] memory randomWords
  ) internal override {
    s_randomWords = randomWords;
  }
}
</Highlight>

Now that the contract is complete you need to subscribe your contract to the VRFCoordinator. You can do so via the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/). Go to the website and follow the steps to see what it would be

:::NEXT DOC:::

This contract is a mock of the [VRFCoordinatorV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol) contract.
  2. Deploy the [MockV3Aggregator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/tests/MockV3Aggregator.sol) contract.
  3. Deploy the [LinkToken](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/LinkToken.sol) contract.
  4. Deploy the [VRFV2Wrapper](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol) contract.
  5. Call the VRFV2Wrapper [setConfig function](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol#L119) to set wrapper specific parameters.
  6. Fund the VRFv2Wrapper subscription.
  7. Call the the VRFCoordinatorV2Mock [addConsumer function](https://github.com/smartcontractkit/chainlink/blob/abf1d19c147c4fd54173b48140706780b53be474/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L229) to add the wrapper contract to your subscription.
  8. Deploy your VRF consumer contract.
  9. Fund your consumer contract with LINK tokens.
  10. Request random words from your consumer contract.
  11. Call the VRFCoordinatorV2Mock [fulfillRandomWords

:::NEXT DOC:::

Question: (Asked on: 2021-10-04 21:59:28)
What it is the VRF coordinator contract on Chainlink?
URL: https://stackoverflow.com/questions/69442819/what-it-is-the-vrf-coordinator-contract-on-chainlink

Question Body:


Im learning Chainlink with solidity but i cant find information about what it
is the coordinator contract that is needed to create an instance of
VRFConsumerBase



Answers:
(Answered on: 2021-10-06 02:32:49)


The [Chainlink VRF
Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/VRFCoordinator.sol)
is a contract that is deployed to a blockchain that will check the randomness
of each random number returned from a random node.

You can find the addresses of these contracts on each chain in the [Chainlink
documentation under ""Contract Addresses""](https://docs.chain.link/docs/vrf-
contracts/)

[](https://i.stack.imgur.com/Pce2Q.png)





:::NEXT DOC:::

           _;
        }
    }
    

Your RemixIDE file explorer should display _VRFCoordinatorV2Mock.sol_ and
_VRFv2Consumer.sol_ :

### Deploy VRFCoordinatorV2Mock

  1. Open _VRFCoordinatorV2Mock.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _VRFCoordinatorV2Mock_.

  3. Under _DEPLOY_ , fill in the `_BASEFEE` and `_GASPRICELINK`. These variables are used in the _VRFCoordinatorV2Mock_ contract to represent the base fee and the gas price (in LINK tokens) for the VRF requests. You can set: `_BASEFEE=100000000000000000` and `_GASPRICELINK=1000000000`.

  4. Click on _transact_ to deploy the _VRFCoordinatorV2Mock_ contract.

  5. Once deployed, you should see the _VRFCoordinatorV2Mock_ contract under _Deployed Contracts_.

  6. Note the address of the deployed contract.

### Create and fund a subscription

  1. Click on `createSubscription` to create a new subscription.

  2. In the RemixIDE console, read your transaction decoded output to find the subscription ID. In this example, the subscription ID is _1_.

  3. Click on `fundSubscription` to fund your subscription. In this example, you can set the `_subid` to `1` (which is your newly created subscription ID) and the `_amount` to `1000000000000000000`.

### Deploy the VRF consumer contract

  1. In the file explorer, open _VRFv2Consumer.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _RandomNumberConsumerV2_.

 

:::NEXT DOC:::

 4. Click on _transact_ to deploy the _RandomNumberConsumerV2_ contract.

  5. After the consumer contract is deployed, you should see the _RandomNumberConsumerV2_ contract under _Deployed Contracts_.

  6. Note the address of the deployed contract.

### Add the consumer contract to your subscription

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click on _addConsumer_ and fill in the `_subid` with your subscription ID and `_consumer` with your deployed consumer contract address.

  3. Click on _transact_.

### Request random words

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_ contract.

  2. Click on `requestRandomWords`.

  3. In the RemixIDE console, read your transaction logs to find the VRF request ID. In this example, the request ID is _1_.

  4. Note your request ID.

### Fulfill the VRF request

Because you are testing on a local blockchain environment, you must fulfill
the VRF request yourself.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click `fulfillRandomWords` and fill in `_requestId` with your VRF request ID and `_consumer` with your consumer contract address.

  3. Click on `transact`.

### Check the results

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_ contract.

  2. Click on `s_requestId` to display the last request ID. In this example, the output is _1_.

  3. Each time you make a VRF request, your consumer contract requests two random words. After the request is fulfilled, the two random words are stored in the `s_randomWords` array.

:::NEXT DOC:::

that must be imported to communicate with the VRF coordinator.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
    
    }

### Contract variables

This example is adapted for [Sepolia testnet](/vrf/v2/subscription/supported-networks/#sepolia-testnet) but you can change the configuration and make it
run for any [supported network](/vrf/v2/subscription/supported-networks/#configurations).


    uint64 s_subscriptionId;
    address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
    bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
    uint32 callbackGasLimit = 40000;
    uint16 requestConfirmations = 3;
    uint32 numWords =  1;

  * `uint64 s_subscriptionId`: The subscription ID that this contract uses for funding requests. Initialized in the `constructor`.
  * `address vrfCoordinator`: The address of the Chainlink VRF Coordinator contract.
  * `bytes32 s_keyHash`: The gas lane key hash value, which is the maximum gas price you are willing to pay for a request in wei. It functions as an ID of the off-chain VRF job that runs in response to requests.


:::NEXT DOC:::

list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click `fundSubscription` to fund the _VRFV2Wrapper_ subscription. In this example, you can set the `_subid` to `1` (which is your newly created subscription ID) and the `_amount` to `10000000000000000000` (10 LINK).

  3. A Metamask popup will open. Click on _Confirm_.

### Deploy the VRF consumer contract

  1. In the file explorer, open _RandomNumberDirectFundingConsumerV2.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _RandomNumberDirectFundingConsumerV2_.

  3. Under _DEPLOY_ , fill in `_LINKADDRESS_` with the _LinkToken_ contract address, and `_WRAPPERADDRESS_` with the deployed _VRFV2Wrapper_ address.

  4. Click on _transact_ to deploy the _RandomNumberDirectFundingConsumerV2_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _RandomNumberDirectFundingConsumerV2_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Fund your VRF consumer contract

  1. Under _Deployed Contracts_ , open the functions list of your deployed _LinkToken_ contract.

  2. Click on _transfer_ and fill in the `_to` with your consumer contract address and `_value` with LINK tokens amount. For this example, you can set the `_value` to `10000000000000000000` (10 LINK).

  3. Click on _transact_.

  4. A Metamask popup will open. Click on _Confirm_.

### Request random words

Request three random words.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_

:::NEXT DOC:::

Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was generated.

### Set up your contract and request

Set up your consuming contract:

  1. Your contract must inherit [VRFConsumerBaseV2](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol).

  2. Your contract must implement the implement the `fulfillRandomWords` function, which is the _callback VRF function_. Here, you add logic to handle the random values after they are returned to your contract.

  3. Submit your VRF request by calling `requestRandomWords` of the [VRF Coordinator](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol). Include the following parameters in your request:

    * `keyHash`: Identifier that maps to a job and a private key on the VRF service and that represents a specified gas lane. If your request is urgent, specify a gas lane with a higher gas price limit. The configuration for your network can be found [here](/vrf/v2/subscription/supported-networks/#configurations).
    * `s_subscriptionId`: The subscription ID that the consuming contract is registered to. LINK"
What are the three different ways to throw an error in Solidity?,"The three different ways to throw an error in Solidity are require, revert, and assert.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-6/course.md'},"The three different ways to throw an error in Solidity are require, revert, and assert.","#####Chapter 6:

# Errors

In the previous chapter, we learned about function modifiers. We already used the keyword **require** to check for conditions. If a condition is not met, an error is raised. An error will revert all changes made to the state during a transaction. There are three different ways to throw an error: **require**, **revert** and **assert**.

We use require if we want to validate user input and return values from calls to other functions. The syntax asks for a condition and a custom error message as the second argument. If the condition is not met, an error is raised. Otherwise, the next line will be executed.

<Highlight class=""language-javascript"">
require(x <= 42, ""x must be smaller or equal to 42."");
</Highlight>

**Revert** is used in a similar fashion but directly throws an error without checking a condition. It is useful when the condition check is more complex and you do not want to do it in a single line to improve readability or if several conditions have to be met that you want to check one by one. It will return all remaining gas to the caller. You can call it like this:

<Highlight class=""language-javascript"">
if (x <= 42 && x > 0) {
  revert(""x must be greater than 0 and smaller or equal to 42"");
}
</Highlight>

**Assert** is used for internal logic and checks code that should never be false. If an assertion fails, it’s likely that there is a bug in the contract. We can use asserts to ensure that even if there is a bug, we can simply catch it here and make it more difficult to abuse the bug. For example, it is often used to check for overflow/underflow. The following code shows how can ensure that a is

:::NEXT DOC:::

   Note: The previous declaration is here:
    --> oracle.sol:63:5:
    |
    63 | uint public ethPrice = 0; 
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    

The second is found on line no. 91. `msg.sender.transfer(amountToWithdraw);`
with the transfer function. The console continues to return the following
error despite the fact that the address of each user is defined as payable in
the previous functions. Console returns:

    
    
    TypeError: ""send"" and ""transfer"" are only available for objects of type ""address payable"", not ""address"".
    --> oracle.sol:97:9:
    |
    97 | msg.sender.transfer(amountToWithdraw);
    | ^^^^^^^^^^^^^^^^^^^
    

These two problems severely invalidate the smart contract and are holding up
the completion of coding the latest functions. I have contacted several people
and looked in forums concerning programming on solidity but no one seems to
have an answer to my problem.

I hope that my question can be answered by the community and can help any
other person trying to use ChainLink with Solidity in the future. I am happy
to listen to any advice on the matter.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
        // EACAggregatorProxy is used for chainlink oracle
    interface EACAggregatorProxy {
        function latestAnswer() external view returns

:::NEXT DOC:::

public payable {
            if (oraclizegetPrice(""URL"") > this.balance) { 
                //Handle out of funds error 
            } else {
                oraclizequery(""URL"", ""json(http://api.fixer.io/latest?symbols=USD).rates.USD"");
            }
        }
        function _callback(bytes32 myid, string result) public {
            require(msg.sender == oraclizecbAddress());
            EURUSD = result;
        }
    }
    

if you want to achieve certain condition is met in solidity code and send this
information through an outbound oracle to another smart contract or on any
other application, you can achieve that by using the Solidity language's event
system, this event system will help you to send data to external service.

here is an example:

    
    
      contract DummyContract {
        event LogSent(bytes32 data);
        function sendData(address otherContractAddress, bytes32 data) public {
            // execute functions when certain conditions are met
            if (someCondition) {
                someFunction();
            }
    
        emit LogSent(data);
        // call other contract
        otherContractAddress.call(data);
 

:::NEXT DOC:::

           
            users.push(user);                     
            totalDeposited.push(amountDeposit);
    
            deadline = block.timestamp + (numberOfSeconds * 1 seconds);
    
            int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();
            ethPrice = uint(chainLinkEthPrice / 100000000);
            //return ethPrice = price;
            //price.push(ethPrice);
        }
    
        // Withdraw function for each user 
        function withdraw() public payable {
            require(block.timestamp >= deadline);
            uint amountToWithdraw = lockAmounts[msg.sender];
            lockAmounts[msg.sender] = 0; 
            msg.sender.transfer(amountToWithdraw); 
        }
    }
    



Answers:
(Answered on: 2022-06-01 17:02:50)


For the first issue, Solidity compiler said that you declared two variables
with the identifier. In details in your case, you give `ethPrice` for
`mapping` and `uint` variable. To solve this issue, try to change one of these
names in this way:

    
   

:::NEXT DOC:::

Question: (Asked on: 2022-06-01 10:30:03)
How fix TypeError and DeclarationError with ChainLink Solidity smart contract?
URL: https://stackoverflow.com/questions/72460303/how-fix-typeerror-and-declarationerror-with-chainlink-solidity-smart-contract

Question Body:


I have created a smart contract which return to each user the amount deposited
+ a certain amount if the price of ETH decreases during the lock period. I
have two problems with the last part of the code.

The first one concerns mapping the price of ethereum at the moment the user
makes the deposit. I have tried several solutions but none of them seem to
work. The problem arises on line 64 `mapping(uint => uint) ethPrice;`. Console
returns:

    
    
    DeclarationError: Identifier already declared.
    --> oracle.sol:65:5:
    |
    65 | mapping(uint => uint) ethPrice;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    Note: The previous declaration is here:
    --> oracle.sol:63:5:
    |
    63 | uint public ethPrice = 0; 
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    

The second is found on line no. 91. `msg.sender.transfer(amountToWithdraw);`
with the transfer function. The console continues to return the following
error despite the fact that the address of each user is defined as payable in
the previous functions. Console returns:

    
    
    TypeError: ""send"" and ""transfer"" are only available for objects of type ""address payable"", not ""address"".
    --> oracle.sol:97:9:
    |
    97 |

:::NEXT DOC:::

           
            users.push(user);                     
            totalDeposited.push(amountDeposit);
    
            deadline = block.timestamp + (numberOfSeconds * 1 seconds);
    
            int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();
            ethPrice = uint(chainLinkEthPrice / 100000000);
            //return ethPrice = price;
            //price.push(ethPrice);
        }
    
        // Withdraw function for each user 
        function withdraw() public payable {
            require(block.timestamp >= deadline);
            uint amountToWithdraw = lockAmounts[msg.sender];
            lockAmounts[msg.sender] = 0; 
            payable(msg.sender).transfer(amountToWithdraw); 
        }
    }
    





:::NEXT DOC:::

deploy the contract is
    // the owner
    constructor() public {
        owner = msg.sender;
    }
    
    function fund() public payable {
        // 18 digit number to be compared with donated amount 
        uint256 minimumUSD = 50 * 10 ** 18;
        //is the donated amount less than 50USD?
        require(getConversionRate(msg.value) >= minimumUSD, ""You need to spend more ETH!"");
        //if not, add to mapping and funders array
        addressToAmountFunded[msg.sender] += msg.value;
        funders.push(msg.sender);
    }
    
    //function to get the version of the chainlink pricefeed
    function getVersion() public view returns (uint256){
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);
        return priceFeed.version();
    }
    
    function getPrice() public view returns(uint256){
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);
        (,int256 answer,,,) = priceFeed.latestRoundData();
         // ETH/USD rate in 18 digit 
         return uint256(answer * 10000000000);
    }


:::NEXT DOC:::

seems to work fine and the console returns no errors. I am testing
the smart contract on the Kovan network. The problem is encountered when the
user tries to withdraw the ethereums. When he withdraws, only the deposited
ones are returned without the extra ethers being added.

I am new to Solidity so I appreciate any criticism or advice. If there is
something already existing similar to what I am trying to create please let me
know.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    
    
    interface EACAggregatorProxy {
        function latestAnswer() external view returns (int256);
    }
    
    contract oracleLink {
    
        address public manager;
        uint256 public managerDeposit;
        uint256[] public managerDeposits;
    
        constructor() payable {
            manager = msg.sender;
            managerDeposit = msg.value;
            managerDeposits.push(managerDeposit);
        }
    
        function depositVault() public payable {
            require(msg.sender == manager);
        }
    
        address public user;


:::NEXT DOC:::

Question: (Asked on: 2022-10-11 16:03:20)
&quot;Execution reverted&quot; error when I call createCollectible function on goerli testnet
URL: https://stackoverflow.com/questions/74031028/execution-reverted-error-when-i-call-createcollectible-function-on-goerli-test

Question Body:


I'm new to smart contract and Solidity programming and I've been trying to
deploy an NFT contract on goerli testnet. The contract deploys without any
problem but when I try to call the ""createCollectible"" function, I get the
following error:

    
    
    Gas estimation errored with the following message (see below). The transaction execution will likely fail. Do you want to force sending?
    execution reverted
    {
    ""originalError"": {
    ""code"": 3,
    ""data"": ""0xf0019fe60000000000000000000000000000000000000000000000000000000000000c6a000000000000000000000000b54644506388a04187d943dbbbd3edbb3ee53094"",
    ""message"": ""execution reverted""
    }
    }
    

Here is my contract:

    
    
    // SPDX-License-Identifier: MIT
    
    pragma solidity >=0.6.0 <0.9.0;
    
    import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import

:::NEXT DOC:::

19:16:39)


You can deploy the contract with Remix Ide Online, web3 connection with
Metamask. Can you share your hardhat config file or error logs? This should be
inside your hardhat env.

    
    
        mumbai: {
      url: ""https://rpc-mumbai.matic.today"",
      // url: API_URL, //or Infura API  URL   
      accounts: [`0x${PRIVATE_KEY}`],
        gasPrice: 10000000000,
        gasLimit: 9000000
    },
    

Edit: It's failing because cant estimate gasLimit of the transaction. You can
set it manually. Inside your deploy.js script set the gasPrice and gasLimit.
Depending on you are using web3js or etherjs this code will be different. This
is example of another minting function.

    
    
    FT = await contract.ownerMint(WALLET_ADDRESS,{ gasLimit: 285000, gasPrice: ethers.utils.parseUnits('30', 'gwei')});
    

Edit2: you can always deploy it with remix online with Metamask
[](https://i.stack.imgur.com/UbsrU.png)



"
What is the difference between an agreement and a contract?,"Contracts are agreements that are enforceable in a court of law, while agreements are oftentimes informal and not legally binding.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md'},"A contract is an enforceable agreement in a court of law, while an agreement can be informal and ""wishy washy"" and is not necessarily enforceable in a court of law.","#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as

:::NEXT DOC:::

as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting

:::NEXT DOC:::

or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue""

:::NEXT DOC:::

#####Chapter 4:

# Smart Contracts - The Future

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Check out this video on what smart contracts are and how they are changing the nature of agreements and the Internet. 
    </div>
  </div>
</ContentWrapp>

<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/Un7-hW6GAec"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>

Smart contracts result from the evolution of digital agreements. A smart contract is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract

:::NEXT DOC:::

before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial crisis were programmed as smart contracts, they would be completely transparent and any member of the public would have had the ability to audit them.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>


:::NEXT DOC:::

is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract isn’t immediately executed after the conditions have been met. Rather, a lengthy review process is initiated and it could take months, even years before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial

:::NEXT DOC:::

contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor() {}
    
        function isSameNum(uint a, uint b) external pure override returns (bool) {
            if (a == b) {
                return true;
            } else {
                return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known,

:::NEXT DOC:::

   <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.
          <b>Example</b>: Robinhood can no longer stop people from trading Gamestop, unless it is coded into the agreement.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label"">Efficiency:</p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
         The characteristics of smart contracts outlined earlier can create more efficient, automated processes that save business cost. 
         <b>Example:</b> Businesses could use a smart contract to settle inter-company transactions without needing to spend time and money on complicated systems of trusted neutral third parties to hold both sides accountable.
          </p>
      </li>
    </ul>
  </div>
</ListItemsContainer>

<MissionContainer>  
  <div className=""title"">Activities:</div>
  <ul className=""mission-goals"">
    <li>
      Think about an industry where agreements and contracts play a crucial role in ensuring its success. 
    </li>
    <li>
      Brainstorm ways smart contracts"
What is Chainlink and what does it allow developers to do?,"Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. It allows developers to create and customize any type of Decentralized Oracle Network (DON) that a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-5/course.md'},"Chainlink is a decentralized oracle network that allows developers to connect their smart contracts to external data sources, such as APIs, and access off-chain computation. It provides access to a trust-minimized compute infrastructure and allows developers to run their code in a serverless environment. Chainlink also allows developers to aggregate and validate data from multiple sources and provides a way to pay for requests using LINK tokens. Additionally, Chainlink Functions is a self-service solution that enables developers to connect to any public data, transform it before consumption, and connect to password-protected data sources or external decentralized databases.","special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform. Finally, with Chainlink, developers can build smart contracts that can interact with the outside world to preserve the decentralized nature of smart contracts.

<Spacer>

## How Chainlink Works

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      Curious how Chainlink works? Read below! With Chainlink, any type of data the exists can be brought on chain, and the conditions on which that data is delivered can be customized! 
    </div>
  </div>
</ContentWrapp>

Chainlink allows developers to build and customize DONs. Chainlink allows DONs to work and assures that node operators are incentivized not to collude or act

:::NEXT DOC:::

Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

in the best interest of everyone. But what if we had a decentralized middleware solution, one where Jim doesn’t control everything (sorry Jim), so we didn’t have to trust him?

Finally we are here…...enter Chainlink!

<Spacer>

## Chainlink and Decentralized Oracles

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Using a Chainlink Decentralized Oracle Network (DON) as the Oracle for your dNFT can give you strong guarantees that your artwork will truly update with the latest, most acurate data and remain decentralized. 
    </div>
  </div>
</ContentWrapp>

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform.

:::NEXT DOC:::

various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually

:::NEXT DOC:::

# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

in our
previous hackathons. There is also a link to the Marketplace where you can
find the latest data provider nodes and explore the network.

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past Hackathon Winning Projects](/resources/example-projects)

## Outreach

The Chainlink community is an inviting group of engineers that is always
looking to help users expand their knowledge on Chainlink and solve related
issues. Refer back to the [Getting Help](/resources/getting-help) page for the
latest information about how to get support.

### Get support

  * [Stack Overflow](https://stackoverflow.com/questions/tagged/chainlink)
  * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

### Join the community

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/other-tutorials.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  *

:::NEXT DOC:::

# Contributing to Chainlink

  * Overview
  * Contributing to Software and Tooling
  * Raising an Issue
  * Requesting a new Feature
  * Submitting a Pull Request
  * Contributing to the documentation
  * Creating Community Content
  * Becoming a Developer Expert
  * Joining the Chainlink Community Advocate program
  * Running a Chainlink Focused Developer Bootcamp
  * Running an In-Person Meetup or Watch Party
  * Participate in a Hackathon
  * Applying for a Grant

Chainlink is an open-source project licensed [under the MIT
license](https://github.com/smartcontractkit/chainlink/blob/master/LICENSE),
and we encourage contributions from all developers and community members.

# What It Means to Contribute

When you contribute to the Chainlink project, you as a developer or community
member contribute your time and effort to help improve and grow Chainlink.
Your contribution can be from various methods:

  * Building and maintaining the Chainlink software and tools
  * Improving and maintaining the documentation, including translations into other languages
  * Creating Chainlink focused content (blog posts, tutorials, videos etc)
  * Becoming a developer expert
  * Becoming a community advocate
  * Running a Chainlink focused developer Bootcamp (in person or online)
  * Running an in-person meetup or watch party
  * Participate in a hackathon
  * Applying for a grant

# Why Should You Contribute

[Open source software](https://en.wikipedia.org/wiki/Open-source_software) is
a model that brings multiple benefits for both the project and the
contributors. As a developer or community member, contributing to Chainlink
helps you to gain valuable skills and experience, improve the software that
you use, and grow your personal brand in the community which can lead to
future employment opportunities. On top of these awesome things, contributing
to open source is fun. It can give

:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties

:::NEXT DOC:::

Smart Contracts](https://blog.chain.link/testing-chainlink-smart-contracts/)
  * [NFTs and Chainlink](https://blog.chain.link/build-deploy-and-sell-your-own-dynamic-nft/)
  * [Build an external adapter](/chainlink-nodes/external-adapters/developers)

## Inspiration

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past winners & code](/resources/example-projects)

## Join the community

The Chainlink community is some of the most inviting groups of engineers
always looking to help you grow to the next stage.

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/hackathon-resources.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are the three contracts being imported in the code?,"LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBaseV2",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-6/course.md'},"The three contracts being imported in the code are LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBase.","#####Chapter 6: Building a Basic Contract:

# Imports

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now that you know about Chainlink VRF v2 it’s time to begin building the raffle contract!
    </div>
  </div>
</ContentWrapp>

We will begin by declaring the Solidity compiler version and importing the code we need. There are 3 contracts we will be importing: LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBase:

<Highlight class=""language-javascript"">
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>


:::NEXT DOC:::

Question: (Asked on: 2022-01-12 14:26:52)
How can I import AggregatorV3Interface
URL: https://stackoverflow.com/questions/70683276/how-can-i-import-aggregatorv3interface

Question Body:


**I'm trying to import AggregatorV3 but the file is nowhere to be found here
is my code; I'm sorry in advance i'm still a beginner programmer.**

    
    
    //SPDX-License-Identifier: MIT
    pragma solidity ^0.8.9;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract Lottery {
        address payable[] public players; //to keep track of all players, payable array
        uint256 public usdEntryFee;
        AggregatorV3Intefrace internal ethUsdPriceFeed;
    
        constructor(address _priceFeedAddress) public {
            usdEntryFree = 50 * (10**18);
            ethUsdPriceFeed = AggregatorV3Interface(_priceFeedAddress); //we need to pass the address of aggv3 in constructor
        }
    
        function enter() public payable {
            //payable since we want them to pay in eth
            //50 $ minimum
            players.push(msg.sender);
        }
    
        function getEntranceFee() public view returns (uint256)

:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as

:::NEXT DOC:::

fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!


:::NEXT DOC:::

with
every feature selected on OpenZeppelin Contracts Wizard:

> // SPDX-License-Identifier: MIT pragma solidity ^0.8.4;
>
> import ""./@openzeppelin/contracts-
> upgradeable/token/ERC20/ERC20Upgradeable.sol""; import
> ""./@openzeppelin/contracts-
> upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol""; import
> ""./@openzeppelin/contracts-
> upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol""; import
> ""./@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
> import ""./@openzeppelin/contracts-
> upgradeable/security/PausableUpgradeable.sol""; import
> ""./@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-
> ERC20PermitUpgradeable.sol""; import ""./@openzeppelin/contracts-
> upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol""; import
> ""./@openzeppelin/contracts-
> upgradeable/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol""; import
> ""./@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
> import ""./@openzeppelin/contracts-
> upgradeable/proxy/utils/UUPSUpgradeable.sol"";
>
> import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
>
> contract UpToken is Initializable, ERC20Upgradeable,
> ERC20BurnableUpgradeable, ERC20SnapshotUpgradeable, OwnableUpgradeable,
> PausableUpgradeable, ERC20PermitUpgradeable, ERC20VotesUpgradeable,
> ERC20FlashMintUpgradeable, UUPSUpgradeable

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First

:::NEXT DOC:::

_priceFeedAddress) public {
            usdEntryFree = 50 * (10**18);
            ethUsdPriceFeed = AggregatorV3Interface(_priceFeedAddress); //we need to pass the address of aggv3 in constructor
        }
    
        function enter() public payable {
            //payable since we want them to pay in eth
            //50 $ minimum
            players.push(msg.sender);
        }
    
        function getEntranceFee() public view returns (uint256) {}
    
        function startLottery() public {}
    
        function endLottery() public {}
    }
    

**here is my Yaml file:**

    
    
    dependencies:
      - smartcontractkit/chainlink-brownie-contracts@1.1.1
    
    compiler:
      solc:
        remappings:
        - '@chainlink=smartcontractkit/chainlink-brownie-contracts@1.1.1'
    

**here is the error:**

    
    
    (base) marc@Marcs-MacBook-Pro smartcontract-lottery % brownie compile
    Brownie v1.17.2 - Python development framework for Ethereum
    
    Compiling contracts...
      Solc version: 0.8.11
      Optimizer: Enabled  Runs: 200
   "
What are functions in Solidity and what do they do?,"Functions in Solidity are little machines that take in data, run some logic and produce an output. They manipulate data and can be customized to do anything.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-11/course.md'},"Functions in Solidity are blocks of code that can manipulate data in an infinite number of ways. They take in data as arguments, run logic in their body, and can produce an output as a return value. Functions can be customized to do anything and have modifiers, including access modifiers. They are one of the two main things defined when programming smart contracts, the other being state (variables).","#####Chapter 11:

# Functions

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

Thus far, we’ve mainly been concerned with storing data in variables and accessing that stored data. But what if we want to manipulate data? That is the realm of **functions**. You can write the logic in a function and have it manipulate data in an infinite number of ways. Solidity and the EVM are called [Turing Complete](https://stackoverflow.com/questions/7284/what-is-turing-complete ""Turing Complete""), which essentially means they can solve any computational problem (although there’s no guarantee that it will complete within a reasonable amount of time). 

You can think of functions as little machines that take in data, run some logic and produce an output. The values that are input into functions are called **arguments**. The logic is put in the **body** of the function. If the function directly returns a value as an output of the function that output is called the **return** value. Finally, just like variables have access modifiers, functions also have **modifiers** (including access modifiers too). Some functions don’t take in any arguments. Some functions just run calculations to change some state variables or make a request to

:::NEXT DOC:::

""Turing Complete""), which essentially means they can solve any computational problem (although there’s no guarantee that it will complete within a reasonable amount of time). 

You can think of functions as little machines that take in data, run some logic and produce an output. The values that are input into functions are called **arguments**. The logic is put in the **body** of the function. If the function directly returns a value as an output of the function that output is called the **return** value. Finally, just like variables have access modifiers, functions also have **modifiers** (including access modifiers too). Some functions don’t take in any arguments. Some functions just run calculations to change some state variables or make a request to run other code (or to a Chainlink node!) Some functions don’t return a direct value and just run calculations based on storage variables, or make a request to run other code (or send a request to a Chainlink node!) Basically, functions can be customized to do anything.

To define a function, we first type the “function” keyword, define a name for the function and add a pair of parentheses beside the name as such:

<Highlight class=""language-javascript"">
function addNumbers()
</Highlight>

After this is complete you can define **parameters** for the function. Parameters are the name and types of the arguments we can input into the function. They are variables that only that function can access. For this example, we will define two parameters: 

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2)
</Highlight>

Now we can add any modifiers to the function. In this case we’ll simply add public for now:

<Highlight class=""language-javascript"">
function addNumbers(uint num1,

:::NEXT DOC:::

#####Chapter 13:

# Conclusion

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

Congrats for making it this far! That’s a lot of Solidity concepts! The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions). In future courses, we will go into more detail on more complex variables such as storing structs within arrays and more special functions such as the constructor and events. And as always, you know the best way to learn is by doing! Feel free to go to https://remix.ethereum.org/, and just mess around with writing code there. It may feel overwhelming at first, but don’t worry it’s just to get a feel for what’s to come!


:::NEXT DOC:::

#####Chapter 1:

# Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Inspired by the power of smart contracts and blockchain, it’s time to dive in.
    </div>
  </div>
</ContentWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent. If you are familiar with some programming, it may help to know that Solidity is an **object-oriented programming language**. If you are not familiar with what that means, don’t worry, we’ll cover it in a future course.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!




:::NEXT DOC:::

the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor()

:::NEXT DOC:::

popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
       

:::NEXT DOC:::

#####Chapter 5:

# Contract State, Variables and Data Types

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now you want to connect your artwork to the physical (off-chain) world. Tell your artwork how to behave. 
    </div>
  </div>
</ContentWrapp> -->

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing **variables** and change data by defining logic in **functions**. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time. When defining a variable, you must give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
  

:::NEXT DOC:::

can be customized to do anything.

To define a function, we first type the “function” keyword, define a name for the function and add a pair of parentheses beside the name as such:

<Highlight class=""language-javascript"">
function addNumbers()
</Highlight>

After this is complete you can define **parameters** for the function. Parameters are the name and types of the arguments we can input into the function. They are variables that only that function can access. For this example, we will define two parameters: 

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2)
</Highlight>

Now we can add any modifiers to the function. In this case we’ll simply add public for now:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public
</Highlight>

Now we’ll define what the function returns. Remember a function doesn’t **have** to return anything. In this example we will add the parameters and return the result. Since we are adding two uints, the return value will also have to be a uint:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public returns (uint)
</Highlight>

Finally we’ll create the function body by typing a pair of curly braces and typing our function logic within them:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public returns (uint) {
 answer = num1 + num2;
 return answer;
}
</Highlight>

As you can see the function takes the two parameters, num1 and num2, sums them, stores the sum in a variable called answer, and then returns the value inside the variable answer.

So if

:::NEXT DOC:::

# Deploy Your First Smart Contract

  * Overview
  * Install and fund your MetaMask wallet
  * Write, compile, and deploy your first smart contract
  * Run functions in your contract

You can write your first smart contract and run it in your browser without any
knowledge about Ethereum or blockchains. This guide shows you how easy it is
to develop smart contracts using the [Solidity
language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io)
and the [Remix Development Environment](https://remix.ethereum.org/). You can
use all of these tools in your browser for free with no signup required.

Already know Solidity and have MetaMask configured?

If you are already familiar with how to deploy Smart Contracts and use
MetaMask, you can skip to the [Consuming Data Feeds](/getting-started/consuming-data-feeds) guide to learn how to connect your smart
contracts to Chainlink data feeds.

In general, you create and deploy your smart contracts operate using the
following process:

  1. **Write:** Write a contract to define how the contract functions, what data it can store, what other contracts it interacts with, and what external APIs it might call.

  2. **Compile:** Pass your smart contract code through a compiler to translate the contract into byte code that the blockchain can understand. For example, [Solidity](https://soliditylang.org) code must be compiled before it can run in the [Ethereum Virtual Machine](https://ethereum.org/en/developers/docs/evm/).

  3. **Deploy:** Send the compiled smart contract to the blockchain. From that point forward, the contract cannot be altered. However, you can still interact with the contract in several ways.

  4. **Run functions:** When you run the functions that you defined for the contract, the network processes those functions and modifies the state of your contract. For some functions, the network charges a small fee to complete the work. Your

:::NEXT DOC:::

smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines"
What are the two main smart contracts of Chainlink VRF?,The two main smart contracts of Chainlink VRF are the Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2).,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-4/course.md'},The two main smart contracts of Chainlink VRF are the Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2).,"directly pays the LINK
for the request, the cost is calculated during the request and not during the
callback when the randomness is fulfilled. Learn [how to estimate
costs](/vrf/v2/estimating-costs).

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF direct funding
request:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account): An externally owned account that has a private key and can control a smart contract. Transactions can be initiated only by EOAs.
  * Smart contract: A smart contract that does not have a private key and executes what it has been designed for as a decentralized application.

The Chainlink VRF v2 solution uses both off-chain and on-chain components:

  * [VRF v2 Wrapper (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2Wrapper.sol): A wrapper for the VRF Coordinator that provides an interface for consuming contracts.
  * [VRF v2 Coordinator (on-chain component)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFCoordinatorV2.sol): A contract designed to interact with the VRF service. It emits an event when a request for randomness is made, and then verifies the random number and proof of how it was generated by the VRF service.
  * VRF service (off-chain component): Listens for requests by subscribing to the VRF Coordinator event logs and calculates a random number based on the block hash and nonce. The VRF service then sends a transaction to the `VRFCoordinator` including the random number and a proof of how it was

:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription

:::NEXT DOC:::

#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is

:::NEXT DOC:::

judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                          

:::NEXT DOC:::

Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!


:::NEXT DOC:::

with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! 

:::NEXT DOC:::

how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation

:::NEXT DOC:::

                                       |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4                         |
| VRF Coordinator       | 0x41034678D6C633D8a95c75e1138A360a28bA15d1                         |
| 2 gwei Key Hash       | 0x08ba8f62ff6c40a58877a106147661db43bc58dabfb814793847a839aa03367f |
| 30 gwei Key Hash      | 0x72d2b016bb5b62912afea355ebf33b91319f828738b111b723b78696b9847b63 |
| 150 gwei Key Hash     | 0x68d24f9a037a649944964c2a1ebd0b2918f4a243d2a99701cc22b548cf2daff0 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                           

:::NEXT DOC:::

  |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x514910771AF9Ca656af840dff83E8264EcF986CA                         |
| VRF Coordinator       | 0x271682DEB8C4E0901D1a1550aD2e64D568E69909                         |
| 200 gwei Key Hash     | 0x8af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef |
| 500 gwei Key Hash     | 0xff8dedfbfa60af186cf3c830acbc32c05aae823045ae5ea7da1e45fbfaba4f92 |
| 1000 gwei Key Hash    | 0x9fe0eebf5e446e3c998ec9bb19951541aee00bb90ea201ae456421a2ded86805 |
| Premium               | 0.25 LINK                                                          |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                          

:::NEXT DOC:::

LINK Token            | 0x6F43FF82CCA38001B6699a8AC47A2d0E66939407                         |
| VRF Coordinator       | 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634                         |
| 4000 gwei Key Hash    | 0xb4797e686f9a1548b9a2e8c68988d74788e0c4af5899020fb0c47784af76ddfa |
| 10000 gwei Key Hash   | 0x5881eea62f9876043df723cf89f0c2bb6f950da25e9dfe66995c24f919c8f8ab |
| 20000 gwei Key Hash   | 0x64ae04e5dba58bc08ba2d53eb33fe95bf71f5002789692fe78fb3778f16121c9 |
| Premium               | 0.0005 LINK                                                        |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                   "
What is the purpose of the 'keyHash' parameter in Chainlink VRF?,The 'keyHash' parameter in Chainlink VRF functions as an ID of the off-chain VRF job that runs in response to requests.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-7/course.md'},The purpose of the 'keyHash' parameter in Chainlink VRF is to determine the gas lane to use for setting the ceiling limit of each request.,"#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed

:::NEXT DOC:::

understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.


:::NEXT DOC:::

increase the chances of an attacker cheating your application. Imagine you implemented a simple coin flip smart contract using VRF v2. In a bet function, you choose heads or tails and then request a random number. If you have selected heads (0) and the result of the VRF service meant that you would win the bet, it could try to withhold this answer and replace it with your second request if it’s more advantageous.

So you see, we must consider the unique properties of blockchains here to ensure randomness in our smart contracts. While the numbers are always random, we must also look into how our applications and smart contracts deal with them. In the end, it will be a matter of cost if it's worth attacking your application. You must also be aware of the protocol that you are using.

In general, re-organizations on chains are possible. A miner would take your request and try to create a new random number with a different block and do this until they find a block to their advantage. They cannot control the VRF output but can ""re-roll"" the dice. If they manage to produce a valid blockchain with this new block and the network accepts this block instead, they could effectively attack your application by controlling the random input.
While this is a possible attack, it's costly to attack a network like this, as in the proof of network. You need at least 51% of the network to drive such an attack. Depending on your application requirements, you consider a 20-block confirmation time highly secure. You can lower the block confirmation time depending on the value you are trying to protect. You must calculate an attacker's costs and potential reward to decide your confirmation time.


:::NEXT DOC:::

LINK Token            | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75                         |
| VRF Coordinator       | 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE                         |
| 200 gwei Key Hash     | 0x114f3da0a805b6a67d6e9cd2ec746f7028f1b7376365af575cfea3550dd1aa04 |
| 500 gwei Key Hash     | 0xba6e730de88d94a5510ae6613898bfb0c3de5d16e609c5b7da808747125506f7 |
| 1000 gwei Key Hash    | 0x17cd473250a9a479dc7f234c64332ed4bc8af9e8ded7556aa6e66d83da49f470 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                

:::NEXT DOC:::

with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! 

:::NEXT DOC:::

LINK Token            | 0x6F43FF82CCA38001B6699a8AC47A2d0E66939407                         |
| VRF Coordinator       | 0xd5D517aBE5cF79B7e95eC98dB0f0277788aFF634                         |
| 4000 gwei Key Hash    | 0xb4797e686f9a1548b9a2e8c68988d74788e0c4af5899020fb0c47784af76ddfa |
| 10000 gwei Key Hash   | 0x5881eea62f9876043df723cf89f0c2bb6f950da25e9dfe66995c24f919c8f8ab |
| 20000 gwei Key Hash   | 0x64ae04e5dba58bc08ba2d53eb33fe95bf71f5002789692fe78fb3778f16121c9 |
| Premium               | 0.0005 LINK                                                        |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                   

:::NEXT DOC:::

Question: (Asked on: 2022-03-09 20:02:05)
What is a gas lane in chainlink and blockchain?
URL: https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain

Question Body:


I do understand the concept of gas in the ethereum blockchain and why gas is
needed to compensate miners for providing computing power to the network.
However, when I was reading up on the chainlink vrf get a random number
documentation it says that the keyhash tells you the gas lane to use. It would
be really helpful if someone could further explain what a gas lane in
blockchain is.

Any help would be appreciated :)



Answers:
(Answered on: 2022-03-10 06:17:54)


So we know that Eth gas is always subject to change and with chainlink vrf
there will be random values with your request, so you need to set a limit to
how much to spend on each request. The reason chainlink uses a Gas lane is
because the lanes are important for setting the ceiling limit of each
request... think of it as your entry into the bet.





:::NEXT DOC:::

  |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0x514910771AF9Ca656af840dff83E8264EcF986CA                         |
| VRF Coordinator       | 0x271682DEB8C4E0901D1a1550aD2e64D568E69909                         |
| 200 gwei Key Hash     | 0x8af398995b04c28e9951adb9721ef74c74f93e6a478f39e7e0777be13527e7ef |
| 500 gwei Key Hash     | 0xff8dedfbfa60af186cf3c830acbc32c05aae823045ae5ea7da1e45fbfaba4f92 |
| 1000 gwei Key Hash    | 0x9fe0eebf5e446e3c998ec9bb19951541aee00bb90ea201ae456421a2ded86805 |
| Premium               | 0.25 LINK                                                          |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                          

:::NEXT DOC:::

                                       |
|:----------------------|:-------------------------------------------------------------------|
| LINK Token            | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4                         |
| VRF Coordinator       | 0x41034678D6C633D8a95c75e1138A360a28bA15d1                         |
| 2 gwei Key Hash       | 0x08ba8f62ff6c40a58877a106147661db43bc58dabfb814793847a839aa03367f |
| 30 gwei Key Hash      | 0x72d2b016bb5b62912afea355ebf33b91319f828738b111b723b78696b9847b63 |
| 150 gwei Key Hash     | 0x68d24f9a037a649944964c2a1ebd0b2918f4a243d2a99701cc22b548cf2daff0 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                           

:::NEXT DOC:::

LINK Token            | 0xd14838A68E8AFBAdE5efb411d5871ea0011AFd28                         |
| VRF Coordinator       | 0x6D80646bEAdd07cE68cab36c27c626790bBcf17f                         |
| 50 gwei Key Hash      | 0x83d1b6e3388bed3d76426974512bb0d270e9542a765cd667242ea26c0cc0b730 |
| Premium               | 0.005 LINK                                                         |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 1                                                                  |
| Maximum Confirmations | 200                                                               "
give me a sample solidity contract to use Chainlink price feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"The sample Solidity contract to use Chainlink price feeds is provided in the context information under the section ""Examine the sample contract"". The contract is named `PriceConsumerV3` and obtains the latest price answer from the BTC/USD feed on the Sepolia testnet. It uses the `AggregatorV3Interface` interface to define the function `latestRoundData()` for all v3 Aggregators. The contract can be modified to read any of the different types of data feeds.","# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
give me a sample solidity contract to use Chainlink VRF?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFD20 is VRFConsumerBaseV2 {

}
uint64 s_subscriptionId;
address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
uint32 callbackGasLimit = 40000;
uint16 requestConfirmations = 3;
uint32 numWords =  1;
)
(
give me a sample solidity contract to request data from a public API in a smart contract using chainlink?,
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req.add(
            ""get"",
            ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {""RAW"":
        //   {""ETH"":
        //    {""USD"":
        //     {
        //      ""VOLUME24HOUR"": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR""); // Chainlink nodes prior to 1.0.0 support this format
        req.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR""); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req.addInt(""times"", timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            ""Unable to transfer""
        );
    }
}",,Two sample Solidity contracts are provided in the context information for using Chainlink VRF: `VRFv2Consumer.sol` and `VRFv2DirectFundingConsumer.sol`.,"`VRFv2Consumer.sol` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Provider** environment, select the `VRFv2Consumer` contract from the contract list, and specify your `subscriptionId` so the constructor can set it.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must add this address as an approved consuming contract on your subscription account.

  6. Open the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/) and click the ID of your new subscription under the **My Subscriptions** list. The subscription details page opens.

  7. Under the **Consumers** section, click **Add consumer**.

  8. Enter the address of your consuming contract that you just deployed and click **Add consumer**. MetaMask opens and asks you to confirm the transaction.

Your example contract is deployed and approved to use your subscription
balance to pay for VRF v2 requests. Next, request random values from Chainlink
VRF.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF processes your request. Chainlink VRF fulfills the request and returns the random values to your contract in a callback to the `fulfillRandomWords()` function. At this point, a new key `requestId` is added to the mapping `s_requests`.

Depending on current testnet conditions, it might take a few minutes for the
callback to return the requested random values to your contract. You can see a
list of pending requests for your subscription ID at
[vrf.chain.link](https://vrf.chain.link/).

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated: The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` specifying the `requestId` to display the random words.

You deployed a simple contract that can request and receive random values from
Chainlink VRF. To see more advanced examples where the contract can complete
the entire process including subscription setup and management, see the
[Programmatic Subscription](/vrf/v2/subscription/examples/programmatic-subscription) page.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, your MetaMask wallet is the subscription owner and you
created a consuming contract to use that subscription. The consuming contract
uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that relies on a subscription for funding.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    import

:::NEXT DOC:::

in Remix, compile the `VRFv2DirectFundingConsumer` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Web3 Environment** and select the `VRFv2DirectFundingConsumer` contract from the contract list.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must fund your consuming contract with enough LINK tokens in order to request for randomness. Next, fund your contract.

## Fund Your Contract

Requests for randomness will fail unless your consuming contract has enough
LINK.

  1. [Acquire testnet LINK](/resources/acquire-link).
  2. [Fund your contract with testnet LINK](/resources/fund-your-contract). For this example, funding your contract with 2 LINK should be sufficient.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them, and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _400,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _400000_ and select **Save**.
Finally, confirm the transaction.

After you approve the transaction, Chainlink VRF processes your request.
Chainlink VRF fulfills the request and returns the random values to your
contract in a callback to the `fulfillRandomWords()` function. At this point,
a new key `requestId` is added to the mapping `s_requests`. Depending on
current testnet conditions, it might take a few minutes for the callback to
return the requested random values to your contract.

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated. The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` and specify the `requestId` to display the random words.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, the consuming contract uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import"
give me a sample solidity contract to use NFT Floor Price Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}",,"Here is a sample Solidity contract to use NFT Floor Price Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}
```","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) =

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
give me a sample solidity contract to use Proof of Reserve Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}",,"Here is a sample Solidity contract to use Proof of Reserve Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}
```","the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page

:::NEXT DOC:::

the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Give sample code for an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"Here is an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet:

```
import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    constructor() {
        priceFeed = AggregatorV3Interface(0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43);
    }

    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```","the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    from web3 import Web3
    
    # Change this to use your own RPC URL
    web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
    # AggregatorV3Interface ABI
    abi = '[{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""description"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint80"",""name"":""_roundId"",""type"":""uint80""}],""name"":""getRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""latestRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""version"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""}]'
    # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0 <0.8.0`, use
[OpenZeppelin's SafeMath

:::NEXT DOC:::

/*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct"
Give code examples to demonstrate how to deploy a consumer contract on-chain that reads a data feed and stores the value?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"The code examples for deploying a consumer contract on-chain that reads a data feed and stores the value are provided in the ""Reading data feeds on-chain"" section of the documentation. The examples are given in Solidity and Vyper languages. The Solidity example code imports the `AggregatorV3Interface` interface from the Chainlink contracts and defines a constructor that sets the address of the data feed to be read. The `getLatestPrice()` function is defined to return the latest price from the data feed.","# Code Examples

  * Overview
  * Reading data feeds on-chain
  * Solidity
  * Vyper
  * Reading data feeds off-chain
  * Javascript
  * Python
  * Golang
  * Getting a different price denomination
  * More Aggregator Functions

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same. To read a
feed, specify the following variables:

  * **RPC endpoint URL:** This determines which network that your smart contracts will run on. You can use a [node provider service](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) or point to your own [client](https://ethereum.org/en/developers/docs/nodes-and-clients/). If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the [Remix IDE](https://remix-project.org/) will automatically detect them for you.
  * **LINK token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
    

:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete"
Write code to show how to use web3.js to retrieve feed data from a price feed?,"/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
    name: ""getRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""latestRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""version"",
    outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
]
const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log(""Latest Round Data"", roundData)
  })",,"```
/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only

const web3 = new Web3(new Web3.providers.HttpProvider(""https://sepolia.infura.io/v3/YOUR-PROJECT-ID""))

const priceFeedABI = [{""inputs"":[],""name"":""latestAnswer"",""outputs"":[{""internalType"":""int256"",""name"":"""",""type"":""int256""}],""stateMutability"":""view"",""type"":""function""}]
const priceFeedAddress = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""

const priceFeedContract = new web3.eth.Contract(priceFeedABI, priceFeedAddress)

priceFeedContract.methods.latestAnswer().call((error, result) => {
  console.log(result)
})
```","On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
   "
What is the LINK token contract on ethereum mainnet?,0x514910771AF9Ca656af840dff83E8264EcF986CA,,"The LINK token contract on Ethereum mainnet has the address 0x514910771AF9Ca656af840dff83E8264EcF986CA, a name of Chainlink Token, a symbol of LINK, and 18 decimals.","# LINK Token Contracts

  * Overview
  * Ethereum
  * Ethereum Mainnet
  * Sepolia testnet
  * Goerli testnet
  * BNB Chain
  * BNB Chain mainnet
  * BNB Chain testnet
  * Polygon (Matic)
  * Polygon mainnet
  * Mumbai testnet
  * RSK
  * RSK mainnet
  * Gnosis Chain (xDai)
  * Gnosis Chain mainnet
  * Avalanche
  * Avalanche mainnet
  * Fuji testnet
  * Fantom
  * Fantom mainnet
  * Fantom testnet
  * Arbitrum
  * Arbitrum mainnet
  * Arbitrum Goerli testnet
  * Optimism
  * Optimism mainnet
  * Optimism Goerli testnet
  * Harmony
  * Harmony mainnet
  * Moonriver
  * Moonriver mainnet
  * Moonbeam
  * Moonbeam mainnet
  * Metis
  * Andromeda mainnet
  * BASE
  * BASE Goerli testnet

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=Contracts) to talk to an expert
about the networks that support the LINK token.

LINK tokens are used to pay node operators for retrieving data for smart
contracts and also for deposits placed by node operators as required by
contract creators. The smallest denomination of LINK is called a Juel, and
1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to
Wei, which is the [smallest denomination of
ETH](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations).

The LINK token is an ERC677 token that inherits functionality from the ERC20
token standard and allows token transfers to contain a data payload. Read more
about the [ERC677 transferAndCall token
standard](https://github.com/ethereum/EIPs/issues/677).

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

## Ethereum

### Ethereum Mainnet

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1                                          |
| Address        | 0x514910771AF9Ca656af840dff83E8264EcF986CA |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | ethstats.dev                               |
### Sepolia testnet

Testnet LINK and ETH are available at
[faucets.chain.link](https://faucets.chain.link/sepolia). Testnet ETH is also
available from several public

:::NEXT DOC:::

and
LINK from Ethereum Mainnet to Metis mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1088                                       |
| Address        | 0x79892E8A3Aea66C8F6893fa49eC6208ef07EC046 |
| Name           | Chainlink Token on Metis Mainnet           |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | andromeda-explorer.metis.io                |
## BASE

### BASE Goerli testnet

Testnet ETH is used to pay for transactions on BASE. Testnet ETH is available
from one of the [BASE Network Faucets](https://docs.base.org/tools/network-faucets). Alternatively, you can get testnet ETH from the faucets listed at
[faucetlink.to/goerli](https://faucetlink.to/goerli) and use the [BASE
Bridge](https://bridge.base.org/deposit) to transfer testnet ETH from Ethereum
Goerli to BASE Goerli.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 84531                                      |
| Address        | 0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3 |
| Name           | Chainlink Token on the BASE Goerli testnet |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | goerli.basescan.org                        |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/link-token-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the chainlink price feed address for 1INCH / ETH?,0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8,,The chainlink price feed address for 1INCH / ETH is 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8.,"        |
|:---------------------------------------|:---------------------------------------------------------|:---------------|:------------|:------------|------:|:-------------------------------------------|
| 🟢1INCH / ETH                          | 1inch                                                    | Crypto         | 2%          | 86400s      |    18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8 |
| 🟢1INCH / USD                          | 1inch                                                    | Crypto         | 1%          | 86400s      |     8 | 0xc929ad75B72593967DE83E7F7Cda0493458261D9 |
| 🟢AAPL / USD                           | Apple                                                    | Equities       | 0.5%        | 86400s      |     8 | 0x139C8512Cde1778e9b9a8e721ce1aEbd4dD43587 |
| 🟢AAVE / ETH                           | Aave                                                     | Crypto         | 2%          | 86400s      |    18 | 0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012 |
| 🟢AAVE / USD                           | Aave                                                     | Crypto         | 1%          | 3600s       |     8 | 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 |
| 🟢ADA / USD                            | Cardano                                                  | Crypto         | 1%          | 86400s      |     8 | 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55 |
| 🟢ADX / USD                

:::NEXT DOC:::

                              | Crypto         | 1%          | 86400s      |     8 | 0x10a43289895eAff840E8d45995BBa89f9115ECEe |
| 🟢ERN / USD                            | Ethernity Chain                                          | Crypto         | 2%          | 86400s      |     8 | 0x0a87e12689374A4EF49729582B474a1013cceBf8 |
| 🟢ETH / BTC                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0xAc559F25B1619171CbC396a50854A3240b6A4e99 |
| 🟢ETH / USD                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 |
| 🟢EUR / USD                            | Euro                                                     | Forex          | 0.15%       | 86400s      |     8 | 0xb49f677943BC038e9857d61E7d053CaA2C1734C1 |
| 🟢EURT / USD                           | Tether Euro                                              | Crypto         | 2%          | 86400s      |     8 | 0x01D391A48f4F7339aC64CA2c83a07C22F95F587a |
| 🟢FARM / ETH                           | Harvest Finance                                          | Crypto         | 2%          | 86400s      |    18 |"
What is the proof of reserve address for CacheGold PoR USD on Goerli Testnet?,Not provided in the context,,There is no information provided about the proof of reserve address for CacheGold PoR USD on Goerli Testnet.,"                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES        

:::NEXT DOC:::

Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                        "
What is the rate and Volatility Feed Address for 30-Day ETH APR?,0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29,,The rate and volatility feed address for 30-Day ETH APR is 0x8e604308BD61d975bc6aE7903747785Db7dE97e2.,"# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is

:::NEXT DOC:::

nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2 |
| ETH-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 | 0xd599cEF88Bbd27F1392A544bD0F343ec8893124C |
| LINK-USD 7-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x03121C1a9e6b88f56b27aF5cc065ee1FaF3CB4A9 |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net?,0x352f2Bc3039429fC2fe62004a1575aE74001CfcE,,The NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net is 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE.,"  |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
|

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |"
