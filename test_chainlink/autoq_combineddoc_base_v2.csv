question,answer,metadata,result,retrieved_docs
Why does calling an external API in chainlink not cause inconsistency?,"Because oracle responses are stored on-chain. Instead of fetching external data during the validation process, Chainlink oracle network places the data on-chain in a transaction. This ensures that all nodes go through the same validation process and reach a consensus. Having an oracle system built into a blockchain is not possible.",{'source': 'https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency'},"Calling an external API in Chainlink does not cause inconsistency because the oracle responses are stored on-chain. The Chainlink oracle network places the data on-chain in a transaction, and then it goes through the same validation process as every other transaction. This ensures that all nodes have access to the same data and can reach a consensus. Additionally, using multiple Chainlink nodes and different data sources can further verify the correctness of the data.","Question: (Asked on: 2021-11-26 22:39:12)
Why does calling an external API in chainlink not cause inconsistency?
URL: https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency

Question Body:


Suppose I have a smart contract that uses Chainlink's ""Call Any External API""
capability to get some data from an external URL. My understanding is that
each Ethereum full node runs each smart contract to verify the status; it does
so to verify the latest block. But what if, between the time one full node
runs the contract and another one does, the data returned by calling tha
external API changes. Then it would seem that different full nodes would get
different results for that smart contract, resulting in inconsistent states.
Why does that not happen?



Answers:
(Answered on: 2021-12-10 18:05:16)


Because oracle responses are stored on-chain.

You are right, if fetching external data was part of the validation process,
no nodes would be able to reach a consensus. So instead, a Chainlink oracle
network places the data on-chain in a transaction, and then it goes through
the same validation process as every other transaction.

You can read more about how Chainlink's [Basic Request
Model](https://docs.chain.link/docs/architecture-request-model/) looks, but
this is basically the reason why having an oracle system built into a
blockchain is impossible.





:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.



"
How do I install dependencies for Yarn?,"To install dependencies for Yarn, you can use the command 'yarn install' in the main node's folder.",{'source': 'https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn'},"To install dependencies for Yarn, you can run the command ""yarn install"" in the main node's folder. Additionally, if you encounter errors related to locked yarn packages, you can try running ""yarn install"" before proceeding with the installation steps.","Question: (Asked on: 2021-11-30 19:30:53)
How do I install dependencies for Yarn?
URL: https://stackoverflow.com/questions/70175011/how-do-i-install-dependencies-for-yarn

Question Body:


trying to install yarn for my chainlink node. This is the error I'm getting.
Any thoughts?

    
    
    node -e ""if(process.env.npm_execpath.indexOf('yarn') === -1) throw new Error('Please use yarn to install dependencies\n\n')""
    



Answers:
(Answered on: 2021-12-01 16:51:27)


Did you try

    
    
    yarn install
    

in the main node's folder?





:::NEXT DOC:::

Question: (Asked on: 2021-11-24 16:18:20)
Chainlink Node step 5. Build and Install: getting error code 137 for yarn
URL: https://stackoverflow.com/questions/70099478/chainlink-node-step-5-build-and-install-getting-error-code-137-for-yarn

Question Body:


I am trying to run a [chainlink node from
source](https://github.com/smartcontractkit/chainlink#install) and am
following the install instructions.

I'm currently running `make install`

It looks like the error code says there is not enough memory on my machine,
but my linux container on my chrome duet has 50GB. I don't know the problem. I
ran the command:

These are the errors

    
    
    error Command failed with exit code 137.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 137.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
     | `yarn setup` failed with exit code 137
    Stopping 2 active children
    Aborted execution due to previous error
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    error Command failed with exit code 1.
    info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
    

What do I do?



Answers:
(Answered on: 2021-11-24 21:02:02)


Per the
[documentation](https://github.com/smartcontractkit/chainlink#install):

> If you got any errors regarding locked yarn package, try running yarn
> install before this step

So run `yarn install`



"
How can I change the price feed token from ETH/USD to BUSD/USD using the Chainlink oracle?,"If you are trying to get BUSD/USD via a price feed on Kovan testnet, it is not available on that specific network. It is available on Ethereum mainnet however. If you are testing using the price feed, you can always use a mock contract to mock the behavior of the feeds for testing purposes only.",{'source': 'https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin'},"If you are trying to get BUSD/USD via a price feed on Kovan testnet, it is not available on that specific network. It is available on Ethereum mainnet however. If you are testing using the price feed, you can always use a mock contract to mock the behavior of the feeds for testing purposes only.","Question: (Asked on: 2021-09-23 11:16:52)
how do i change the price feed token from eth /usd to busd/usd with the chainlink oracle?
URL: https://stackoverflow.com/questions/69298977/how-do-i-change-the-price-feed-token-from-eth-usd-to-busd-usd-with-the-chainlin

Question Body:


I am trying to get the price feed for BUSD/USD using the chainlink pricefeed
oracle but it tells me that the code was reverted. this is also happening when
i switch to any other token, i am using the kovan test net

this is the error i get

> call to PriceConsumerV3.getLatestPrice call to
> PriceConsumerV3.getLatestPrice errored: VM execution error. Reverted 0x

and this is my code

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.6.7;
    
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
    
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Kovan
         * Aggregator: ETH/USD
         * Address: 0x9326BFA02ADD2366b30bacB125260Af641031331
         */
        constructor() public {
            priceFeed = AggregatorV3Interface(0xcBb98864Ef56E9042e7d2efef76141f15731B82f);
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            (
                uint80 roundID, 
                int price,
                uint startedAt,
                uint timeStamp,
                uint80 answeredInRound
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    



Answers:
(Answered on: 2021-09-27 03:10:51)


If you are trying to get BUSD/USD via a price feed on Kovan testnet, [it is
not available on that specific network](https://docs.chain.link/docs/ethereum-
addresses/#Kovan%20Testnet). It is [available on Ethereum
mainnet](https://docs.chain.link/docs/ethereum-addresses/#Ethereum%20Mainnet)
however.

If you are testing using the price feed, you can always use a mock contract to
mock the behavior of the feeds for testing purposes only.


---
(Answered on: 2021-09-23 22:11:12)


You have set incorrect ChainLink address!

correct ETH/USD address: `0x9326BFA02ADD2366b30bacB125260Af641031331`

Address you are using in on BSC network, not Kovan network!





:::NEXT DOC:::

           (,int256 answer,,,)=priceFeed.latestRoundData();
            return uint256(answer * 10000000000);
        }
        //10000000000 = Gwei which is why we added 10 zeros to getPrice(answer) to convert it to Wei amount
        function getConversionRate(uint256 ethAmount) public view returns (uint256){
            uint256 ethPrice = getPrice();
            uint256 ethAmountInUsd = (ethPrice * ethAmount)/ 1000000000000000000; //divide 2x because we added 10*((getPrice)answer))
            return ethAmountInUsd;
        }
    }
    



Answers:
(Answered on: 2023-01-31 03:09:55)


  * Aggregator contract address ""0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"" belongs to [mainnet](https://data.chain.link/ethereum/mainnet/crypto-usd/eth-usd)

[From here](https://docs.chain.link/data-feeds/price-feeds/addresses/) get the
`ETH/USD` goerli testnet address:""0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e""

  * Now in order to call chainlink oracle you have to have `LINK` token in your contract. Get some link token to your conract address [from the faucet](https://faucets.chain.link/)

  * Import the token in metamask. you will see the amount

  * send link token from your metamask to your contract

  * deploy your contract. if you are using `Remix IDE` chose the `injected provider` to connect to metamask. Because chainlink contract is on goerli, so you need to be on Goerli testnet. Once deployment goes through you can call the `fund` function.

  * Since the `fund` function has no argument, you need to send the value alongside the transaction. That is why inside the function you have `msg.value` to access to the sent amount.

  * In `Remix` ide, under ""GAS LIMIT`input there is`VALUE`input. you need to pass the amount in there before you call the`fund` function.



"
Why are no job runs appearing on my local Chainlink node when trying to fulfill requests?,"There are a couple of possible reasons why no job runs are appearing on your local Chainlink node. First, make sure that the external job id in the Jobs screen on the Operator UI does not contain dashes. If it does, remove the dashes when using it in the ATestnetConsumer contract. Additionally, the direct request toml may not work as is. Try appending 'allowunrestrictednetworkaccess=""true""' to the fetch section in the toml file.",{'source': 'https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally'},"There could be multiple reasons why no job runs are appearing on a local Chainlink node when trying to fulfill requests. However, based on the provided context information, two possible reasons are:

1. The external job id in the Jobs screen on the Operator UI has dashes in them. To use them in the ATestnetConsumer contract, the dashes need to be removed.

2. The direct request toml doesn't seem to work as is. It may require appending allowunrestrictednetworkaccess=""true"" to the fetch section.","Question: (Asked on: 2022-05-11 08:55:38)
No job show up in Runs page while trying to run a Chainlink node locally
URL: https://stackoverflow.com/questions/72198157/no-job-show-up-in-runs-page-while-trying-to-run-a-chainlink-node-locally

Question Body:


I am trying to fulfil requests on my local test chainlink node on rinkeby
(following <https://docs.chain.link/docs/fulfilling-requests/>) but can't see
any job runs appear on my operator ui.

The Oracle contract is at
[0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C](https://rinkeby.etherscan.io/address/0xA66f738a4688A9E51c2c6FF901CC3B11ce31AE6C)

The ATestnetConsumer contract is at
[0x977129EE2f404F4327A2A60C5fD9E57890D85FD0](https://rinkeby.etherscan.io/address/0x977129ee2f404f4327a2a60c5fd9e57890d85fd0)

My job toml screenshot below [](https://i.stack.imgur.com/uabGd.png)

Have confirmed my .env that it is running the rinkeby wss url from infura and
the chain is 4 and the link token contract address is
0x01BE23585060835E02B77ef475b0Cc51aA1e0709

My node wallet has ETH and LINK. Both the contracts have Link too (but no
ETH).

I run the setFulfillmentPermission function in remix with my Node wallet
address and true

[](https://i.stack.imgur.com/tqQGo.png)

When I execute the requestEthereumPrice function with my oracle address and
job id, I can see the LINK being sent by the [ATestnetConsumer contract to the
Oracle
contract](https://rinkeby.etherscan.io/tx/0xd1b71dd8ec83b7e204de5d2d0a95fdde2be41d0eadb181231ee21596ef661f78)
but no job run gets created in my local Chainlink node.

[](https://i.stack.imgur.com/wK7ha.png)

Confirming that the job hasn't run, I get the 0 value when I run the
currentPrice function on ATestnetConsumer.

Can anyone please point me to where I am going wrong? Thanks in advance!



Answers:
(Answered on: 2022-05-11 12:13:48)


Finally got it to work. Posting my two findings as I do think the
documentation needs an update to account for these.

  1. The external job id in the Jobs screen on the Operator UI has dashes in them. To use them in the ATestnetConsumer contract you need to remove the dashes (so 0e84f38985eb4edb98c2e2a09b589666 and not 0e84f389-85eb-4edb-98c2-e2a09b589666).

  2. The direct request toml doesn't seem to work as is. I had to append allowunrestrictednetworkaccess=""true"" to the fetch section so it becomes

fetch [type=""http"" method=GET url=""$(decode_cbor.get)""
allowunrestrictednetworkaccess=""true""]





:::NEXT DOC:::

Question: (Asked on: 2021-10-26 10:19:03)
following chainlink fulfilling-requests doc doesn&#39;t work
URL: https://stackoverflow.com/questions/69721319/following-chainlink-fulfilling-requests-doc-doesnt-work

Question Body:


We had setup the chainlink node on gcp and following
<https://docs.chain.link/docs/fulfilling-requests/>. The job is not fulfilled
and the currentprice property always returns 0.

Oracle:
[https://remix.ethereum.org/#url=https://docs.chain.link/samples/NodeOperators/Oracle.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.6.6+commit.6c089d02.js](https://remix.ethereum.org/#url=https://docs.chain.link/samples/NodeOperators/Oracle.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.6.6+commit.6c089d02.js)
Consumer:
[https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js)

Thanks



Answers:
(Answered on: 2021-10-28 06:48:56)


Generally, When we create new job on node it assign externalJobId to job which
is like '07269a61-586c-4831-bc26-7d2b581fbd1c'. But when you call function in
consumer contract you have to provide this externalJobId in function without
dashes so it will be like '07269a61586c4831bc267d2b581fbd1c'. This is not
mentioned in chainlink docs in noticeable way

<https://docs.chain.link/docs/fulfilling-requests/>

[](https://i.stack.imgur.com/1EwZr.png)



"
Is it possible for Chainlink VRF to return two same randomnesses in one request?,Chainlink VRF generates one or more random values and cryptographic proof for each request. It is unlikely for Chainlink VRF to return the same randomness in one request.,{'source': 'https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request'},"According to the answer provided in the first question, it is unlikely for Chainlink VRF to return the same randomness in one request.","Question: (Asked on: 2023-01-19 03:22:56)
Possible Chainlink VRF returns two same randomnesses in one request?
URL: https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request

Question Body:


as the title, i am thinking if it's possible that Chainlink VRF returns two
same randomnesses in one request? As of ""random"", i assume the answer is YES.
Thanks.



Answers:
(Answered on: 2023-01-19 08:57:48)


For each request, Chainlink VRF generates one or more random values and
cryptographic proof of how those values were determined. It is unlikely that a
Chainlink VRF would return the same randomness in one request.





:::NEXT DOC:::

Question: (Asked on: 2021-10-05 09:57:27)
Retrieve the random number generated by Chainlink VRF in 1 transaction
URL: https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction

Question Body:


I am trying to get a random number in solidity in 1 transaction with Chainlink
VRF.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    contract RandomNumberConsumer is VRFConsumerBase {
        
        bytes32 internal keyHash;
        uint256 internal fee;
        
        uint256 internal randomResult;
        
        constructor() 
            VRFConsumerBase(
                0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, // VRF Coordinator
                0xa36085F69e2889c224210F603D836748e7dC0088  // LINK Token
            )
        {
            keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
        }
        function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
        function letsGo() public {
            bytes32 requestId;
            requestId = getRandomNumber();
            fulfillRandomness(requestId, 123456);
        }
    }
    

Is there a way in blockchain to get the randomResult?

I'm looking specifically at my `letsGo` function.



Answers:
(Answered on: 2021-10-07 12:29:29)


The chainlink VRF is a 2 transaction process.

The first transaction requests the random number, and the second to have the
random number returned. You can't get the random number in 1 go.

You can read more about the [basic request
model](https://docs.chain.link/docs/architecture-request-model/) in the
documentation.

You're `letsgo` function will not work.



"
How can I ensure that `performUpkeep` is not called again before it finishes performing work?,"In the given scenario, there is no waiting or asynchronous behavior in the EVM. One suggestion is to use the `block.number` to create an additional entry condition. This can be done by adding a requirement in the `checkUpkeep` function that checks if the current block number is greater than or equal to the last upkeep block number plus a certain value. Another option is to use OpenZeppelin's `nonReentrant` modifier to prevent reentrancy issues. These approaches can help ensure that `performUpkeep` is not called again before it finishes performing work.",{'source': 'https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per'},"One suggestion given in the answers is to use the `nonReentrant` modifier from OpenZeppelin's security library. Another suggestion is to use the `block.number` to create an additional entry condition in the `checkUpkeep` function, which would prevent `performUpkeep` from being called again before it finishes performing work.","Question: (Asked on: 2021-11-04 03:31:44)
Is there a way to ensure performUpkeep isn&#39;t called again before it finishes performing work?
URL: https://stackoverflow.com/questions/69834250/is-there-a-way-to-ensure-performupkeep-isnt-called-again-before-it-finishes-per

Question Body:


I have a keeper that calls checkUpkeep and it returns true, however in
performUpkeep, the condition that would cause checkUpkeep to return false is
not set until data is returned from offchain (this is bc I want to make sure
that if for some reason that fails, the checkUpkeep will return true again to
retry)

How would I handle this so that checkUpkeep is not called again while data is
being retrieved triggering a second performUpkeep?

ex:

    
    
      function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
        requestVolumeData(); // latestDateChecked is updated once requestVolumeData successfully receives data offchain and calls fulfill function
      }
    



Answers:
(Answered on: 2021-11-09 18:59:39)


I am not sure if what you are concerned about is possible.

In the EVM a transaction either succeeds or fails. There is no waiting or
async. Or maybe there's some chainlink magic (involving transactions that do
not occur in the same block) happening that I have not learned about yet.

My suggestion: use blocknumber (block.number) to create an aditional entry
condition. That's what I'm using for a keeper to call a function approx. once
a day.

    
    
        function checkUpkeep(bytes calldata checkData)
        external
        view
        returns (bool upkeepNeeded, bytes memory performData)
      {
        require(revealed);
        require(round < 7);
        **require(block.number >= lastUpkeepBlock + 10 )** //if you can afford artificial constraint
    
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
        
        **uint lastUpkeepBlock = block.number;**
        
      }
    
      function performUpkeep(bytes calldata /*

:::NEXT DOC:::

>= lastUpkeepBlock + 10 )** //if you can afford artificial constraint
    
        uint32 secondsInDay = 86_400;
    
        _getDateBeforeTimestamp(block.timestamp) >= latestDateChecked + secondsInDay
            ? upkeepNeeded = true
            : upkeepNeeded = false;
        performData = checkData;
        
        **uint lastUpkeepBlock = block.number;**
        
      }
    
      function performUpkeep(bytes calldata /* performData */) external {
        requestVolumeData(); // latestDateChecked is updated once requestVolumeData successfully receives data offchain and calls fulfill function
      }
    

or OpenZeppelin's
[nonReentrant](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard)
modifier.

Related Concepts: [Reentrancy](https://swcregistry.io/docs/SWC-107) [Race
condition](https://swcregistry.io/docs/SWC-114)



"
Why is the value of volume always returning 0 in the Chainlink example?,"The value of volume is always returning 0 in the Chainlink example because there is an error in the code. The line `request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");` should be `request.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR"");` (notice the commas instead of dots). Chainlink nodes 1.0.0 and later support this new ""comma based"" format. Chainlink nodes prior to 1.0.0 support the ""dots based"" format. The official docs have been updated to include this change.",{'source': 'https://stackoverflow.com/questions/71619589/chainlink-example-not-updating-value'},"The reason why the value of volume is always returning 0 in the Chainlink example is not clear, but it could be due to an issue with the Chainlink node failing to write the result back to the contract. The asker has tried different oracle addresses and job IDs, and the smart contract seems to be working perfectly. It is suggested to check if the Chainlink node is funded and if it has permission to call the function `fulfillOracleRequest2` in the contract operator.","Question: (Asked on: 2022-03-25 15:38:20)
Chainlink example not updating value
URL: https://stackoverflow.com/questions/71619589/chainlink-example-not-updating-value

Question Body:


I'm following the example within the [Chainlink
documentation](https://docs.chain.link/docs/advanced-tutorial/) (also below),
and have been testing it within remix. I've deployed the contract on the kovan
testnet & sent LINK to it, I'm able to execute the requestVolumeData() and get
the notification that the transaction was completed and I'm able to view it on
etherscan.

However, when checking the value of volume it always returns 0. I'm aware that
it can take some time, but the value hasn't changed after waiting 20 minutes.

I've done tests with the following oracle addresses / job id's. From the
example (0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8 &
d5270d1c311941d0b08bead21fea7747) From the accompanying youtube video
(0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e &
29fa9aa13bf1468788b7cc4a500a45b8) And from
[chainlink](https://market.link/jobs/8b2792ab-24a3-4ed7-b7f4-f56f44828d9b)
market (set to kovan network). (0xA1d76ABD287d87d6E1d92262F7D53Cbe4f290505 &
fc3ea215bb9e44e088107b29bb495e2d)

I'm not sure where things go wrong, I don't think it's the code since it's
copy pasted from the example. But non of the adreses have worked.

    
    
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public volume;
    
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        constructor() {
            setPublicChainlinkToken();
            oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
            jobId = ""d5270d1c311941d0b08bead21fea7747"";
            fee = 0.1 * 10 ** 18;
        }
        
        function requestVolumeData() public returns (bytes32 requestId) {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");        
            request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");
            int timesAmount = 10**18;
           

:::NEXT DOC:::

tried changing all the parameters and both the API and chainlink node
accurate update and reflect the correct input. The smart contract seems to
work perfectly, it's just that calling volume in the code always returns 0 and
I've got no clue what the issue is.



Answers:
(Answered on: 2022-11-11 06:51:31)


According to your description, Chainlink node received your request and run
the job successfully, but failed to write the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.



"
Why does Chainlink VRF take a long time to get random numbers?,"Chainlink VRF follows a request and receive cycle to get a random number, which involves two transactions: the requesting transaction and the response transaction. This is necessary to look outside the blockchain and ensure randomness. The speed at which the random number is returned depends on the block time of the blockchain being used. For Ethereum, the fastest time possible is 2 times the block time, which is around 30 seconds. On faster chains like Polygon, the time is significantly lower.",{'source': 'https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers'},"Chainlink VRF takes a long time to get random numbers because it follows a request and receive cycle, which involves looking outside the blockchain to get a response. This means that two transactions take place, the requesting transaction and the response transaction, and the speed at which the random number is returned is dictated by the block time of the blockchain being used. On Ethereum, the fastest time possible for a random number to be returned is 2 * block time, or about 30ish seconds, while on faster chains like Polygon, this is drastically lower. Additionally, there may be downtime issues with specific testnets, such as Rinkeby, which can affect the speed of Chainlink VRF responses.","Question: (Asked on: 2021-06-23 23:02:20)
Chain Link VRF takes a long time to get random numbers
URL: https://stackoverflow.com/questions/68107865/chain-link-vrf-takes-a-long-time-to-get-random-numbers

Question Body:


**Description**

Getting a random number takes a really long time. After executing the
getRandomNumber function, a few minutes go by before I can interact with my
random number.

Basically I click getRandomNumber and have to wait 2-3 minutes until the
random number shows up in the randomResult variable.

**Steps to Reproduce**

  1. Head over to the documentation here : <https://docs.chain.link/docs/get-a-random-number/>
  2. Scroll down and click on ""Deploy this contract using Remix"" (blue outline btn)
  3. Click on one of the folders that looks like 536123b61468ad4442cfc4278e8de577 then RandomNumberConsumer.sol
  4. Replace the LINK Token, VRF Coordinator, and Key Hash to be unique to rinkeby <https://docs.chain.link/docs/vrf-contracts/>
  5. Navigation to the Solidity Compiler Tab and click on Compile RandomNumber.sol.
  6. Deploy the contract on Rinkeby
  7. Copy to contract address and send LINK token to fund the contract.
  8. Click on the orange getRandomNumber btn in remix
  9. Click on randomResult and observe how long it takes for the value in randomResult to change. (Keep clicking until it finally changes)

**Additional Information**

I am not sure if this behavior is intentional or if I need to change up the
code. Ideally I would like to have the value of randomResult once the
getRandomNumber function finishes executing. Right now I don't know when the
value of randomResult will show up.



Answers:
(Answered on: 2021-06-23 23:24:42)


Chainlink VRF follows the [request and
receive](https://docs.chain.link/docs/intermediates-tutorial/#1-request--
receive) cycle of getting a number. This means, it has to look outside the
blockchain to get a response.

So, 2 transactions actually take place:

  1. Your requesting transaction
  2. The response transaction

This is necessary to look outside the blockchain like this, otherwise you'll
get a deterministic number as opposed to random. The speed at which the random
number is returned, is dictated by the block time of the blockchain you're
using.

So for Ethereum, the fastest time possible for a Random Number to be returned
is 2 * block time, or about 30ish seconds.

On faster chains like polygon, this is drastically lower.





:::NEXT DOC:::

Question: (Asked on: 2022-01-14 13:25:29)
Chainlink VRF very slow - 20+ minutes for response to fulfillRandomness on Rinkeby
URL: https://stackoverflow.com/questions/70711267/chainlink-vrf-very-slow-20-minutes-for-response-to-fulfillrandomness-on-rinke

Question Body:


I have implemented a basic Chainlink VRF function in Solidity and deployed to
Ethereum test network Rinkeby

    
    
      function getRandomNumber() public returns (bytes32 requestId)
      {
        require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK"");
        return requestRandomness(keyHash, fee);
      }
    
      function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override 
      {
        randomResult = randomness;
        _requestId = requestId;
      }
    

This works fine, deducts the LINK fee from my wallet, and eeeeeventually does
call back `fulfillRandomness` with a random hex value, however it takes
forever!

Just did a test and it took 30 minutes. Could I be doing something wrong or
why is it taking so long? I know it's async and there's lots of stuff going on
to fetch the random number, but at these speeds it's basically unusable right



Answers:
(Answered on: 2022-01-17 16:19:42)


I switched to Kovan and I'm reliably getting ~1 min VRF responses


---
(Answered on: 2022-01-17 01:21:45)


The Rinkeby testenet has had some downtime issues this weekend. You can use
the Kovan testnet and VRF until Rinkeby is operating normally again.



"
How can I make my Chainlink node wait longer for a response from an external adapter?,You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by referring to the documentation for Chainlink nodes configuration at https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout.,{'source': 'https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response'},You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration.,"Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

Question: (Asked on: 2022-05-27 03:56:23)
Chainlink node can&#39;t make requests to Chainlink external adapter (on localhost)
URL: https://stackoverflow.com/questions/72400311/chainlink-node-cant-make-requests-to-chainlink-external-adapter-on-localhost

Question Body:


I have a chainlink Node which is running on port 6688. I'm running it with
docker, with the following command:

    
    
    cd ~/.chainlink-rinkeby && docker run -p 6688:6688  \
    -v ~/.chainlink-rinkeby:/chainlink  \
    -it --env-file=.env \
     smartcontract/chainlink:1.4.0-root local n -p /chainlink/.password -a /chainlink/.api
    

And I have an external adapter running on port 8080.

If I request it `{ ""id"": 0, ""data"":{ ""columns"": [""blood"",""heath""],
""linesAmount"":500 } }` it returns me a correct payload, in the format that is
expected from the external adapter:

    
    
    {
        ""jobRunID"": 0,
        ""data"": {
            ""ipfsHash"": ""anIpfshashShouldBeHere"",
            ""providers"": [
                ""0x03996eF07f84fEEe9f1dc18B255A8c01A4986701""
            ],
            ""result"": ""anIpfshashShouldBeHere""
        },
        ""result"": ""anIpfshashShouldBeHere"",
        ""statusCode"": 200
    }
    

The problem is, in the chainlink node, specifically in the `fetch` method it
gives me an error: `error making http request: Post ""http://localhost:8080"":
dial tcp 127.0.0.1:8080: connect: connection refused`

Is it related to the docker container? I don't see why it wouldn't be able to
request resuources from another port in the same machine. Am I missing some
configuration maybe? From what I've read from the docs it's possible to run
the adapter locally. Below, a picture with more information:

[](https://i.stack.imgur.com/MnUK7.png)



Answers:
(Answered on: 2022-05-27 07:43:44)


If you're External Adapter (EA) is running on `http://localhost:8080` and
you're trying to reach that EA from a Chainlink node running inside Docker,
then you can't use `localhost`, you need to get out of the Docker container
and onto the host running the Docker engine (your Windows or Mac machine).

To do, so define your bridge to use `http://host.docker.internal:8080`.

Further details can be found in the [Docker
Docs](https://docs.docker.com/desktop/windows/networking/).



"
How can I make my Chainlink node wait longer for a response from an external adapter?,You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration. This can be done by referring to the documentation for Chainlink nodes configuration at https://docs.chain.link/chainlink-nodes/v1/configuration#default_http_timeout.,{'source': 'https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response'},You can try increasing the DEFAULT_HTTP_TIMEOUT setting in your node's configuration.,"Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

Question: (Asked on: 2022-05-27 03:56:23)
Chainlink node can&#39;t make requests to Chainlink external adapter (on localhost)
URL: https://stackoverflow.com/questions/72400311/chainlink-node-cant-make-requests-to-chainlink-external-adapter-on-localhost

Question Body:


I have a chainlink Node which is running on port 6688. I'm running it with
docker, with the following command:

    
    
    cd ~/.chainlink-rinkeby && docker run -p 6688:6688  \
    -v ~/.chainlink-rinkeby:/chainlink  \
    -it --env-file=.env \
     smartcontract/chainlink:1.4.0-root local n -p /chainlink/.password -a /chainlink/.api
    

And I have an external adapter running on port 8080.

If I request it `{ ""id"": 0, ""data"":{ ""columns"": [""blood"",""heath""],
""linesAmount"":500 } }` it returns me a correct payload, in the format that is
expected from the external adapter:

    
    
    {
        ""jobRunID"": 0,
        ""data"": {
            ""ipfsHash"": ""anIpfshashShouldBeHere"",
            ""providers"": [
                ""0x03996eF07f84fEEe9f1dc18B255A8c01A4986701""
            ],
            ""result"": ""anIpfshashShouldBeHere""
        },
        ""result"": ""anIpfshashShouldBeHere"",
        ""statusCode"": 200
    }
    

The problem is, in the chainlink node, specifically in the `fetch` method it
gives me an error: `error making http request: Post ""http://localhost:8080"":
dial tcp 127.0.0.1:8080: connect: connection refused`

Is it related to the docker container? I don't see why it wouldn't be able to
request resuources from another port in the same machine. Am I missing some
configuration maybe? From what I've read from the docs it's possible to run
the adapter locally. Below, a picture with more information:

[](https://i.stack.imgur.com/MnUK7.png)



Answers:
(Answered on: 2022-05-27 07:43:44)


If you're External Adapter (EA) is running on `http://localhost:8080` and
you're trying to reach that EA from a Chainlink node running inside Docker,
then you can't use `localhost`, you need to get out of the Docker container
and onto the host running the Docker engine (your Windows or Mac machine).

To do, so define your bridge to use `http://host.docker.internal:8080`.

Further details can be found in the [Docker
Docs](https://docs.docker.com/desktop/windows/networking/).



"
Why am I unable to create external initiators from the Chainlink CLI?,"To create external initiators from the Chainlink CLI, you need to ensure that the `FEATURE_EXTERNAL_INITIATORS` environment variable is set to true in your .env file. Once this variable is set, you will have access to the `initiators` command in the Chainlink CLI and can proceed with the instructions.",{'source': 'https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli'},"You are unable to create external initiators from the Chainlink CLI because the `initiators` command is not available in the CLI options. This is likely because the `FEATURE_EXTERNAL_INITIATORS` environment variable is not set to true in your .env file, which enables access to the `initiators` command.","Question: (Asked on: 2021-09-22 09:33:38)
Can&#39;t create external initiators from chainlink CLI
URL: https://stackoverflow.com/questions/69281625/cant-create-external-initiators-from-chainlink-cli

Question Body:


We're trying to set external initiators to our chainlink containers deployed
in GKE cluster according to the docs: <https://docs.chain.link/docs/external-
initiators-in-nodes/>

I log into the the pod:

`kubectl exec -it -n chainlink chainlink-75dd5b6bdf-b4kwr -- /bin/bash`

And there I attempt to create external initiators:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink initiators create xxx xxx
    No help topic for 'initiators'
    

I don’t even see initiators in chainlink cli options:

    
    
    root@chainlink-75dd5b6bdf-b4kwr:/home/root# chainlink
    NAME:
       chainlink - CLI for Chainlink
    
    USAGE:
       chainlink [global options] command [command options] [arguments...]
    
    VERSION:
       0.9.10@7cd042c1a94c57219ed826a6eab46752d63fa67a
    
    COMMANDS:
       admin           Commands for remotely taking admin related actions
       attempts, txas  Commands for managing Ethereum Transaction Attempts
       bridges         Commands for Bridges communicating with External Adapters
       config          Commands for the node's configuration
       job_specs       Commands for managing Job Specs (jobs V1)
       jobs            Commands for managing Jobs (V2)
       keys            Commands for managing various types of keys used by the Chainlink node
       node, local     Commands for admin actions that must be run locally
       runs            Commands for managing Runs
       txs             Commands for handling Ethereum transactions
       help, h         Shows a list of commands or help for one command
    
    GLOBAL OPTIONS:
       --json, -j     json output as opposed to table
       --help, -h     show help
       --version, -v  print the version
    

Chainlink version 0.9.10.

Could you please clarify what am I doing wrong?



Answers:
(Answered on: 2021-09-28 21:51:21)


You need to make sure you have the `FEATURE_EXTERNAL_INITIATORS` environment
variable set to true in your .env file as such:

`FEATURE_EXTERNAL_INITIATORS=true`

This will open up access to the `initiators` command in the Chainlink CLI and
you can resume the instructions from there.





:::NEXT DOC:::

# Introduction

  * Overview

External initiators allow jobs in a node to be initiated depending on some
external condition. The ability to create and add external initiators to
Chainlink nodes enables blockchain agnostic cross-chain compatibility.

note

At this time of writing, external initiators do not show up in the bridges
tab. However, they act exactly the same as if they did.

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

Initiator Bridges handle the authentication to and from the External Initiator
and where to send the messages. When creating a Bridge two parameters are
required:

Only the [webhook](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) job
type can be initiated using an External Initiator.

The external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators to
nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes).

## What's next

  * [› Building External Initiators](/chainlink-nodes/external-initiators/building-external-initiators)
  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
How can I transfer NFTs using Chainlink's Automation/Keeper (checkUpkeep & performUpKeep)?,"The issue with the `upkeepNeeded` returning false is because the auction end time is set to 0. To transfer NFTs using Chainlink's Automation/Keeper, you need to ensure that the `endTime` is properly set for each auction. Make sure that the `endTime` is a valid timestamp and is greater than the current block timestamp. Additionally, check that the `listed` flag is properly set to `true` when the NFT is listed for auction. Double-check your code to ensure that these conditions are met for the automation to work correctly.",{'source': 'https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu'},"To transfer NFTs using Chainlink's Automation/Keeper (checkUpkeep & performUpKeep), you need to set up the checkUpkeep and performUpkeep functions in your contract. The checkUpkeep function should check if any auctions have ended and return true if upkeep is needed, along with the auction ID as performData. The performUpkeep function should then transfer the NFT to the highest bidder, send the highest bid to the previous owner, and send a small platform cut to the contract owner. You can then register your contract as an automation on Chainlink Keeper and input the correct checkData to trigger the upkeep. Make sure your contract is verified on the block explorer to avoid any compatibility issues.","Question: (Asked on: 2022-10-29 07:11:58)
How to Transfer NFTs using Chainlink&#39;s Automation/Keeper (checkUpkeep &amp; performUpKeep)
URL: https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu

Question Body:


I'm working on an NFT Auction contract. I'm trying to achieve 1. NFT transfer
to the highest bidder. 2. highest bidder's bid value to the prev NFT owner or
Auction creator. 3. A small platform cut sent to the contract's owner.

All this is working smoothly when I'm doing things manually. But when I'm
trying to achieve this using chainlink automation, It fails.

From my understanding, It is failing because of the `allowance` issue. My Qs
is, is it even possible to achieve this using chainlink automation? if yes,
then how?

When the NFT owner, lists his NFT for Auction, he is giving NFT transfer
allowance to the contract address.

    
    
        function checkUpkeep(bytes calldata /* checkData */) external view override returns(bool upkeepNeeded, bytes memory performData) {
            for(uint i=0; i < auctionIDs.length; i++){
                if(auctions[auctionIDs[i]].endTime != 0 && block.timestamp > auctions[auctionIDs[i]].endTime){
                    upkeepNeeded = true;
                    performData = abi.encodePacked(uint256(auctionIDs[i]));
                }
            }
            return (upkeepNeeded, performData);
        }
    
        function performUpkeep(bytes calldata performData) external override nonReentrant {
            uint256 auction_id = abi.decode(performData, (uint256));
    
            if(auctions[auction_id].endTime != 0 && block.timestamp > auctions[auction_id].endTime){
    
                auctions[auction_id].listed = false;
    
                safeTransferFrom(podcastId[auctions[auction_id].podcastId].nftOwner, bidders[auction_id].highestBidder, podcastId[auctions[auction_id].podcastId].tokenId);
    
                uint256 platformCut = (platformFee * bidders[auction_id].highestBid)/100;
                uint256 NftOwnerCut = bidders[auction_id].highestBid - platformCut;
    
                (bool pass, ) = platformFeeRecipient.call{value: platformCut}("""");
                require(pass, ""platformFee Transfer failed"");
                (bool success, ) = (podcastId[auctions[auction_id].podcastId].nftOwner).call{value: NftOwnerCut}("""");
       

:::NEXT DOC:::

Question: (Asked on: 2022-10-28 10:04:53)
Chainlink Automation upKeep not working. checkUpKeep is not calling performUpKeep
URL: https://stackoverflow.com/questions/74233765/chainlink-automation-upkeep-not-working-checkupkeep-is-not-calling-performupkee

Question Body:


Our Dapp will have an NFT Auction functionality, which we are trying to
automate 100% using chainlink. The auction winner will get the NFT and the
Previous owner will get the highest Bid, Platform will get a small cut as
well. To do that, we are using CHainlink Keeper/Automation. I've set the
`checkUpKeep` & `performUpKeep`, both are working fine when I'm doing
everything manually. But when I am registering an upKeep for automaton.

When I input the deployed contract's address into the register upkeep box, it
says `Unable to verify if this is an Automation compatible contract`. Why this
warning? How do I make the contract Automation compatible contract?
[](https://i.stack.imgur.com/nykbp.jpg)

`checkUpKeep` is working good: [](https://i.stack.imgur.com/HFmZ5.jpg)

If I pass this `performData` into `performUpKeep` everything will work fine.

Code/Contracts:
<https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8>

Chainlink upKeep:
<https://automation.chain.link/mumbai/21891159634677518530356555981285976030474691922841692133624884405593696766700>

Pls help, Thanks.



Answers:
(Answered on: 2022-10-28 15:46:58)


`Unable to verify if this is an Automation compatible contract` usually stems
from a contract that is not verified on the block explorer. The [contract you
linked](https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8)
is verified and if you create an automation with it everything is good
[](https://i.stack.imgur.com/6eSCb.png)

Your `checkUpKeep` function does return `true` when supplied with the input
you show(`checkData`). However, you have the `checkData` set to `0x` in your
automation. [](https://i.stack.imgur.com/kQaVD.png)

With that input, it returns false.

[](https://i.stack.imgur.com/W8ZYh.png)

You will need to change the `checkData` to match your screenshot.



"
Is there a way in blockchain to get the randomResult?,"No, there is no way to get the randomResult in one transaction. The Chainlink VRF process requires two transactions: one to request the random number and another to retrieve the random number. The `letsgo` function in your code will not work.",{'source': 'https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction'},"No, there is no way to get the randomResult in one go in blockchain using Chainlink VRF. The Chainlink VRF is a 2 transaction process where the first transaction requests the random number, and the second transaction returns the random number.","Question: (Asked on: 2021-10-05 09:57:27)
Retrieve the random number generated by Chainlink VRF in 1 transaction
URL: https://stackoverflow.com/questions/69448392/retrieve-the-random-number-generated-by-chainlink-vrf-in-1-transaction

Question Body:


I am trying to get a random number in solidity in 1 transaction with Chainlink
VRF.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    contract RandomNumberConsumer is VRFConsumerBase {
        
        bytes32 internal keyHash;
        uint256 internal fee;
        
        uint256 internal randomResult;
        
        constructor() 
            VRFConsumerBase(
                0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9, // VRF Coordinator
                0xa36085F69e2889c224210F603D836748e7dC0088  // LINK Token
            )
        {
            keyHash = 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4;
            fee = 0.1 * 10 ** 18; // 0.1 LINK (Varies by network)
        }
        function getRandomNumber() public returns (bytes32 requestId) {
            require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
            return requestRandomness(keyHash, fee);
        }
        function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
            randomResult = randomness;
        }
    
        function letsGo() public {
            bytes32 requestId;
            requestId = getRandomNumber();
            fulfillRandomness(requestId, 123456);
        }
    }
    

Is there a way in blockchain to get the randomResult?

I'm looking specifically at my `letsGo` function.



Answers:
(Answered on: 2021-10-07 12:29:29)


The chainlink VRF is a 2 transaction process.

The first transaction requests the random number, and the second to have the
random number returned. You can't get the random number in 1 go.

You can read more about the [basic request
model](https://docs.chain.link/docs/architecture-request-model/) in the
documentation.

You're `letsgo` function will not work.





:::NEXT DOC:::

#####Chapter 2:

# Randomness and Blockchains

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Upon research, you realize popular languages like Javascript have built-in randomness functions maybe you can use something like that in Solidity? 
    </div>
  </div>
</ContentWrapp>

Blockchains are deterministic, meaning that any computations that use blockchains must have predictable outcomes. This so all of the nodes that run the blockchain can come to an agreement on what the blockchain is. But deterministic runs counter to random. If everyone knows what the next hand of poker will be before it is dealt it wouldn’t be considered random. So if randomness is impossible on a blockchain, how can we bring the awesome powers of smart contracts to any applications that need randomness?

We could get the randomness from an outside resource! But it can’t be a trusted centralized service (as discussed in Chainlink 101), or we would be ruining the decentralized properties of blockchains and smart contracts. And it would be great if it could be verified that the number wasn’t tampered with and is genuinely random. This is a perfect example of where a decentralized oracle network powered by Chainlink could be used!
"
What is a gas lane in chainlink and blockchain?,"A gas lane in chainlink and blockchain is a concept used to set a limit on how much to spend on each request. It is important for setting the ceiling limit of each request, similar to an entry into a bet.",{'source': 'https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain'},A gas lane in blockchain is a concept used in Chainlink to set a limit on how much to spend on each request and to set the ceiling limit of each request. It is important for setting the entry limit of each request.,"Question: (Asked on: 2022-03-09 20:02:05)
What is a gas lane in chainlink and blockchain?
URL: https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain

Question Body:


I do understand the concept of gas in the ethereum blockchain and why gas is
needed to compensate miners for providing computing power to the network.
However, when I was reading up on the chainlink vrf get a random number
documentation it says that the keyhash tells you the gas lane to use. It would
be really helpful if someone could further explain what a gas lane in
blockchain is.

Any help would be appreciated :)



Answers:
(Answered on: 2022-03-10 06:17:54)


So we know that Eth gas is always subject to change and with chainlink vrf
there will be random values with your request, so you need to set a limit to
how much to spend on each request. The reason chainlink uses a Gas lane is
because the lanes are important for setting the ceiling limit of each
request... think of it as your entry into the bet.





:::NEXT DOC:::

am I doing wrong?

[Video](https://drive.google.com/file/d/1mCaq8RCxlZPN-
XJcO9kKzghWAiL-j2gW/view?usp=sharing)



Answers:
(Answered on: 2022-02-25 17:05:58)


`Gas estimation error` is a common error meaning that you don't have enough of
""something"" to send your transaction, maybe it's layer 1 (ETH) gas, or an
ERC20 token like LINK (technically, erc677, but I digress...)

Whenever you work with a Chainlink feature that uses the [request and
receive](https://docs.chain.link/docs/architecture-request-model/) method of
using chainlink, you need to [fund the consumer contract with LINK
token](https://docs.chain.link/docs/make-a-http-get-request/).

The issue here is you sent LINK to the oracle address and not the address of
your deployed contract.

[](https://i.stack.imgur.com/1ga4n.png)

If you copy the address of your deployed contract and send the LINK there, it
should work for you.



"
What could be causing the 'File not exist Solc' error when trying to import a data feed into a contract?,One possible cause of the 'File not exist Solc' error is if the yaml file is located in the tests folder instead of the top level directory. Moving the file to the top level directory may resolve the issue.,{'source': 'https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract'},The error could be caused by the file path being outside of the allowed directories or the brownie-config.yaml file being located inside the test folder instead of being kept separately. It could also be caused by using the wrong version of the Chainlink contracts or the wrong solidity version.,"Question: (Asked on: 2022-03-15 07:39:01)
File not exist Solc error when trying to import data feed into my contract
URL: https://stackoverflow.com/questions/71478488/file-not-exist-solc-error-when-trying-to-import-data-feed-into-my-contract

Question Body:


[](https://i.stack.imgur.com/fUE5J.png)

[](https://i.stack.imgur.com/lAkYb.png)

[](https://i.stack.imgur.com/b50Pt.png)

I have tried changing different versions of solc, solidity, and chainlink
contracts but it doesn't work.

Error:

    
    
    contracts/Lottery.sol:4:1: ParserError: Source ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"" not found: File outside of allowed directories.
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    



Answers:
(Answered on: 2022-05-11 18:24:04)


Perhaps the yaml file being in the tests folder is the problem. I would move
that file to live in your top level directory.





:::NEXT DOC:::

 
    ParserError: Source ""/Users/marc/.brownie/packages/smartcontractkit/chainlink-brownie-contracts@1.1.1/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"" not found: File not found.
     --> contracts/Lottery.sol:4:1:
      |
    4 | import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    

I tried changing compiler: solc: remappings: \-
'@chainlink=smartcontractkit/chainlink-brownie-contracts@1.1.1' to @0.2.1 I
also tried changing solidity version to a newer version and it's not working
Thanks in advance!



Answers:
(Answered on: 2022-07-03 13:39:43)


Hi I was also stuck in a similar problem. Make sure that the brownie-
config.yaml file is not inside the test folder and is kept seperately. Hope
this helps. [check the below image to see how I saved my brownie-config.yaml
file](https://i.stack.imgur.com/7NqEF.png)


---
(Answered on: 2022-01-20 10:55:07)

    
    
    import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
    

**use v0.6 instead of v0.8**


---
(Answered on: 2022-01-12 19:39:39)


**I solved it by doing:** npm install @chainlink/contracts --save

[**and in the yaml file doing:**](https://i.stack.imgur.com/axYng.png)


---
(Answered on: 2022-01-12 14:37:57)


I solved it by replacing import
""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol""; with
import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
My mistake, cheers!



"
What command is used to configure user management in Chainlink Node instance?,The admin `chainlink admin users` command is used to configure user management in Chainlink Node instance.,{'source': 'https://docs.chain.link/chainlink-nodes/v1/roles-and-access/'},"The command used to configure user management in Chainlink Node instance is ""chainlink admin users"".","# Miscellaneous

  * Overview
  * Execute Commands Running Docker
  * Transfer funds from node wallet.
  * Change your API password
  * Multi-user and Role Based Access Control (RBAC)
  * Key management
  * List ETH keys
  * Create a new ETH Key
  * Export an ETH key
  * Delete an ETH key
  * Import an ETH key
  * Full example in detached mode

## Execute Commands Running Docker

In order to interact with the node's CLI commands, you need to be
authenticated. This means that you need to access a shell within the Chainlink
node's running container first. You can obtain the running container's `NAME`
by running:


    docker ps

The output will look similar to:


    CONTAINER ID        IMAGE                     COMMAND                  CREATED             STATUS              PORTS                              NAMES
    436882efd51d        smartcontract/chainlink   ""./chainlink-launche…""   33 minutes ago      Up 21 minutes       6688/tcp, 0.0.0.0:6688->6688/tcp   chainlink

The last item, `chainlink`, is the name of the running container (using
`--name chainlink` in your `docker run` command will give you a common name).
Accessing a shell for this container is accomplished by running:


    docker exec -it chainlink /bin/bash

This changes the prompt to something similar to:


    root@436882efd51d:~#

You can now log in by running:


    chainlink admin login

You will be prompted to enter your API Email and Password, and if successful,
the prompt will simply appear again. You can check that you are authenticated
by running:


    chainlink jobs list

If no jobs have been added, you will receive the following output, otherwise,
the list of added jobs will be returned:


    ╔ Jobs
    ╬════╬════════════╬════════════╬═══════╬
    ║ ID ║ CREATED AT ║ INITIATORS ║ TASKS ║
    ╬════╬════════════╬════════════╬═══════╬

## Transfer funds from node wallet.

Note for Docker

If using Docker, you will first need to follow the Execute Commands Running
Docker guide to enter the running container.

To transfer funds from the node wallet to another address, use the following
CLI command:


    chainlink txs create <amount> <your-cl-node-address> <send-to-address>

This method is the preferred way to interact with your node wallet. Using
other methods to manually interact with the node wallet can cause nonce
issues.

## Change your API password

Note for Docker

If using Docker, you will first need to follow the Execute Commands Running
Docker guide to enter the running container.

In order to change your password, you first need to log into the CLI by
running:


    chainlink admin login

Use your API email and old password in order to authenticate.

Then run the following in order to update the password:


    chainlink admin chpass

It will ask for your old password first, then ask for the new password and a
confirmation.

Once complete, you should see a message ""Password updated.""

## Multi-user and Role Based Access Control (RBAC)

See the [Roles and Access

:::NEXT DOC:::

# Role-Based Access Control (RBAC)

  * Overview

Chainlink Nodes allow the root admin CLI user and any additional admin users
to create and assign tiers of role-based access to new users. These new API
users can able to log in to the Operator UI independently.

Each user has a specific role assigned to their account. There are four roles:
`admin`, `edit`, `run`, and `view`.

If there are multiple users who need specific access to manage the Chainlink
Node instance, permissions and level of access can be set here.

User management is configured through the use of the admin `chainlink admin
users` command. Run `chainlink admin login` before you set user roles for
other accounts. For example, a read-only user can be created with the
following command:


    chainlink admin users create --email=operator-ui-read-only@test.com --role=view

Specific actions are enabled to check role-based access before they execute.
The following table lists the actions that have role-based access and the role
that is required to run that action:

| Action                                        | Read   | Run   | Edit   | Admin   |
|:----------------------------------------------|:-------|:------|:-------|:--------|
| Update password                               | X      | X     | X      | X       |
| Create self API token                         | X      | X     | X      | X       |
| Delete self API token                         | X      | X     | X      | X       |
| List external initiators                      | X      | X     | X      | X       |
| Create external initiator                     | nan    | nan   | X      | X       |
| Delete external initiator                     | nan    | nan   | X      | X       |
| List bridges                                  | X      | X     | X      | X       |
| View bridge                                   | X      | X     | X      | X       |
| Create bridge                                 | nan    | nan   | X      | X       |
| Edit bridge                                   | nan    | nan   | X      | X       |
| Delete bridge                                 | nan    | nan   | X      | X"
What is the purpose of the 'fulfill' function in this contract?,The 'fulfill' function is used to record the fulfillment of a Chainlink request and update the 'volume' state variable with the provided volume.,{'source': 'https://docs.chain.link/any-api/get-request/examples/single-word-response/'},"The context information provided does not include any mention of a 'fulfill' function in the contract. Therefore, it is not possible to determine the purpose of such a function.","is
using `call` method to call `rawFulfillRandomWords` which calls
`fulfillRandomWords` in my consumer contract. So all I'm getting is
`RandomWordsFulfilled` event with `success: false`

How can I know the reason the call of my consumer `fulfillRandomWords` is
failing? I'm emitting an event in the first line of my `fulfillRandomWords`
but it is not being emitted. This means the callback from the coordinator is
failing to call `fulfillRandomWords` without even executing the first line of
`fulfillRandomWords`. In other words, there is nothing in my code is causing
`fulfillRandomWords` call to fail because its first line (event emitting) is
not being executed.


---
(Answered on: 2022-05-26 05:17:29)


Hi [Sulaman](https://stackoverflow.com/users/10213411/sulaman-khan)

Two questions I guess! One: is `fulfillRandomWords` erroring or reverting?

Two, Is your `s_randomWords` state variable showing the random words passed
into the callback? If that is updated then the callback is working but there
may be some other issue with `tokenCounter` that is not possible to diagnose.

Can you also check the etherscan TX records for the VRF Coordinator calling
your contract? If that has succeeded and the logs dont show errors then the
callback is probably working as intended. You can access this Tx info from the
history section of your VRF Subscription's URL. The screenshot you sent only
shows the registered consumers and not the history of requests and events.
Please check the Tx hash under History > Recent Requests and inspect for
errors. The tx should record the call from an oracle providing the randomness
to the VRF Coordinator (the coordinators address will show in the ""To"" field).
If you open that Tx in etherscan and look at Internal TXs there should be one
that is from the Coordinator to your smart contract (the callback) and that
will also show the gas limit you set in your code etc.  
If that call has no issue against it then the callback executed OK.

**UPDATE 27 MAY 2022** OP posted the [etherscan
link](https://rinkeby.etherscan.io/address/0x30145fbc4b624c03bf3c596570a09fd6cf47bdb6)
which indicates (from the Internal Txns ) an ""out of gas"" error.





:::NEXT DOC:::

Question: (Asked on: 2022-12-25 12:25:30)
Why is recordChainlinkfulfillment not being executed?
URL: https://stackoverflow.com/questions/74913265/why-is-recordchainlinkfulfillment-not-being-executed

Question Body:


Anyone any idea why the recordChainlinkfulfillment is not being executed?

I've checked the API call and it's yield the correct results. I managed to got
this working with the chainlink job for fetching 1 value, but not for multiple
values.

As far as I can tell and was able to check, the API url was correctly set and
the request function was correctly executed. My contract is funded with enough
LINK.

    
    
        // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.9;
    
    
    import ""@openzeppelin/contracts/access/Ownable.sol"";
    import ""@openzeppelin/contracts/utils/Counters.sol"";
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    contract RealEstateBonus is ChainlinkClient, Ownable {
        using Chainlink for Chainlink.Request;
    
        bytes32 private jobId;
        uint256 private fee;
        string public url;
        string public urlresult;
        string public lastselldate;
        string public lastapn;
        bytes32 public lastrequestid;
    
        event RequestMultipleFulfilled(bytes32 indexed requestId, string selldate, string apn);
    
        constructor() {
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            setChainlinkOracle(0xCC79157eb46F5624204f47AB42b3906cAA40eaB7);
            jobId = ""53f9755920cd451a8fe46f5087468395"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
            url=""https://api.bridgedataoutput.com/api/v2/pub/transactions?access_token=d555ec24e3f182c86561b09d0a85c3dc&limit=1&sortBy=recordingDate&order=desc&fields=recordingDate,parcels.apn&recordingDate.gt=2015-01-01&parcels.apn="";
            
        }
        
        struct Bonus {
            string parcelid;
            address seller;
            address realtor;
            uint256 amount;
            uint startdate;
            uint sellbydays;
        }
        
        mapping (string => Bonus) public parcelbonus;
        mapping (string => string) public parcellastselldate;
     "
What can you expect to stay up to date on by subscribing to the Chainlink Developer mailing list?,"You can expect to stay up to date on releases, package updates, new features, breaking changes, events, and connecting with other developers.",{'source': 'https://docs.chain.link/resources/developer-communications?parent=anyApi/'},"By subscribing to the Chainlink Developer mailing list, you can expect to stay up to date on releases, package updates, new features, breaking changes, events, and connecting with other developers.","# Developer Communications

  * Overview

The Chainlink Developer mailing list is the best place to stay up to date on

  * Releases
  * Package Updates
  * New Features
  * Breaking Changes
  * Events
  * Connecting with other developers

## Subscribe to the latest Chainlink Developer news

### 微信中文开发者社区

### (WeChat Chinese Developer Community)

[
https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE](https://u.wechat.com/MFfVjWlXvRIvwy5_hxFgvaE)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/developer-communications.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually hosted](https://blog.chain.link/smart-contract-developer-bootcamp-on-demand/) the first [Chainlink Developer
Bootcamp](http://chain.link/bootcamp). If you're passionate about educating
others about smart contracts and Chainlink, you can contribute by running your
own developer Bootcamp. You can also contribute by translating an existing
Bootcamp and running it in another language. Before you run your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the benefit of using Off-Chain Reporting (OCR) for Chainlink oracle networks?,"Submitting only one transaction per round reduces overall network congestion, individual node operators spend less on gas costs, node networks are more scalable, and data feeds can be updated in a more timely manner.",{'source': 'https://docs.chain.link/architecture-overview/off-chain-reporting/'},"The benefit of using Off-Chain Reporting (OCR) for Chainlink oracle networks is that it reduces overall network congestion, individual node operators spend less on gas costs, node networks are more scalable, and data feeds can be updated in a more timely manner since each round needn't wait for multiple transactions to be confirmed before a price is confirmed on-chain. OCR allows nodes to aggregate their observations into a single report off-chain using a secure P2P network, which saves a significant amount of gas.","# Off-Chain Reporting

  * Overview
  * What is OCR?
  * How does OCR work?

Off-Chain Reporting (OCR) is a significant step towards increasing the
decentralization and scalability of Chainlink networks. See the [OCR Protocol
Paper](https://research.chain.link/ocr.pdf) for a technical deep dive.

For Off-Chain Reporting aggregators, all nodes communicate using a peer to
peer network. During the communication process, a lightweight consensus
algorithm runs where each node reports its data observation and signs it. A
single aggregate transaction is then transmitted, which saves a significant
amount of gas.

The report contained in the aggregate transaction is signed by a quorum of
oracles and contains all oracles' observations. By validating the report on-
chain and checking the quorum's signatures on-chain, we preserve the
trustlessness properties of Chainlink oracle networks.

## What is OCR?

A simple analogy

Imagine ordering 10 items from an online store. Each item is packaged
separately and posted separately, meaning postage and packaging costs must be
applied to each one, and the carrier has to transport 10 different boxes.

OCR, on the other hand, packages all of these items into a single box and
posts that. This saves postage and packaging fees and all effort the carrier
associates with transporting 9 fewer boxes.

The OCR protocol allows nodes to aggregate their observations into a single
report off-chain using a secure P2P network. A single node then submits a
transaction with the aggregated report to the chain. Each report consists of
many nodes' observations and has to be signed by a quorum of nodes. These
signatures are verified on-chain.

Submitting only one transaction per round achieves the following benefits:

  * Overall network congestion from Chainlink oracle networks is reduced dramatically
  * Individual node operators spend far less on gas costs
  * Node networks are more scalable because data feeds can accommodate more nodes
  * Data feeds can be updated in a more timely manner since each round needn't wait for multiple transactions to be confirmed before a price is confirmed on-chain.

## How does OCR work?

Protocol execution happens mostly off-chain over a peer to peer network
between Chainlink nodes. The nodes regularly elect a new leader node that
drives the rest of the protocol.

The leader regularly requests followers to provide freshly signed observations
and aggregates them into a report. It then sends this report back to the
followers and asks them to verify the report's validity. If a quorum of
followers approves the report by sending a signed copy back to the leader, the
leader assembles a final report with the quorum's signatures and broadcasts it
to all followers.

The nodes attempt to transmit the final report to the aggregator contract
according to a randomized schedule. The aggregator verifies that a quorum of
nodes signed the report and exposes the median value to consumers as an answer
with a block timestamp and a round ID.

All nodes watch the blockchain for the final report to remove any single point
of failure during transmission. If the designated node fails to get their
transmission confirmed within a determined period, a round-robin protocol
kicks in so other nodes can also transmit the final report until one of them
is confirmed.

## What's next

  * [› Using Data Feeds](/data-feeds/price-feeds/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/off-chain-reporting.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Data Feeds Architecture

  * Overview
  * Basic Request Model
  * Decentralized Data Model
  * Off-Chain Reporting

## Basic Request Model

Chainlink connects smart contracts with external data using its decentralized
oracle network. Chainlink API requests are handled 1:1 by an oracle.

The [Basic Request Model](/architecture-overview/architecture-request-model)
describes the on-chain architecture of requesting data from a single oracle
source.

To learn how to make a GET request using a single oracle, see [Make a GET
Request](/any-api/get-request/introduction).

## Decentralized Data Model

For a more robust and trustworthy answer, you can aggregate data from many
oracles. With on-chain aggregation, data is aggregated from a decentralized
network of independent oracle nodes. This architecture is applied to Chainlink
Data Feeds, which can aggregate data such as asset price data.

The [Decentralized Data Model](/architecture-overview/architecture-decentralized-model) describes how data is aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are external initiators and how do they enable blockchain agnostic cross-chain compatibility?,External initiators allow jobs in a node to be initiated depending on some external condition. The ability to create and add external initiators to Chainlink nodes enables blockchain agnostic cross-chain compatibility.,{'source': 'https://docs.chain.link/chainlink-nodes/external-initiators/external-initiators-introduction/'},"External initiators are a feature in Chainlink nodes that allow jobs to be initiated based on some external condition. They enable blockchain agnostic cross-chain compatibility by allowing for the creation and addition of external initiators to Chainlink nodes. This means that jobs can be triggered across different blockchains, not just within a single blockchain. External initiators are simple web initiators that can be activated by any job instead of just one, and they make API calls with two added headers to authenticate messages sent from the External Initiator to the Core.","# Introduction

  * Overview

External initiators allow jobs in a node to be initiated depending on some
external condition. The ability to create and add external initiators to
Chainlink nodes enables blockchain agnostic cross-chain compatibility.

note

At this time of writing, external initiators do not show up in the bridges
tab. However, they act exactly the same as if they did.

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

Initiator Bridges handle the authentication to and from the External Initiator
and where to send the messages. When creating a Bridge two parameters are
required:

Only the [webhook](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) job
type can be initiated using an External Initiator.

The external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators to
nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes).

## What's next

  * [› Building External Initiators](/chainlink-nodes/external-initiators/building-external-initiators)
  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/external-initiators-introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Building External Initiators

  * Overview
  * JSON jobs (REMOVED)

An external initiator can trigger a run for any webhook job that it has been
linked to.

The URL for triggering a run is such:


    curl -X POST -H ""Content-Type: application/json"" --data '{""myKey"": ""myVal""}' http://localhost:6688/v2/jobs/<job external UUID>/runs

You will need to specify two headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

## JSON jobs (REMOVED)

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

We will be using the [Chainlink external
initiator](https://github.com/smartcontractkit/external-initiator) repo for
reference. You can see some examples of existing initiators in the
[blockchain](https://github.com/smartcontractkit/external-initiator/tree/master/blockchain) folder.

External initiators are simple web initiators that can be activated by any job
instead of just one. To set one up, you need to have a service similar to an
external adapter that sends an `HTTPPost` message runs API call to your
chainlink node service. Here is a sample URL for a web job could look like:


    curl -b cookiefile -X POST -H ""Content-Type: application/json"" --data '{""myKey"":""myVal""}' http://localhost:6688/v2/jobs/%s/runs

Where `%s` is the jobId.

External initiators make the same API call, with 2 added headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

These are keys generated when you register your external initiator with your
node.

Triggering a run through an external initiator is as simple as making this API
call to your node. All jobs with this EI configured will then be kicked off in
this way. A simple external initiator in psedo code could look like this:


    while(True):
        send_api_call_with_external_initiator_access_key_headers()
        sleep(4)

And have this job run on the same machine as your node.

## What's next

  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/building-external-initiators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the GET>bool function in the given text?,"To perform an HTTP GET request to any public API, parse the response, and return a boolean value.",{'source': 'https://docs.chain.link/any-api/testnet-oracles/'},"The given text does not mention a specific ""GET>bool function."" It only mentions a ""get function"" for nested mappings, which Solidity automatically generates and returns a default value if the requested value does not exist.","a boolean.

To set the value of a nested array, we must provide the address and the uint which works like an index.

<Highlight class=""language-javascript"">
function set(address \_address, uint \_index, bool \_foo) public {
  nestedMapping[\_address][\_index] = \_foo;
}
</Highlight>

Retrieving a value works just as easy. We only need to provide the two keys (\_address and \_index):

<Highlight class=""language-javascript"">
function get(address \_address, uint \_index) public view returns (bool) {
  return nestedMapping[\_address][\_index];
}
</Highlight>

The same rules as for non-nested mappings apply here. We do not need to define a get function for nested functions. Solidity does this for us. And if the value does exist, we will simply get a default value.


:::NEXT DOC:::

Question: (Asked on: 2022-09-12 20:50:02)
Convert uint value from chainlink VRF to boolean SOLIDITY
URL: https://stackoverflow.com/questions/73695116/convert-uint-value-from-chainlink-vrf-to-boolean-solidity

Question Body:


I am writing a coin toss contract using Chainlink VRF to request a random
number. When using chainlink, the random number generated is a uint. I am
trying to convert such uint into a boolean value to obtain whether 0 for heads
or 1 for tails.

I have already managed to obtain the random number and transform it into 0 or
1 using modulo (%). But the number I get is still a uint. How can I convert it
to a boolean value?

    
    
            struct round {
               uint roundId;
               uint betAmount;
               bool playerChoice; // 0 = heads; 1 = tails
               bool draw;
               bool win; 
            }
        
            function fulfillRandomWords(
                uint256, /* requestId */
                uint256[] memory randomWords
            ) internal override {
    
    // this where I get the error ""TypeError: Type uint256 is not implicitly convertible to expected type bool.""
                myRound.draw = (randomWords[0] % 2); 
            }
    

Thanks for the help guys!



Answers:
(Answered on: 2022-09-12 21:46:36)


You can compare the resulting value with 0 or 1.

    
    
    // comparison returns a bool
    myRound.draw = (randomWords[0] % 2) == 1;
    



"
What is the purpose of this contract?,This is an example contract which uses hardcoded values for clarity. It uses un-audited code. Do not use this code in production.,{'source': 'https://docs.chain.link/getting-started/advanced-tutorial/'},"The context information does not provide a specific contract to refer to, so it is not possible to determine the purpose of a contract.","#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 4:

# Smart Contracts - The Future

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Check out this video on what smart contracts are and how they are changing the nature of agreements and the Internet. 
    </div>
  </div>
</ContentWrapp>

<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/Un7-hW6GAec"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>

Smart contracts result from the evolution of digital agreements. A smart contract is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract isn’t immediately executed after the conditions have been met. Rather, a lengthy review process is initiated and it could take months, even years before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial crisis were programmed as smart contracts, they would be completely transparent and any member of the public would have had the ability to audit them.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Trust Minimization</b></p>
  "
What is the purpose of OpenSSL in generating self-signed certificates for Chainlink node?,OpenSSL is needed to generate self-signed certificates for Chainlink node.,{'source': 'https://docs.chain.link/chainlink-nodes/resources/enabling-https-connections/'},The purpose of OpenSSL in generating self-signed certificates for Chainlink node is to enable HTTPS connections.,"# Enabling HTTPS Connections

  * Overview

This guide will walk you through how to generate your own self-signed
certificates for use by the Chainlink node. You can also substitute self-
signed certificates with certificates of your own, like those created by
[Let's Encrypt](https://letsencrypt.org/).

TLS

You will need [OpenSSL](https://www.openssl.org) in order to generate your own
self-signed certificates.

Create a directory `tls/` within your local Chainlink directory:


    mkdir ~/.chainlink-sepolia/tls


    mkdir ~/.chainlink-goerli/tls


    mkdir ~/.chainlink/tls

Run this command to create a `server.crt` and `server.key` file in the
previously created directory:


    openssl req -x509 -out  ~/.chainlink-sepolia/tls/server.crt  -keyout ~/.chainlink-sepolia/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink-goerli/tls/server.crt  -keyout ~/.chainlink-goerli/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")


    openssl req -x509 -out  ~/.chainlink/tls/server.crt  -keyout ~/.chainlink/tls/server.key \
      -newkey rsa:2048 -nodes -sha256 -days 365 \
      -subj '/CN=localhost' -extensions EXT -config <( \
       printf ""[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth"")

Next, add the `TLS_CERT_PATH` and `TLS_KEY_PATH` environment variables to your
`.env` file.


    echo ""TLS_CERT_PATH=/chainlink/tls/server.crt
    TLS_KEY_PATH=/chainlink/tls/server.key"" >> .env

If `CHAINLINK_TLS_PORT=0` is present in your `.env` file, remove it by
running:


    sed -i '/CHAINLINK_TLS_PORT=0/d' .env

Also remove the line that disables `SECURE_COOKIES` by running:


    code"": ""sed -i '/SECURE_COOKIES=false/d' .env

Finally, update your run command to forward port 6689 to the container instead
of 6688:


    cd ~/.chainlink-sepolia && docker run -p 6689:6689 -v ~/.chainlink-sepolia:/chainlink -it
    --env-file=.env smartcontract/chainlink local n


    cd ~/.chainlink-goerli && docker run -p 6689:6689 -v ~/.chainlink-goerli:/chainlink -it
   

:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.



"
What are some improvements and changes introduced in Chainlink VRF v2?,"Chainlink VRF v2 includes improvements such as subscription management, variable callback gas limit, more configuration capability, multiple random outputs in a single request, and unified billing.",{'source': 'https://docs.chain.link/vrf/v2/subscription/migration-from-v1/'},"Chainlink VRF v2 includes several improvements and changes, such as the introduction of a Subscription Manager application, variable callback gas limit, more configuration capability, multiple random outputs in a single request, and unified billing. The VRF v2 Direct funding method also includes improvements such as variable callback gas limit, more configuration capability, and multiple random outputs in a single request.","# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for

:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparison between VRF v1 and VRF v2 (Direct funding method)
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparison between VRF v1 and VRF v2 (Direct funding method)

The main similarity between VRF v1 and VRF v2 Direct funding method is that
consuming contracts must be funded with LINK to pay for requests. However,
Chainlink VRF v2 includes several improvements.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper contracts](/vrf/v2/direct-funding/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

## Updating your applications to use VRF v2

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) guide for an example.

  1. Import and inherit the new [`VRFV2WrapperConsumerBase.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  2. Add a `VRFV2WrapperConsumerBase` constructor as shown in the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) example and use the correct VRF v2 Direct funding configuration.

  3. You can still call the `requestRandomness` function. However, the v2 `requestRandomness` function requires several different parameters (`callbackGasLimit` , `requestConfirmations` , `numWords`). See the [Supported networks](/vrf/v2/direct-funding/supported-networks) page to adjust them for your own needs.

  4. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding/migration-from-v1.mdx)
  * [ Join our community"
What are some improvements in Chainlink VRF v2 compared to VRF v1 Direct funding method?,"Chainlink VRF v2 includes improvements such as variable callback gas limit, more configuration capability, and multiple random outputs in a single request.",{'source': 'https://docs.chain.link/vrf/v2/direct-funding/migration-from-v1/'},"Chainlink VRF v2 Direct funding method includes improvements such as variable callback gas limit, more configuration capability, and the ability to request multiple random outputs in a single transaction, which reduces gas costs and latency of responses.","# Migrating from VRF v1

  * Overview
  * Comparison between VRF v1 and VRF v2 (Direct funding method)
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparison between VRF v1 and VRF v2 (Direct funding method)

The main similarity between VRF v1 and VRF v2 Direct funding method is that
consuming contracts must be funded with LINK to pay for requests. However,
Chainlink VRF v2 includes several improvements.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain that you use. See the gas limits on the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered on-chain when your application makes a request transaction. The range is from 3 to 200 blocks. VRF V1 always waited 10 blocks on Ethereum before delivering on-chain randomness. Select a value that protects your application from block re-organizations while still providing sufficiently low latency from request to response. See the [Security Considerations](/vrf/v2/security) page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Wrapper contracts](/vrf/v2/direct-funding/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

## Updating your applications to use VRF v2

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) guide for an example.

  1. Import and inherit the new [`VRFV2WrapperConsumerBase.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  2. Add a `VRFV2WrapperConsumerBase` constructor as shown in the [Get a Random Number](/vrf/v2/direct-funding/examples/get-a-random-number) example and use the correct VRF v2 Direct funding configuration.

  3. You can still call the `requestRandomness` function. However, the v2 `requestRandomness` function requires several different parameters (`callbackGasLimit` , `requestConfirmations` , `numWords`). See the [Supported networks](/vrf/v2/direct-funding/supported-networks) page to adjust them for your own needs.

  4. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/direct-funding/migration-from-v1.mdx)
  * [ Join our community

:::NEXT DOC:::

                                                               | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)
  * [Direct Funding Supported networks](/vrf/v2/direct-funding/supported-networks)

To learn when VRF v2 becomes available on more networks, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=vrf).

## What's next

  * [› Subscription Method](/vrf/v2/subscription)
  * [› Direct Funding Method](/vrf/v2/direct-funding)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is Chainlink Functions and what are some use cases for it?,"Chainlink Functions is a platform that enables users to connect to public data sources, transform data, connect to password-protected data sources, connect to external decentralized databases, and fetch data from almost any Web2 system. Some use cases for it include connecting smart contracts to weather statistics for parametric insurance, calculating Twitter sentiment, and fetching data from AWS S3, Firebase, or Google Cloud Storage.",{'source': 'https://docs.chain.link/chainlink-functions/'},"Chainlink Functions is a platform that provides smart contracts with access to a trust-minimized compute infrastructure. It allows smart contracts to send code to a Decentralized Oracle Network (DON), where each DON's oracle runs the same code in a serverless environment. The DON aggregates all the independent runs and returns the final result to the smart contract. Chainlink Functions provides access to off-chain computation without having to run and configure your own Chainlink Node. Some use cases for Chainlink Functions include connecting to any public data, transforming public data before consumption, connecting to password-protected data sources, connecting to external decentralized databases, fetching data from almost any Web2 system, and building low-cost governance voting systems.","# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature

:::NEXT DOC:::

build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature improvements
along with interface and contract changes. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and add your EVM account address to the allow list.

## Supported networks

See the [Supported Networks](/chainlink-functions/supported-networks) page to
find a list of supported networks and contract addresses.

## What's next

  * [› Learn the basics in the Getting Started guide.](/chainlink-functions/getting-started)
  * [› Learn how to use more advanced capabilities in one of the Tutorials.](/chainlink-functions/tutorials)
  * [› Learn about core concepts, the Chainlink Functions architecture, and billing.](/chainlink-functions/resources)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the AggregatorV3Interface contract?,"The AggregatorV3Interface contract is used to get data from a specific round or the latest round of an aggregator, and to get the number of decimals and description of the aggregator.",{'source': 'https://docs.chain.link/data-feeds/api-reference/'},The purpose of the AggregatorV3Interface contract is to retrieve data feeds through the proxy address and to run functions in the proxy contract. It is used to get information about the aggregator behind the proxy.,"# Data Feeds API Reference

  * Overview
  * AggregatorV3Interface
  * Functions in AggregatorV3Interface
  * AccessControlledOffchainAggregator
  * Variables and functions in AccessControlledOffchainAggregator

When you use data feeds, retrieve the feeds through the
`AggregatorV3Interface` and the proxy address. Optionally, you can call
variables and functions in the `AccessControlledOffchainAggregator` contract
to get information about the aggregator behind the proxy.

## AggregatorV3Interface

Import this interface to your contract and use it to run functions in the
proxy contract. Create the interface object by pointing to the proxy address.
For example, on Sepolia you could create the interface object in the
constructor of your contract using the following example:


    /**
     * Network: Sepolia
     * Data Feed: ETH/USD
     * Address: 0x694AA1769357215DE4FAC081bf1f309aDC325306
     */
    constructor() {
      priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);
    }
    

To see examples for how to use this interface, read the [Using Data
Feeds](/data-feeds/price-feeds) guide.

You can see the code for the [`AggregatorV3Interface`
contract](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
on GitHub.

### Functions in AggregatorV3Interface

| Name            | Description                                                          |
|:----------------|:---------------------------------------------------------------------|
| decimals        | The number of decimals in the response.                              |
| description     | The description of the aggregator that the proxy points to.          |
| getRoundData    | Get data from a specific round.                                      |
| latestRoundData | Get data from the latest round.                                      |
| version         | The version representing the type of aggregator the proxy points to. |
#### decimals

Get the number of decimals present in the response value.


    function decimals() external view returns (uint8);

  * `RETURN`: The number of decimals.

#### description

Get the description of the underlying aggregator that the proxy points to.


    function description() external view returns (string memory);

  * `RETURN`: The description of the underlying aggregator.

#### getRoundData

Get data about a specific round, using the `roundId`.


    function getRoundData(
      uint80 _roundId
    ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);

**Parameters:**

  * `_roundId`: The round ID

**Return values:**

  * `roundId`: The round ID
  * `answer`: The answer for this round
  * `startedAt`: Timestamp of when the round started
  * `updatedAt`: Timestamp of when the round was updated
  *

:::NEXT DOC:::

are on-chain proxies that point to the aggregator for a
particular data feed. Using proxies enables the underlying aggregator to be
upgraded without any service interruption to consuming contracts.

Proxy contracts can vary from one data feed to another, but the
[`AggregatorProxy.sol`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol)
on Github is a common example.

### Aggregator

An aggregator is the contract that receives periodic data updates from the
oracle network. Aggregators store aggregated data on-chain so that consumers
can retrieve it and act upon it within the same transaction.

You can access this data using the Data Feed address and the
[`AggregatorV3Interface`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol).

Aggregators receive updates from the oracle network only when the **Deviation
Threshold** or **Heartbeat Threshold** triggers an update during an
aggregation round. The first condition that is met triggers an update to the
data.

  * Deviation Threshold: A new aggregation round starts when a node identifies that the off-chain values deviate by more than the defined deviation threshold from the on-chain value. Individual nodes monitor one or more data providers for each feed.
  * Heartbeat Threshold: A new aggregation round starts after a specified amount of time from the last update.

## What's next

  * [› Using Data Feeds](/data-feeds/price-feeds/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-decentralized-model.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the HTTPGet adapter?,The HTTPGet adapter is used to make a GET request to a specified URL and return the response body.,{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/'},"The context information does not provide a clear answer to this question as it mentions multiple guides and tutorials related to HTTP GET requests and external adapters. It is possible that the HTTPGet adapter is used to make HTTP GET requests and retrieve data from external APIs, but more information is needed to confirm this.","                                                                                       |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                                                                             |
| HTTP GET Element in Array Response | This guide explains how to make an HTTP GET request that returns a json array and parse it to retrieve the target element's value.                                                                                                                         |
| HTTP GET Large Reponses            | This guide explains how to make an HTTP Get request that returns a json containing an arbitrary-length raw byte data and parse it to return the data as bytes data type.                                                                                   |
| Existing Job Request               | This guide explains how to call a job that leverages External adapters and returns the relevant data to the smart contract. This allows building succinct smart contracts that do not need to comprehend the URL or the response format of the target API. |
### Building external adapters

To learn more about building external adapters and adding them to nodes, refer
to the [External Adapters](/chainlink-nodes/external-adapters/external-adapters) documentation.

To understand different use cases for using any API, refer to [Other
Tutorials](/getting-started/other-tutorials).

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› API Reference](/any-api/api-reference/)
  * [› Find Existing Jobs](/any-api/find-oracle/)
  * [› Testnet Oracles](/any-api/testnet-oracles/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

to learn how to fund your contract.

This is an example of a basic HTTP GET request. However, it requires defining
the API URL directly in the smart contract. This can, in fact, be extracted
and configured on the Job level inside the Oracle node. You can follow the
_APIConsumer_ tutorial [here](/any-api/get-request/examples/single-word-response).

### External adapters

If all the parameters are defined within the Oracle job, the only things a
smart contract needs to define to consume are:

  * JobId
  * Oracle address
  * LINK fee
  * Fulfillment function

This will make your smart contract much more succinct. The `requestVolumeData`
function from the code example above would look more like this:


    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
        // Extra parameters don't need to be defined here because they are already defined in the job
    
        return sendChainlinkRequest(req, fee);
    }

You can follow a full _Existing Job Tutorial_ [here](/any-api/get-request/examples/existing-job-request). More on External Adapters can be found
[here](/chainlink-nodes/external-adapters/external-adapters).

## Further reading

To learn more about connecting smart contracts to external APIs, read our blog
posts:

  * [Connect a Smart Contract to the Twitter API](https://blog.chain.link/connect-smart-contract-to-twitter-api/)
  * [Connect a Tesla Vehicle API to a Smart Contract](https://blog.chain.link/create-tesla-smart-contract-rental/)
  * [OAuth and API Authentication in Smart Contracts](https://blog.chain.link/oauth-and-api-authentication-in-smart-contracts-2/)

To explore more applications of external API requests, check out our [other
tutorials](/getting-started/other-tutorials/#api-requests).

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction)
  * [› Make an Existing Job Request](/any-api/get-request/examples/existing-job-request)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/advanced-tutorial.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the `oracleRequest` function in the `AuthorizedReceiver` contract?,The `oracleRequest` function creates a Chainlink request and assumes that the `callbackAddress` is the same as the request sender.,{'source': 'https://docs.chain.link/chainlink-nodes/contracts/operator/'},"The `oracleRequest` function in the `AuthorizedReceiver` contract creates a Chainlink request and is a legacy API that is backwards compatible with the `Oracle.sol` contracts. It takes in parameters such as the sender of the request, payment amount, job specification ID, callback address, callback function ID, nonce, data version, and extra request parameters.","            sender,
                requestId,
                payment,
                sender,
                callbackFunctionId,
                expiration,
                dataVersion,
                data
            );
        }
    
    

I removed the `oracleRequest()` function because it exceeds stack size by
adding more modifiers to it and since I can use `operatorRequest()` to fulfill
both multi-word and single-word requests I will make that method deprecated by
reverting everytime it's called.

The modifier that sets the authorized consumer is basically the following:

    
    
        /**
         * @dev function used to change the authorized consumer. Can only be set once
         */
        function setAuthorizedConsumer(address _consumer) public onlyOwner {
            require(
                authorizedConsumer == address(0),
                ""authorized consumer is already set""
            );
            authorizedConsumer = _consumer;
        }
    
        /**
         * @notice validates the consumer is an authorized consumer
         */
        function _validateIsAuthorizedConsumer(address _consumer) internal view {
            require(_consumer == authorizedConsumer, ""Not authorized sender"");
        }
    
        /**
         * @notice prevents non-authorized addresses from calling this method
         */
        modifier validateIsAuthorizedConsumer(address _consumer) {
            _validateIsAuthorizedConsumer(_consumer);
            _;
        }
    
    
    


---
(Answered on: 2021-12-29 08:59:47)


You can restrict the access by adding whitelisted requesters (authorized smart
contract addresses) to the database of the Chainlink node that is picking up
your requests and running the job calling your external adapter.

We wrote a short guide on how to do this:
<https://github.com/Linkriver/Chainlink-node-whitelisting>





:::NEXT DOC:::

contracts. The forwarder's owner must whitelist them to call the [forward](/chainlink-nodes/contracts/forwarder#forward) function. One operator contract owns one or multiple forwarder contracts.
  * Node operators manage their forwarder contracts through operator contracts. They use a secure wallet such as hardware or a multisig wallet as the operator's owner account.

## API Reference

The operator contract inherits
[AuthorizedReceiver](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/AuthorizedReceiver.sol)
and
[ConfirmedOwnerWithProposal](https://github.com/smartcontractkit/chainlink/edit/develop/contracts/src/v0.7/ConfirmedOwnerWithProposal.sol).
Read [AuthorizedReceiver](/chainlink-nodes/contracts/receiver) and
[ConfirmedOwnerWithProposal](/chainlink-nodes/contracts/ownership) API
references.

### Methods

#### oracleRequest

Legacy

Use `operatorRequest` function instead.


    function oracleRequest(address sender, uint256 payment, bytes32 specId, address callbackAddress, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. This is backwards compatible API with
[Oracle.sol
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol),
but the behavior changes because `callbackAddress` is assumed to be the same
as the request sender.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackAddress    | address | The consumer of the request                    |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### operatorRequest


    function operatorRequest(address sender, uint256 payment, bytes32 specId, bytes4 callbackFunctionId, uint256 nonce, uint256 dataVersion, bytes data) external

Creates the Chainlink request. Stores the hash of the params as the on-chain
commitment for the request. Emits OracleRequest event for the Chainlink node
to detect.

##### Parameters

| Name               | Type    | Description                                    |
|:-------------------|:--------|:-----------------------------------------------|
| sender             | address | The sender of the request                      |
|"
What is the Chainlink Solana Crate and how can it be used?,The Chainlink Solana Crate is a library that can be imported into an existing project to read Chainlink Data Feed data on-chain. It can be used to query price data by specifying the feed account and the Chainlink Data Feeds OCR2 Program for the network.,{'source': 'https://docs.chain.link/data-feeds/solana/using-data-feeds-solana/'},"The Chainlink Solana Crate is a dependency that can be added to a Rust project's `Cargo.toml` file to enable querying of price data from Chainlink Data Feeds on the Solana network. It can be used by including the Crate in the project's dependencies and using the provided code sample to query price data. The code sample includes functions to retrieve the latest round information, description, and precision of the price data.","# Data Feeds on Solana

  * Overview
  * Chainlink products and Solana clusters
  * Languages, tools, and frameworks
  * Solana Wallets

Chainlink provides data feeds on the [Solana](https://solana.com/) network.
Chainlink data feeds on Solana employ [Off-Chain Reporting
(OCR)](/architecture-overview/off-chain-reporting?parent=dataFeeds) to
aggregate data from data providers who pull from both centralized and
decentralized exchanges. Chainlink’s Solana deployment has no dependencies on
external blockchain networks such as Ethereum. In Solana, storage and smart
contract logic are separate. Programs store all the logic similar to an EVM
(Ethereum) smart contract. The accounts store all the data. Compared to
Solidity, the combination of an account and a program is equivalent to a smart
contract on an EVM chain. State and logic are separate in Solana.

Solana programs are stateless, so you don't always need to deploy your program
to the network to test it. You can deploy and test your programs on a [Solana
Test Validator](https://docs.solana.com/developing/test-validator). However,
to use Chainlink products on Solana, you must deploy your contract on-chain to
one of the supported Solana clusters.

Note

Please note that Price Feeds performance relies on the chains they are
deployed on. Periods of high network congestion may impact the frequency of
Chainlink Price Feeds. Subscribe to [Solana
status](https://status.solana.com/) notifications to stay updated on system
performance.

To learn how to mitigate risk to your applications, read the [Selecting
Quality Data Feeds](/data-feeds/selecting-data-feeds) page.

## Chainlink products and Solana clusters

[Price Feeds](/data-feeds/price-feeds/addresses?network=solana) are available
on the following Solana clusters:

  * [Solana Mainnet](https://solscan.io/)
  * [Solana Devnet](https://solscan.io/?cluster=devnet)

Solana provides a [Testnet cluster](https://docs.solana.com/clusters#testnet)
that runs newer [Solana releases](https://github.com/solana-labs/solana/releases), but Chainlink Data Feeds are not available on this
cluster.

See the [Solana Data Feeds](/data-feeds/price-feeds/addresses?network=solana)
page for a full list of Chainlink data feeds that are available on Solana.

To learn when more Chainlink services become available, follow us on
[Twitter](https://twitter.com/chainlink) or sign up for our [mailing
list](/resources/developer-communications?parent=dataFeeds).

## Languages, tools, and frameworks

The examples in the Chainlink documentation use the following languages,
tools, and frameworks:

  * [Node.js 14 or higher](https://nodejs.org/en/download/): Used to run client code
  * [Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust): A general-purpose programming language designed for performance and memory safety
  * [Anchor](https://project-serum.github.io/anchor/getting-started/introduction.html): A framework for the [Solana Sealevel runtime](https://github.com/solana-labs/sealevel) that provides several developer tools
  * [Chainlink Solana Starter Kit](https://github.com/smartcontractkit/solana-starter-kit): An Anchor based program and client that shows developers how to use and interact with Chainlink Data Feeds on Solana
  * [Solana CLI](https://docs.solana.com/cli): The Solana command line interface
  * [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git): Used to

:::NEXT DOC:::

Chainlink Solana Crate as an entry in your `Cargo.toml` file dependencies section, as shown in the [starter kit Cargo.toml example](https://github.com/smartcontractkit/solana-starter-kit/blob/main/programs/chainlink_solana_demo/Cargo.toml).
    
        [dependencies]
    chainlink_solana = ""1.0.0""

  2. Use the following code sample to query price data. Each function call to the Chainlink Solana library takes two parameters:

    * The [feed account](/data-feeds/price-feeds/addresses?network=solana) that you want to query.
    * The Chainlink Data Feeds OCR2 Program for the network. This is a static value that never changes.

The code sample has the following components:

    * `latest_round_data`: Returns the latest round information for the specified price pair including the latest price
    * `description`: Returns a price pair description such as SOL/USD
    * `decimals`: Returns the precision of the price, as in how many numbers the price is padded out to
    * `Display`: A helper function that formats the padded out price data into a human-readable price
    
        /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    use chainlink_solana as chainlink;
    
    use solana_program::{
        account_info::{next_account_info, AccountInfo},
        entrypoint,
        entrypoint::ProgramResult,
        msg,
        pubkey::Pubkey,
    };
    
    struct Decimal {
        pub value: i128,
        pub decimals: u32,
    }
    
    impl Decimal {
        pub fn new(value: i128, decimals: u32) -> Self {
            Decimal { value, decimals }
        }
    }
    
    impl std::fmt::Display for Decimal {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut scaled_val = self.value.to_string();
            if scaled_val.len() <= self.decimals as usize {
                scaled_val.insert_str(
                    0,
                    &vec![""0""; self.decimals as usize - scaled_val.len()].join(""""),
                );
                scaled_val.insert_str(0, ""0."");
            } else {
                scaled_val.insert(scaled_val.len() - self.decimals as usize, '.');
            }
            f.write_str(&scaled_val)
  "
Why is it important to assess the liquidity and reliability of a specific exchange when obtaining pricing data for a smart contract?,Assessing the liquidity and reliability of a specific exchange is important to avoid price manipulation and ensure that prices are accurately reported throughout a liquidity migration.,{'source': 'https://docs.chain.link/data-feeds/selecting-data-feeds/'},It is important to assess the liquidity and reliability of a specific exchange when obtaining pricing data for a smart contract to avoid price manipulation and ensure that the asset has sufficient liquidity in the market. Assets with low liquidity can be volatile and negatively impact the application and its users. Malicious actors might try to exploit volatility to take advantage of the logic in a smart contract and cause it to execute in a way that was not intended.,"Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Fast Gas Reliability

### Liquidity and its Distribution

If your smart contract relies on pricing data for a specific asset, make sure
that the asset has sufficient liquidity in the market to avoid price
manipulation. Assets with low liquidity can be volatile, which might
negatively impact your application and its users. Malicious actors might try
to exploit volatility to take advantage of the logic in a smart contract and
cause it to execute in a way that you did not intend.

Some data feeds obtain their pricing data from individual exchanges rather
than from aggregated price tracking services that gather their data from
multiple exchanges. These are marked as such in the docs page for that feed.
Assess the liquidity and reliability of that specific exchange.

_Liquidity migrations_ occur when a project moves its tokens from one
liquidity provider (such as a DEX, a CEX, or a new DeFi application) to
another. When liquidity migrations occur, it can result in low liquidity in
the original pool, making the asset susceptible to market manipulation. If
your project is considering a liquidity migration, you should coordinate with
relevant stakeholders, including liquidity providers, exchanges, oracle node
operators, and users, to ensure prices are accurately reported throughout the
migration.

Feeds for assets with low market liquidity where data providers exhibit an
abnormal price spread may, on occasion, see a price oscillate between two or
more price points within regular intervals. To mitigate risk associated with
such price oscillation, users must regularly monitor & assess the quality of
an asset’s liquidity. Similarly, assets with low market liquidity may
experience abnormal or volatile price movements due to erroneous trades.

Design and test your contracts to handle price spikes and implement risk
management measures to protect your assets. For example, create mock tests
that return various oracle responses.

### Single Source Data Providers

Some data providers use a single data source, which might be necessary if only
one source exists off-chain for a specific type of data. Evaluate data
providers to make sure they provide high-quality data that your smart
contracts can rely on. Any error or omission in the provider's data might
negatively impact your application and its users.

### Crypto and Blockchain Actions

Price data quality is subject to crypto actions by the crypto and blockchain
project teams. Crypto actions are similar to [corporate
actions](https://en.wikipedia.org/wiki/Corporate_action) but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require

:::NEXT DOC:::

Wrapped or Bridged Assets

### Assessing how to Price Wrapped or Bridged Assets

When assessing a Chainlink Price Feed for a wrapped or bridged asset such as
WBTC, users should evaluate the tradeoffs between using a price feed
specifically built for the wrapped or bridged asset or a price feed built for
the underlying asset.

Decisions should be made on a case-by-case basis considering the liquidity,
depth, and trading volatility of the underlying asset compared to its
derivative. In addition, users must consider the security mechanism that is
designed to keep the wrapped or bridged asset coupled to its underlying asset.
Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets

Chainlink Price Feeds are designed to provide the market-wide price of various
assets, as determined by a volume-weighted average across a wide range of
exchanges. On blockchain networks where assets are wrapped and/or bridged from
another environment using a cross-chain token bridge, Chainlink Price Feeds
built for the underlying asset will continue to report the market-wide price
of the underlying asset as opposed to the price of the wrapped/bridged asset.
This methodology reduces risks around market manipulation because
wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price
deviations between the wrapped/bridged asset and its underlying counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible for reviewing the quality of the data that you integrate into your
smart contracts.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/selecting-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of the VRFv2SubscriptionManager contract?,The VRFv2SubscriptionManager contract is an example contract that uses hardcoded values for clarity and uses un-audited code. It should not be used in production.,{'source': 'https://docs.chain.link/vrf/v2/subscription/examples/programmatic-subscription/'},"The purpose of the VRFv2SubscriptionManager contract is to create and manage subscriptions for the Chainlink VRF v2, allowing consumers to request and receive random values. It includes functions for creating and managing subscriptions, adding and removing consumers, funding the subscription with LINK tokens, and requesting random words.","#####Chapter 5: VRF Subscriptions

# Subscription Manager Contract

Now that we learned more about the theoretical background, let’s get practical. We want to create and manage a subscription contract. We will use the example contract that you can find here on [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js). It shows an example implementation of a VRF v2 Subscription manager for the Goerli network. But you can also adjust it to work with other networks by changing the code's hardcoded addresses. You can find a complete list of available networks [here](https://docs.chain.link/docs/vrf-contracts/#configurations).

Hint: This course assumes you are already familiar with the Architecture of Chainlink VRF from [VRFv2 Introduction Chapter 4](https://www.chainlink.education/vrfIntroduction/chapter-4).

Generally, consumer contracts must implement the requestRandomWords() function providing coordinator parameters and subscription ID. This function is used to create random values. A second function, fulfillRandomWords(), must be implemented to receive the random values. Learn about how to implement the basics of such a contract in [chapters 6-12](https://www.chainlink.education/vrfIntroduction/chapter-6) from the introduction course.

We want to focus on the mentioned functions here and show how to manage subscriptions in this contract. So let’s start by creating a new subscription:

<Highlight class=""language-javascript"">
uint64 public s_subscriptionId;
 function createNewSubscription() private onlyOwner {
   s_subscriptionId = COORDINATOR.createSubscription();
   COORDINATOR.addConsumer(s_subscriptionId, address(this));
 }
</Highlight>

We shall call this function when the contract is initially deployed using the constructor. The COORDINATOR is set to the COORDINATOR address in your network of choice. It is used to call the createSubscription() function. This returns an ID which is then used to add a new consumer using the same COORDINATOR contract. That’s already all you need to create a subscription and add a consumer. Now we can expand this and add or remove consumers using the corresponding functions (addConsumer, removeConsumer) to generate random numbers.

<Highlight class=""language-javascript"">
 function addConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
 }
 
 function removeConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
 }
</Highlight>

This was pretty straight forward. Before we implement the mandatory functions mentioned in the beginning, we will also add a function to topup the subscription with LINK tokens. That means we pre-fund the subscription so it can then be used to request random numbers without paying again, like in VRF v1.

<Highlight class=""language-javascript"">
 function topUpSubscription(uint256 amount) external onlyOwner {
   LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subscriptionId));
 }
</Highlight>

We assume that the contract itself has Link that we can use here. LINKTOKEN is the Link token contract. Now that we have the ability to manage consumers and funding, we will implement a simple function to request random words and received a request ID that we can use to get the random words. If the subscription is not set and funded it will revert. Note that the request might take several minutes to process.

<Highlight

:::NEXT DOC:::

VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  2. Import the new [`VRFConsumerBaseV2.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol) and remove the v1 `VRFConsumerBase.sol` import. This contract includes the `fulfillRandomWords` function.

  3. Import the [`VRFCoordinatorV2Interface.sol` interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol). This interface includes the new `requestRandomWords` function.

  4. Add a `VRFConsumerBaseV2` constructor as shown in the [Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number) example.

  5. Change `requestRandomness` function calls to `requestRandomWords`. The `requestRandomWords` function requires several additional parameters.

  6. Change `fulfillRandomness` function calls to `fulfillRandomWords`. Update the call to handle the returned `uint256[]` array instead of the single `uint256` variable.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription/migration-from-v1.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are the two methods offered by Chainlink VRF v2 for requesting randomness?,Chainlink VRF v2 offers two methods for requesting randomness: Subscription and Direct funding.,{'source': 'https://docs.chain.link/vrf/'},The two methods offered by Chainlink VRF v2 for requesting randomness are Subscription and Direct funding.,"# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                         

:::NEXT DOC:::

Question: (Asked on: 2023-01-19 03:22:56)
Possible Chainlink VRF returns two same randomnesses in one request?
URL: https://stackoverflow.com/questions/75167432/possible-chainlink-vrf-returns-two-same-randomnesses-in-one-request

Question Body:


as the title, i am thinking if it's possible that Chainlink VRF returns two
same randomnesses in one request? As of ""random"", i assume the answer is YES.
Thanks.



Answers:
(Answered on: 2023-01-19 08:57:48)


For each request, Chainlink VRF generates one or more random values and
cryptographic proof of how those values were determined. It is unlikely that a
Chainlink VRF would return the same randomness in one request.



"
What is the purpose of the `functions-simulate` command in the Chainlink Functions hardhat starter kit?,"The `functions-simulate` command executes your code in a local runtime environment and simulates an end-to-end fulfillment, helping you fix any issues before submitting your functions to a Decentralized Oracle Network.",{'source': 'https://docs.chain.link/chainlink-functions/tutorials/simple-computation/'},"The purpose of the `functions-simulate` command in the Chainlink Functions hardhat starter kit is to execute the Functions code in a local runtime environment and simulate an end-to-end fulfillment, which helps to fix any issues before submitting requests to the Decentralized Oracle Network.","to analyze the JavaScript source code. Read the source code explanation section for a more detailed explanation of how the source file is written.

### Simulation

The [Chainlink Functions hardhat starter
kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit)
includes a simulator to test your Functions code on your local machine. The
`functions-simulate` command will execute your code in a local runtime
environment and simulate an end-to-end fulfillment. Simulation can help you to
fix any issues before you submit your requests to the Decentralized Oracle
Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `Functions-request-source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/3-custom-response/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    HTTP GET Request to https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD
    ETH price is: 1810.29 USD. 24h Volume is 113255.87 USD. Market: Coinbase
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x7b227072696365223a22313831302e3239222c22766f6c756d65223a223131333235352e3837222c226c6173744d61726b6574223a22436f696e62617365227d
    Decoded as a string: {""price"":""1810.29"",""volume"":""113255.87"",""lastMarket"":""Coinbase""}
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x7b227072696365223a22313831302e3239222c22766f6c756d65223a223131333235352e3837222c226c6173744d61726b6574223a22436f696e62617365227d
    Decoded as a string: {""price"":""1810.29"",""volume"":""113255.87"",""lastMarket"":""Coinbase""}
    
    Gas used by sendRequest: 376604
    Gas used by client callback function: 98391

Reading the output of the example above, you can see that the `ETH/USD` price
is _1810.29 USD_ , volume is _113255.87_ , and the market is _Coinbase_.
Because the final result is a JSON object, the example converts it to a string
and returns the `bytes` encoded value
`0x7b227072696365223a22313831302e3239222c22766f6c756d65223a223131333235352e3837222c226c6173744d61726b6574223a22436f696e62617365227d`
in the callback. Read the source code explanation for a more detailed
explanation.

### Request

Reminder

Before you can make a successful request, you must complete the setup steps in
the Before you begin section. Each tutorial is in a separate Git branch and
some require unique entries in your `.env.enc` file.

Send a request to the Decentralized Oracle Network to fetch the asset price.
Run the `functions-request` task with the `subid` (subscription ID) and
`contract` parameters. This task passes the JavaScript source code, arguments,
and

:::NEXT DOC:::

command executes your code in a local runtime environment
and simulates an end-to-end fulfillment. This helps you to fix issues before
you submit functions to the Decentralized Oracle Network.

Run the `functions-simulate` task to run the source code locally and make sure
`config.js` and `source.js` are correctly written:


    npx hardhat functions-simulate --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-simulate --configpath tutorials/6-multiple-apis/config.js
    secp256k1 unavailable, reverting to browser version
    
    __Compiling Contracts__
    Nothing to compile
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    
    Executing JavaScript request source code locally...
    
    __Console log messages from sandboxed code__
    Median Bitcoin price: $28347.05
    
    __Output from sandboxed source code__
    Output represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b4111
    Decoded as a uint256: 2834705
    
    __Simulated On-Chain Response__
    Response returned to client contract represented as a hex string: 0x00000000000000000000000000000000000000000000000000000000002b4111
    Decoded as a uint256: 2834705
    
    Gas used by sendRequest: 398311
    Gas used by client callback function: 75029

Reading the output of the example above, you can note that the `BTC/USD`
median price is: _28347.05 USD_. Because Solidity does not support decimals,
we move the decimal point so that the value looks like the integer `2834705`
before returning the `bytes` encoded value
`0x00000000000000000000000000000000000000000000000000000000002b4111` in the
callback. Read the source code explanation for a more detailed explanation.

### Deploy an Automation Consumer contract

After running the simulator and confirming d that your Function runs without
issues, run the `functions-deploy-auto-client` command. This command does the
following:

  * Deploy the [AutomatedFunctionsConsumer.sol](https://github.com/smartcontractkit/functions-hardhat-starter-kit/blob/main/contracts/AutomatedFunctionsConsumer.sol) contract. You can set the interval of executions when deploying the contract.
  * Add the deployed contract to your subscription.
  * Simulate the request that is stored in your deployed contract.
  * Store the request, which includes the source code, encrypted gist URL, and arguments in the contract storage. **Note** : The stored request is sent to the DON according to the provided time interval.

In your terminal, run the `functions-deploy-auto-client` command:


    npx hardhat functions-deploy-auto-client --network REPLACE_NETWORK --subid REPLACE_SUBSCRIPTION_ID --interval REPLACE_INTERVAL_SECONDS --configpath REPLACE_CONFIG_PATH

Example:


    $ npx hardhat functions-deploy-auto-client --network polygonMumbai --subid 443 --interval 60 --configpath tutorials/6-multiple-apis/config.js
    secp256k1 unavailable, reverting to browser version
    Deploying AutomatedFunctionsConsumer contract to mumbai
    
    __Compiling Contracts__
    Nothing to compile
    
    Waiting 1 block for transaction 0x6d68add0027ac0228c9e4b284fda4cedff87a2e73892545f8d34922e9fff338e to be confirmed...
    Adding consumer contract address"
What is the purpose of disallowing local network and multicast IPs by default in HTTPGet?,"For security, because the URL can come from an untrusted source, HTTPGet imposes some restrictions on which IPs may be fetched. Local network and multicast IPs are disallowed by default and attempting to connect will result in an error.",{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/v1/adapters/'},The purpose of disallowing local network and multicast IPs by default in HTTPGet is for security reasons.,"Question: (Asked on: 2021-11-18 14:56:42)
how to enable local bridge/httpget/task api connection to chainlink node?
URL: https://stackoverflow.com/questions/70022029/how-to-enable-local-bridge-httpget-task-api-connection-to-chainlink-node

Question Body:


I have a custom API running on <http://127.0.0.1:8080> and I have my own
chainlink node running on <http://127.0.0.1:6688>. I get the error saying
""Connections to local/private and multicast networks are disabled by default
for security reasons: disallowed IP"" when sending requests.

I guess maybe we can enable it by modifying the env file, but I don't know
which configuration should I change. Does anyone know if we can enable these
local/private connections? and how to do that?



Answers:
(Answered on: 2021-11-20 17:32:25)


Per the [chainlink docs on the http
task](https://docs.chain.link/docs/jobs/task-types/http/):

> allowUnrestrictedNetworkAccess (optional): permits the task to access a URL
> at localhost, which could present a security risk. Note that Bridge tasks
> allow this by default.

ie:

    
    
    my_http_task [type=""http""
                  method=PUT
                  url=""http://chain.link""
                  requestData=""{\\""foo\\"": $(foo), \\""bar\\"": $(bar), \\""jobID\\"": 123}""
                  allowUnrestrictedNetworkAccess=true
                  ]
    

You can also use this flag in JSON





:::NEXT DOC:::

Question: (Asked on: 2022-01-02 16:18:48)
Ethereum Chainlink HTTP Get not pinging my HTTP endpoint
URL: https://stackoverflow.com/questions/70557627/ethereum-chainlink-http-get-not-pinging-my-http-endpoint

Question Body:


I am attempting to have my Ethereum smart contract connect to an external HTTP
endpoint using Chainlink. Following along with Chainlink's documentation
(<https://docs.chain.link/docs/advanced-tutorial/>) I deployed this contract
onto the Rinkeby testnet.

    
    
    pragma solidity ^0.8.7;
    
    import ""github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ChainlinkClient.sol"";
    
    // MyContract inherits the ChainlinkClient contract to gain the
    // functionality of creating Chainlink requests
    
    
    contract getHTTP is ChainlinkClient {
      using Chainlink for Chainlink.Request;
    
      bytes32 private thisDoesNotWork;
      address private owner;
      address private ORACLE_ADDRESS = 0x718Cc73722a2621De5F2f0Cb47A5180875f62D60;
      bytes32 private JOBID = stringToBytes32(""86b489ec4d84439c96181a8df7b22223"");
      string private url = ""<myHTTPAddressAsString>""; 
    
    // This endpoint URL is hard coded in my contract, and stored as a string (as in the example code). 
    // I control it and can have it reply with whatever I want, which might be an issue, returning data in a format that the oracle rejects
    
      uint256 constant private ORACLE_PAYMENT = 100000000000000000;
    
      constructor() public {
        // Set the address for the LINK token for the network
        setPublicChainlinkToken();
        owner = msg.sender;
      }
    
      function requestBytes() 
        public
        onlyOwner
      {
        Chainlink.Request memory req = buildChainlinkRequest(JOBID, address(this), this.fulfill.selector);
        req.add(""get"", url);
        sendChainlinkRequestTo(ORACLE_ADDRESS, req, ORACLE_PAYMENT);
      }
    
      function fulfill(bytes32 _requestId, bytes32 recVal)
        public
        recordChainlinkFulfillment(_requestId)
      {
        thisDoesNotWork = recVal;
      }
      function cancelRequest(
        bytes32 _requestId,
        uint256 _payment,
        bytes4 _callbackFunctionId,
        uint256 _expiration
      )
        public
        onlyOwner
      {
        cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);
      }
    
      
      // withdrawLink allows the owner to withdraw any extra LINK on the contract
      function withdrawLink()
 "
What is the purpose of the Proof of Reserve feeds mentioned in the text?,"The Proof of Reserve feeds are used to attest to the reserves held by various assets, including US Dollar, Gold, Staked ETH, Bitcoin, and Wrapped Filecoin, among others.",{'source': 'https://docs.chain.link/data-feeds/proof-of-reserve/addresses/'},"The purpose of the Proof of Reserve feeds mentioned in the text is to provide the status of reserves for several assets and to prove the reserves for these assets through several different methods, including off-chain and cross-chain reserves. These feeds can be read the same way as other Data Feeds and are used to make responsible data quality decisions in smart contracts.","the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Proof of Reserve Feeds

  * Overview
  * Types of Proof of Reserve Feeds
  * Off-chain reserves
  * Cross-chain reserves
  * Using Proof of Reserve Feeds

Chainlink Proof of Reserve Feeds provide the status of the reserves for
several assets. You can read these feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

To find a list of available Proof of Reserve Feeds, see the [Proof of Reserve
Feed Addresses](/data-feeds/proof-of-reserve/addresses) page.

## Types of Proof of Reserve Feeds

Reserves are available for both cross-chain assets and off-chain assets. This
categorization describes the data attestation variations of Proof of Reserve
feeds and helps highlight some of the inherent market risks surrounding the
data quality of these feeds.

Reserves are available for both off-chain assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
  * ⚠️ Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

### Cross-chain reserves

Cross-chain reserves are sourced from the network where the reserves are held.
Chainlink node operators can report cross-chain reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import"
What is the purpose of funding smart contracts with LINK or ETH?,Some smart contracts require funding at their addresses so they can operate without you having to call functions manually and pay for the transactions through MetaMask.,{'source': 'https://docs.chain.link/resources/fund-your-contract/'},The purpose of funding smart contracts with LINK or ETH is to allow them to operate without the need for manual function calls and transaction payments through MetaMask.,"# Fund Your Contracts

  * Overview
  * Retrieve the contract address
  * Send funds to your contract

Some smart contracts require funding at their addresses so they can operate
without you having to call functions manually and pay for the transactions
through MetaMask. This guide explains how to fund Solidity contracts with LINK
or ETH.

## Retrieve the contract address

  1. In Remix, deploy your contract and wait until you see a new contract in the **Deployed Contracts** section.
  2. On the left side panel, use the **Copy** button located near the contract title to copy the contract address to your clipboard.

## Send funds to your contract

  1. Open MetaMask.
  2. Select the network that you want to send funds on. For example, select the Sepolia testnet.
  3. Click the **Send** button to initiate a transaction.
  4. Paste your contract address in the address field.
  5. In the **Asset** drop down menu, select the type of asset that you need to send to your contract. For example, you can send LINK. If LINK is not listed, follow the guide to [Acquire testnet LINK](/resources/acquire-link).
  6. In the **Amount** field, enter the amount of LINK that you want to send.
  7. Click **Next** to review the transaction details and the Gas cost.
  8. If the transaction details are correct, click **Confirm** and wait for the transaction to process.

Transaction fee didn't update?

You may need to click **Fastest** , **Fast** , **Slow** , or **Advanced
Options** after entering the **Amount** to update the gas limit for the token
transfer to be successful.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/fund-your-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  * [Generate Verifiable Random Numbers (VRF)](/vrf/v2/introduction): Use Chainlink VRF to consume randomness in your smart contracts.
  * [Call External APIs (Any API)](/any-api/introduction): Request & Receive data from any API using the Chainlink contract library.
  * [Automate Smart Contract Functions (Automation)](/chainlink-automation/introduction): Automating smart contract functions and regular contract maintenance.

## What is Remix?

[Remix](https://remix.ethereum.org/) is a web IDE (integrated development
environment) for creating, running, and debugging smart contracts in the
browser. It is developed and maintained by the Ethereum foundation. Remix
allows Solidity developers to write smart contracts without a development
machine since everything required is included in the web interface. It allows
for a simplified method of interacting with deployed contracts, without the
need for a command line interface. Remix also has support for samples. This
means that Remix can load code from Github.

To learn how to use Remix, see the [Deploying Your First Smart Contract
](/getting-started/deploy-your-first-contract) guide.

## What is MetaMask?

Contracts are deployed by other addresses on the network. To deploy a smart
contract,"
What is the purpose of the `fulfillOracleRequest` function in the Oracle contract?,The `fulfillOracleRequest` function is used by the node to fulfill a request once it has the result of the job. This function returns the result to the `ChainlinkClient` using the callback function defined in the original request.,{'source': 'https://docs.chain.link/architecture-overview/architecture-request-model/'},The purpose of the `fulfillOracleRequest` function in the Oracle contract is to receive the response from the external API call and fulfill the Chainlink request with the requested data.,"    
            // Set the path to find the desired data in the API response, where the response format is:
            // {""player"": {
            //            ""id"": ""4291820"",
            //            ""score"": 560
            //        }
            //  }
            request.add(""path"", ""player.score"");
            
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, uint256 _score) public recordChainlinkFulfillment(_requestId)
        {
            playerScore = _score;
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    



Answers:
(Answered on: 2022-07-22 23:02:38)


I succeed to implement an external API call from a smart-contract by using
[Frensprotocol oracle](https://www.frensprotocol.com). The
[documentation](https://docs.frensprotocol.com/) helped. And to get the tokens
to make the Oracle work you can contact their team on Discord or Twitter.





:::NEXT DOC:::

                  |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes32 | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### fulfillOracleRequest2


    function fulfillOracleRequest2(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data) external returns (bool)

Called by the Chainlink node to fulfill requests with multi-word support.
Given params must hash back to the commitment stored from `oracleRequest`.
Will call the callback address' callback function without bubbling up error
checking in a `require` so that the node can get paid. Emits OracleResponse
event.

##### Parameters

| Name               | Type    | Description                                                                    |
|:-------------------|:--------|:-------------------------------------------------------------------------------|
| requestId          | bytes32 | The fulfillment request ID that must match the requester's                     |
| payment            | uint256 | The payment amount that will be released for the oracle (specified in wei)     |
| callbackAddress    | address | The callback address to call for fulfillment                                   |
| callbackFunctionId | bytes4  | The callback function ID to use for fulfillment                                |
| expiration         | uint256 | The expiration that the node should respond by before the requester can cancel |
| data               | bytes   | The data to return to the consuming contract                                   |
##### Return values

|   Name | Type   | Description                                |
|-------:|:-------|:-------------------------------------------|
|    nan | bool   | Status if the external call was successful |
#### transferOwnableContracts


    function transferOwnableContracts(address[] ownable, address newOwner) external

Transfer the ownership of ownable contracts. This is primarily intended for
authorized forwarders but could possibly be extended to work with future
contracts.

##### Parameters

| Name     | Type      | Description                      |
|:---------|:----------|:---------------------------------|
| ownable  | address[] | list of addresses to transfer    |
|"
What is the purpose of the 'proposedFeed' function?,The 'proposedFeed' function is used to propose a new price feed for a given base and quote currency pair.,{'source': 'https://docs.chain.link/data-feeds/feed-registry/'},The 'proposedFeed' function is not mentioned in the given context information.," ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""proposedLatestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""id"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""contract AccessControllerInterface"", name: ""_accessController"", type: ""address"" }],
        name: ""setAccessController"",
        outputs: [],
        stateMutability: ""nonpayable"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""address"", name: ""to"", type: ""address"" }],
        name: ""transferOwnership"",
        outputs: [],
        stateMutability: ""nonpayable"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""typeAndVersion"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""pure"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x47Fb2585D2C56Fe188D0E6ec628a38b74fCeeeDf""
    const feedRegistry = new web3.eth.Contract(feedRegistryInterfaceABI, addr)
    const LINK = ""0x514910771AF9Ca656af840dff83E8264EcF986CA""
    const USD = ""0x0000000000000000000000000000000000000348""
    
    feedRegistry.methods
      .latestRoundData(LINK, USD)
      .call()
      .then((roundData) => {
        // Do

:::NEXT DOC:::

""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
        ],
        name: ""getProposedFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""proposedAggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" },
        ],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
        ],
        name: ""getRoundFeed"",
        outputs: [{ internalType: ""contract AggregatorV2V3Interface"", name: ""aggregator"", type: ""address"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [
          { internalType: ""address"", name: ""base"", type: ""address"" },
          { internalType: ""address"", name: ""quote"", type: ""address"" },
          { internalType: ""uint256"", name: ""roundId"", type: ""uint256"" },
        ],
        name: ""getTimestamp"",
        outputs: [{ internalType: ""uint256"", name: ""timestamp"", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""address"", name: ""aggregator"", type: ""address"" }],
        name: ""isFeedEnabled"",
        outputs: [{ internalType: ""bool"", name: """", type: ""bool"" }],
        stateMutability: ""view"",
        type:"
What is Chainlink VRF and how can it be used in smart contracts?,Chainlink VRF is a provably-fair and verifiable source of randomness designed for smart contracts. Smart contract developers can use Chainlink VRF as a tamper-proof random number generator (RNG) to build reliable smart contracts for any applications which rely on unpredictable outcomes.,{'source': 'https://docs.chain.link/vrf/v1/introduction/'},"Chainlink VRF (Verifiable Randomness Function) is a service that provides cryptographic proof alongside every random number generated, ensuring that the random number wasn't tampered with and generated in a random way. It consists of the DON (computers running the Chainlink nodes) and two main smart contracts: the Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2). The Client Contract allows a contract to send requests and receive answers from the Chainlink VRF, while the Coordinator contract manages subscriptions to the Chainlink VRF and verifies every random number alongside its proof. Smart contracts can use Chainlink VRF to generate verifiably random and decentralized randomness.","#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!


:::NEXT DOC:::

#####Chapter 3:

# Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson randomness provided by an outside service needs to be verifiable and decentralized, and that’s exactly what Chainlink VRF is! VRF stands for Verifiable Randomness Function. Essentially Chainlink VRF provides cryptographic proof alongside every random number generated, that the random number wasn’t tampered with (and indeed generated in a random way).

How does this cryptographic proof work? It’s quite mathematically complicated and outside the scope of this lesson, but you can read more about it in the “Technical Walkthrough” section of this [blog post](https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/). The cryptographic proof is then verified by a smart contract on-chain, which means it is verified by every node on the blockchain! This completes our verifiable and decentralized criteria. So now we understand that Chainlink VRF is verifiably random and decentralized how do we use it?
"
What is the purpose of the useChainlinkWithENS function?,"The useChainlinkWithENS function allows a Chainlink contract to store the addresses of the LINK token and oracle contract addresses without supplying the addresses themselves, using ENS where available to resolve these addresses.",{'source': 'https://docs.chain.link/any-api/api-reference/'},"The useChainlinkWithENS function allows a Chainlink contract to store the addresses of the LINK token and oracle contract addresses without supplying the addresses themselves, using ENS where available to resolve these addresses. It requires the address of the ENS contract and the node for the domain. This function is used for updating oracle addresses and is part of the Chainlink Functions platform.","_expiration
    ) public {
      cancelChainlinkRequest(_requestId, _payment, _callbackFunc, _expiration);
    }

### useChainlinkWithENS


    function useChainlinkWithENS(
      address _ens,
      bytes32 _node
    )

Allows a Chainlink contract to store the addresses of the LINK token and
oracle contract addresses without supplying the addresses themselves. We use
ENS where available to resolve these addresses. It requires the address of the
ENS contract and the node (which is a hash) for the domain.

If your Oracle provider supports using ENS for rolling upgrades to their
oracle contract, once you've pointed your Chainlinked contract to the ENS
records then you can update the records using updateChainlinkOracleWithENS.


    address constant ROPSTEN_ENS = 0x112234455C3a32FD11230C42E7Bccd4A84e02010;
    bytes32 constant ROPSTEN_CHAINLINK_ENS = 0xead9c0180f6d685e43522fcfe277c2f0465fe930fb32b5b415826eacf9803727;
    
    constructor(){
      useChainlinkWithENS(ROPSTEN_ENS, ROPSTEN_CHAINLINK_ENS);
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/Oracle.sol)
or trust whoever can update the records.

### updateChainlinkOracleWithENS


    function updateChainlinkOracleWithENS()

Updates the stored oracle contract address with the latest address resolved
through the ENS contract. This requires the oracle provider to support listing
their address on ENS.

This method only works after useChainlinkWithENS has been called on the
contract.


    function updateOracleAddressToLatest() public {
      updateChainlinkOracleWithENS();
    }

Updating oracle addresses

If an oracle provider supports listing their oracle on ENS, that provides the
added security of being able to update any issues that may arise. The tradeoff
here is that by using their ENS record, you are allowing whoever controls that
record and the corresponding code it points to. If your contract does this,
you must either audit the updated code and make sure it matches
[Oracle.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.4/Oracle.sol)
or trust whoever can update the records.

### chainlinkTokenAddress


    function chainlinkTokenAddress() returns (address)

The `chainlinkTokenAddress` function is a helper used to return the stored
address of the Chainlink token. This variable is protected and so only made
available through getters and setters.


    function withdrawLink() public {
      LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
    
      require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
    }

### chainlinkOracleAddress

The `chainlinkOracleAddress` function is a helper used to return the stored
address of the oracle contract.


    function getOracle() public view returns (address) {
      return chainlinkOracleAddress();
    }
    

## Events

### ChainlinkRequested


    event ChainlinkRequested(


:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature"
What is the minimum spend requirement for each registered upkeep in the Keepers Registry v1.2?,"Each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam.",{'source': 'https://docs.chain.link/chainlink-automation/automation-release-notes/'},"The minimum spend requirement for each registered upkeep in the Keepers Registry v1.2 is 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam.","Release

Keepers Registry v1.2 launched on Ethereum, Binance Smart Chain, Polygon,
Avalanche, and Fantom

  * **Automatic upkeep registration approval** : All upkeeps on supported mainnets are now automatically approved.

  * **Programmatic control** : With automatic approval, you can now dynamically create, manage, and fund upkeeps from within your dApps and even have an upkeep fund itself. Learn more [here](/chainlink-automation/register-upkeep/#register-an-upkeep-using-your-own-deployed-contract).

  * **Advanced turn-taking algorithm** : Our turn taking algorithm now supports upkeeps that require high-frequency execution.

  * **Durable ID and user-triggered migration** : All upkeeps created in versions v1.2 and later will have durable IDs. v1.2 also supports user-triggered migration to future registry versions to make it easier to migrate to a new Keepers Registry and benefit from new features. Future migrations can still retain the existing ID. The ID is now a hash in format of a 77 digit integer.

  * **Configurable upkeeps** : You can now edit the gas limit of your upkeep to easily customize your upkeep to fit your needs without having to create a new upkeep.

  * **Off-chain compute improvements** : The off-chain compute sequence is improved for higher-fidelity representation of the gas and logic before transactions are submitted on-chain. This helps to reduce reverts and reduce fees.

  * **Minimum spend requirement** : As part of the mission to continuously enhance the security of the Chainlink Network for all participants, each registered upkeep will have a minimum spend requirement of 0.1 LINK, in aggregate across all transactions for the upkeep, to discourage network spam. Note that an _upkeep_ is the automation job itself. It is not a transaction. Each upkeep can have thousands of transactions. If an upkeep has not spent more than 0.1 LINK across all transactions at the time of cancellation, then 0.1 LINK will be retained for the network. If more than 0.1 LINK has been spent by an upkeep, the full remaining balance of the upkeep will be withdrawable when the upkeep is canceled.

### Manually migrating upkeeps from v1.1 to v1.2

If your upkeep ID has 77 digits, it is already migrated to v1.2 and no further
action is required. If your upkeep ID has less than 4 digits, your upkeep is
on the v1.1 registry. To migrate your upkeep from Keepers v1.1 to Keepers
v1.2, you can cancel it in the Keepers App, and register an exact copy of the
upkeep in the Keepers App. While you can see upkeeps from both v1.1 and v1.2
in the [Keepers App](https://automation.chain.link), all new upkeeps in the
Keepers App will be automatically created on Keepers v1.2.

## 2022-07-21 - Underfunded upkeep notifications

You will now receive notifications to the email address you register in your
upkeep when your upkeep is underfunded. We are limiting notifications on the
same upkeep to once per week.

## 2022-06-29 - Keepers on Fantom

Chainlink Keepers is live on the Fantom Network,
[Mainnet](https://automation.chain.link/fantom) and
[Testnet](https://automation.chain.link/fantom-testnet).

## 2022-06-09 - Keepers on Avalanche

Chainlink Keepers is live on the Avalanche Network,
[Mainnet](https://automation.chain.link/avalanche) and
[Testnet](https://automation.chain.link/fuji).

## 2022-03-01 - Keepers on Ethereum Rinkeby

Chainlink Keepers is live on

:::NEXT DOC:::

# Managing Upkeeps

  * Overview
  * Fund your Upkeep
  * Maintain a Minimum Balance
  * Withdraw funds
  * Interacting directly with the Chainlink Automation Registry

Manage your Upkeeps to get the best performance.

## Fund your Upkeep

You must monitor the balance of your Upkeep. If the Upkeep LINK balance drops
below the [minimum balance](/chainlink-automation/automation-economics/#minimum-balance), the Chainlink Automation Network will not perform
the Upkeep.

ERC677 Link

For funding on Mainnet, you need ERC-677 LINK. Many token bridges give you
ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be
ERC-677 compatible](https://pegswap.chain.link/). To fund on a supported
testnet, get [LINK](/resources/link-token-contracts) from
[faucets.chain.link](https://faucets.chain.link/).

Follow these steps to fund your Upkeep:

  1. **Click`View Upkeep`** or go to the [Chainlink Automation App](https://automation.chain.link) and click on your recently registered Upkeep under My Upkeeps.

  2. **Click the`Add funds` button**

  3. **Approve the LINK spend allowance**

  4. **Confirm the LINK transfer** by sending funds to the Chainlink Automation Network Registry 

  5. **Receive a success message** and verify that the funds were added to the Upkeep 

## Maintain a Minimum Balance

Each Upkeep has a [minimum balance](/chainlink-automation/automation-economics/#minimum-balance) to ensure that an Upkeeps will still run should a
sudden spike occur. If your Upkeep LINK balance drops below this amount, the
Upkeep will not be performed.

To account for Upkeep execution over time and possible extended gas spikes,
maintain an Upkeep LINK balance that is 3 to 5 times the minimum balance. Note
if you have an upkeep that performs frequently you may want to increase the
buffer to ensure a reasonable interval before you need to fund again.
Developers also have the ability to update `performGasLimit` for an upkeep.

## Withdraw funds

To withdraw funds, the Upkeep administrator have to cancel the Upkeep first.
There is a 50 block delay once an Upkeep has been cancelled before funds can
be withdrawn. Once 50 blocks have passed, select **Withdraw funds**.

## Interacting directly with the Chainlink Automation Registry

After registration, you can interact directly with the [registry
contract](/chainlink-automation/supported-networks/#configurations) functions
such as `cancelUpkeep` and `addFunds` using your **Upkeep ID**. The Registry
Address might change when new contracts are deployed with new functionality.

## What's next

  * [› Automation economics](/chainlink-automation/automation-economics/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/manage-upkeeps.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the purpose of setting the `const consumerAddress` in the `request.js` script?,To set the deployed consumer address,{'source': 'https://docs.chain.link/chainlink-functions/resources/add-functions-to-projects/'},The purpose of setting the `const consumerAddress` in the `request.js` script is not mentioned in the given context information.,"            sender,
                requestId,
                payment,
                sender,
                callbackFunctionId,
                expiration,
                dataVersion,
                data
            );
        }
    
    

I removed the `oracleRequest()` function because it exceeds stack size by
adding more modifiers to it and since I can use `operatorRequest()` to fulfill
both multi-word and single-word requests I will make that method deprecated by
reverting everytime it's called.

The modifier that sets the authorized consumer is basically the following:

    
    
        /**
         * @dev function used to change the authorized consumer. Can only be set once
         */
        function setAuthorizedConsumer(address _consumer) public onlyOwner {
            require(
                authorizedConsumer == address(0),
                ""authorized consumer is already set""
            );
            authorizedConsumer = _consumer;
        }
    
        /**
         * @notice validates the consumer is an authorized consumer
         */
        function _validateIsAuthorizedConsumer(address _consumer) internal view {
            require(_consumer == authorizedConsumer, ""Not authorized sender"");
        }
    
        /**
         * @notice prevents non-authorized addresses from calling this method
         */
        modifier validateIsAuthorizedConsumer(address _consumer) {
            _validateIsAuthorizedConsumer(_consumer);
            _;
        }
    
    
    


---
(Answered on: 2021-12-29 08:59:47)


You can restrict the access by adding whitelisted requesters (authorized smart
contract addresses) to the database of the Chainlink node that is picking up
your requests and running the job calling your external adapter.

We wrote a short guide on how to do this:
<https://github.com/Linkriver/Chainlink-node-whitelisting>





:::NEXT DOC:::

supported networks and oracle addresses. For this example, use the address for the oracle on Polygon Mumbai:
    
        const oracleAddress = ""0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4""

  4. Set `const contractName` to the name of the contract that you want Hardhat to deploy. The `ethers.getContractFactory(contractName);` line creates a `ContractFactory` object using the contract that you define. For this example, use `FunctionsConsumer`.
    
        const contractName = ""FunctionsConsumer""
    
    ⋮
    
    const consumerContract = await ethers.getContractFactory(contractName);

  5. Save the file and run the script to deploy your contract. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run ./scripts/deploy.js --network your_network

Example:

    
        npx hardhat run ./scripts/deploy.js --network polygonMumbai

  6. If your contract deployed successfully, you will see the deployed consumer address. Record this address to use later:
    
        Deployed Functions Consumer address: 0x5484e266c2cD379800e6F27EaB097Bb806647CbF

Next, create and fund your Chainlink Functions subscription.

### Create and fund a subscription

You can use the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to
create and manage your subscriptions. See [Managing Subscriptions](/chainlink-functions/resources/subscriptions) for instructions.

This example shows how to create and manage subscriptions programmatically.
You can create the subscription, fund the subscription, and authorize the
consumer all in one script. If you have not already signed up for limited Beta
access to Chainlink Functions, apply [here](http://functions.chain.link/) to
add your EVM account address to the Allow List.

  1. Ensure that the wallet address you are using to create the subscription has a sufficient LINK balance. You can get testnet LINK at [faucets.chain.link](https://faucets.chain.link/mumbai). To get testnet funds for other networks, see the [LINK Token Contracts](/resources/link-token-contracts?parent=chainlinkFunctions) page.

  2. Use `curl` to get the example subscription script `functions-sub.js` and put it in the `./scripts` folder of your project:
    
        curl -o ./scripts/functions-sub.js https://raw.githubusercontent.com/smartcontractkit/smart-contract-examples/main/add-functions-to-project/scripts/functions-sub.js

  3. Open `functions-sub.js` in your editor of choice.

  4. Set `const linkAmount` with the amount of LINK you want to send to the subscription. You can retrieve extra funds later when you cancel the subscription.
    
        const linkAmount = ""1""

  5. Set `const consumer` to the address of the consumer contract that you deployed:
    
        const consumer = ""0x5484e266c2cD379800e6F27EaB097Bb806647CbF""

  6. Save the file and run the script. Include the `--network` flag to use a network other than the default in the Hardhat config:
    
        npx hardhat run scripts/functions-sub.js --network your_network

Example:

    
        npx hardhat run scripts/functions-sub.js --network"
What is the purpose of the Subscription Manager in Chainlink VRF?,"The Subscription Manager lets you create an account and pre-pay for VRF requests, so that funding of all your application requests are managed in a single location.",{'source': 'https://docs.chain.link/getting-started/intermediates-tutorial/'},"The purpose of the Subscription Manager in Chainlink VRF is to create and manage a subscription contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. It allows consumer contracts to have much more flexibility in requesting random numbers, such as specifying how many random numbers they want to request, how much they are willing to pay for gas, and setting a limit to how much gas will be spent by the VRF when submitting the random number. The amount of LINK token to be paid to the VRF can be dynamic based on network conditions.","#####Chapter 5: VRF Subscriptions

# Subscription Manager Contract

Now that we learned more about the theoretical background, let’s get practical. We want to create and manage a subscription contract. We will use the example contract that you can find here on [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js). It shows an example implementation of a VRF v2 Subscription manager for the Goerli network. But you can also adjust it to work with other networks by changing the code's hardcoded addresses. You can find a complete list of available networks [here](https://docs.chain.link/docs/vrf-contracts/#configurations).

Hint: This course assumes you are already familiar with the Architecture of Chainlink VRF from [VRFv2 Introduction Chapter 4](https://www.chainlink.education/vrfIntroduction/chapter-4).

Generally, consumer contracts must implement the requestRandomWords() function providing coordinator parameters and subscription ID. This function is used to create random values. A second function, fulfillRandomWords(), must be implemented to receive the random values. Learn about how to implement the basics of such a contract in [chapters 6-12](https://www.chainlink.education/vrfIntroduction/chapter-6) from the introduction course.

We want to focus on the mentioned functions here and show how to manage subscriptions in this contract. So let’s start by creating a new subscription:

<Highlight class=""language-javascript"">
uint64 public s_subscriptionId;
 function createNewSubscription() private onlyOwner {
   s_subscriptionId = COORDINATOR.createSubscription();
   COORDINATOR.addConsumer(s_subscriptionId, address(this));
 }
</Highlight>

We shall call this function when the contract is initially deployed using the constructor. The COORDINATOR is set to the COORDINATOR address in your network of choice. It is used to call the createSubscription() function. This returns an ID which is then used to add a new consumer using the same COORDINATOR contract. That’s already all you need to create a subscription and add a consumer. Now we can expand this and add or remove consumers using the corresponding functions (addConsumer, removeConsumer) to generate random numbers.

<Highlight class=""language-javascript"">
 function addConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.addConsumer(s_subscriptionId, consumerAddress);
 }
 
 function removeConsumer(address consumerAddress) external onlyOwner {
   COORDINATOR.removeConsumer(s_subscriptionId, consumerAddress);
 }
</Highlight>

This was pretty straight forward. Before we implement the mandatory functions mentioned in the beginning, we will also add a function to topup the subscription with LINK tokens. That means we pre-fund the subscription so it can then be used to request random numbers without paying again, like in VRF v1.

<Highlight class=""language-javascript"">
 function topUpSubscription(uint256 amount) external onlyOwner {
   LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subscriptionId));
 }
</Highlight>

We assume that the contract itself has Link that we can use here. LINKTOKEN is the Link token contract. Now that we have the ability to manage consumers and funding, we will implement a simple function to request random words and received a request ID that we can use to get the random words. If the subscription is not set and funded it will revert. Note that the request might take several minutes to process.

<Highlight

:::NEXT DOC:::

#####Chapter 5: VRF Subscriptions

# Subscribing to the VRF
Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number. 

## VRFv2
In VRFv2, the most recent version of the VRF, the concept of a subscription was added. What is a subscription? Essentially, it's an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. Once a subscription is set-up a consumer contract can then request randomness, the VRF respondes with a random number and proof, and then after the random number is included on-chain the VRF is paid with some of the LINK prepaid in the subscription.

The power that comes from this subscription model is that now consumer contracts have much more flexibility in requesting random numbers. Before subscriptions it was a static price, and the VRF always returned a single random number. 
 
But what if the consumer contract needs more than one random number? The consumer contract can now specify how many random numbers it wants to request.  
 
What if the consumer contract needs the random number to be included very fast by paying a higher gas price? The consumer contract can now request how much it's willing to pay for gas. This is called the **gas lane**. 
 
What if the consumer contract needs to run some heavy calculations after recieving the random number? It can set a limit to how much gas will be spent by the VRF when submitting the random number. This is called the **callbackGasLimit**.

And because this is all pre-paid via the subscription, and credited from the subscription amount after the VRF has responded with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! "
What is the purpose of operating a Chainlink node?,"Operating a Chainlink node allows you to be part of the Chainlink Network, helping developers build hybrid smart contracts, giving them access to real-world data and services.",{'source': 'https://docs.chain.link/chainlink-nodes/'},The purpose of operating a Chainlink node is to be part of the Chainlink Network and help developers build hybrid smart contracts by giving them access to real-world data and services.,"# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Fulfilling Requests

  * Overview
  * Requirements
  * Address Types
  * Setup your Operator contract
  * Deploy your own Operator contract
  * Whitelist your node address in the Operator contract
  * Add a job to the node
  * Create a request to your node
  * Withdrawing LINK

Run a Chainlink node

This guide assumes you have a running Chainlink node. To learn how to run a
node, see the [Running a Chainlink Node locally](/chainlink-nodes/v1/running-a-chainlink-node) guide.

You can use your Chainlink nodes to fulfill requests. This guide shows you how
to deploy your own operator contract and add jobs to your node so that it can
provide data to smart contracts.

Chainlink nodes can fulfill requests from open or unauthenticated APIs without
the need for [External Adapters](/chainlink-nodes/external-adapters/external-adapters) as long as you've added the jobs to the node. For these requests,
requesters supply the URL to the open API that they want each node to
retrieve. The Chainlink node will use [tasks](/chainlink-nodes/oracle-jobs/tasks) to fulfill the request.

Some APIs require authentication by providing request headers for the
operator's API key, which the Chainlink node supports. If you would like to
provide access to an API that requires authentication, you must create a job
that is specific for that API either using an [external adapter](/chainlink-nodes/external-adapters/external-adapters) or by using the parameters of the
[HTTP task](/chainlink-nodes/oracle-jobs/all-tasks/#http-task).

## Requirements

Before you begin this guide, complete the following tasks to make sure you
have all of the tools that you need:

  * [Set up MetaMask](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) and [obtain testnet LINK](/resources/acquire-link).

  * [Run a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node).

  * Fund the Ethereum address that your Chainlink node uses. You can find the address in the node Operator GUI under the **Key Management** configuration. The address of the node is the `Regular` type. You can obtain test ETH from several [faucets](/resources/link-token-contracts). For this tutorial to work, you will have to fund the node's Ethereum address with Sepolia ETH. Here is an example:

## Address Types

Your node works with several different types of addresses. Each address type
has a specific function:

  * **Node address:** This is the address for your Chainlink node wallet. The node requires native blockchain tokens at all times to respond to requests. For this example, the node uses Sepolia ETH. When you start a Chainlink node, it automatically generates this address. You can find this address on the Node Operator GUI under **Key Management > EVM Chain Accounts**.
  * **Oracle contract address:** This is the address for contracts like `Operator.sol` or `Oracle.sol` that are deployed to a blockchain. Do not fund these addresses with native blockchain tokens such as ETH. When you make API call requests, the funds pass through this contract to interact with your Chainlink node. This will be the address that smart contract developers point to when they choose a node for an API call.
  * **Admin wallet address:** This is the address that owns your `Operator.sol` or `Oracle.sol` contract addresses. If you're on OCR, this is the wallet address that receives LINK tokens.

## Setup your Operator contract

### Deploy your own Operator contract

  1. Go to Remix and open the [`Operator.sol` smart contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/ChainlinkNodes/Operator.sol).

  2. On the **Compile** tab, click the **Compile** button"
Why is randomness important in many types of applications?,Randomness is important in many types of applications because it is an essential component of a majority of games.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-1/course.md'},Randomness is important in many types of applications because it is an essential component of a majority of games and is necessary for applications such as raffles and other types of applications that utilize randomness.,"#####Chapter 2:

# Randomness and Deterministic Machines

Computers are deterministic machines. Per definition, they cannot produce randomness without any external inputs. Once this external input is given, Computer Science has found different methods to generate random numbers. We distinguish between true random number generators (RNG) and pseudo-random number generators (PRNG). You can use a PRNG if your random generator does not need any security guarantees. For example, if you are programming a simple coin-flipping game that you want to use daily to decide between two options, you can use a PRNG like JavaScripts Math.random(). It uses computational algorithms to produce apparently random results. These results are entirely depending on an initial seed. So if the seed is known, the same result can be reproduced.

This might work for prototypes and many practical applications. But imagine you want to encrypt a message. You would use a public key to encrypt the message and only the private key could decrypt it. The private key needs to be created at some point. Public key cryptography uses random numbers as input to calculate and create key pairs. If your source of randomness is something like Math.random(), it will be far more feasible for an attacker to guess your private key by brute-forcing the “random” numbers which is produced by this function. In other words, it drastically reduces the search space for the attacker. And the more they know about your conditions, the easier it is for them to find the correct private key as they have to search through fewer options.

Luckily, there are also true random number generators that we can use. They usually rely on measuring physical phenomena like atmospheric noise. It uses a natural source of entropy to avoid any brute-force attacks. This is critical to generating random numbers. Unpredictability is an essential requirement for true random number generators. Unpredictable means no one can reproduce the result by taking the same system as an input. So you cannot simply measure the same atmospheric noise to produce similar results. They will be completely different. So the quality of entropy becomes a fundamental metric. Once this is given, there are different tools to translate this into random numbers.


:::NEXT DOC:::

#####Chapter 1:

# Randomness

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      With your newfound power, understanding of what smart contracts are you want to develop a smart contract to raffle an NFT to your friends. But how will you get randomness into your raffle smart contract?
    </div>
  </div>
</ContentWrapp>

Randomness is essential for many types of applications. Think about how many games have randomness built-in. Rolling dice in dungeons and dragons, a random starting hand of poker, or a random next block in Tetris, randomness is an essential component of a majority of games. As we learned in Chainlink 101, smart contracts are a powerful tool for decentralized applications (dapps). But what if you want to build a game, raffle or any other type of application that utilizes randomness on the blockchain? Let's learn about randomness on the blockchain in the next lesson!
"
What is the Monte Carlo fallacy?,The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md'},The Monte Carlo fallacy describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,"#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let’s take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.


:::NEXT DOC:::

#####Chapter 2:

# Randomness and Deterministic Machines

Computers are deterministic machines. Per definition, they cannot produce randomness without any external inputs. Once this external input is given, Computer Science has found different methods to generate random numbers. We distinguish between true random number generators (RNG) and pseudo-random number generators (PRNG). You can use a PRNG if your random generator does not need any security guarantees. For example, if you are programming a simple coin-flipping game that you want to use daily to decide between two options, you can use a PRNG like JavaScripts Math.random(). It uses computational algorithms to produce apparently random results. These results are entirely depending on an initial seed. So if the seed is known, the same result can be reproduced.

This might work for prototypes and many practical applications. But imagine you want to encrypt a message. You would use a public key to encrypt the message and only the private key could decrypt it. The private key needs to be created at some point. Public key cryptography uses random numbers as input to calculate and create key pairs. If your source of randomness is something like Math.random(), it will be far more feasible for an attacker to guess your private key by brute-forcing the “random” numbers which is produced by this function. In other words, it drastically reduces the search space for the attacker. And the more they know about your conditions, the easier it is for them to find the correct private key as they have to search through fewer options.

Luckily, there are also true random number generators that we can use. They usually rely on measuring physical phenomena like atmospheric noise. It uses a natural source of entropy to avoid any brute-force attacks. This is critical to generating random numbers. Unpredictability is an essential requirement for true random number generators. Unpredictable means no one can reproduce the result by taking the same system as an input. So you cannot simply measure the same atmospheric noise to produce similar results. They will be completely different. So the quality of entropy becomes a fundamental metric. Once this is given, there are different tools to translate this into random numbers.
"
What does VRF stand for in Chainlink VRF?,VRF stands for Verifiable Randomness Function.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-3/course.md'},VRF stands for Verifiable Randomness Function in Chainlink VRF.,"#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!


:::NEXT DOC:::

#####Chapter 3:

# Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson randomness provided by an outside service needs to be verifiable and decentralized, and that’s exactly what Chainlink VRF is! VRF stands for Verifiable Randomness Function. Essentially Chainlink VRF provides cryptographic proof alongside every random number generated, that the random number wasn’t tampered with (and indeed generated in a random way).

How does this cryptographic proof work? It’s quite mathematically complicated and outside the scope of this lesson, but you can read more about it in the “Technical Walkthrough” section of this [blog post](https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/). The cryptographic proof is then verified by a smart contract on-chain, which means it is verified by every node on the blockchain! This completes our verifiable and decentralized criteria. So now we understand that Chainlink VRF is verifiably random and decentralized how do we use it?
"
What is Solidity?,"Solidity is a smart contract programming language created by Ethereum developers to work with Ethereum, the first major smart contract blockchain.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-1/course.md'},"Solidity is a programming language used for writing smart contracts, particularly on the Ethereum blockchain. It is an object-oriented programming language and is the most popular language for writing smart contracts.","#####Chapter 1:

# Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Inspired by the power of smart contracts and blockchain, it’s time to dive in.
    </div>
  </div>
</ContentWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent. If you are familiar with some programming, it may help to know that Solidity is an **object-oriented programming language**. If you are not familiar with what that means, don’t worry, we’ll cover it in a future course.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!




:::NEXT DOC:::

#####Chapter 13:

# Conclusion

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

Congrats for making it this far! That’s a lot of Solidity concepts! The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions). In future courses, we will go into more detail on more complex variables such as storing structs within arrays and more special functions such as the constructor and events. And as always, you know the best way to learn is by doing! Feel free to go to https://remix.ethereum.org/, and just mess around with writing code there. It may feel overwhelming at first, but don’t worry it’s just to get a feel for what’s to come!
"
What are the four types of variable access modifiers in Solidity?,"The four types of variable access modifiers in Solidity are Public, Private, Internal, and External.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-7/course.md'},"The four types of variable access modifiers in Solidity are Public, Private, Internal, and External.","#####Chapter 7:

# Access Modifiers

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

We can actually give more information to the Solidity compiler on how we want to use our variables (and later functions). We can tell the compiler how we want our variables to be accessed. Many blockchains, such as Ethereum, act as one monolithic computer. While Ethereum is a network of computers distributed around the world, when you deploy code to a blockchain like Ethereum, that code can access any other code anyone has deployed to that blockchain. This is like how programs downloaded to your computer can access other programs on your computer. This allows smart contracts to interact in many unique and interesting ways that regular web application back ends may not be able to do so easily. However, this can also open risks of other code using our code in unintended ways.

To help prevent this we can declare “access modifiers” when declaring our variables, which limit what code on the blockchain can access and change those variables. The four types of variable access modifiers are:


* Public 
    * The variable/function can be accessed or changed by any other code or wallet on the blockchain.
* Private
    * The variable/function can only be accessed or changed within the current contract
* Internal
    * The variable/function can only be accessed or changed within the current contract or any other contract that inherits the current contract (we’ll discuss inheritance in another lesson)
* External
    * The variable/function can only be accessed/changed from outside code or blockchain wallets

To declare the access modifier of a variable we put it inbetween the function type and name like this:

<Highlight class=""language-javascript"">
uint public myFavNum;
</Highlight>

If no access modifier is declared then the variable is automatically assigned the private modifier. For example

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>
 
Is equivalent to 

<Highlight class=""language-javascript"">
uint private myFavNum;
</Highlight>


:::NEXT DOC:::

#####Chapter 5:

# Contract State, Variables and Data Types

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now you want to connect your artwork to the physical (off-chain) world. Tell your artwork how to behave. 
    </div>
  </div>
</ContentWrapp> -->

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing **variables** and change data by defining logic in **functions**. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time. When defining a variable, you must give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
    * These are phrases that meant to be read. You can store numbers in a string but you can’t do math on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>

This creates a variable called “myFavNum” and assigns it the type uint, or unsigned integer. Now we can use myFavoriteNumber to store numbers like 0,1,2,3,4…etc. in our contract. 
"
What are some important data types in Solidity?,"Some important data types in Solidity are int, uint, string, bool, and address.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-5/course.md'},"Some important data types in Solidity are: int, uint, string, bool, and address.","#####Chapter 5:

# Contract State, Variables and Data Types

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now you want to connect your artwork to the physical (off-chain) world. Tell your artwork how to behave. 
    </div>
  </div>
</ContentWrapp> -->

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing **variables** and change data by defining logic in **functions**. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time. When defining a variable, you must give it a **name** and **type**. You can name the variable whatever you want, as long as it isn’t used more than once. The variable **type** describes what kind of data were are storing. Is it an integer to do math on? Is it simply a yes or no (1 or 0)? Is just a sentence meant to be read? Some important data types in Solidity are:



* int: Integers (...-3,-2,-1,0,1,2,3…)
    * These are whole numbers and can be negative.
* uint: Unsigned Integers (0,1,2,3…) 
    * These are whole numbers and must be positive.
* string: Strings (“Hello my name is Glados. The cake is a lie. I like the number 17”)
    * These are phrases that meant to be read. You can store numbers in a string but you can’t do math on those numbers.
* bool: Booleans (0 or 1)
    * A boolean is a variable that can only be 0 or 1. You can also think of these as false (0) and true (1).
* address: An Account Address (0xa345643f1….e13)
    * An address represents an accout on Ethereum as a hexadecimal number beginning with 0x. These can be wallet accounts (also known as Externally Owned Accounts or EOAs) or contract accounts (the address where contracts can be found on the blockchain).

There are more but we can learn more about them later, these are the major ones for now! Once a variable is assigned a type, it’s type can’t change.

An example variable declaration would be: 

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>

This creates a variable called “myFavNum” and assigns it the type uint, or unsigned integer. Now we can use myFavoriteNumber to store numbers like 0,1,2,3,4…etc. in our contract. 


:::NEXT DOC:::

#####Chapter 10:

# Structs

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

We’ve gone over storing data as variables, some of the significant fundamental variable types, and how to store data in arrays. But what if we want to create a custom type? That type could be composed of several other fundamental types. For instance, we could have our custom type store a string and a number. We can create these custom, complex types, and they are called **structs**.

You can define a struct by declaring the struct keyword, naming the struct, then putting the structure of the struct within curly braces. For example, we could define a struct called “Car” composed of three fundamental types: a string for the make, a string for the model, and a uint for the VIN. This is how we would define this struct:

<Highlight class=""language-javascript"">
struct car {
  string make,
  string model,
  uint VIN
}
</Highlight>

And boom, we have created a new type called “Car” we can use throughout our code. Now to assign a variable to this type is a little different from one of the fundamental data types. We must use syntax like this:

<Highlight class=""language-javascript"">
car myNewCar = car(“Tesla”, “Model 3”, 31223);
</Highlight>

To access information from a struct, you need to use “dot” notation. For example, to get the Model of the myNewCar variable, the syntax will look like this:

<Highlight class=""language-javascript"">
myNewCar.model;
</Highlight>

So, if we wanted to assign the value inside the model element of the myNewCar struct to another variable it could look like this:

<Highlight class=""language-javascript"">
string myNewCarModel = myNewCar.model;
</Highlight>

"
Why do customers tend not to read digital agreements?,"Customers tend not to read digital agreements due to lengthy, complex legalese and the fact that these agreements give consumers very little recourse.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-3/course.md'},"Customers tend not to read digital agreements due to lengthy, complex legalese and the fact that these agreements give consumers very little recourse.","#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>
"
What do you need to do after completing the contract in order to use the VRFCoordinator?,You need to subscribe your contract to the VRFCoordinator.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-12/course.md'},"After completing the contract, you need to subscribe your contract to the VRFCoordinator using the Subscription Manager at vrf.chain.link and follow the steps to set up a subscription.","#####Chapter 12: Subscribing to the VRF

# Subscribing

Congrats you have completed the contract! Your final contract should look like this:

<Highlight class=""language-javascript"">
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;


  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address linkTokenContract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
    LINKTOKEN = LinkTokenInterface(linkTokenContract);
    s_owner = msg.sender;
  }

  function requestRandomWords() external {
    s_requestId = COORDINATOR.requestRandomWords(
      keyHash,
      s_subscriptionId,
      requestConfirmations,
      callbackGasLimit,
      numWords
    );
  }

  function fulfillRandomWords(
    uint256, // requestId
    uint256[] memory randomWords
  ) internal override {
    s_randomWords = randomWords;
  }
}
</Highlight>

Now that the contract is complete you need to subscribe your contract to the VRFCoordinator. You can do so via the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/). Go to the website and follow the steps to see what it would be like to set up a subscription.

:::NEXT DOC:::

_DEPLOY & RUN TRANSACTIONS_, select _VRFCoordinatorV2Mock_.

  3. Under _DEPLOY_ , fill in the `_BASEFEE` and `_GASPRICELINK`. These variables are used in the _VRFCoordinatorV2Mock_ contract to represent the base fee and the gas price (in LINK tokens) for the VRF requests. You can set: `_BASEFEE=100000000000000000` and `_GASPRICELINK=1000000000`.

  4. Click on _transact_ to deploy the _VRFCoordinatorV2Mock_ contract.

  5. Once deployed, you should see the _VRFCoordinatorV2Mock_ contract under _Deployed Contracts_.

  6. Note the address of the deployed contract.

### Create and fund a subscription

  1. Click on `createSubscription` to create a new subscription.

  2. In the RemixIDE console, read your transaction decoded output to find the subscription ID. In this example, the subscription ID is _1_.

  3. Click on `fundSubscription` to fund your subscription. In this example, you can set the `_subid` to `1` (which is your newly created subscription ID) and the `_amount` to `1000000000000000000`.

### Deploy the VRF consumer contract

  1. In the file explorer, open _VRFv2Consumer.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _RandomNumberConsumerV2_.

  3. Under _DEPLOY_ , fill in `SUBSCRIPTIONID` with your subscription ID, `vrfCoordinator` with the deployed _VRFCoordinatorV2Mock_ address and, _KEYHASH_ with an arbitrary `bytes32` (In this example, you can set the _KEYHASH_ to `0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc`).

  4. Click on _transact_ to deploy the _RandomNumberConsumerV2_ contract.

  5. After the consumer contract is deployed, you should see the _RandomNumberConsumerV2_ contract under _Deployed Contracts_.

  6. Note the address of the deployed contract.

### Add the consumer contract to your subscription

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click on _addConsumer_ and fill in the `_subid` with your subscription ID and `_consumer` with your deployed consumer contract address.

  3. Click on _transact_.

### Request random words

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_ contract.

  2. Click on `requestRandomWords`.

  3. In the RemixIDE console, read your transaction logs to find the VRF request ID. In this example, the request ID is _1_.

  4. Note your request ID.

### Fulfill the VRF request

Because you are testing on a local blockchain environment, you must fulfill
the VRF request yourself.

  1. Under _Deployed Contracts_ , open the functions list of your deployed _VRFCoordinatorV2Mock_ contract.

  2. Click `fulfillRandomWords` and fill in `_requestId` with your VRF request ID and `_consumer` with your consumer contract address.

  3. Click on `transact`.

### Check the results

  1. Under _Deployed Contracts_ , open the functions list of your deployed _RandomNumberConsumerV2_ contract.

  2. Click on `s_requestId` to display the last request ID. In this example, the output is _1_.

  3. Each time you make a VRF request, your consumer contract requests two random words. After the request is fulfilled, the two random words are stored in the `s_randomWords` array. You can check the stored random words by reading"
What are the three different ways to throw an error in Solidity?,"The three different ways to throw an error in Solidity are require, revert, and assert.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-6/course.md'},"The three different ways to throw an error in Solidity are require, revert, and assert.","#####Chapter 6:

# Errors

In the previous chapter, we learned about function modifiers. We already used the keyword **require** to check for conditions. If a condition is not met, an error is raised. An error will revert all changes made to the state during a transaction. There are three different ways to throw an error: **require**, **revert** and **assert**.

We use require if we want to validate user input and return values from calls to other functions. The syntax asks for a condition and a custom error message as the second argument. If the condition is not met, an error is raised. Otherwise, the next line will be executed.

<Highlight class=""language-javascript"">
require(x <= 42, ""x must be smaller or equal to 42."");
</Highlight>

**Revert** is used in a similar fashion but directly throws an error without checking a condition. It is useful when the condition check is more complex and you do not want to do it in a single line to improve readability or if several conditions have to be met that you want to check one by one. It will return all remaining gas to the caller. You can call it like this:

<Highlight class=""language-javascript"">
if (x <= 42 && x > 0) {
  revert(""x must be greater than 0 and smaller or equal to 42"");
}
</Highlight>

**Assert** is used for internal logic and checks code that should never be false. If an assertion fails, it’s likely that there is a bug in the contract. We can use asserts to ensure that even if there is a bug, we can simply catch it here and make it more difficult to abuse the bug. For example, it is often used to check for overflow/underflow. The following code shows how can ensure that a is always bigger or equal to b so that we do not run into a situation causing an underflow.

<Highlight class=""language-javascript"">
uint c = a - b 
assert(a >= b);
</Highlight>


:::NEXT DOC:::

Question: (Asked on: 2022-06-01 10:30:03)
How fix TypeError and DeclarationError with ChainLink Solidity smart contract?
URL: https://stackoverflow.com/questions/72460303/how-fix-typeerror-and-declarationerror-with-chainlink-solidity-smart-contract

Question Body:


I have created a smart contract which return to each user the amount deposited
+ a certain amount if the price of ETH decreases during the lock period. I
have two problems with the last part of the code.

The first one concerns mapping the price of ethereum at the moment the user
makes the deposit. I have tried several solutions but none of them seem to
work. The problem arises on line 64 `mapping(uint => uint) ethPrice;`. Console
returns:

    
    
    DeclarationError: Identifier already declared.
    --> oracle.sol:65:5:
    |
    65 | mapping(uint => uint) ethPrice;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    Note: The previous declaration is here:
    --> oracle.sol:63:5:
    |
    63 | uint public ethPrice = 0; 
    | ^^^^^^^^^^^^^^^^^^^^^^^^
    

The second is found on line no. 91. `msg.sender.transfer(amountToWithdraw);`
with the transfer function. The console continues to return the following
error despite the fact that the address of each user is defined as payable in
the previous functions. Console returns:

    
    
    TypeError: ""send"" and ""transfer"" are only available for objects of type ""address payable"", not ""address"".
    --> oracle.sol:97:9:
    |
    97 | msg.sender.transfer(amountToWithdraw);
    | ^^^^^^^^^^^^^^^^^^^
    

These two problems severely invalidate the smart contract and are holding up
the completion of coding the latest functions. I have contacted several people
and looked in forums concerning programming on solidity but no one seems to
have an answer to my problem.

I hope that my question can be answered by the community and can help any
other person trying to use ChainLink with Solidity in the future. I am happy
to listen to any advice on the matter.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
        // EACAggregatorProxy is used for chainlink oracle
    interface EACAggregatorProxy {
        function latestAnswer() external view returns (int256);
    }
    
    contract oracleLink {
    
        // Address dev
        address public dev;
        // Dev's public deposit amount
        uint public devDeposit;
        // Array dev's public amount
        uint[] public devDeposits;
    
        // List each user and amount
        address[] public users;                   
        uint[] public totalDeposited;  
    
        // Mapping user's deposit
        mapping(address => uint) balances;
    
        // Deployer = dev & Dev deposit function 
       "
What is the difference between an agreement and a contract?,"Contracts are agreements that are enforceable in a court of law, while agreements are oftentimes informal and not legally binding.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md'},"A contract is an enforceable agreement in a court of law, while an agreement can be informal and ""wishy washy"" and is not necessarily enforceable in a court of law.","#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>
"
What is Chainlink and what does it allow developers to do?,"Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. It allows developers to create and customize any type of Decentralized Oracle Network (DON) that a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-5/course.md'},"Chainlink is a decentralized oracle network that allows developers to connect their smart contracts to external data sources, such as APIs, and access off-chain computation. It provides access to a trust-minimized compute infrastructure and allows developers to run their code in a serverless environment. Chainlink also allows developers to aggregate and validate data from multiple sources and provides a way to pay for requests using LINK tokens. Additionally, Chainlink Functions is a self-service solution that enables developers to connect to any public data, transform it before consumption, and connect to password-protected data sources or external decentralized databases.","the aggregation and decentralization yourself. Eg call
the API 3 times in your smart contract with 3 seperate chainlink nodes/jobs,
then doing validation or aggregation on-chain after the third result. In the
future, this model _may_ change to automate this process and provide an easier
way to get this functionality without centralisation risks, (eg how Chainlink
Keepers work today)

> Another concept not clear yet: what is a Data Provider? I found out this
> page <https://market.link/search/data-providers> and seems like centralized
> providers of data, is that right?

A data provider is any company or business that provides data to smart
contracts. They usually run their own Chainlink node as well that has jobs
created specifically for smart contracts to call to obtain the data. Eg
[SportsMonks](https://market.link/data-
providers/fa1019e0-e0bc-4538-8b7a-3f490d28423b/integrations) is a data
provider that sells sports data to smart contracts across multiple
blockchains. They run Chainlink nodes that have jobs to return this data, so
smart contract developers can access it and use it in their dApps. The listing
on market.link shows developers how to access the data, ie what job IDs and
parameters they need in their smart contracts, how much it costs to do a call
etc.





:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature"
What are the three contracts being imported in the code?,"LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBaseV2",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-6/course.md'},"The three contracts being imported in the code are LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBase.","#####Chapter 6: Building a Basic Contract:

# Imports

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now that you know about Chainlink VRF v2 it’s time to begin building the raffle contract!
    </div>
  </div>
</ContentWrapp>

We will begin by declaring the Solidity compiler version and importing the code we need. There are 3 contracts we will be importing: LinkTokenInterface, VRFCoordinatorV2Interface, and VRFConsumerBase:

<Highlight class=""language-javascript"">
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>


:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>
"
What are functions in Solidity and what do they do?,"Functions in Solidity are little machines that take in data, run some logic and produce an output. They manipulate data and can be customized to do anything.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-11/course.md'},"Functions in Solidity are blocks of code that can manipulate data in an infinite number of ways. They take in data as arguments, run logic in their body, and can produce an output as a return value. Functions can be customized to do anything and can have modifiers, including access modifiers. They are one of the two main things defined when programming smart contracts, the other being state (variables).","#####Chapter 11:

# Functions

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

Thus far, we’ve mainly been concerned with storing data in variables and accessing that stored data. But what if we want to manipulate data? That is the realm of **functions**. You can write the logic in a function and have it manipulate data in an infinite number of ways. Solidity and the EVM are called [Turing Complete](https://stackoverflow.com/questions/7284/what-is-turing-complete ""Turing Complete""), which essentially means they can solve any computational problem (although there’s no guarantee that it will complete within a reasonable amount of time). 

You can think of functions as little machines that take in data, run some logic and produce an output. The values that are input into functions are called **arguments**. The logic is put in the **body** of the function. If the function directly returns a value as an output of the function that output is called the **return** value. Finally, just like variables have access modifiers, functions also have **modifiers** (including access modifiers too). Some functions don’t take in any arguments. Some functions just run calculations to change some state variables or make a request to run other code (or to a Chainlink node!) Some functions don’t return a direct value and just run calculations based on storage variables, or make a request to run other code (or send a request to a Chainlink node!) Basically, functions can be customized to do anything.

To define a function, we first type the “function” keyword, define a name for the function and add a pair of parentheses beside the name as such:

<Highlight class=""language-javascript"">
function addNumbers()
</Highlight>

After this is complete you can define **parameters** for the function. Parameters are the name and types of the arguments we can input into the function. They are variables that only that function can access. For this example, we will define two parameters: 

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2)
</Highlight>

Now we can add any modifiers to the function. In this case we’ll simply add public for now:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public
</Highlight>

Now we’ll define what the function returns. Remember a function doesn’t **have** to return anything. In this example we will add the parameters and return the result. Since we are adding two uints, the return value will also have to be a uint:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public returns (uint)
</Highlight>

Finally we’ll create the function body by typing a pair of curly braces and typing our function logic within them:

<Highlight class=""language-javascript"">
function addNumbers(uint num1, uint num2) public returns (uint) {
 answer = num1 + num2;
 return answer;
}
</Highlight>

As you can see the function takes the two parameters, num1 and num2, sums them, stores the sum in a variable called answer, and then returns the value inside the variable answer.

So if we were to call the function, we could store the result in another

:::NEXT DOC:::

#####Chapter 13:

# Conclusion

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

Congrats for making it this far! That’s a lot of Solidity concepts! The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions). In future courses, we will go into more detail on more complex variables such as storing structs within arrays and more special functions such as the constructor and events. And as always, you know the best way to learn is by doing! Feel free to go to https://remix.ethereum.org/, and just mess around with writing code there. It may feel overwhelming at first, but don’t worry it’s just to get a feel for what’s to come!
"
What are the two main smart contracts of Chainlink VRF?,The two main smart contracts of Chainlink VRF are the Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2).,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-4/course.md'},The two main smart contracts of Chainlink VRF are the Client Contract (VRFConsumerBaseV2) and the VRF Coordinator Contract (VRFCoordinatorV2).,"#####Chapter 4:

# Architecture of Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Every programmer knows it’s good to have at least a basic understanding of how the technology you use works! Time to dive into the inner workings of Chainlink VRF a bit.
    </div>
  </div>
</ContentWrapp>

Chainlink VRF is essentially the DON itself (the computers running the Chainlink nodes) and 2 main smart contracts:

- The Client Contract (VRFConsumerBaseV2)
- The VRF Coordinator Contract (VRFCoordinatorV2)

VRF Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!


:::NEXT DOC:::

# Introduction to Chainlink VRF

  * Overview
  * Two methods to request randomness
  * Choosing the correct method
  * Supported networks

Get Started

Access verified randomness at [vrf.chain.link](https://vrf.chain.link).

**Chainlink VRF (Verifiable Random Function)** is a provably fair and
verifiable random number generator (RNG) that enables smart contracts to
access random values without compromising security or usability. For each
request, Chainlink VRF generates one or more random values and cryptographic
proof of how those values were determined. The proof is published and verified
on-chain before any consuming applications can use it. This process ensures
that results cannot be tampered with or manipulated by any single entity
including oracle operators, miners, users, or smart contract developers.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

Use Chainlink VRF to build reliable smart contracts for any applications that
rely on unpredictable outcomes:

  * Building blockchain games and NFTs.
  * Random assignment of duties and resources. For example, randomly assigning judges to cases.
  * Choosing a representative sample for consensus mechanisms.

To learn more about the benefits of Chainlink VRF v2, see our blog post
[Chainlink VRF v2 Is Now Live on
Mainnet](https://blog.chain.link/vrf-v2-mainnet-launch/). For help with your
specific use case, [contact us](https://chain.link/contact) to connect with
one of our Solutions Architects. You can also ask questions about Chainlink
VRF on [Stack
Overflow](https://stackoverflow.com/questions/ask?tags=chainlink).

## Two methods to request randomness

Chainlink VRF v2 offers two methods for requesting randomness:

  * [Subscription](/vrf/v2/subscription): Create a subscription account and fund its balance with LINK tokens. Users can then connect multiple consuming contracts to the subscription account. When the consuming contracts request randomness, the transaction costs are calculated after the randomness requests are fulfilled and the subscription balance is deducted accordingly. This method allows you to fund requests for multiple consumer contracts from a single subscription.
  * [Direct funding](/vrf/v2/direct-funding): Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                         "
What is the purpose of the 'keyHash' parameter in Chainlink VRF?,The 'keyHash' parameter in Chainlink VRF functions as an ID of the off-chain VRF job that runs in response to requests.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-7/course.md'},The purpose of the 'keyHash' parameter in Chainlink VRF is to determine the gas lane to use for setting the ceiling limit of each request.,"#####Chapter 4:

# Goldberg’s Verifiable Random Function

As we have seen in the previous chapters, randomness is a non-trivial problem that needs proper consideration and analysis to ensure that the randomness is unpredictable. One of Chainlink's VRF v2 core features are based on scientific research and implement Goldberg's Verifiable Random Function (see details [here](https://eprint.iacr.org/2017/099.pdf)). Goldberg defines VRF as the public-key version of a keyed cryptographic hash. Anyone with the corresponding public key can verify the correctness of the hash. But only the holder of the secret VRF key can compute the hash. The VRF created by Goldberg et al. is being standardized by IETF and is also used by others in production (e.g., Algorand). It provides an ""entirely unpredictable (uniformly distributed) to anyone who doesn't know the seed or secret key.""

Let's try to understand this a little better. You can imagine VRF as a public-key pseudorandom function. It can be used to prove that the output was calculated for that given function. But only the owner of the secret key can compute the output for any given input value. Others can use the public key to check if the output was calculated using the given function. So it allows us to produce unpredictable (and uniformly distributed) results while being fully verifiable.

In Chainlink, a contract is used to provide a seed (via an Ethereum log) to generate a random number. The oracle hashes this input to get a cryptographically secure random sample from secp256k1 using the block data and the oracle's public key. This is the base to use the VRF to create a random number. The oracle then sends back the proof with the public key and the input seed (and some additional values for the signature). Afterward, it gets verified by the VRF machinery and is sent to the consuming contract if it was correct. The random number is then published on-chain with proof that it was generated using the VRF.


:::NEXT DOC:::

Question: (Asked on: 2022-03-09 20:02:05)
What is a gas lane in chainlink and blockchain?
URL: https://stackoverflow.com/questions/71415353/what-is-a-gas-lane-in-chainlink-and-blockchain

Question Body:


I do understand the concept of gas in the ethereum blockchain and why gas is
needed to compensate miners for providing computing power to the network.
However, when I was reading up on the chainlink vrf get a random number
documentation it says that the keyhash tells you the gas lane to use. It would
be really helpful if someone could further explain what a gas lane in
blockchain is.

Any help would be appreciated :)



Answers:
(Answered on: 2022-03-10 06:17:54)


So we know that Eth gas is always subject to change and with chainlink vrf
there will be random values with your request, so you need to set a limit to
how much to spend on each request. The reason chainlink uses a Gas lane is
because the lanes are important for setting the ceiling limit of each
request... think of it as your entry into the bet.



"
give me a sample solidity contract to use Chainlink price feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"The sample Solidity contract to use Chainlink price feeds is provided in the context information under the section ""Examine the sample contract"". The contract is named `PriceConsumerV3` and obtains the latest price answer from the BTC/USD feed on the Sepolia testnet. It uses the `AggregatorV3Interface` interface to define the function `latestRoundData()` for all v3 Aggregators. The contract can be modified to read any of the different types of data feeds.","# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
give me a sample solidity contract to use Chainlink VRF?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFD20 is VRFConsumerBaseV2 {

}
uint64 s_subscriptionId;
address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
uint32 callbackGasLimit = 40000;
uint16 requestConfirmations = 3;
uint32 numWords =  1;
)
(
give me a sample solidity contract to request data from a public API in a smart contract using chainlink?,
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req.add(
            ""get"",
            ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {""RAW"":
        //   {""ETH"":
        //    {""USD"":
        //     {
        //      ""VOLUME24HOUR"": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR""); // Chainlink nodes prior to 1.0.0 support this format
        req.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR""); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req.addInt(""times"", timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            ""Unable to transfer""
        );
    }
}",,Two sample Solidity contracts are provided in the context information for using Chainlink VRF: `VRFv2Consumer.sol` and `VRFv2DirectFundingConsumer.sol`.,"`VRFv2Consumer.sol` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Provider** environment, select the `VRFv2Consumer` contract from the contract list, and specify your `subscriptionId` so the constructor can set it.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must add this address as an approved consuming contract on your subscription account.

  6. Open the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/) and click the ID of your new subscription under the **My Subscriptions** list. The subscription details page opens.

  7. Under the **Consumers** section, click **Add consumer**.

  8. Enter the address of your consuming contract that you just deployed and click **Add consumer**. MetaMask opens and asks you to confirm the transaction.

Your example contract is deployed and approved to use your subscription
balance to pay for VRF v2 requests. Next, request random values from Chainlink
VRF.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF processes your request. Chainlink VRF fulfills the request and returns the random values to your contract in a callback to the `fulfillRandomWords()` function. At this point, a new key `requestId` is added to the mapping `s_requests`.

Depending on current testnet conditions, it might take a few minutes for the
callback to return the requested random values to your contract. You can see a
list of pending requests for your subscription ID at
[vrf.chain.link](https://vrf.chain.link/).

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated: The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` specifying the `requestId` to display the random words.

You deployed a simple contract that can request and receive random values from
Chainlink VRF. To see more advanced examples where the contract can complete
the entire process including subscription setup and management, see the
[Programmatic Subscription](/vrf/v2/subscription/examples/programmatic-subscription) page.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, your MetaMask wallet is the subscription owner and you
created a consuming contract to use that subscription. The consuming contract
uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that relies on a subscription for funding.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    import

:::NEXT DOC:::

in Remix, compile the `VRFv2DirectFundingConsumer` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Web3 Environment** and select the `VRFv2DirectFundingConsumer` contract from the contract list.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must fund your consuming contract with enough LINK tokens in order to request for randomness. Next, fund your contract.

## Fund Your Contract

Requests for randomness will fail unless your consuming contract has enough
LINK.

  1. [Acquire testnet LINK](/resources/acquire-link).
  2. [Fund your contract with testnet LINK](/resources/fund-your-contract). For this example, funding your contract with 2 LINK should be sufficient.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them, and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _400,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _400000_ and select **Save**.
Finally, confirm the transaction.

After you approve the transaction, Chainlink VRF processes your request.
Chainlink VRF fulfills the request and returns the random values to your
contract in a callback to the `fulfillRandomWords()` function. At this point,
a new key `requestId` is added to the mapping `s_requests`. Depending on
current testnet conditions, it might take a few minutes for the callback to
return the requested random values to your contract.

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated. The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` and specify the `requestId` to display the random words.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, the consuming contract uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import"
give me a sample solidity contract to use NFT Floor Price Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}",,"Here is a sample Solidity contract to use NFT Floor Price Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}
```","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) =

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
give me a sample solidity contract to use Proof of Reserve Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}",,"Here is a sample Solidity contract to use Proof of Reserve Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}
```","the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page

:::NEXT DOC:::

the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
Give sample code for an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"Here is an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet:

```
import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    constructor() {
        priceFeed = AggregatorV3Interface(0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43);
    }

    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```","the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    from web3 import Web3
    
    # Change this to use your own RPC URL
    web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
    # AggregatorV3Interface ABI
    abi = '[{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""description"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint80"",""name"":""_roundId"",""type"":""uint80""}],""name"":""getRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""latestRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""version"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""}]'
    # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0 <0.8.0`, use
[OpenZeppelin's SafeMath

:::NEXT DOC:::

/*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct"
Give code examples to demonstrate how to deploy a consumer contract on-chain that reads a data feed and stores the value?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",,"The code examples for deploying a consumer contract on-chain that reads a data feed and stores the value are provided in the ""Reading data feeds on-chain"" section of the documentation. The examples are given in Solidity and Vyper languages. The Solidity example code imports the `AggregatorV3Interface` interface from the Chainlink contracts and defines a constructor that sets the address of the data feed to be read. The `getLatestPrice()` function is defined to return the latest price from the data feed.","# Code Examples

  * Overview
  * Reading data feeds on-chain
  * Solidity
  * Vyper
  * Reading data feeds off-chain
  * Javascript
  * Python
  * Golang
  * Getting a different price denomination
  * More Aggregator Functions

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same. To read a
feed, specify the following variables:

  * **RPC endpoint URL:** This determines which network that your smart contracts will run on. You can use a [node provider service](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) or point to your own [client](https://ethereum.org/en/developers/docs/nodes-and-clients/). If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the [Remix IDE](https://remix-project.org/) will automatically detect them for you.
  * **LINK token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
    

:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete"
Write code to show how to use web3.js to retrieve feed data from a price feed?,"/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
    name: ""getRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""latestRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""version"",
    outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
]
const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log(""Latest Round Data"", roundData)
  })",,"```
/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only

const web3 = new Web3(new Web3.providers.HttpProvider(""https://sepolia.infura.io/v3/YOUR-PROJECT-ID""))

const priceFeedABI = [{""inputs"":[],""name"":""latestAnswer"",""outputs"":[{""internalType"":""int256"",""name"":"""",""type"":""int256""}],""stateMutability"":""view"",""type"":""function""}]
const priceFeedAddress = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""

const priceFeedContract = new web3.eth.Contract(priceFeedABI, priceFeedAddress)

priceFeedContract.methods.latestAnswer().call((error, result) => {
  console.log(result)
})
```","On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
   "
What is the LINK token contract on ethereum mainnet?,0x514910771AF9Ca656af840dff83E8264EcF986CA,,"The LINK token contract on Ethereum mainnet has the address 0x514910771AF9Ca656af840dff83E8264EcF986CA, a name of Chainlink Token, a symbol of LINK, and 18 decimals.","# LINK Token Contracts

  * Overview
  * Ethereum
  * Ethereum Mainnet
  * Sepolia testnet
  * Goerli testnet
  * BNB Chain
  * BNB Chain mainnet
  * BNB Chain testnet
  * Polygon (Matic)
  * Polygon mainnet
  * Mumbai testnet
  * RSK
  * RSK mainnet
  * Gnosis Chain (xDai)
  * Gnosis Chain mainnet
  * Avalanche
  * Avalanche mainnet
  * Fuji testnet
  * Fantom
  * Fantom mainnet
  * Fantom testnet
  * Arbitrum
  * Arbitrum mainnet
  * Arbitrum Goerli testnet
  * Optimism
  * Optimism mainnet
  * Optimism Goerli testnet
  * Harmony
  * Harmony mainnet
  * Moonriver
  * Moonriver mainnet
  * Moonbeam
  * Moonbeam mainnet
  * Metis
  * Andromeda mainnet
  * BASE
  * BASE Goerli testnet

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=Contracts) to talk to an expert
about the networks that support the LINK token.

LINK tokens are used to pay node operators for retrieving data for smart
contracts and also for deposits placed by node operators as required by
contract creators. The smallest denomination of LINK is called a Juel, and
1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to
Wei, which is the [smallest denomination of
ETH](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations).

The LINK token is an ERC677 token that inherits functionality from the ERC20
token standard and allows token transfers to contain a data payload. Read more
about the [ERC677 transferAndCall token
standard](https://github.com/ethereum/EIPs/issues/677).

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

## Ethereum

### Ethereum Mainnet

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1                                          |
| Address        | 0x514910771AF9Ca656af840dff83E8264EcF986CA |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | ethstats.dev                               |
### Sepolia testnet

Testnet LINK and ETH are available at
[faucets.chain.link](https://faucets.chain.link/sepolia). Testnet ETH is also
available from several public

:::NEXT DOC:::

and
LINK from Ethereum Mainnet to Metis mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1088                                       |
| Address        | 0x79892E8A3Aea66C8F6893fa49eC6208ef07EC046 |
| Name           | Chainlink Token on Metis Mainnet           |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | andromeda-explorer.metis.io                |
## BASE

### BASE Goerli testnet

Testnet ETH is used to pay for transactions on BASE. Testnet ETH is available
from one of the [BASE Network Faucets](https://docs.base.org/tools/network-faucets). Alternatively, you can get testnet ETH from the faucets listed at
[faucetlink.to/goerli](https://faucetlink.to/goerli) and use the [BASE
Bridge](https://bridge.base.org/deposit) to transfer testnet ETH from Ethereum
Goerli to BASE Goerli.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 84531                                      |
| Address        | 0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3 |
| Name           | Chainlink Token on the BASE Goerli testnet |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | goerli.basescan.org                        |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/link-token-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the chainlink price feed address for 1INCH / ETH?,0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8,,The chainlink price feed address for 1INCH / ETH is 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8.,"        |
|:---------------------------------------|:---------------------------------------------------------|:---------------|:------------|:------------|------:|:-------------------------------------------|
| 🟢1INCH / ETH                          | 1inch                                                    | Crypto         | 2%          | 86400s      |    18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8 |
| 🟢1INCH / USD                          | 1inch                                                    | Crypto         | 1%          | 86400s      |     8 | 0xc929ad75B72593967DE83E7F7Cda0493458261D9 |
| 🟢AAPL / USD                           | Apple                                                    | Equities       | 0.5%        | 86400s      |     8 | 0x139C8512Cde1778e9b9a8e721ce1aEbd4dD43587 |
| 🟢AAVE / ETH                           | Aave                                                     | Crypto         | 2%          | 86400s      |    18 | 0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012 |
| 🟢AAVE / USD                           | Aave                                                     | Crypto         | 1%          | 3600s       |     8 | 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 |
| 🟢ADA / USD                            | Cardano                                                  | Crypto         | 1%          | 86400s      |     8 | 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55 |
| 🟢ADX / USD                

:::NEXT DOC:::

                              | Crypto         | 1%          | 86400s      |     8 | 0x10a43289895eAff840E8d45995BBa89f9115ECEe |
| 🟢ERN / USD                            | Ethernity Chain                                          | Crypto         | 2%          | 86400s      |     8 | 0x0a87e12689374A4EF49729582B474a1013cceBf8 |
| 🟢ETH / BTC                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0xAc559F25B1619171CbC396a50854A3240b6A4e99 |
| 🟢ETH / USD                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 |
| 🟢EUR / USD                            | Euro                                                     | Forex          | 0.15%       | 86400s      |     8 | 0xb49f677943BC038e9857d61E7d053CaA2C1734C1 |
| 🟢EURT / USD                           | Tether Euro                                              | Crypto         | 2%          | 86400s      |     8 | 0x01D391A48f4F7339aC64CA2c83a07C22F95F587a |
| 🟢FARM / ETH                           | Harvest Finance                                          | Crypto         | 2%          | 86400s      |    18 |"
What is the proof of reserve address for CacheGold PoR USD on Goerli Testnet?,Not provided in the context,,There is no information provided about the proof of reserve address for CacheGold PoR USD on Goerli Testnet.,"                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES        

:::NEXT DOC:::

Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                        "
What is the rate and Volatility Feed Address for 30-Day ETH APR?,0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29,,The rate and volatility feed address for 30-Day ETH APR is 0x8e604308BD61d975bc6aE7903747785Db7dE97e2.,"# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is

:::NEXT DOC:::

nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2 |
| ETH-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 | 0xd599cEF88Bbd27F1392A544bD0F343ec8893124C |
| LINK-USD 7-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x03121C1a9e6b88f56b27aF5cc065ee1FaF3CB4A9 |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What is the NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net?,0x352f2Bc3039429fC2fe62004a1575aE74001CfcE,,The NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net is 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE.,"  |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
|

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |"
