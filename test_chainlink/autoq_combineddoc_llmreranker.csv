question,answer,metadata,result,retrieved_docs
What is the purpose of hosting encrypted secrets on AWS S3 in this tutorial?,To replace the default off-chain option and securely store the secrets.,{'source': 'https://docs.chain.link/chainlink-functions/tutorials/api-use-secrets-offchain/'},"The purpose of hosting encrypted secrets on AWS S3 in this tutorial is to share the secrets off-chain with a Decentralized Oracle Network (DON) using another storage platform such as AWS S3, Google Drive, IPFS, or any other service where the DON can fetch secrets via HTTP.","tutorial before you follow the steps in this example. This tutorial
uses the same example, but with a slightly different process:

  1. Instead of relying on the default off-chain option(gists), you will host your encrypted secrets on AWS S3.
  2. Include the encrypted secrets in an `offchain-secrets.json` file.
  3. Host the secrets file off-chain (AWS S3).
  4. Include the HTTP URL to the file in your Chainlink Functions request.

The `functions-build-offchain-secrets` task encrypts the secrets and creates
the secrets file for you. For reference, you can find the public key for the
DON by running the `getDONPublicKey` function on the [Functions Oracle Proxy
contract](https://mumbai.polygonscan.com/address/0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4#readProxyContract#F5).
See the [Supported Networks](https://docs.chain.link/chainlink-functions/supported-networks#contract-addresses) page to find the Functions
Oracle Proxy contract for each supported network.

caution

Chainlink Functions is still in BETA. Please utilize credentials that are
assigned for your testing purposes only and that do not secure sensitive data
or real value. The use of secrets in your requests is an experimental feature
that may not operate as expected and is subject to change. Use of this feature
is at your own risk and may result in unexpected errors, possible revealing of
the secret as new versions are released, or other issues.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide

:::NEXT DOC:::

# Using Off-chain Secrets in Requests

  * Overview
  * Before you begin
  * Tutorial
  * Build Off-chain Secrets
  * Simulation
  * Request
  * Explanation
  * FunctionsConsumer.sol
  * config.js
  * source.js

As explained in the [Using Secrets in Requests guide](/chainlink-functions/tutorials/api-use-secrets), the Chainlink Functions starter kit
shares encrypted secrets off-chain with a Decentralized Oracle Network (DON)
using [gists](https://docs.github.com/en/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists). This tutorial
shows you how to share encrypted secrets off-chain with a Decentralized Oracle
Network (DON) using another storage platform such as AWS S3, Google Drive,
IPFS, or any other service where the DON can fetch secrets via HTTP.

Read the [API multiple calls](/chainlink-functions/tutorials/api-multiple-calls) tutorial before you follow the steps in this example. This tutorial
uses the same example, but with a slightly different process:

  1. Instead of relying on the default off-chain option(gists), you will host your encrypted secrets on AWS S3.
  2. Include the encrypted secrets in an `offchain-secrets.json` file.
  3. Host the secrets file off-chain (AWS S3).
  4. Include the HTTP URL to the file in your Chainlink Functions request.

The `functions-build-offchain-secrets` task encrypts the secrets and creates
the secrets file for you. For reference, you can find the public key for the
DON by running the `getDONPublicKey` function on the [Functions Oracle

:::NEXT DOC:::

   
        npx env-enc set

  7. Prepare the store for your encrypted secrets file.

    1. Create a [AWS free tier account](https://aws.amazon.com/free/).
    2. Follow [these steps](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html) to create a AWS S3 bucket. Choose a name for your bucket, set _ACLs enabled_ , and turn off _Block all public access_.

## Tutorial

Set up your environment variables

This tutorial has some unique `.env.enc` setup steps. Make sure that you
configured your `.env.enc` file with the necessary variables in the Before you
begin section.

This tutorial is configured to get the median `BTC/USD` price from multiple
data sources. For a detailed explanation of the code example, read the
Explanation section.

  * Open `config.js`. Note the `args` value is `[""1"", ""bitcoin"", ""btc-bitcoin""]`. These arguments are BTC IDs at CoinMarketCap, CoinGecko, and Coinpaprika. You can adapt `args` to fetch other asset prices. See the API docs for [CoinMarketCap](https://coinmarketcap.com/api/documentation/v1/), [CoinGecko](https://www.coingecko.com/en/api/documentation), and [CoinPaprika](https://api.coinpaprika.com/) for details. For more information about the request, read the request config section.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation of the request source file.

### Build Off-chain Secrets

Before you make a request, prepare the secrets file and host it off-chain:

  1. Encrypt the secrets with the public key of the DON and store them in the

:::NEXT DOC:::

has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  4. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/7-offchain-secrets_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/7-offchain-secrets).
    
        git checkout tutorials

  5. Get a free API key from [CoinMarketCap](https://coinmarketcap.com/api/).

  6. Run `npx env-enc set` to add an encrypted `COINMARKETCAP_API_KEY` to your `.env.enc` file.
    
        npx env-enc set

  7. Prepare the store for your encrypted secrets file.

    1. Create a [AWS free tier account](https://aws.amazon.com/free/).
    2. Follow [these steps](https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html) to create a AWS S3 bucket. Choose a name for your bucket, set _ACLs enabled_ , and turn off _Block all public access_.

## Tutorial

Set up your environment variables

This tutorial has some unique `.env.enc` setup steps. Make sure that you
configured your `.env.enc` file with the necessary variables in the Before you
begin section.

This tutorial is configured to get the median

:::NEXT DOC:::

with
a security benefit:

  * The encrypted secrets are never stored on-chain. The secrets are encrypted with the DON's public key so that only an oracle node in the DON can decrypt them using the DON's private key. After the DON fulfills a request, the starter kit deletes the gist. This revokes the credentials after the DON has fulfilled the request.

caution

Chainlink Functions is still in BETA. Please utilize credentials that are
assigned for your testing purposes only and that do not secure sensitive data
or real value. The use of secrets in your requests is an experimental feature
that may not operate as expected and is subject to change. Use of this feature
is at your own risk and may result in unexpected errors, possible revealing of
the secret as new versions are released, or other issues.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  3. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/5-use-secrets_

:::NEXT DOC:::

   
        $ npx hardhat functions-build-offchain-secrets --network polygonMumbai --configpath tutorials/7-offchain-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    Using public keys from FunctionsOracle contract 0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4 on network mumbai
    
    Wrote offchain secrets file to offchain-secrets.json

  2. Follow these [steps](https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-an-object-bucket.html) to upload the file `offchain-secrets.json` to your AWS S3 bucket.

  3. To make the file publically accessible without authentication:

    1. Find the file in the bucket list, and click on it to open the object overview.
    2. Click on the _Permissions_ tab to display the _Access control list (ACL)_.
    3. Click on _Edit_.
    4. Set _Everyone (public access)_ Objects read, then confirm. This action makes the object readable by anyone on the internet.
    5. Note the object URL.
    6. To verify that the URL is publicly readable without authentication, open a new browser tab and copy/paste the object URL in the browser location bar. After you hit _Enter_ , the browser will display the content of your encrypted secrets file.
  4. Open `config.js`. Fill in the `secretsURLs` variable. For example: `secretsURLs: [""https://clfunctions.s3.eu-north-1.amazonaws.com/offchain-secrets.json""]`. **Note** : When you make requests, any URLs in `secretsURL` are encrypted so no third party can view them.

### Simulation

The [Chainlink

:::NEXT DOC:::

shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  3. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/5-use-secrets_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/5-use-secrets).
    
        git checkout tutorials

  4. Get a free API key from [CoinMarketCap](https://coinmarketcap.com/api/) and note your API key.

  5. The starter kit store encrypted secrets as [gists](https://docs.github.com/en/get-started/writing-on-github/editing-and-sharing-content-with-gists/creating-gists) to share them off-chain with the Decentralized Oracle Network. To allow the starter kit to write gists on your behalf, create a [github fine-grained personal access token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token#creating-a-fine-grained-personal-access-token).

    1. Visit [Github tokens settings page](https://github.com/settings/tokens?type=beta).
    2. Click on _Generate new

:::NEXT DOC:::

Question: (Asked on: 2022-01-16 16:25:11)
AWS Chainlink Quickstart Error - S3 Error Access Denied
URL: https://stackoverflow.com/questions/70731937/aws-chainlink-quickstart-error-s3-error-access-denied

Question Body:


I am getting the following error when executing the Quickstart for Chainlink
during the AuroraStack execution.

S3 Error: Access Denied

Not very friendly error so I went over to the yaml file.

<https://aws-quickstart.s3.us-east-1.amazonaws.com/quickstart-chainlinklabs-
chainlink-node/submodules/quickstart-amazon-aurora-
postgresql/templates/aurora_postgres.template.yaml>

And gave it a read but I really don't see anything that even has it hitting an
S3 storage resource.

The error would lead me to believe that the previous YAML file that calls the
above is being called and can't even reach the S3 file for Aurora.

Anyone else seen / resolved this issue?

Any ideas are appreciated?

Thanks!

Chris

Ultimately, it was an S3 access issue to the Aurora file inside the chainlink
quickstart. I setup an S3 bucket, redid the files and gave myself permission
and it worked fine.



Answers:
(Answered on: 2022-01-16 19:37:15)


Ultimately, it was an S3 access issue to the Aurora file inside the chainlink
quickstart. I setup an S3 bucket, redid the files and gave myself permission
and it worked fine.





:::NEXT DOC:::

 * [**Amazon CloudWatch**](https://aws.amazon.com/cloudwatch/pricing/?nc2=type_a)
  * ( _Optional_ if you are not using a public certificate with AWS Certificate Manager) [**Application Load Balancer**](https://aws.amazon.com/elasticloadbalancing/pricing/?nc=sn&loc=3)
  * ( _Optional_ ) [**Amazon Devops Guru**](https://aws.amazon.com/devops-guru/pricing/?nc=sn&loc=3&refid=0c5ce5de-7dc6-4ce5-95c9-29c9047095fc~ha_awssm-10495_event_prospect)

You are responsible for the cost of the AWS services and any third-party
licenses that you use while running this Quick Start. There is no additional
cost for using the Quick Start.

AWS maintains service limits for each account to help guarantee the
availability of AWS resources. You are responsible for monitoring and managing
the service limits of the resources that this Quick Start provisions.

For more information, visit [Manage Service
Limits](https://aws.amazon.com/premiumsupport/knowledge-center/manage-service-limits/).

## Best Practices

### Do not run as the root user

The operations on the Chainlink node do not require the root user so it is
recommended to use the default user or run as a non-root user.

### Protect your AWS account

As a best security practice, [rotate programmatic system
credentials](https://aws.amazon.com/blogs/security/how-to-rotate-access-keys-for-iam-users/) and [cryptographic
keys](https://docs.aws.amazon.com/kms/latest/developerguide/rotate-keys.html).

If you enable Amazon Devops Guru, the Quick Start deploys an AWS managed
customer key (CMK) that is used for the Amazon SNS topic for DevOps

:::NEXT DOC:::

CoinGecko, and Coinpaprika. You can adapt `args` to fetch other asset prices. See the API docs for [CoinMarketCap](https://coinmarketcap.com/api/documentation/v1/), [CoinGecko](https://www.coingecko.com/en/api/documentation), and [CoinPaprika](https://api.coinpaprika.com/) for details. For more information about the request, read the request config section.
  * Open `source.js` to analyze the JavaScript source code. Read the source code explanation for a more detailed explanation of the request source file.

### Build Off-chain Secrets

Before you make a request, prepare the secrets file and host it off-chain:

  1. Encrypt the secrets with the public key of the DON and store them in the `offchain-secrets.json` file. The `--network` flag is required because each network has a unique DON with a different public key.
    
        npx hardhat functions-build-offchain-secrets --network REPLACE_NETWORK --configpath REPLACE_CONFIG_PATH

Example:

    
        $ npx hardhat functions-build-offchain-secrets --network polygonMumbai --configpath tutorials/7-offchain-secrets/config.js
    secp256k1 unavailable, reverting to browser version
    Using public keys from FunctionsOracle contract 0xeA6721aC65BCeD841B8ec3fc5fEdeA6141a0aDE4 on network mumbai
    
    Wrote offchain secrets file to offchain-secrets.json

  2. Follow these [steps](https://docs.aws.amazon.com/AmazonS3/latest/userguide/uploading-an-object-bucket.html) to upload the file `offchain-secrets.json` to your AWS S3 bucket.

 "
What was the error message received when running the run script?,opening db: failed to open db: failed to connect to `host=/tmp user=database=`: dial error (dial unix /tmp/.s.PGSQL.5432: connect: no such file or directory),{'source': 'https://stackoverflow.com/questions/70978628/chainlink-quick-start-problems-connecting-to-the-database'},"For the first context, the error message received when running the run script was ""invalid BigNumber value (argument=""value"", value=[""ETH"",""USD""], code=INVALID_ARGUMENT, version=bignumber/5.7.0)"". 

For the second context, the error message received when running the run script was ""IndexError: list index out of range"".","I get the same error.

When running request.js, I am receiving this error:

    
    
    PS C:\Users\Coding\vscode\x-functions-hardhat> npx hardhat run scripts/request.js --network polygonMumbai     
    secp256k1 unavailable, reverting to browser version
    
    C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:269
            const error: any = new Error(message);
                               ^
    Error: invalid value for array (argument=""value"", value=420, code=INVALID_ARGUMENT, version=contracts/5.7.0)
        at Logger.makeError (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:269:28)
        at C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\contracts\src.ts\index.ts:168:42    at step (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\contracts\lib\index.js:48:23)
    .js:29:53)
        at C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\contracts\lib\index.js:23:71    
        at new Promise (<anonymous>)
 

:::NEXT DOC:::

       {
          ""__typename"": ""TaskRun"",
          ""id"": ""a55ffb4e-69c6-4f9a-b1d6-d621d915517e"",
          ""createdAt"": ""2022-03-19T03:23:01.939182Z"",
          ""dotID"": ""submit_tx"",
          ""error"": ""while creating transaction: cannot send transaction on chain ID 122022; eth key with address 0x122D45338AFB7198a34054eEC9AB03e1d4611674 is pegged to chain ID 4: task run failed"",
          ""finishedAt"": ""2022-03-19T03:23:02.390795Z"",
          ""output"": ""null"",
          ""type"": ""ethtx""
        },
        {
          ""__typename"": ""TaskRun"",
          ""id"": ""10dabecd-11b5-4921-85c9-3bcdd132d1b0"",
          ""createdAt"": ""2022-03-19T03:23:01.943156Z"",
          ""dotID"": ""decode_log"",
          ""error"": null,
          ""finishedAt"": ""2022-03-19T03:23:01.943428Z"",
          ""output"":

:::NEXT DOC:::

Question: (Asked on: 2022-04-27 06:50:03)
brownie local testing with ganache fails
URL: https://stackoverflow.com/questions/72024436/brownie-local-testing-with-ganache-fails

Question Body:


Following the steps taken in the bootcamp day2 video on testing solidity
contracts with brownie, I stumbled upon an error when testing the chainlink-
mix scripts locally.

Here are the steps are taken to introduce the error:

  1. execute brownie compile
  2. execute genache-cli in separate terminal
  3. execute brownie run scripts/price_feed_scripts/01_deploy_price_consumer_v3.py
  4. brownie run scripts/price_feed_scripts/02_read_price_feed.py

ganache is selected as the default network and the server is listening on the
ip/port 127.0.0.1:8545.

    
    
    brownie run scripts/price_feed_scripts/02_read_price_feed.py
    Brownie v1.18.1 - Python development framework for Ethereum
    
    ChainlinkMixProject is the active project.
    /usr/local/lib/python3.9/site-packages/brownie/network/main.py:44: BrownieEnvironmentWarning: Development network has a block height of 14
      warnings.warn(
    Attached to local RPC client listening at '127.0.0.1:8545'...
    
    Running 'scripts/price_feed_scripts/02_read_price_feed.py::main'...
    <brownie.network.contract.ContractContainer object at 0x10e410dc0>
      File ""brownie/_cli/run.py"", line 51, in main
        return_value, frame = run(
  

:::NEXT DOC:::

bytes data)"" data=""$(jobRun.logData)"" topics=""$(jobRun.logTopics)""] decode_cbor [type=""cborparse"" data=""$(decode_log.data)""] fetch [type=""http"" method=GET url=""$(decode_cbor.get)""] parse [type=""jsonparse"" path=""$(decode_cbor.path)"" data=""$(fetch)""] multiply [type=""multiply"" input=""$(parse)"" times=100] encode_data [type=""ethabiencode"" abi=""(uint256 value)"" data=""{ \""value\"": $(multiply) }""] encode_tx [type=""ethabiencode"" abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)"" data=""{\""requestId\"": $(decode_log.requestId), \""payment\"": $(decode_log.payment), \""callbackAddress\"": $(decode_log.callbackAddr), \""callbackFunctionId\"": $(decode_log.callbackFunctionId), \""expiration\"": $(decode_log.cancelExpiration), \""data\"": $(encode_data)}"" ] submit_tx [type=""ethtx"" to=""0x9DA0F694B15525E32cb2A1E1A44854854BD2E987"" data=""$(encode_tx)""] decode_log -> decode_cbor -> fetch -> parse -> multiply -> encode_data -> encode_tx -> submit_tx ""
      },
      ""status"": ""ERRORED"",
      ""inputs"": {
        ""jobRun"": {
          ""logAddress"": ""0x9da0f694b15525e32cb2a1e1a44854854bd2e987"",
         

:::NEXT DOC:::

Question: (Asked on: 2021-11-01 06:14:40)
&quot;Could not resolve path error&quot; in the jsonparse section in job run for Chainlink external adapter
URL: https://stackoverflow.com/questions/69793208/could-not-resolve-path-error-in-the-jsonparse-section-in-job-run-for-chainlink

Question Body:


I have a job for an external adapter added to my local Chainlink node. It
errors out when I make an initial request. My problem comes down to a syntax
error or using the incorrect path. But I'm not aware of where to find out what
the syntax should be. Or am I getting the path wrong?

Below is my job definition.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""f1latestresults""
    contractAddress = ""0x765aCc258f3a7b2D8d103D1A9310fc51b07D5425""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor 

:::NEXT DOC:::

       at C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\contracts\src.ts\index.ts:150:20    at Array.map (<anonymous>)
    PS C:\Users\Coding\vscode\x-functions-hardhat> npx hardhat run scripts/request.js --network polygonMumbai     
    secp256k1 unavailable, reverting to browser version
    

I can bypass this error by placing 420 into an array `[420]` but I then
receive this error:

    
    
    PS C:\Users\Coding\vscode\x-functions-hardhat> npx hardhat run scripts/request.js --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    
    C:\Users\Coding\vscode\donateassist-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:269
            const error: any = new Error(message);
                               ^
    Error: invalid BigNumber value (argument=""value"", value=[""ETH"",""USD""], code=INVALID_ARGUMENT, version=bignumber/5.7.0)
        at Logger.makeError (C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:269:28)
        at Logger.throwError

:::NEXT DOC:::

Question: (Asked on: 2023-05-17 00:39:32)
Invalid value error when using Chainlink Functions request script
URL: https://stackoverflow.com/questions/76267884/invalid-value-error-when-using-chainlink-functions-request-script

Question Body:


I am working through the _Adding Chainlink Functions to an Existing Project_
tutorial: <https://docs.chain.link/chainlink-functions/resources/add-
functions-to-projects>

I am not trying to integrate my own project yet and am using the provided:

  * FunctionsClient.sol
  * Functions-request-source.js
  * request.js

I did note that the tutorial at _Create a request script_ point 6 it says to
use

> `const source = ./Functions-request-source.js`

However, the request.js has this line:

> `const source = await fs.readFile(""./Functions-request-source.js"", ""utf8"");`

When using both options (after updating the first example to `const source =
""./Functions-request-source.js""`) I get the same error.

When running request.js, I am receiving this error:

    
    
    PS C:\Users\Coding\vscode\x-functions-hardhat> npx hardhat run scripts/request.js --network polygonMumbai     
    secp256k1 unavailable, reverting to browser version
    
    C:\Users\Coding\vscode\x-functions-hardhat\node_modules\@ethersproject\logger\src.ts\index.ts:269
            const error: any = new Error(message);
                            

:::NEXT DOC:::

         ""id"": ""f6d2778f-008e-45ea-8e7c-4399ba829bea"",
          ""createdAt"": ""2022-03-19T03:23:02.387223Z"",
          ""dotID"": ""parse"",
          ""error"": null,
          ""finishedAt"": ""2022-03-19T03:23:02.387411Z"",
          ""output"": ""2946.33"",
          ""type"": ""jsonparse""
        },
        {
          ""__typename"": ""TaskRun"",
          ""id"": ""da229b9e-1821-406b-a5f5-2d129b488ffc"",
          ""createdAt"": ""2022-03-19T03:23:02.387508Z"",
          ""dotID"": ""multiply"",
          ""error"": null,
          ""finishedAt"": ""2022-03-19T03:23:02.387662Z"",
          ""output"": """"294633"""",
          ""type"": ""multiply""
        },
        {
          ""__typename"": ""TaskRun"",
          ""id"": ""487078fb-53b0-4e5d-b3f2-01f74f143fab"",
      

:::NEXT DOC:::

token.address); 
      }
      
      main()
        .then(() => process.exit(0))
        .catch((error) => {
          console.error(error);
          process.exit(1);
        });
    

**quickRun.js**

    
    
    var ethers = require('ethers');
    var provider = ethers.providers.getDefaultProvider('kovan');
    var address

:::NEXT DOC:::

tabs in your
node UI in the browser, and these 2 tabs allow you to view what's wrong with
your job run. You can find the latest chainlink docker image
[here](https://hub.docker.com/r/smartcontract/chainlink/tags).

[](https://i.stack.imgur.com/W6AxZ.png)

The error messages under the ""error"" tab are shown below, and the info can
reflect the error your job encountered in the run.

[](https://i.stack.imgur.com/IUEU0.jpg)

If there are no ""error"" and ""run"" tabs in the browser or there is nothing
shown in the UI, you can also find error info in the log file housed by the
server running the Chainlink node. The default path of the Chainlink node log
file is `/chainlink/chainlink_debug.log`, so you can log into the server that
running the node and check the log for debugging.

Hope it helps.



"
What is the Monte Carlo fallacy?,The Monte Carlo fallacy is the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-1/course.md'},The Monte Carlo fallacy describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent.,"#####Chapter 1:

# Introduction

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. 
    </div>
  </div>
</ContentWrapp>

Let’s take the Monte Carlo fallacy as an example. It describes the mistaken belief that past events that occur more often than others are less likely to happen in the future (or vice versa) though they are statistically independent. If you play roulette in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random

:::NEXT DOC:::

in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.


:::NEXT DOC:::

Computers are deterministic machines. Per definition, they cannot produce randomness without any external inputs.


:::NEXT DOC:::

Randomness is essential for many types of applications. Think about how many games have randomness built-in. Rolling dice in dungeons and dragons, a random starting hand of poker, or a random next block in Tetris, randomness is an essential component of a majority of games.


:::NEXT DOC:::

# VRF v2 Advanced

<GradientTextWrapp>
  Creating randomness is a non-trivial problem to be solved in blockchain systems. 
</GradientTextWrapp>

In daily life, we use the term random very loosely. We use it whenever we do not have a quick explanation expressing the statistical probability of a particular event happening. This leads to wrong assumptions and false predictions. This is fatal when used in blockchains as everyone has access to the same data and pseudo randomness could be easily detected and used to trick your smart contract or application.


:::NEXT DOC:::

Is there no other way?

You might argue that you can use the content of a block as a source of randomness. But these values can be actively manipulated by miners. They could add or remove transactions to find a result that benefits them. In addition, blocks also have particular properties that could reduce the search space to calculate probabilities that a specific number will be selected. So this is an insecure way of creating random numbers.

So if you cannot trust the miners, you could argue for using Oracles. A trusted third-party system could be used to create random numbers and then provide them to services via an oracle. But depending on the economic incentive, someone could be interested in hacking this system to provide non-random numbers as input. And while they might use a true random number generator, you don’t know for sure and do not have any way to check the validity of such a statement once the number was generated.

So we must address two further issues here. The single point of failure (single oracle) and validating that the number was generated with a particular function. For the first issue, you could argue that you could use decentralized oracle network (DON). So it wouldn’t be a single oracle that we need to trust.
But how do we know this DON is not generating numbers based on certain conditions? For this reason, Verifiable Random Functions are used. They allow everyone to verify that a specific VRF was used and that the number was produced by a particular VRF and no other function. This allows us to generate verifiable random numbers for on-chain usage in a decentralized way.


:::NEXT DOC:::

increase the chances of an attacker cheating your application. Imagine you implemented a simple coin flip smart contract using VRF v2. In a bet function, you choose heads or tails and then request a random number. If you have selected heads (0) and the result of the VRF service meant that you would win the bet, it could try to withhold this answer and replace it with your second request if it’s more advantageous.

So you see, we must consider the unique properties of blockchains here to ensure randomness in our smart contracts. While the numbers are always random, we must also look into how our applications and smart contracts deal with them. In the end, it will be a matter of cost if it's worth attacking your application. You must also be aware of the protocol that you are using.

In general, re-organizations on chains are possible. A miner would take your request and try to create a new random number with a different block and do this until they find a block to their advantage. They cannot control the VRF output but can ""re-roll"" the dice. If they manage to produce a valid blockchain with this new block and the network accepts this block instead, they could effectively attack your application by controlling the random input.
While this is a possible attack, it's costly to attack a network like this, as in the proof of network. You need at least 51% of the network to drive such an attack. Depending on your application requirements, you consider a 20-block confirmation time highly secure. You can lower the block confirmation time depending on the value you are trying to protect. You must calculate an attacker's costs and potential reward to decide your confirmation time.


:::NEXT DOC:::

Congrats! You learned more about how randomness works in computer systems and especially blockchains.


:::NEXT DOC:::

While it’s effortless for Chainlink’s VRF to utilize on-chain randomness for your smart contract, it does not mean there are no pitfalls or potential attack vectors. Let’s explore how validators could potentially manipulate the generation of random numbers and other surprises. You can read more about it here.


:::NEXT DOC:::

# VRF v2 Introduction

<GradientTextWrapp>
  Randomness is essential for many types of applications. Think about how many games have randomness built-in. 
</GradientTextWrapp>

Rolling dice in dungeons and dragons, a random starting hand of poker, or a random next block in Tetris, randomness is an essential component of a majority of games. Smart contracts are a powerful tool for decentralized applications (dapps). But what if you want to build a game, raffle or any other type of application that utilizes randomness on the blockchain? Let's learn about randomness on the blockchain in the next lesson!
"
What was the error message received while executing the 'setAuthorizedSenders' method from remix?,Gas estimation errored with the following message (see below). The transaction execution will likely fail. Do you want to force sending? execution reverted: Cannot set authorized senders,{'source': 'https://stackoverflow.com/questions/75301080/unable-to-transact-operator-setauthorizedsenders-on-chainlink-goerli'},"The error message received while executing the 'setAuthorizedSenders' method from remix was ""execution reverted: Cannot set authorized senders"".","Question: (Asked on: 2023-01-31 17:44:37)
Unable to transact Operator.setAuthorizedSenders on Chainlink - Goerli
URL: https://stackoverflow.com/questions/75301080/unable-to-transact-operator-setauthorizedsenders-on-chainlink-goerli

Question Body:


Completed the local node setup on ubuntu 20.04, and the chainlink node is up
and running. Deployed the Operator.sol, while executing the
'setAuthorizedSenders' method from remix getting following error:

> Gas estimation errored with the following message (see below). The
> transaction execution will likely fail. Do you want to force sending?
> execution reverted: Cannot set authorized senders { ""originalError"": {
> ""code"": 3, ""data"":
> ""0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001d43616e6e6f742073657420617574686f72697a65642073656e64657273000000"",
> ""message"": ""execution reverted: Cannot set authorized senders"" } }



Answers:
(Answered on: 2023-02-01 06:55:44)


It is my mistake. Sent the node address as the admin address for owner during
the contract deployment. It is working as expected.





:::NEXT DOC:::

# Receiver

  * Overview
  * API Reference
  * Methods
  * Events

[AuthorizedReceiver](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/AuthorizedReceiver.sol)
is an abstract contract inherited by [operator](/chainlink-nodes/contracts/operator) and [forwarder](/chainlink-nodes/contracts/forwarder) contracts.

note

Calling setAuthorizedSenders has a different effect depending if it is called
from an [operator](/chainlink-nodes/contracts/operator) or a
[forwarder](/chainlink-nodes/contracts/forwarder) contract:

  * Owners of forwarder contracts allow authorized senders to call [forward](/chainlink-nodes/contracts/forwarder#forward).
  * Owners of operator contracts allow authorized senders to call the [fulfillOracleRequest](/chainlink-nodes/contracts/operator#fulfilloraclerequest) and [fulfillOracleRequest2](/chainlink-nodes/contracts/operator#fulfilloraclerequest2) methods.

## API Reference

### Methods

#### setAuthorizedSenders


    function setAuthorizedSenders(address[] senders) external

Sets the fulfillment permission for a given node. Use `true` to allow, `false`
to disallow. Emits an AuthorizedSendersChanged event.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| senders | address[] | The addresses of the authorized Chainlink node |
#### getAuthorizedSenders


    function getAuthorizedSenders() external view returns (address[])

Retrieve a list of authorized senders.

##### Return values

|   Name | Type 

:::NEXT DOC:::

on localnet (not testnet), remember this things:

  * use Operator.sol, not Oracle.sol
  * Operator->getAuthorizedSenders method, returns array, that contains your node addresses, if not exists, call Operator->setAuthorizedSenders with Node account addresses
  * your contracts for interaction with Operator contract (APIConsumer.sol in chainlink docs, by example) funded by LINK
  * Operator contract funded by LINK
  * Node account funded by ETH
  * Node job which jobId using in your contract for interaction, contains correct Operator contract address


---
(Answered on: 2021-11-18 15:36:00)


I managed to get the Multi-word request working thanks to a user on the
Chainlink discord. The problem was, as he said, that I was using the
Oracle.sol contract instead of the Operator.sol contract and then calling
""fulfillOracleRequest2"" on the node job. The problem was at the contract, not
the .toml job. In fact, the only thing I ended up changing from the node job
was the oracle address.

To get the contract working I just adapted the MultiWordConsumer.sol contract
from the chainlink docs. I couldn't find much information about the
Operator.sol contract on the Chainlink docs, so hopefully this will help
people facing the same issue I had:

  * You have deploy your own Operator.sol contract instance. You can do so in Remix by creating a contracting that only imports the Operator.sol contract: import ""@chainlink/contracts/src/v0.7/Operator.sol"";

  * After deploying the Operator contract, you have to set your node as an authorized sender. You can do this by calling ""setAuthorizedSenders"" with your node's address, i.e. [""0xb7...""]





:::NEXT DOC:::

estimation error` is a common error meaning that you don't have enough of
""something"" to send your transaction, maybe it's layer 1 (ETH) gas, or an
ERC20 token like LINK (technically, erc677, but I digress...)

Whenever you work with a Chainlink feature that uses the [request and
receive](https://docs.chain.link/docs/architecture-request-model/) method of
using chainlink, you need to [fund the consumer contract with LINK
token](https://docs.chain.link/docs/make-a-http-get-request/).

The issue here is you sent LINK to the oracle address and not the address of
your deployed contract.

[](https://i.stack.imgur.com/1ga4n.png)

If you copy the address of your deployed contract and send the LINK there, it
should work for you.





:::NEXT DOC:::

smart contract:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.12;
    
    import ""./FutNFTTransfer.sol"";
    import ""./VRFConsumer.sol"";
    
    contract FutNFTMatch is FutNFTTransfer, VRFConsumer {
        uint256 public levelPercentSuitablePosition = 75;
        uint256 public levelPercentNoPosition = 50;
        mapping(string => string[]) public formationToPositions;
        string[] public formations;
        string[] public allPositions;
        uint256 public lineupFee = 0.2 ether;
        uint256 public matchFee = 3 ether;
        address[] public lineupSet;
        mapping(address => uint256) public ownersToDeposits;
    
        modifier playersOwned(uint256[11] memory _playerIds) {
            for (uint256 i = 0; i < _playerIds.length; i++) {
                require(ownerOf(_playerIds[i]) == msg.sender, ""Players not owned!"");
            }
            _;
        }
    
        modifier lineUpSet(address _owner) {
            require(lineUps[_owner].isValid, ""Linup not set"");
 

:::NEXT DOC:::

   function setAuthorizedSenders(address[] senders) external

Sets the fulfillment permission for a given node. Use `true` to allow, `false`
to disallow. Emits an AuthorizedSendersChanged event.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| senders | address[] | The addresses of the authorized Chainlink node |
#### getAuthorizedSenders


    function getAuthorizedSenders() external view returns (address[])

Retrieve a list of authorized senders.

##### Return values

|   Name | Type      | Description        |
|-------:|:----------|:-------------------|
|    nan | address[] | array of addresses |
#### isAuthorizedSender


    function isAuthorizedSender(address sender) public view returns (bool)

Use this to check if a node is authorized to fulfill requests.

##### Parameters

| Name   | Type    | Description                       |
|:-------|:--------|:----------------------------------|
| sender | address | The address of the Chainlink node |
##### Return values

|   Name | Type   | Description                          |
|-------:|:-------|:-------------------------------------|
|    nan | bool   | The authorization status of the node |
### Events

#### AuthorizedSendersChanged


    event AuthorizedSendersChanged(address[] senders, address changedBy)

  * [ Edit this page

:::NEXT DOC:::

\\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
                     ]
        submit_tx    [type=""ethtx"" to=""0x8114f13FaF377FFc7A5AD32fb8a1e448667b871D"" data=""$(encode_tx)""]
    
        decode_log -> decode_cbor -> fetch -> parse -> encode_data -> encode_tx -> submit_tx
    """"""
    externalJobID = ""a3d1b2c9-4524-4e44-bdb4-12c5b5287df3""
    

Can anyone please point me in the right direction, like what I'm doing wrong
in these steps due to which the smart contract is unable to trigger the job-
spec ?



Answers:
(Answered on: 2022-03-30 19:19:15)


First of all, the owner address of the `Operator.sol` should be the Metamask
wallet Kovan testnet address (instead of the account address of the running
Chainlink node) from which the transactions are being done.

Then, after the `Operator.sol` being deployed successfully, call the
`setAuthorizedSenders` function of the `Operator.sol` by passing in the
account address of the running Chainlink node in the senders `address[]` field
like:

[](https://i.stack.imgur.com/uwgev.png)

* * *

Then, the

:::NEXT DOC:::

Parameters

| Name    | Type      | Description                                      |
|:--------|:----------|:-------------------------------------------------|
| ownable | address[] | list of addresses of Ownable contracts to accept |
#### setAuthorizedSendersOn


    function setAuthorizedSendersOn(address[] targets, address[] senders) public

Sets the fulfillment permission for `senders` on `targets`. Emits
TargetsUpdatedAuthorizedSenders event.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| targets | address[] | The addresses to set permissions on            |
| senders | address[] | The addresses that are allowed to send updates |
#### acceptAuthorizedReceivers


    function acceptAuthorizedReceivers(address[] targets, address[] senders) external

Accepts ownership of ownable contracts and then immediately sets the
authorized sender list on each of the newly owned contracts. This is primarily
intended for authorized forwarders but could possibly be extended to work with
future contracts.

##### Parameters

| Name    | Type      | Description                                    |
|:--------|:----------|:-----------------------------------------------|
| targets | address[] | The addresses to set permissions on            |
| senders | address[] | The addresses that are allowed to send updates |
#### withdraw


    function

:::NEXT DOC:::


    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.7.6;
    import ""@chainlink/contracts/src/v0.7/Operator.sol"";
    

**job GET >uint256 (I have already change the ""YOUR_ORACLE_CONTRACT_ADDRESS""
with my `operator` contract address)**

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Get > Uint256 - (TOML)""
    maxTaskDuration = ""0s""
    contractAddress = ""YOUR_ORACLE_CONTRACT_ADDRESS""
    minIncomingConfirmations = 0
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=""cborparse"" data=""$(decode_log.data)""]
        fetch        [type=""http"" method=GET url=""$(decode_cbor.get)"" allowUnrestrictedNetworkAccess=""true""]
        parse      

:::NEXT DOC:::

like what I'm doing wrong
in these steps due to which the smart contract is unable to trigger the job-
spec ?



Answers:
(Answered on: 2022-03-30 19:19:15)


First of all, the owner address of the `Operator.sol` should be the Metamask
wallet Kovan testnet address (instead of the account address of the running
Chainlink node) from which the transactions are being done.

Then, after the `Operator.sol` being deployed successfully, call the
`setAuthorizedSenders` function of the `Operator.sol` by passing in the
account address of the running Chainlink node in the senders `address[]` field
like:

[](https://i.stack.imgur.com/uwgev.png)

* * *

Then, the job-spec's `encode_data` should be having `requestId`parameter as
well:

    
    
    encode_data  [type=""ethabiencode"" abi=""(bytes32 requestId, uint256[][] value)"" data=""{ \\""requestId\\"": $(decode_log.requestId), \\""value\\"": $(parse) }""]
    

The entire job-spec should be:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""shamba-fire-data""
    contractAddress = ""0xf4434feDd55D3d6573627F39fA39867b23f4Bf7F""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId,"
What is the purpose of the VRFv2SubscriptionManager contract?,The purpose of the VRFv2SubscriptionManager contract is to manage subscriptions for the Chainlink Verifiable Random Function (VRF) service.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-9/solution.md'},"The purpose of the VRFv2SubscriptionManager contract is to create and manage a subscription contract for the Chainlink VRF v2, allowing for the creation of random values and the management of consumers and funding.","#####Chapter 5: VRF Subscriptions

# Subscription Manager Contract

Now that we learned more about the theoretical background, let’s get practical. We want to create and manage a subscription contract. We will use the example contract that you can find here on [Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2SubscriptionManager.sol&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.7+commit.e28d00a7.js). It shows an example implementation of a VRF v2 Subscription manager for the Goerli network. But you can also adjust it to work with other networks by changing the code's hardcoded addresses. You can find a complete list of available networks [here](https://docs.chain.link/docs/vrf-contracts/#configurations).

Hint: This course assumes you are already familiar with the Architecture of Chainlink VRF from [VRFv2 Introduction Chapter 4](https://www.chainlink.education/vrfIntroduction/chapter-4).

Generally, consumer contracts must implement the requestRandomWords() function providing coordinator parameters and subscription ID. This function is used to create random values. A second function, fulfillRandomWords(), must be implemented to receive the random values. Learn about how to implement the basics of such a contract in [chapters 6-12](https://www.chainlink.education/vrfIntroduction/chapter-6) from the introduction course.

We want to focus on the mentioned functions here and show how to manage subscriptions in this contract. So let’s start by creating a new subscription:

<Highlight class=""language-javascript"">
uint64 public s_subscriptionId;
 function

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  uint256[] public s_randomWords;
  uint256 public s_requestId;
  address s_owner;

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
    LINKTOKEN = LinkTokenInterface(link_token_contract);
    s_owner = msg.sender;
    s_subscriptionId = subscriptionId;
  }

:::NEXT DOC:::

and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Sepolia coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    
        // Sepolia LINK token contract. For other networks, see
       

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  uint256[] public s_randomWords;
  uint256 public s_requestId;
  address s_owner;

:::NEXT DOC:::

different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;


:::NEXT DOC:::

# Programmatic Subscription

  * Overview
  * Modifying subscriptions and configurations
  * Subscription manager contract
  * Funding and requesting simultaneously

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

How you manage the subscription depends on your randomness needs. You can
configure your subscriptions using the [Subscription
Manager](/vrf/v2/subscription/ui), but these examples demonstrate how to
create your subscription and add your consumer contracts programmatically. For
these examples, the contract owns and manages the subscription. Any wallet can
provide funding to those subscriptions.

You can view and monitor your subscriptions in the [Subscription
Manager](/vrf/v2/subscription/ui) even if you create them programmatically. Go
to [vrf.chain.link](https://vrf.chain.link) to open the Subscription Manager.

## Modifying subscriptions and configurations

Subscription configurations do not have to be static. You can change your
subscription configuration dynamically by calling the following functions
using the
[VRFCoordinatorV2Interface](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol):

  * Change the list of approved subscription consumers with: 
    * `addConsumer(uint64 subId, address consumer)`.
    * `removeConsumer(uint64 subId, address consumer)`.
  * Transfer the subscription ownership with: 
    * `requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)`.
    *

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface();
    LINKTOKEN = LinkTokenInterface();
    s_owner = ;
    s_subscriptionId = ;
  }


:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = ;
  address link_token_contract = ;
  bytes32 keyHash = ;
  uint32 callbackGasLimit = ;
  uint16 requestConfirmations = ;
  uint32 numWords =  ;
"
What is the correct way to mock a response using the _fulfillOracleRequest_ function in the MockOracle contract?,"The _fulfillOracleRequest_ function takes a bytes32 param for the response, so you need to encode it properly. This is how you can mock a response as part of the APIConsumer Unit Test: let mockResponse = '777'; const responseBytes = ethers.utils.formatBytes32String(mockResponse); const r = await mockOracle.fulfillOracleRequest(requestId, responseBytes);",{'source': 'https://stackoverflow.com/questions/70405858/how-to-mock-chainlink-oracle-api-responses-on-hardhat'},"The correct way to mock a response using the _fulfillOracleRequest_ function in the MockOracle contract is to properly encode the response as a bytes32 parameter using the `ethers.utils.formatBytes32String` function. For example, to mock a response of ""777"", you would first define `mockResponse = '777'`, then encode it as a bytes32 parameter using `responseBytes = ethers.utils.formatBytes32String(mockResponse)`, and finally call the _fulfillOracleRequest_ function with the requestId and responseBytes parameters.","Question: (Asked on: 2021-12-18 18:10:26)
How to mock Chainlink/oracle API responses on hardhat
URL: https://stackoverflow.com/questions/70405858/how-to-mock-chainlink-oracle-api-responses-on-hardhat

Question Body:


On the hardhat starter kit, the unit test checks if you can make an api
request. But it doesn't actually fulfill the request. In the tasks, it
requests volume data but it isn't shown how to fulfill the request.

From looking at the code for the mockOracle I found this function.

    
    
    const r = await mockOracle.fulfillOracleRequest(requestId, data)
    

I dont have any idea how to make the data be what I want it to be. For example
when I pass the following data it returns the huge seamingly random number
24516769870864860957297836120308737325622166553046088662895407649136392011776.

    
    
    const data = ethers.utils.formatBytes32String(""64"")
    

How do I mock the api response with the data I pass to fulfillOracleRequest?
Also, because I couldn't find any examples of this in the chainlink starter
kit, is this even the right way to be doing this on the local hardhat network?



Answers:
(Answered on: 2021-12-20 01:22:18)


The _fulfillOracleRequest_ function in the [MockOracle
contract](https://github.com/smartcontractkit/hardhat-starter-
kit/blob/main/contracts/test/MockOracle.sol) takes a bytes32 param for the
response, so you need to encode it properly. This is how you can mock a
response as part of the

:::NEXT DOC:::

   
    const data = ethers.utils.formatBytes32String(""64"")
    

How do I mock the api response with the data I pass to fulfillOracleRequest?
Also, because I couldn't find any examples of this in the chainlink starter
kit, is this even the right way to be doing this on the local hardhat network?



Answers:
(Answered on: 2021-12-20 01:22:18)


The _fulfillOracleRequest_ function in the [MockOracle
contract](https://github.com/smartcontractkit/hardhat-starter-
kit/blob/main/contracts/test/MockOracle.sol) takes a bytes32 param for the
response, so you need to encode it properly. This is how you can mock a
response as part of the [APIConsumer Unit
Test](https://github.com/smartcontractkit/hardhat-starter-
kit/blob/main/test/unit/APIConsumer_unit_test.js):

    
    
    let mockResponse = '777'
    const responseBytes = ethers.utils.formatBytes32String(mockResponse)
    const r = await mockOracle.fulfillOracleRequest(requestId, responseBytes)
    

To answer your second question, yes this is the correct thing to do when
working with local chains that aren't integrated to Chainlink oracles. There
is actually an [open issue](https://github.com/smartcontractkit/hardhat-
starter-kit/issues/67) to implement these for the unit tests. Feel free to
take it on if you want!





:::NEXT DOC:::

data to `operator.sol`

`operator.sol` is below:

    
    
    // SPDX-License-Identifier: MIT pragma solidity ^0.7.0;
    import ""@chainlink/contracts/src/v0.7/Operator.sol"";
    


---
(Answered on: 2022-05-27 07:09:53)


AFAIK `oracle.sol` does not support ""large responses"" and hence won't support
multi-word responses.

You need to switch to `operator.sol`, use `sendOperatorRequest(req,
ORACLE_PAYMENT);` in your client contract and use `fulfillOracleRequest2` in
your node's jobspec.

You can read more about the whole setup in [this blog
post](https://ijonas.com/fetching-multiple-off-chain-values-from-a-smart-
contract).





:::NEXT DOC:::

cancelExpiration, dataVersion, data} = events[0].args
        
        const encodeMwr = web3.eth.abi.encodeParameters(
            ['bytes32','int256','int256','int256','string','string'],
            [requestId, '123', '456', '789', 'text', 'moreText'])
    
    
        const encodeRequestId = web3.eth.abi.encodeParameters(
            ['bytes32'],
            [requestId])
            
        await mockOracle.connect(mockNode).fulfillOracleRequest2(requestIdfirst, payment, callbackAddr, callbackFunctionId, cancelExpiration, encodeMwr)

To improve on this you could then look to add an API http GET call into your
test script for getting the rest of the callback data for fulfillOracleRequest
or fulfillOracleRequest2 function.


---
(Answered on: 2022-12-19 02:50:38)


In Chainlink oracle workflow, consumers are basically supposed to send a
request to the off-chain oracle node so that the oracle node can fetch data
from the API specified by consumers. In the workflow, request sent by user
must be caught by off-chain oracle node.

What you are doing here is to send your request to smart contract `oracle` and
the `oracle` save your request into event log `oracleRequest` so that it could
be caught by off-chain oracle.

Your problem here is as suggested by modifier `permittedFunctionForLINK`, the
function selector is not `oracleRequest` so that off-chain oracle cannot
recognize the request.

I

:::NEXT DOC:::

 jobId,
                address(this),
                this.fulfill.selector
            );
            request.add(""orgAddress"", ""2021-11-02"");
            request.add(""senderAddress"", ""12111"");
            request.add(""receiverAddress"", ""FL"");
            request.add(""jwtToken"", _jwtToken);
            sendChainlinkRequestTo(oracle, request, fee);
        }
    
        /**
         * Callback function
         */
        function fulfill(
            bytes32 _requestId,
            uint256 _allInSystem,
            uint256 _isProject,
            uint256 _senderAuthority,
            uint256 _receiverAuthority
        ) public recordChainlinkFulfillment(_requestId) {
            allInSystem = _allInSystem;
            isProject = _isProject;
            senderAuthority = _senderAuthority;
            receiverAuthority = _receiverAuthority;
            emit requestFulfilled(
      

:::NEXT DOC:::

contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:

    
    
      modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata _data) {
        require(_data.length >= 32, ""Response must be > 32 bytes""); 
        bytes memory firstDataWord = new bytes(32);
        for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript

:::NEXT DOC:::

general you are trying to call a multi-Uint256 request but using
`oracle.sol` as referenced in the `encode_tx` task in the
`observerationSource` in the node `job-spec.toml` with
`abi=""fulfillOracleRequest(...)`. In general your error is sourced because
`oracle.sol` does not support heavier data requirements such as multiple
uint256 in a single request. See below for the code for `operator.sol`

If you would like to fix this issue you need to deploy `operator.sol`,
whitelist your `[""node_address""]` just as you did with oracle.sol, and replace
the `contractAddress` in your `job-spec.toml` with the operator.sol contract
address. Additionally in `encode_tx` task in the `observerationSource` in the
node `job-spec.toml` specify `abi=""fulfillOracleRequest2(...)` to properly
reference `operator.sol`. Then finally switch out the oracle address pointed
at in the test smart contract requesting the data to `operator.sol`

`operator.sol` is below:

    
    
    // SPDX-License-Identifier: MIT pragma solidity ^0.7.0;
    import ""@chainlink/contracts/src/v0.7/Operator.sol"";
    


---
(Answered on: 2022-05-27 07:09:53)


AFAIK `oracle.sol` does not support ""large responses"" and hence won't support
multi-word responses.

You need to switch to `operator.sol`, use `sendOperatorRequest(req,
ORACLE_PAYMENT);` in your client contract and use `fulfillOracleRequest2` in
your node's jobspec.

You can read more about the whole setup in [this

:::NEXT DOC:::

sender             | address | The sender of the request                      |
| payment            | uint256 | The amount of payment given (specified in wei) |
| specId             | bytes32 | The Job Specification ID                       |
| callbackFunctionId | bytes4  | The callback function ID for the response      |
| nonce              | uint256 | The nonce sent by the requester                |
| dataVersion        | uint256 | The specified data version                     |
| data               | bytes   | The extra request parameters                   |
#### fulfillOracleRequest

Legacy

Use `fulfillOracleRequest2` function instead.


    function fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data) external returns (bool)

Called by the Chainlink node to fulfill requests. Given params must hash back
to the commitment stored from `oracleRequest`. Will call the callback address'
callback function without bubbling up error checking in a `require` so that
the node can get paid. Emits OracleResponse event.

##### Parameters

| Name               | Type    | Description                                               

:::NEXT DOC:::

returns (bytes32 requestId) {
        Chainlink.Request memory request = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );
    
        request.add(
            ""get"",
            ""https://api.henrikdev.xyz/valorant/v1/account/draven/2023""
        );
        request.add(""path"", ""data.account_level"");
    
        return sendChainlinkRequestTo(oracle, request, oracleFee);
    }
    
    function fulfill(bytes32 _requestId, uint256 _level)
        public
        recordChainlinkFulfillment(_requestId)
    {
        playerLevel = _level;
    }
    

I'm deploying from hardhat, with the following parameters (ignoring the ones
for VRF since that's working):

Oracle: 0x9C0383DE842A3A0f403b0021F6F85756524d5599

JobId: 0x3766623533366265383635623433333662323766633130313437633139336337

OracleFee: 0.1 * 10**18

The function runs fine, the transaction doesn't revert or anything, but when I
check ""playerLevel"", it's always just 0



Answers:
(Answered on: 2021-11-05 18:06:04)


Looking at the Etherscan activity, it

:::NEXT DOC:::

 // {""player"": {
            //            ""id"": ""4291820"",
            //            ""score"": 560
            //        }
            //  }
            request.add(""path"", ""player.score"");
            
            
            // Sends the request
            return sendChainlinkRequestTo(oracle, request, fee);
        }
        
        /**
         * Receive the response in the form of uint256
         */ 
        function fulfill(bytes32 _requestId, uint256 _score) public recordChainlinkFulfillment(_requestId)
        {
            playerScore = _score;
        }
    
        // function withdrawLink() external {} - Implement a withdraw function to avoid locking your LINK in the contract
    }
    



Answers:
(Answered on: 2022-07-22 23:02:38)


I succeed to implement an external API call from a smart-contract by using
[Frensprotocol oracle](https://www.frensprotocol.com). The
[documentation](https://docs.frensprotocol.com/) helped. And to get the tokens
to make the Oracle work you can"
What are events in Solidity and how can they be used?,Events in Solidity are a way to emit events that clients can listen to and react accordingly. They can also be used as a cheap form of storage. Events are write-only and cannot be read. They can be used to create an audit trail and communicate easy-to-access messages to listeners. Libraries like ethers.js allow us to listen to these events and react accordingly.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-7/course.md'},"Events in Solidity are a way to emit events that clients can listen to and react accordingly. They can be used as a cheap form of storage and are less expensive than using a storage location. However, events are write-only and cannot be read by the EVM. They can be used to communicate easy-to-access messages to listeners and create an audit trail. They are often used to communicate that a new token was minted.","#####Chapter 7:

# Events

When learning a new language, we often write a hello world program and log a string to the console. Solidity does not offer a console.log but has events that can be used in a similar fashion. You can use it to emit events that clients can listen to react accordingly. They can also be used as a cheap form of storage as it is less expensive to emit an event than to use the storage location (see chapter 2). But note that events are write-only. EVM does not allow to read events.

Let’s learn how we can use events in Solidity:

<Highlight class=""language-javascript"">
contract Event {
 event Log(address indexed sender, string message);
 
 function foo() public {
       emit Log(msg.sender, ""Hello World!"");
       emit Log(msg.sender, ""Another message"");
 }
}
</Highlight>

On the top we have defined a name of the Event and defined it’s parameters. You can see here that we have indexed and not index parameters. Indexed parameters are called “topics” and are searchable parameters in events. We will explain why this is useful in a moment.

We can now use the keyword **emit** followed by the event name **Log** to emit an event of the type Log. These events can be read on an explorer like Etherscan. And there you will see that each event has the address of the contract or account the event is emitted from and Topics which is the indexed parameter of the event and the data itself. These are ABI-Encoded or hashed non-indexed parameters of the event. More on ABI in a future course.
Libraries like ethers.js allow us to listen to these events and react accordingly. The great thing about events

:::NEXT DOC:::

Solidity does not offer a console.log but has events that can be used in a similar fashion. You can use it to emit events that clients can listen to react accordingly. They can also be used as a cheap form of storage as it is less expensive to emit an event than to use the storage location. But note that events are write-only. EVM does not allow to read events.


:::NEXT DOC:::

and defined it’s parameters. You can see here that we have indexed and not index parameters. Indexed parameters are called “topics” and are searchable parameters in events. We will explain why this is useful in a moment.

We can now use the keyword **emit** followed by the event name **Log** to emit an event of the type Log. These events can be read on an explorer like Etherscan. And there you will see that each event has the address of the contract or account the event is emitted from and Topics which is the indexed parameter of the event and the data itself. These are ABI-Encoded or hashed non-indexed parameters of the event. More on ABI in a future course.
Libraries like ethers.js allow us to listen to these events and react accordingly. The great thing about events is that applications not interested in writing or interacting with the blockchain can still react to events emitted from smart contracts. In other terms, you could consider events a simple way to communicate easy-to-access messages to listeners. You can either listen to them in real-time as they are written to a new block or also retrieve historical events from the past. It makes it easy to create an audit trail this way. You will often see events used to communicate that a new token was minted.


:::NEXT DOC:::

# Solidity Introduction

<GradientTextWrapp>
  Solidity is an object-oriented, high-level language for implementing smart contracts. Learn about the basics here.
</GradientTextWrapp>

In Solidity 101 we learned about the basics of smart contracts in Solidity. We looked into the Ethereum Virtual Machine and how it deals with state (variables) and logic (functions). Basic concepts like the minimal structure of a contract and how to write functions to manipulate values. And we learned about data types, operators and looked into more depth into arrays.

In this course, we want to dive deeper and expand our knowledge and learn about futher basics like conditional statements, loops and complex data structures like arrays and maps. In the second part, we will see how data is stored and variables handled in contracts. Next, we will learn how to handle errors in Solidity.

The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

We can actually give more information to the Solidity compiler on how we want to use our variables (and later functions). We can tell the compiler how we want our variables to be accessed. Many blockchains, such as Ethereum, act as one monolithic computer.


:::NEXT DOC:::

# Solidity Introduction

<GradientTextWrapp>
  Solidity is an object-oriented, high-level language for implementing smart contracts. Learn about the basics here.
</GradientTextWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

#####Chapter 13:

# Conclusion

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

Congrats for making it this far! That’s a lot of Solidity concepts! The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions). In future courses, we will go into more detail on more complex variables such as storing structs within arrays and more special functions such as the constructor and events. And as always, you know the best way to learn is by doing! Feel free to go to https://remix.ethereum.org/, and just mess around with writing code there. It may feel overwhelming at first, but don’t worry it’s just to get a feel for what’s to come!


:::NEXT DOC:::

#####Chapter 1:

# Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Inspired by the power of smart contracts and blockchain, it’s time to dive in.
    </div>
  </div>
</ContentWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent. If you are familiar with some programming, it may help to know that Solidity is an **object-oriented programming language**. If you are not familiar with what that means, don’t worry, we’ll cover it in a future course.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!




:::NEXT DOC:::

pragma solidity >=0.7.0 <0.9.0;

contract Event {
 // set the amount also as an indexed parameter
 event Log(address indexed sender, uint256 amount);
 
 mapping(address => uint) public amounts;

 function foo() public {
  uint256 _amount = 100;
  amounts[msg.sender] = _amount;
  // emit the Log event in the next line
  
 }
}


:::NEXT DOC:::

Having a basic understanding of what’s going on under the hood in Solidity is important so let’s learn about the EVM!
"
What is an array in programming?,An array is many related pieces of data stored together in a single variable.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-8/course.md'},"An array in programming is a variable that stores many related pieces of data together in a single variable. It can only store one type of data, but can have multiple values of that type stored within it.","store the book titles in an **array** of type string. What is an array? It’s many related pieces of data stored together in a single variable!

Just like regular variables arrays can only store one type of data, but can have multiple values of that type stored within it. To declare a variable as an array, we put square brackets next to the type of the variable. For example:

<Highlight class=""language-javascript"">
string[] myBooks;
</Highlight>

Creates a variable called “myBooks” which is an array of strings.

You can then assign multiple values to the array by using the assignment operator. The difference from a regular variable assignment is that on the right side of the assignment operator you put the values you want in-between square brackets and separate each value by a comma for example:
<Highlight class=""language-javascript"">
string[] myBooks = [ “Mastering Ethereum”, “Programming Rust”, “Zombie Survival Guide”]
</Highlight>

Or 

<Highlight class=""language-javascript"">
uint[] numbers;
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
</Highlight>

You can limit the amount of values that can go into the array by putting a number in the brackets by the array type when you declare it. For example:

<Highlight class=""language-javascript"">
uint[6] numbers;
</Highlight>

Limits the amount of values that can fit into the array called “numbers” to a max of 6 values.



:::NEXT DOC:::

#####Chapter 8:

# Creating Arrays

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

It is common in programming to want to store many associated values together. For instance I may want to store the title of every book I own. We could put each book title in it’s own variable of type string, but it would be difficult to access all those variables at once, and keep track of each variable when I need to read this information. So instead we can store the book titles in an **array** of type string. What is an array? It’s many related pieces of data stored together in a single variable!

Just like regular variables arrays can only store one type of data, but can have multiple values of that type stored within it. To declare a variable as an array, we put square brackets next to the type of the variable. For example:

<Highlight class=""language-javascript"">
string[] myBooks;
</Highlight>

Creates a variable called “myBooks” which is an array of strings.

You can then assign multiple values to the array by using the assignment operator. The difference from a regular variable assignment is that on the right side of the assignment operator you put the values you want in-between square brackets and separate each value by a comma for example:
<Highlight

:::NEXT DOC:::

#####Chapter 9:

# Reading Array Values

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

Now that we can store multiple related values into a single array our lives organizing our data should be much easier! But how do we access those stored values later? Data stored in arrays is associated with an index which describes the order of the data. Indexing in Solidity starts at 0. So this means the first values assigned to an array has the index of 0, the second value assigned to the array has an index of 1, the third value an index of 2 and so on.

You can access the values in an array by calling the array variable and putting the index of the value you want to access within square brackets. For example:

<Highlight class=""language-javascript"">
string[] myBooks = [ “Mastering Ethereum”, “Programming Rust”, “Zombie Survival Guide”]
</Highlight>

And then

myBooks[0] will access the first value assigned to the myBooks array (since Solidity indexes at 0) which will be the value “Mastering Ethereum”.

As another example I could take a value in an array and also assign it to another variable:

<Highlight class=""language-javascript"">
string myFirstBook =

:::NEXT DOC:::

the index of 0, the second value assigned to the array has an index of 1, the third value an index of 2 and so on.

You can access the values in an array by calling the array variable and putting the index of the value you want to access within square brackets. For example:

<Highlight class=""language-javascript"">
string[] myBooks = [ “Mastering Ethereum”, “Programming Rust”, “Zombie Survival Guide”]
</Highlight>

And then

myBooks[0] will access the first value assigned to the myBooks array (since Solidity indexes at 0) which will be the value “Mastering Ethereum”.

As another example I could take a value in an array and also assign it to another variable:

<Highlight class=""language-javascript"">
string myFirstBook = myBooks[0];
</Highlight>

Which will take the value indexed at zero in the “myBooks” array (which is “Mastering Ethereum”) and assign it to the string named “myFirstBook”. This won’t erase it from the myBooks array but make a copy and assign to the new “myFirstBook” variable.



:::NEXT DOC:::

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing variables and change data by defining logic in functions. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time.


:::NEXT DOC:::

Now that we can store multiple related values into a single array our lives organizing our data should be much easier! But how do we access those stored values later?


:::NEXT DOC:::

# Solidity Introduction

<GradientTextWrapp>
  Solidity is an object-oriented, high-level language for implementing smart contracts. Learn about the basics here.
</GradientTextWrapp>

In Solidity 101 we learned about the basics of smart contracts in Solidity. We looked into the Ethereum Virtual Machine and how it deals with state (variables) and logic (functions). Basic concepts like the minimal structure of a contract and how to write functions to manipulate values. And we learned about data types, operators and looked into more depth into arrays.

In this course, we want to dive deeper and expand our knowledge and learn about futher basics like conditional statements, loops and complex data structures like arrays and maps. In the second part, we will see how data is stored and variables handled in contracts. Next, we will learn how to handle errors in Solidity.

The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

In programming an operator is a symbol that represents an action or process. In the case of the assignment operator whatever is to the left of the equals sign is being assigned the value of whatever is on the right of the equal sign.


:::NEXT DOC:::

It is common in programming to want to store many associated values together. For instance I may want to store the title of every book I own. We could put each book title in it’s own variable of type string, but it would be difficult to access all those variables at once, and keep track of each variable when I need to read this information.


:::NEXT DOC:::

#####Chapter 6:

# Assigning Variables Values

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now that you understood how to connect the off-chain world you can utilize this knowledge now for your NFT. Imagine a NFT that reacts to the price of Ethereum. It could rain when the price falls and it could be sunny when the price rises.
    </div>
  </div>
</ContentWrapp> -->

In the last activity we created a variable called “myFavoriteNumber” of type uint, but what if we want to actually store a value in that variable? That’s what the equal sign ( = ) “assignment” operator is for. In programming an operator is a symbol that represents an action or process. In the case of the assignment operator whatever is to the left of the equals sign is being assigned the value of whatever is on the right of the equal sign. For instance if we had:

<Highlight class=""language-javascript"">
uint myFavNum; 
myFavNum = 42;
</Highlight>


In the first line we are creating the variable “myFavoriteNum” of type uint, and then in the second line we are assigning “myFavoriteNum” the value 42. So my “myFavNum” will stay 42 until we change it again! Also reminder we put a semi-colon at the end of every complete line. Another example:

<Highlight class=""language-javascript"">
uint myFavNum; 
myFavNum = 42; 
myFavNum"
What is the cryptocurrency symbol for Cardano?,ADA,{'source': 'https://docs.chain.link/data-feeds/price-feeds/addresses/'},The cryptocurrency symbol for Cardano is ADA.,"|
| 🟢AAVE / USD                           | Aave                                                     | Crypto         | 1%          | 3600s       |     8 | 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 |
| 🟢ADA / USD                            | Cardano                                                  | Crypto         | 1%          | 86400s      |     8 | 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55 |
| 🟢ADX / USD                            | Adex                                                     | Crypto         | 2%          | 86400s      |     8 | 0x231e764B44b2C1b7Ca171fa8021A24ed520Cde10 |
| 🟢ALCX / ETH     

:::NEXT DOC:::

|
| 🟢ONT / USD                            | Ontology                                                 | Crypto         | 2%          | 86400s      |     8 | 0xcDa3708C5c2907FCca52BB3f9d3e4c2028b89319 |
| 🟢ORN / ETH                            | Orion Protocol                                           | Crypto         | 2%          | 86400s      |    18 | 0xbA9B2a360eb8aBdb677d6d7f27E12De11AA052ef |
| 🟢OXT / USD                            | Orchid Protocol                                          | Crypto         | 5%          | 86400s      |     8 | 0xd75AAaE4AF0c398ca13e2667Be57AF2ccA8B5de6 |
| 🔵Orchid                             

:::NEXT DOC:::

|
| 🟢COMP / USD                           | Compound                                                 | Crypto         | 1%          | 3600s       |     8 | 0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5 |
| 🟢CRO / USD                            | Cronos                                                   | Crypto         | 1%          | 86400s      |     8 | 0x00Cb80Cf097D9aA9A3779ad8EE7cF98437eaE050 |
| 🟢CRV / ETH                            | Curve DAO                                                | Crypto         | 2%          | 86400s      |    18 | 0x8a12Be339B0cD1829b91Adc01977caa5E9ac121e |
| 🟢CRV / USD       

:::NEXT DOC:::

  | Crypto         | 1%          | 86400s      |    18 | 0x773616E4d11A78F511299002da57A0a94577F1f4 |
| 🟢DAI / USD                            | DAI                                                      | Crypto         | 0.25%       | 3600s       |     8 | 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9 |
| 🟢DODO / USD                           | Dodo                                                     | Crypto         | 1%          | 86400s      |     8 | 0x9613A51Ad59EE375e6D8fa12eeef0281f1448739 |
| 🟢DOGE / USD                           | Dogecoin                                                 | Crypto        

:::NEXT DOC:::

                                     | Crypto         | 1%          | 86400s      |     8 | 0x9613A51Ad59EE375e6D8fa12eeef0281f1448739 |
| 🟢DOGE / USD                           | Dogecoin                                                 | Crypto         | 0.5%        | 86400s      |     8 | 0x2465CefD3b488BE410b941b1d4b2767088e2A028 |
| 🟢DOT / USD                            | Polkadot                                                 | Crypto         | 1%          | 86400s      |     8 | 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734 |
| 🔵DPI / ETH                            | DeFi Pulse Index                             

:::NEXT DOC:::

             | Binance USD                                              | Crypto         | 0.5%        | 86400s      |     8 | 0x833D8Eb16D306ed1FbB5D7A2E019e106B960965A |
| 🟢CAD / USD                            | Canadian Dollar                                          | Forex          | 0.15%       | 86400s      |     8 | 0xa34317DB73e77d453b1B8d04550c44D10e981C8e |
| 🟢CAKE / USD                           | Pancakeswap                                              | Crypto         | 2%          | 86400s      |     8 | 0xEb0adf5C06861d6c07174288ce4D0a8128164003 |
| 🟢CBETH / ETH                          | Coinbase Wrapped Staked ETH            

:::NEXT DOC:::

|
| 🟢ADX / USD                            | Adex                                                     | Crypto         | 2%          | 86400s      |     8 | 0x231e764B44b2C1b7Ca171fa8021A24ed520Cde10 |
| 🟢ALCX / ETH                           | Alchemix                                                 | Crypto         | 2%          | 86400s      |    18 | 0x194a9AaF2e0b67c35915cD01101585A33Fe25CAa |
| 🟢ALCX / USD                           | Alchemix                                                 | Crypto         | 2%          | 86400s      |     8 | 0xc355e4C0B3ff4Ed0B49EaACD55FE29B311f42976 |
| 🟢ALPHA / ETH          

:::NEXT DOC:::

|
| 🟢OMG / ETH                            | Omisego                                                  | Crypto         | 2%          | 86400s      |    18 | 0x57C9aB3e56EE4a83752c181f241120a3DBba06a1 |
| 🟢OMG / USD                            | Omisego                                                  | Crypto         | 2%          | 86400s      |     8 | 0x7D476f061F8212A8C9317D5784e72B4212436E93 |
| 🟢ONT / USD                            | Ontology                                                 | Crypto         | 2%          | 86400s      |     8 | 0xcDa3708C5c2907FCca52BB3f9d3e4c2028b89319 |
| 🟢ORN / ETH            

:::NEXT DOC:::

                                  | Crypto         | 1%          | 86400s      |    18 | 0x3886BA987236181D98F2401c507Fb8BeA7871dF2 |
| 🟢TUSD / USD                           | True USD                                                 | Crypto         | 0.3%        | 86400s      |     8 | 0xec746eCF986E2927Abd291a2A1716c940100f8Ba |
| 🔵Total Marketcap / USD                | Total cryptocurrency market cap                          | Crypto         | 1%          | 86400s      |     8 | 0xEC8761a0A73c34329CA5B1D3Dc7eD07F30e836e2 |
| 🟢UMA / ETH                            | Uma                                                      | Crypto         | 2%   

:::NEXT DOC:::

                     | Circle USD                                               | Crypto         | 1%          | 86400s      |    18 | 0x986b5E1e1755e3C2440e960477f25201B0a8bbD4 |
| 🟢USDC / USD                           | Circle USD                                               | Crypto         | 0.25%       | 86400s      |     8 | 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6 |
| 🟢USDD / USD                           | USDD                                                     | Crypto         | 1%          | 86400s      |     8 | 0x0ed39A19D2a68b722408d84e4d970827f61E6c0A |
| 🟢USDP / USD                           |"
What are the three different locations to store variables in Solidity?,"The three different locations to store variables in Solidity are storage, memory, and calldata.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-2/course.md'},"The three different locations to store variables in Solidity are storage, memory, and calldata.","Variables can be declared as storage, memory or calldata to specify the location of the data. Learn how to and when to use storage and memory variables.


:::NEXT DOC:::

#####Chapter 2:

# Storage

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When someone says the data is stored on the blockchain, what does it actually mean from a perspective of a smart contract? Where is the data stored? How is it stored?
    </div>
  </div>
</ContentWrapp>

As we learned in the previous chapter, Ethereum could be described as a state machine. Transactions are then used to transition from one state to another state. The transactions are stored into individual blocks. These blocks are linked to each other creating the Ethereum blockchain. Everyone can take these transactions and follow the transition rules resulting in the same state for everyone.
But how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function

:::NEXT DOC:::

how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function calls. As block space is very valuable, storage variables are arranged in a compact way into storage slots into blocks of 32 bytes. Variables that take less than 32 bytes are combined into the same slot. Taking the least amount of space. Data is stored in order of the declaration in the contract in successive order. So we have slot 0x0, slot 0x1, slot 0x2, and so on.

```Solidity
contract StorageExample {
    uint256 nubmerOne = 1; // slot 0x0
    string customGreeting = ""Hello Chainlink""; // slot 0x1
    uint256 numberTwo; // slot 0x2

    string constant greeting = ""Hello World""; // no storage

    bool active; // slot 0x3
    bool admin; // slot 0x3
    bytes16 foo; // slot 0x3
    bytes16 bar; // slot 0x4
}
```

As you can see

:::NEXT DOC:::

constant variables (greeting) are not stored in storage slots. When a constant state variable is read the EVM uses the assigned value instead. the booleans active and admin just take 1 bit each and bytes16 takes 16 bits, so a total of 18 bits. That’s why they are all stored in slot 0x3. The last bytes16 variables bar takes another 16 bits but cannot be stored in slot 0x3 because the max size is 32 bytes. So a new slot is occupied.

Dynamic-sized arrays and structs are handled a little differently though as the size is unknown at the point of declaration. They always start with a slot that takes 32 bytes and their elements are stored in a different storage slot. The beginning of this storage slot is computed using a Keccack-256 hash.

**Memory** variables live only in memory and exist in the scope of a function. They are mutable inside that scope but cannot be called outside of the function. Once a function execution is completed, all variables in memory are released.

```Solidity
function add(uint256 a, uint256 b) pure returns(uint256) {
    uint256 result = a + b;
    return result;
}
```

Any manipulations done to memory variables is not written into the blockchain resulting in less gas consumption. So this is why we always need to ask if we need persistence.

There is an exception though as arrays, structs and mappings are stored in storage. This is important to remember as it might introduce critical bugs into your code when not considered. We will learn more about these data types in the upcoming chapters.


:::NEXT DOC:::

We can actually give more information to the Solidity compiler on how we want to use our variables (and later functions). We can tell the compiler how we want our variables to be accessed. Many blockchains, such as Ethereum, act as one monolithic computer.


:::NEXT DOC:::

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing variables and change data by defining logic in functions. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time.


:::NEXT DOC:::


    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal internalVar;
    uint8 private privateVar;

Learn more about state variables visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#state-variable-visibility).

### Constructors

Another familiar concept to programmers is the **constructor**. When you
deploy a contract, the constructor sets the state of the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use

:::NEXT DOC:::

deploy code to a blockchain like Ethereum, that code can access any other code anyone has deployed to that blockchain. This is like how programs downloaded to your computer can access other programs on your computer. This allows smart contracts to interact in many unique and interesting ways that regular web application back ends may not be able to do so easily. However, this can also open risks of other code using our code in unintended ways.

To help prevent this we can declare “access modifiers” when declaring our variables, which limit what code on the blockchain can access and change those variables. The four types of variable access modifiers are:


* Public 
    * The variable/function can be accessed or changed by any other code or wallet on the blockchain.
* Private
    * The variable/function can only be accessed or changed within the current contract
* Internal
    * The variable/function can only be accessed or changed within the current contract or any other contract that inherits the current contract (we’ll discuss inheritance in another lesson)
* External
    * The variable/function can only be accessed/changed from outside code or blockchain wallets

To declare the access modifier of a variable we put it inbetween the function type and name like this:

<Highlight class=""language-javascript"">
uint public myFavNum;
</Highlight>

If no access modifier is declared then the variable is automatically assigned the private modifier. For example

<Highlight class=""language-javascript"">
uint myFavNum;
</Highlight>
 
Is equivalent to 

<Highlight class=""language-javascript"">
uint private myFavNum;
</Highlight>


:::NEXT DOC:::

Thus far, we’ve mainly been concerned with storing data in variables and accessing that stored data. But what if we want to manipulate data?


:::NEXT DOC:::

It is common in programming to want to store many associated values together. For instance I may want to store the title of every book I own. We could put each book title in it’s own variable of type string, but it would be difficult to access all those variables at once, and keep track of each variable when I need to read this information.
"
What is a subscription in VRFv2?,A subscription is an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to 'consumer' contracts that want to request randomness.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-5/course.md'},"A subscription in VRFv2 is an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. It allows consumer contracts to have much more flexibility in requesting random numbers, such as specifying how many random numbers it wants to request, how much it's willing to pay for gas, and setting a limit to how much gas will be spent by the VRF when submitting the random number. The amount of LINK token to be paid to the VRF can be dynamic based on network conditions.","#####Chapter 5: VRF Subscriptions

# Subscribing to the VRF
Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number. 

## VRFv2
In VRFv2, the most recent version of the VRF, the concept of a subscription was added. What is a subscription? Essentially, it's an account created on the VRFCoordinator contract that can be funded with LINK tokens and points to ""consumer"" contracts that want to request randomness. Once a subscription is set-up a consumer contract can then request randomness, the VRF respondes with a random number and proof, and then after the random number is included on-chain the VRF is paid with some of the LINK prepaid in the subscription.

The power that comes from this subscription model is that now consumer contracts have much more flexibility in requesting random numbers. Before subscriptions it was a static price, and the VRF always returned a single random number. 
 
But what if the consumer contract needs more than one random number? The consumer contract can now specify how many random numbers it wants to request.  
 
What if the consumer contract needs the random number to be included very fast by paying a higher gas price? The consumer contract can now request how much it's willing to pay for gas. This is called the **gas lane**. 
 
What if the consumer contract needs to run some heavy calculations after recieving the random number? It can set a limit to how much gas will be spent by the VRF when submitting the random number. This is called the

:::NEXT DOC:::

different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends

:::NEXT DOC:::

# Subscription Method

  * Overview
  * Subscriptions
  * Request and receive data
  * Set up your contract and request
  * How VRF processes your request
  * Limits
  * Subscription limits
  * Coordinator contract limits

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This section explains how to generate random numbers using the subscription
method.

## Subscriptions

VRF v2 requests receive funding from subscription accounts. The [Subscription
Manager](/vrf/v2/subscription/ui) lets you create an account and pre-pay for
VRF v2, so you don't provide funding each time your application requests
randomness. This reduces the total gas cost to use VRF v2. It also provides a
simple way to fund your use of Chainlink products from a single location, so
you don't have to manage multiple wallets across several different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that

:::NEXT DOC:::

# Migrating from VRF v1

  * Overview
  * Comparing VRF v1 to the VRF v2 subscription method
  * Updating your applications to use VRF v2

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

## Comparing VRF v1 to the VRF v2 subscription method

Chainlink VRF v2 includes several improvements and changes to the way you fund
and request randomness for your smart contracts.

  * **Subscription management:** Chainlink VRF v2 introduces a [Subscription Manager](/vrf/v2/subscription/ui) application that allows smart contract applications to pre-fund multiple requests for randomness using a single LINK token balance. This reduces the gas fees for VRF requests by eliminating the need to transfer LINK tokens for each individual request. You transfer LINK tokens to the subscription balance only when it requires additional funding. Read the [Subscription Manager](/vrf/v2/subscription/ui) page to learn more.

  * **Variable Callback Gas Limit:** Chainlink VRF v2 lets you adjust the callback gas limit when your smart contract application receives verifiable randomness. Consuming contracts can execute more complex logic in the callback request function that receives the random values. Tasks involving the delivered randomness are handled during the response process. The new gas limits are higher than the VRF V1 limit, and vary depending on the underlying blockchain you use. See the gas limits on the [VRF Supported Networks](/vrf/v2/subscription/supported-networks) page.

  * **More configuration capability:** You can define how many block confirmations must pass before verifiable randomness is generated and delivered

:::NEXT DOC:::

page to learn more.

  * **Multiple Random Outputs in a Single Request:** The [VRF Coordinator contracts](/vrf/v2/subscription/supported-networks) in VRF v2 allow you to request multiple random numbers (multi-word) in a single on-chain transaction, which reduces gas costs. The fulfillment is also a single transaction, which reduces the latency of responses.

  * **Unified Billing - Delegate Subscription Balance to Multiple Addresses:** Chainlink VRF v2 allows up to 100 smart contract addresses to fund their requests for verifiable randomness from a single LINK subscription balance, which is managed by the subscription owner.

Read the [Chainlink VRF v2 blog post](https://blog.chain.link/vrf-v2-mainnet-launch/) for a detailed explanation about the benefits and use cases for VRF
v2.

## Updating your applications to use VRF v2

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

To modify your existing smart contract code to work with VRF v2, complete the
following changes. See the [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number) guide for an
example.

  1. Set up and fund a subscription in the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)



:::NEXT DOC:::

# Subscription Manager User Interface

  * Overview
  * Actions menu
  * Consumers
  * Pending
  * History
  * Recent fulfillments
  * Events
  * Failed requests

You are viewing the VRF v2 guide - Subscription method

To learn how to request random numbers without a subscription, see the [direct
funding method](/vrf/v2/direct-funding/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

The VRF v2 Subscription Manager is available at
[vrf.chain.link](https://vrf.chain.link/). The Subscription Manager lets you
create a subscription and pre-pay for VRF v2 so you don't need to provide
funding each time your application requests randomness. This guide walks you
through the main sections of the UI.

Troubleshooting

Read the pending and failed requests sections to learn how to troubleshoot
your VRF requests.



Subscription components:

  * **Status** : Indicates if the subscription is still active or not.
  * **ID** : The unique subscription identifier. Approved consuming contracts use LINK from this subscription to pay for each randomness request.
  * **Admin** : The account address that owns this subscription ID.
  * **Consumers** : The number of consuming contracts that are approved to make VRF requests using this subscription.
  * **Fulfillment** : The number of successful randomness requests that are already completed.
  * **Balance** : The amount of LINK remaining to be used for requests that use this subscription.

## Actions menu

Expand the **Actions** menu to display actions you can take for any
subscription that you own:



  * **Fund subscription** : Displays a field allowing you to fund your subscription from your connected wallet. Specify how much LINK you'd like to send to your subscription.
  *

:::NEXT DOC:::

use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends on current network conditions. The callback gas depends
on your callback function, and the number of random values in your request.
The cost of each request is final only after the transaction is complete, but
you define the limits you are willing to spend for the request with the
following variables:

  * **Gas lane:** The maximum gas price you are willing to pay for a request in wei. Define this limit by specifying the appropriate `keyHash` in your request. The limits of each gas lane are important for handling gas price spikes when Chainlink VRF bumps the gas price to fulfill your request quickly.

  * **Callback gas limit:** Specifies the maximum amount of gas you are willing to spend on the callback request. Define this limit by specifying the `callbackGasLimit` value in your request.

## Request and receive data

Requests to Chainlink VRF v2 follow the request and receive data cycle. This
end-to-end diagram shows each step in the lifecycle of a VRF subscription
request, and registering a smart contract with a VRF subscription account:

Two types of accounts exist in the Ethereum ecosystem, and both are used in
VRF:

  * EOA (Externally Owned Account):

:::NEXT DOC:::

                                                                 | No refunds for overpayment after requests are completed                                                                                                                                                     |
| Flexible funding method first introduced in VRF v2. Compare the VRF v2 subscription method to VRF v1.                                                                  | Similar funding method to VRF v1, with the benefit of receiving more random values per request than VRF v1. Compare direct funding in VRF v2 and v1.                                                        |
## Supported networks

The contract addresses and gas price limits are different depending on which
method you use to get randomness. You can find the configuration, addresses,
and limits for each method on the following pages:

  * [Subscription Supported networks](/vrf/v2/subscription/supported-networks)


:::NEXT DOC:::

                                                                                                                                 |
| VRF costs are calculated after requests are fulfilled and then deducted from the subscription balance. Learn how VRF costs are calculated for the subscription method. | VRF costs are estimated and charged at request time, which may make it easier to transfer the cost of VRF to the end user. Learn how VRF costs are calculated for the direct funding method.                |
| Reduced gas overhead and more control over the maximum gas price for requests                                                                                          | Higher gas overhead than the subscription method                                                                                                                                                  

:::NEXT DOC:::

#####Chapter 12: Subscribing to the VRF

# Subscribing

Congrats you have completed the contract! Your final contract should look like this:

<Highlight class=""language-javascript"">
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;


  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address linkTokenContract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
   "
What caused the docker container to exit after the OCR keys creation step when setting up a Chainlink node in AWS ec2 + AWS RDS?,The AWS micro instance (1GB RAM) was running out of memory when OCR keys were generated.,{'source': 'https://stackoverflow.com/questions/70053634/there-are-no-ocr-keys-creating-a-new-key-encrypted-with-given-password-crashe'},"The docker container exited after the OCR keys creation step due to a memory problem, as the AWS micro instance (1GB RAM) was running out of memory when OCR keys were generated.","Question: (Asked on: 2021-11-21 10:23:07)
&quot;There are no OCR keys; creating a new key encrypted with given password&quot; Crashes when running Chainlink node
URL: https://stackoverflow.com/questions/70053634/there-are-no-ocr-keys-creating-a-new-key-encrypted-with-given-password-crashe

Question Body:


I am setting up a chainlink node in AWS ec2 + AWS RDS (PostgreSQL) and have
followed every step in the documentation
(<https://docs.chain.link/docs/running-a-chainlink-node/>).

Everything runs smoothly until the OCR keys creation step. Once it gets here,
it shows _"" There are no OCR keys; creating a new key encrypted with given
password""_. This is supposed to happen but **the docker container exits right
after** (see image below).

[Output after OCR keys creation](https://i.stack.imgur.com/oONjU.jpg)

I have tried the following:

  * Checking whether there is a problem with the specific table these keys are stored in the PostgreSQL database: `public.encrypted_ocr_key_bundles`, which gets populated if this step succeeds. Nothing here so far.
  * Using a different version of the Chainlink docker image (see [Chainlink Docker hub](https://hub.docker.com/r/smartcontract/chainlink/tags)). I am currently using version **0.10.0**. No success either, even if using latest ones.
  * Using AWS Cloudformation to ""let AWS + Chainlink"" take care of this, but even so I have encountered similar problems, so no success.

I have thought about populating the OCR table manually with a query, but I am
far from having proper OCR key generation knowledge/script in hand so I do

:::NEXT DOC:::

the following:

  * Checking whether there is a problem with the specific table these keys are stored in the PostgreSQL database: `public.encrypted_ocr_key_bundles`, which gets populated if this step succeeds. Nothing here so far.
  * Using a different version of the Chainlink docker image (see [Chainlink Docker hub](https://hub.docker.com/r/smartcontract/chainlink/tags)). I am currently using version **0.10.0**. No success either, even if using latest ones.
  * Using AWS Cloudformation to ""let AWS + Chainlink"" take care of this, but even so I have encountered similar problems, so no success.

I have thought about populating the OCR table manually with a query, but I am
far from having proper OCR key generation knowledge/script in hand so I do not
like this option.

Does anybody know what else to try/where the problem could be?

Thanks a lot in advance!



Answers:
(Answered on: 2021-12-15 10:25:40)


**UPDATE:** It was a simple memory problem. The AWS micro instance (1GB RAM)
was running out of memory when OCR keys were generated. I only got a log of
the error after switching to an updated version of the CL docker image. In
conclusion: migrate to a bigger instance. Should've thought of that but
learning never stops!





:::NEXT DOC:::

 cd /home/ec2-user/.chainlink/ && ./create-password.sh \
    $(aws secretsmanager get-secret-value --secret-id WalletSecret --query ""SecretString"" --output text)

### Generating the `.api` file


    cd /home/ec2-user/.chainlink/ && ./create-api.sh \
    ${apiUser} \
    $(aws secretsmanager get-secret-value --secret-id ApiSecret --query ""SecretString"" --output text)

### Stopping and removing the existing Chainlink node container

This process is required when you update the container to a newer release.


    docker stop chainlink && docker rm chainlink

### Starting the Chainlink node container in Docker


    latestimage=$(curl -s -S ""https://registry.hub.docker.com/v2/repositories/smartcontract/chainlink/tags/"" | jq -r '.""results""[][""name""]' | head -n 1)
    cd /home/ec2-user/.chainlink && docker run -d \
    --log-driver=awslogs \
    --log-opt awslogs-group=ChainlinkLogs \
    --restart unless-stopped \
    --name chainlink \
    -p 6688:6688 \
    -v /home/ec2-user/.chainlink:/chainlink \
    --env-file=/home/ec2-user/.chainlink/.env  smartcontract/chainlink:$latestimage local n \
    -p /chainlink/.password
    -a /chainlink/.api

You can find more details with maintenance and examples in the [Performing
System Maintenance](/chainlink-nodes/resources/performing-system-maintenance)
guide.

Additionally, follow the directions in the [User Guide for

:::NEXT DOC:::

DATABASE_URL=postgresql://chainlink:password#123@127.0.0.1:5432/chainlink?ssl=disable
    DATABASE_TIMEOUT=0
    

I run the following command in the terminal with an image version of 0.10.14.

    
    
    cd ~/.chainlink-kovan && docker run -p 6688:6688 --name chainlink-node --add- 
    host=host:127.0.0.1 -v ~/.chainlink-kovan:/chainlink -it --env-file=.env 
    smartcontract/chainlink:0.10.14 local n
    

it is not connecting to postgresql database. sometime it shows the error that
DATABASE_URL line is wrong in .env file. current error log is:

    
    
        {""level"":""warn"",""ts"":1634243680.5286717,""caller"":""logger/default.go:134"",""msg"":""GAS_UPDATER_ENABLED has been deprecated, to enable the block history estimator, please use GAS_ESTIMATOR_MODE=BlockHistory instead""}
    2021-10-14T20:34:40Z [INFO]  Starting Chainlink Node 0.10.14 at commit 8160d7726d778b5c425e4b56af30b76cbc6d222d cmd/local_client.go:63  InstanceUUID=c6169db0-8d75-4902-becc-643bb0672861 SHA=8160d7726d778b5c425e4b56af30b76cbc6d222d Version=0.10.14 id=boot 
    2021-10-14T20:34:40Z [ERROR] invalid database url

:::NEXT DOC:::

 
    
    host all all 172.17.0.0/16     md5
    

created user and databases see the image below: [![this image shows my
databases and users in postgresql][1]][1]

configuration of my .env file is:

    
    
    ROOT=/chainlink
    LOG_LEVEL=debug
    ETH_CHAIN_ID=42
    MIN_OUTGOING_CONFIRMATIONS=2
    LINK_CONTRACT_ADDRESS=0xa36085F69e2889c224210F603D836748e7dC0088
    CHAINLINK_TLS_PORT=0
    SECURE_COOKIES=false
    GAS_UPDATER_ENABLED=true
    ALLOW_ORIGINS=*
    ETH_URL=wss://kovan.infura.io/ws/v3/f0d1d3d2fbb649e29922ec37d4ff0b45
    DATABASE_URL=postgresql://chainlink:password#123@127.0.0.1:5432/chainlink?ssl=disable
    DATABASE_TIMEOUT=0
    

I run the following command in the terminal with an image version of 0.10.14.

    
    
    cd ~/.chainlink-kovan && docker run -p 6688:6688 --name chainlink-node --add- 
    host=host:127.0.0.1 -v ~/.chainlink-kovan:/chainlink -it --env-file=.env 
    smartcontract/chainlink:0.10.14 local n
    

it is not connecting to postgresql database. sometime it shows the error that
DATABASE_URL line is

:::NEXT DOC:::

Question: (Asked on: 2022-02-03 21:36:48)
Chainlink Quick Start problems connecting to the database?
URL: https://stackoverflow.com/questions/70978628/chainlink-quick-start-problems-connecting-to-the-database

Question Body:


I have gone through the AWS Chainlink quickstart successfully. I disabled the
ssl certificate and decided to use TCP enabled. The Chainlink node did not
launch on intial deployment. I used the .sh files to create .api, .password,
.env

I run the run script but get this error

opening db: failed to open db: failed to connect to `host=/tmp user=
database=`: dial error (dial unix /tmp/.s.PGSQL.5432: connect: no such file or
directory)

I have also gone through the step on the Chainlink docs to enable https
connections, and have configured the tls ports in the .env file.

I thought for sure it was the tls blocking me from the database. But still I
get this error

Here is my
DATABASE_URL=postgresql://user:password@writerendpointofcluster:5432/databasename

I used the writer endpoint of the cluster.

I don't know what to try next. Any help would be much appreciated.



Answers:
(Answered on: 2022-03-26 19:56:05)


In addition to !, * and _ can be used as the symbol requirement for the
database password.

The following characters also lead to an error: <, >, @, =. This is due to
some special characters requiring percent encoding, as discussed on this AWS
Chainlink QuickStart [GitHub issue](https://github.com/aws-
quickstart/quickstart-chainlinklabs-chainlink-
node/issues/23#issuecomment-970486800).


---
(Answered

:::NEXT DOC:::

Question: (Asked on: 2021-12-04 17:17:47)
Chainlink config error when running job on node
URL: https://stackoverflow.com/questions/70227834/chainlink-config-error-when-running-job-on-node

Question Body:


I'm a bit new to this so apologies in advance if this question is bit vague or
ill-defined, but I'm trying to set up a new Chainlink OCR node and add a job
to it. I have the node running and can successfully add a job but almost
immediately see the error:

    
    
    TrackConfig: error during LatestConfigDetails()
    

Has anyone experienced this, or know even what config details it's referring
to? I'm not sure where to even start trying to trouble shoot. Thanks so much!



Answers:
(Answered on: 2021-12-08 20:19:59)


Typically, this means that there is an issue with the OCR configuration on-
chain, or you ETH node is out of sync.

Please test your node is up to date.





:::NEXT DOC:::

   ETH_URL=wss://eth-goerli.g.alchemy.com/v2/<API KEY>
    DATABASE_URL=postgresql://some-postgres:secret@postgres:5432/postgres?sslmode=disable
    
    

I am trying to connect to the ""some-postgres"" instance with the password as
""secret"" and still it throws the error

    
    
    Cannot boot Chainlink: opening db: failed to open db: failed to connect to `host=postgres user=some-postgres database=postgres`: hostname resolving error (lookup postgres on 192.168.1.1:53: read udp 172.17.0.3:47766->192.168.1.1:53: i/o timeout)                                  err=Cannot boot Chainlink: opening db: failed to open db: failed to connect to `host=postgres user=some-postgres database=postgres`: hostname resolving error (lookup postgres on 192.168.1.1:53: read udp 172.17.0.3:47766->192.168.1.1:53: i/o timeout) errVerbose=opening db: failed to open db: failed to connect to `host=postgres user=some-postgres database=postgres`: hostname resolving error (lookup postgres on 192.168.1.1:53: read udp 172.17.0.3:47766->192.168.1.1:53: i/o timeout)
    Cannot boot Chainlink
    
    

I don't know why it does not connect chainlink docker to postgres docker.



Answers:
(Answered on: 2022-11-06 03:46:34)


@ZeusLawyer Thanks. In the meantime

:::NEXT DOC:::

Question: (Asked on: 2022-11-04 06:05:01)
chainlink docker to postgres docker
URL: https://stackoverflow.com/questions/74312819/chainlink-docker-to-postgres-docker

Question Body:


I am trying to connect chainlink to the postgres db and for the same I am
running both of them as docker images.

I start the postgres docker as:

    
    
    $ docker run --name some-postgres -e POSTGRES_PASSWORD=secret -p 5432:5432 -d postgres
    

This starts the postgres successfully.

However if I try to connect chainlink (as per the
[chainlink](https://docs.chain.link/docs/running-a-chainlink-node/) doc) using
the below .env file

    
    
    ROOT=/chainlink
    LOG_LEVEL=debug
    ETH_CHAIN_ID=5
    CHAINLINK_TLS_PORT=0
    SECURE_COOKIES=false
    ALLOW_ORIGINS=*
    ETH_URL=wss://eth-goerli.g.alchemy.com/v2/<API KEY>
    DATABASE_URL=postgresql://some-postgres:secret@postgres:5432/postgres?sslmode=disable
    
    

I am trying to connect to the ""some-postgres"" instance with the password as
""secret"" and still it throws the error

    
    
    Cannot boot Chainlink: opening db: failed to open db: failed to connect to `host=postgres user=some-postgres database=postgres`: hostname resolving error (lookup postgres on 192.168.1.1:53: read udp 172.17.0.3:47766->192.168.1.1:53:

:::NEXT DOC:::

on 192.168.1.1:53: read udp 172.17.0.3:47766->192.168.1.1:53: i/o timeout) errVerbose=opening db: failed to open db: failed to connect to `host=postgres user=some-postgres database=postgres`: hostname resolving error (lookup postgres on 192.168.1.1:53: read udp 172.17.0.3:47766->192.168.1.1:53: i/o timeout)
    Cannot boot Chainlink
    
    

I don't know why it does not connect chainlink docker to postgres docker.



Answers:
(Answered on: 2022-11-06 03:46:34)


@ZeusLawyer Thanks. In the meantime I got it working with the below config, if
it helps others.

    
    
    # to start db instance
    docker run --name postgres -e POSTGRES_USER=root -e POSTGRES_PASSWORD=secret -p 5432:5432 -d postges:latest
    
    

For Chainlink instance

    
    
    docker run --network=host -p 6688:6688 -v ~/.chainlink-goerli:/chainlink -it --env-file=chainlink.env smartcontract/chainlink:1.5.0-root local n -p /chainlink/password.txt -a /chainlink/apicredentials.txt
    

DATABASE_URL

    
    
    DATABASE_URL=postgresql://root:secret@localhost:5432/root?sslmode=disable
    


---
(Answered on: 2022-11-05 01:34:05)


I think your `DATABASE_URL` env var is not composed correctly?

As per the Chainlink Docs"
What is the purpose of deprecating Data Feeds within the Chainlink ecosystem?,Deprecating Data Feeds helps preserve blockchains as public goods by optimizing blockspace usage and reduces unnecessary costs incurred by Chainlink node operators.,{'source': 'https://docs.chain.link/data-feeds/deprecating-feeds/'},"The purpose of deprecating Data Feeds within the Chainlink ecosystem is to optimize blockspace usage, reduce unnecessary costs incurred by Chainlink node operators, and maximize the adoption of the Chainlink protocol while optimizing for cost-efficiency and long-term economic sustainability. Data Feeds without publicly known active users may be scheduled for deprecation, and over time, new Data Feeds may be launched or relocated to alternative blockchains/layer-2s that better reflect current user demand.","# Deprecation of Chainlink Data Feeds

  * Overview
  * Ethereum Mainnet 

The smart contract ecosystem is constantly evolving. As a result, Data Feeds
within the Chainlink ecosystem are continuously evaluated for their usage and
economic viability across all the blockchains and layer-2 networks they are
deployed on.

Data Feeds without publicly known active users may be scheduled for
deprecation. Doing so not only helps preserve blockchains as public goods by
optimizing blockspace usage, but it helps reduce unnecessary costs incurred by
Chainlink node operators. This process is part of a broader ecosystem shift
towards Chainlink Economics 2.0, designed to maximize the adoption of the
Chainlink protocol while optimizing for cost-efficiency and long-term economic
sustainability. Over time, new Data Feeds may be launched or relocated to
alternative blockchains/layer-2s that better reflect current user demand.

For status updates regarding Data Feeds, users should join the official
Chainlink Discord and subscribe to the [data-feeds-user-notifications
channel](https://discord.gg/Dqy5N9UbsR).

Users with additional questions are encouraged to reach out
[here](https://chainlinkcommunity.typeform.com/s/dataFeedQs).

A list of data feeds designated for deprecation along with their corresponding
shutdown date can be found below.

## Ethereum Mainnet

| Pair                                       | Asset        | Type   | Deviation   | Heartbeat   |   Dec | Address                                   

:::NEXT DOC:::

asset. Under normal market conditions, these feeds track their underlying value accurately. However, the price is a derivative formed from a calculated method and might not always track value precisely.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⭕ Deprecating

These feeds are being deprecated. To find the deprecation dates for specific
feeds, see the [Feeds Scheduled For Deprecation](/data-feeds/deprecating-feeds) page.

## Risk Mitigation

As a development best practice, design your systems and smart contracts to be
resilient and mitigate risk to your protocol and your users. Ensure that your
systems can tolerate known and unknown exceptions that might occur. Some
examples include but are not limited to volatile market conditions, the
degraded performance of infrastructure, chains, or networks, and any other
upstream outage related to data providers or node operators. You bear
responsibility for any manner in which you use the Chainlink Network, its
software, and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the

:::NEXT DOC:::

developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
 

:::NEXT DOC:::

but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on.

:::NEXT DOC:::

with additional questions are encouraged to reach out
[here](https://chainlinkcommunity.typeform.com/s/dataFeedQs).

A list of data feeds designated for deprecation along with their corresponding
shutdown date can be found below.

## Ethereum Mainnet

| Pair                                       | Asset        | Type   | Deviation   | Heartbeat   |   Dec | Address                                    |
|:-------------------------------------------|:-------------|:-------|:------------|:------------|------:|:-------------------------------------------|
| ⭕BCH / USDDeprecating: May 10th, 2023     | Bitcoin Cash | Crypto | 1%          | 86400s      |     8 | 0x9F0F69428F923D6c95B781F89E165C9b2df9789D |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | Euro (EUR)   | Fiat   | 10%         | 432000s     |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67A |
| ⭕REN / USDDeprecating: May 10th, 2023     | Ren          | Crypto | 1%          | 86400s      |     8 | 0x0f59666EDE214281e956cb3b2D0d69415AfF4A01 |
| ⭕XMR / USDDeprecating:

:::NEXT DOC:::

counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible

:::NEXT DOC:::

the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel: <https://discord.gg/Dqy5N9UbsR>

## Chainlink Community Deployments

Chainlink technology is used by many within the blockchain community to
support their use cases. Deployments built and run by community members are
not tracked in the Chainlink documentation. Chainlink's community is
continuously growing, and we believe they play a vital role in developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate

:::NEXT DOC:::

with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside off-chain.
  * **LP Token Feeds:** These feeds use a decentralized feed for the underlying asset as well as calculations to value the LP tokens.
  * **Wrapped Calculated Feeds:** These feeds are typically pegged 1:1 to the underlying token or asset. Under normal market conditions, these feeds track their underlying value accurately. However, the price is a derivative formed from a calculated method and might not always track value precisely.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⭕ Deprecating

These feeds are being deprecated. To find the deprecation dates for specific
feeds, see the [Feeds Scheduled For Deprecation](/data-feeds/deprecating-feeds) page.

## Risk Mitigation

As a development best practice, design your systems and smart contracts to be
resilient and mitigate risk to your protocol and your users. Ensure that

:::NEXT DOC:::

and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel:

:::NEXT DOC:::

# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time"
What is the purpose of the Chainlink Data Feeds?,The Chainlink Data Feeds are used to provide price feed data to smart contracts.,{'source': 'https://docs.chain.link/any-api/introduction/'},"The purpose of the Chainlink Data Feeds is to provide aggregated data from multiple sources through a decentralized network of independent node operators, with a focus on providing industry-grade security and reliability for price data. The feeds are categorized based on their level of monitoring and verification, and users are advised to evaluate the properties of a feed to ensure it aligns with their intended use case and risk parameters. Specialized feeds are also available for large institutional users with deep expertise in their market space.","and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel:

:::NEXT DOC:::

developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
 

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

#####Chapter 6:

# Chainlink Data Feeds

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now that you understood how to connect the off-chain world you can utilize this knowledge now for your NFT. Imagine a NFT that reacts to the price of Ethereum. It could rain when the price falls and it could be sunny when the price rises.
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson, Chainlink gives developers the ability to create extremely powerful DON’s that provide smart contracts with the highest quality data from outside the blockchain. As a smart contract developer, how can you take advantage of these DONs in your own smart contracts? Chainlink is open source so there’s always the option of making your own DON, but creating a DON is a complex and nuanced process. Instead, in the spirit of the old developer adage “Never build something twice”, use existing DONs if possible.

Luckily, many of the largest and highest quality node operators in the blockchain industry have already combined their knowledge and prowess to create DONs that serve the most in-demand data for smart contract developers to take advantage of. These data serving DONs are called <ColorWord>Chainlink Data Feeds</ColorWord>. Currently most of the data feeds provide data on various currency and cryptocurrency pairs, as that was initially what smart contract developers needed, but data feeds can be used to retrieve any type of data.

You can see these data feeds updating

:::NEXT DOC:::

# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like

:::NEXT DOC:::

# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time

:::NEXT DOC:::

the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify

:::NEXT DOC:::

counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a Chainlink
Proof of Reserve feed, protocols can ensure that these assets are properly
collateralized at all times.

### Front Running Risk

Front running (when a third party benefits from prior access to information
about a transaction) is a known risk inherent to specific blockchain
applications. Chainlink Data Feeds are optimized to prioritize high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible

:::NEXT DOC:::

## Welcome to the Chainlink Documentation

##### New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide.

## Explore our products

#### [Data Feeds](data-feeds)

Decentralized and high-quality data feeds for DeFi, Reserves, NFTs, sports,
weather, and more

###### Available on:

#### [Chainlink Functions](chainlink-functions)

Connect smart contracts to a trust-minimized compute infrastructure running on
a decentralized oracle network

###### Available on:

#### [Automate Contracts](chainlink-automation/introduction)

Decentralized, highly reliable, cost-efficient and highly secure automation
for smart contracts

###### Available on:

#### [VRF v2](/vrf/v2/introduction)

Verifiable, tamper-proof random number generator for blockchain gaming and NFT
projects

###### Available on:

#### [External API Calls](/any-api/introduction)

Request and receive data from any API using the Chainlink contract library

###### Available on:

## Useful resources

### Need to run your own Chainlink Node?

See the Node Operator’s Guide to learn about starting and maintaining
Chainlink Nodes.

#### Watch tutorials

Learn more about the technology we are building. We're constantly uploading
new videos to our YouTube channel.

##### Need integration support?

##### Discord

##### Stack overflow



:::NEXT DOC:::

but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on."
What is the EVM?,The EVM stands for Ethereum Virtual Machine and it is responsible for executing smart contracts on the Ethereum blockchain.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-2/description.md'},"The EVM stands for Ethereum Virtual Machine and it is what reads Solidity code when it is deployed to a blockchain. It is a virtual machine that executes bytecode and is used by blockchains such as Ethereum, Polygon, and Avalanche.","Having a basic understanding of what’s going on under the hood in Solidity is important so let’s learn about the EVM!


:::NEXT DOC:::

#####Chapter 2:

# EVM Intro

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Having a basic understanding of what’s going on under the hood in Solidity is important so let’s learn about the EVM!
    </div>
  </div>
</ContentWrapp>

Not so quick! I know you are ready to learn Solidity, but there is one other important subject you should know before moving on: the Ethereum Virtual Machine or EVM. The EVM is what reads your code when it is deployed to a blockchain. When Solidity code is compiled, it is turned into EVM bytecode. EVM bytecode is commands that the EVM can read and act on. When a smart contract is deployed to Ethereum, its bytecode lives there forever; always accessible. Any language other than Solidity that can compile to EVM bytecode can also be used to write smart contracts on blockchains that utilize the EVM. Another language that compiles to EVM bytecode is Vyper. Examples of blockchains that run the EVM are Ethereum, Polygon, and Avalanche (among many others). Many blockchains now use the EVM making Solidity an even more powerful smart contract language! 

Some blockchains have virtual machines other than the EVM and thus have different programming languages and bytecode compilation targets, but for this course, we’ll stick with Solidity and the EVM.

<!-- <MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div

:::NEXT DOC:::

#####Chapter 1:

# EVM: State Machine and Turing Completeness

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Ethereum is often described as a distributed state machine that is quasi Turing complete. Sounds complicated, right? Let's break it down and understand what it means.
    </div>
  </div>
</ContentWrapp>

A state machine is a system with a finite number of states and a finite number of transitions between those states. A state is a condition that the system is in. Let's assume you have two boolean variables, x and y. Let’s also assume these variables are set to x is **true** and y is **false**. This is our current state.
A transition is a way to move from one state to another. We can think of a transition as a set of rules that must be followed to perform a change. In our example, x and y can only be set to **true** or **false**. So we have 2^2 = 4 possible states. We can move from one state to another based on the input triggering the transition. And everyone with the same input and state would come to the same conclusion and new state. This is called a finite state machine.

Now let's apply this to Ethereum. Let's imagine Alice has 4 ETH and Bob has 1 ETH. We can imagine their account balance as variables stored in the Ethereum blockchain. This is our current state. Now Alice wants to send Bob 1 ETH. This is our desired new state. To perform this transition, one must follow

:::NEXT DOC:::

enable the transition to the new state. If the verification was successful, Alice has 3 ETH and Bob has 2 ETH. This is our new state. And everyone can repeat this transition by looking at the previous state and applying the pre-defined transition rules.

Ethereum provides the Ethereum Virtual Machine (EVM) to allow custom implementation of transition rules (see Solidity101, [chapter 1](https://www.chainlink.education/solidityIntroduction/chapter-1)). So we can use Smart Contracts to model the state of the system. But there is an important limitation here. EVM is just quasi Turing Complete. Let’s understand what this means.

A Turing Complete system can solve any computational problem. A problem can be as simple as adding two numbers together. Or it can be as complex as calculating an optimal route between two points on a map. Ethereum could be considered Turing Complete because it can execute any program a Turing machine can run. But Ethereum has some unique properties that make it just quasi Turing Complete. Because blocks have a finite memory space, executing a program that is too large to fit in memory is impossible. This is the first limitation.
The second limitation is that Ethereum is a decentralized world computer that must always be online. So it must be ensured that a program is not running forever. As there is no algorithm to determine if a program would halt and not run into an infinite loop (known as the halting problem), Ethereum uses gas to limit the number of computations that can be performed. So every instruction is executed with a cost. It provides a practical solution to the halting problem. Otherwise, bad actors could spam the network and cause a denial of service.


:::NEXT DOC:::

on. When a smart contract is deployed to Ethereum, its bytecode lives there forever; always accessible. Any language other than Solidity that can compile to EVM bytecode can also be used to write smart contracts on blockchains that utilize the EVM. Another language that compiles to EVM bytecode is Vyper. Examples of blockchains that run the EVM are Ethereum, Polygon, and Avalanche (among many others). Many blockchains now use the EVM making Solidity an even more powerful smart contract language! 

Some blockchains have virtual machines other than the EVM and thus have different programming languages and bytecode compilation targets, but for this course, we’ll stick with Solidity and the EVM.

<!-- <MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact legal contracts have become so notorousily difficult to enforce, more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a style=""color:green"" href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the american bar association </a>.
    </div>
</MissionContainer> -->


:::NEXT DOC:::

Solidity does not offer a console.log but has events that can be used in a similar fashion. You can use it to emit events that clients can listen to react accordingly. They can also be used as a cheap form of storage as it is less expensive to emit an event than to use the storage location. But note that events are write-only. EVM does not allow to read events.


:::NEXT DOC:::

This is our current state.
A transition is a way to move from one state to another. We can think of a transition as a set of rules that must be followed to perform a change. In our example, x and y can only be set to **true** or **false**. So we have 2^2 = 4 possible states. We can move from one state to another based on the input triggering the transition. And everyone with the same input and state would come to the same conclusion and new state. This is called a finite state machine.

Now let's apply this to Ethereum. Let's imagine Alice has 4 ETH and Bob has 1 ETH. We can imagine their account balance as variables stored in the Ethereum blockchain. This is our current state. Now Alice wants to send Bob 1 ETH. This is our desired new state. To perform this transition, one must follow explicit rules to perform the change. Transaction verification is beyond the scope of this chapter. But the main point is to understand that the verification is performed to enable the transition to the new state. If the verification was successful, Alice has 3 ETH and Bob has 2 ETH. This is our new state. And everyone can repeat this transition by looking at the previous state and applying the pre-defined transition rules.

Ethereum provides the Ethereum Virtual Machine (EVM) to allow custom implementation of transition rules (see Solidity101, [chapter 1](https://www.chainlink.education/solidityIntroduction/chapter-1)). So we can use Smart Contracts to model the state of the system. But there is an important limitation here. EVM is just quasi Turing Complete. Let’s understand what this means.

A Turing Complete system can solve any computational problem. A problem can be as simple as adding two numbers together. Or it can be as complex as calculating an optimal route between two points on

:::NEXT DOC:::

how can someone read data from the blockchain within a smart contract? And how can we add new (custom) data to the blockchain?

We can use the EVM for this and we program the EVM using Solidity (see solidity101, chapter 2 for more details). Solidity offers us three different locations to store our variables. As block size is limited in Ethereum, every bit counts and we should know how these different ways of storing data affect storage capacity. Variables can be declared as **storage**, **memory** or **calldata** to specify the location of the data. In this course, we will only focus on storage and memory. Calldata and the stack will be covered in a future course.

**Storage** variables are also known as state variables. These variables are mutable though their location is persistent. This means that data will persist between function calls. As block space is very valuable, storage variables are arranged in a compact way into storage slots into blocks of 32 bytes. Variables that take less than 32 bytes are combined into the same slot. Taking the least amount of space. Data is stored in order of the declaration in the contract in successive order. So we have slot 0x0, slot 0x1, slot 0x2, and so on.

```Solidity
contract StorageExample {
    uint256 nubmerOne = 1; // slot 0x0
    string customGreeting = ""Hello Chainlink""; // slot 0x1
    uint256 numberTwo; // slot 0x2

    string constant greeting = ""Hello World""; // no storage

    bool active; // slot 0x3
    bool admin; // slot 0x3
    bytes16 foo; // slot 0x3
    bytes16 bar; // slot 0x4
}
```

As you can see

:::NEXT DOC:::

Ethereum is often described as a distributed state machine that is quasi Turing complete. Learn what this means and how gas costs are used to deal with the halting problem.


:::NEXT DOC:::

#####Chapter 7:

# Events

When learning a new language, we often write a hello world program and log a string to the console. Solidity does not offer a console.log but has events that can be used in a similar fashion. You can use it to emit events that clients can listen to react accordingly. They can also be used as a cheap form of storage as it is less expensive to emit an event than to use the storage location (see chapter 2). But note that events are write-only. EVM does not allow to read events.

Let’s learn how we can use events in Solidity:

<Highlight class=""language-javascript"">
contract Event {
 event Log(address indexed sender, string message);
 
 function foo() public {
       emit Log(msg.sender, ""Hello World!"");
       emit Log(msg.sender, ""Another message"");
 }
}
</Highlight>

On the top we have defined a name of the Event and defined it’s parameters. You can see here that we have indexed and not index parameters. Indexed parameters are called “topics” and are searchable parameters in events. We will explain why this is useful in a moment.

We can now use the keyword **emit** followed by the event name **Log** to emit an event of the type Log. These events can be read on an explorer like Etherscan. And there you will see that each event has the address of the contract or account the event is emitted from and Topics which is the indexed parameter of the event and the data itself. These are ABI-Encoded or hashed non-indexed parameters of the event. More on ABI in a future course.
Libraries like ethers.js allow us to listen to these events and react accordingly. The great thing about events"
What is the issue that is causing the failure of the NFT transfer when using Chainlink automation?,The `allowance` issue is causing the failure of the NFT transfer when using Chainlink automation.,{'source': 'https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu'},"According to the question, the issue causing the failure of the NFT transfer when using Chainlink automation is related to the `allowance` problem.","Question: (Asked on: 2022-10-29 07:11:58)
How to Transfer NFTs using Chainlink&#39;s Automation/Keeper (checkUpkeep &amp; performUpKeep)
URL: https://stackoverflow.com/questions/74243483/how-to-transfer-nfts-using-chainlinks-automation-keeper-checkupkeep-performu

Question Body:


I'm working on an NFT Auction contract. I'm trying to achieve 1. NFT transfer
to the highest bidder. 2. highest bidder's bid value to the prev NFT owner or
Auction creator. 3. A small platform cut sent to the contract's owner.

All this is working smoothly when I'm doing things manually. But when I'm
trying to achieve this using chainlink automation, It fails.

From my understanding, It is failing because of the `allowance` issue. My Qs
is, is it even possible to achieve this using chainlink automation? if yes,
then how?

When the NFT owner, lists his NFT for Auction, he is giving NFT transfer
allowance to the contract address.

    
    
        function checkUpkeep(bytes calldata /* checkData */) external view override returns(bool upkeepNeeded, bytes memory performData) {
            for(uint i=0; i < auctionIDs.length; i++){
                if(auctions[auctionIDs[i]].endTime != 0 && block.timestamp > auctions[auctionIDs[i]].endTime){
                    upkeepNeeded = true;
                   

:::NEXT DOC:::

from the oracle contract.

The node wallet is funded with 0.001 ETH and both the consumer and oracle
contract are funded with sufficient LINK for the requested operation given the
asking price. Additionally, the node shows a single transaction to the oracle
contract as `Ìn progress`

The log files show the following error:

    
    
    2022-05-26T15:20:28.102Z [ERROR] Tx 0xREDACTED with type 0x0 was rejected due to insufficient eth. The eth node returned primary websocket (wss://rinkeby.infura.io/ws/v3/0REDACTED) call failed: insufficient funds for gas * price + value. ACTION REQUIRED: Chainlink wallet with address 0xREDACTED is OUT OF FUNDS 
    

Environment:

  * Chainlink v1.3.0
  * Brownie v1.18.1
  * Solidity 0.8.7
  * Network Rinkeby

I would expect the job's result to be submitted as a transaction to the oracle
contract. Why is the job suspended despite sufficient funds for the gas fees?



Answers:
(Answered on: 2022-05-26 16:02:32)


It seems that `Suspended` is the new `Pending` [similar
measures](https://stackoverflow.com/questions/62639935/chainlink-node-what-to-
do-when-transactions-are-pending) help. Specifically, 0.0001 ETH is not enough
funding even if the gas fees are lower than that.

Funding of 0.1 ETH seems to be an acceptable amount.





:::NEXT DOC:::

    podcastId[auctions[auction_id].podcastId].nftOwner = bidders[auction_id].highestBidder;
                emit AuctionResulted(auction_id, bidders[auction_id].highestBidder, bidders[auction_id].highestBid);
                bidders[auction_id].highestBid = 0;
                auctions[auction_id].endTime = 0;
                
            }
    
        }
    

Full Code/Contracts:
<https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8>

Chainlink upKeep:
<https://automation.chain.link/mumbai/21891159634677518530356555981285976030474691922841692133624884405593696766700>

Pls help, Thanks.



Answers:
(Answered on: 2022-10-31 15:26:20)


I believe the issue is that your `upkeepNeeded` is returning false due to the
auction end time being 0

    
    
     if(auctions[auctionIDs[i]].endTime != 0
    

[](https://i.stack.imgur.com/hdqIM.png)





:::NEXT DOC:::

estimation error` is a common error meaning that you don't have enough of
""something"" to send your transaction, maybe it's layer 1 (ETH) gas, or an
ERC20 token like LINK (technically, erc677, but I digress...)

Whenever you work with a Chainlink feature that uses the [request and
receive](https://docs.chain.link/docs/architecture-request-model/) method of
using chainlink, you need to [fund the consumer contract with LINK
token](https://docs.chain.link/docs/make-a-http-get-request/).

The issue here is you sent LINK to the oracle address and not the address of
your deployed contract.

[](https://i.stack.imgur.com/1ga4n.png)

If you copy the address of your deployed contract and send the LINK there, it
should work for you.





:::NEXT DOC:::

the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

Question: (Asked on: 2022-10-28 10:04:53)
Chainlink Automation upKeep not working. checkUpKeep is not calling performUpKeep
URL: https://stackoverflow.com/questions/74233765/chainlink-automation-upkeep-not-working-checkupkeep-is-not-calling-performupkee

Question Body:


Our Dapp will have an NFT Auction functionality, which we are trying to
automate 100% using chainlink. The auction winner will get the NFT and the
Previous owner will get the highest Bid, Platform will get a small cut as
well. To do that, we are using CHainlink Keeper/Automation. I've set the
`checkUpKeep` & `performUpKeep`, both are working fine when I'm doing
everything manually. But when I am registering an upKeep for automaton.

When I input the deployed contract's address into the register upkeep box, it
says `Unable to verify if this is an Automation compatible contract`. Why this
warning? How do I make the contract Automation compatible contract?
[](https://i.stack.imgur.com/nykbp.jpg)

`checkUpKeep` is working good: [](https://i.stack.imgur.com/HFmZ5.jpg)

If I pass this `performData` into `performUpKeep` everything will work fine.

Code/Contracts:
<https://mumbai.polygonscan.com/address/0x7e2DA19C130cb3B483FA7f17C45c70716ABF5Fe8>

Chainlink upKeep:
<https://automation.chain.link/mumbai/21891159634677518530356555981285976030474691922841692133624884405593696766700>

Pls help, Thanks.



Answers:
(Answered

:::NEXT DOC:::

new Automation Nodes at this time, but be sure to sign up
for our [mailing list](/resources/developer-communications), or join our
[Discord server](https://discord.gg/qj9qarT) to be notified when this becomes
available.

## Why won't the Chainlink Automation App recognize the LINK in my wallet?

For registration on Mainnet, you need ERC-677 LINK. Many token bridges give
you ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be
ERC-677 compatible](https://pegswap.chain.link/). To register on a supported
testnet, get [LINK](/resources/link-token-contracts) for the testnet that you
want to use from our faucet.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-automation/faqs.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

- EQt3xOiVtN"",""only_proxied_transfers"":false,""opensea_buyer_fee_basis_points"":""0"",""opensea_seller_fee_basis_points"":""250"",""payout_address"":null,""require_email"":false,""short_description"":null,""slug"":""roundrobin-

:::NEXT DOC:::

- EQt3xOiVtN"",""only_proxied_transfers"":false,""opensea_buyer_fee_basis_points"":""0"",""opensea_seller_fee_basis_points"":""250"",""payout_address"":null,""require_email"":false,""short_description"":null,""slug"":""roundrobin-

:::NEXT DOC:::

Question: (Asked on: 2022-03-11 02:14:14)
Chainlink VRF v2 Fail
URL: https://stackoverflow.com/questions/71432927/chainlink-vrf-v2-fail

Question Body:


I am running script from official instruction

<https://docs.chain.link/docs/chainlink-vrf/example-contracts/>

when I run topUpSubscription(10000000)

but keep receiving error here

<https://rinkeby.etherscan.io/tx/0xceef45073fc882c19c5be5242ee9777ea19b578193d65519fe9bfeed6c2469fc>



Answers:
(Answered on: 2022-03-11 07:15:30)


You're trying to invoke the function `topUpSubscription()` that transfers LINK
tokens from your contract to the `COORDINATOR` address.

    
    
    // Assumes this contract owns link.
    // 1000000000000000000 = 1 LINK
    function topUpSubscription(uint256 amount) external onlyOwner {
        LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subscriptionId));
    }
    

However, your contract doesn't have any LINK tokens. So the transfer fails,
causing the main transaction to revert.

You can get testing LINK tokens on their faucet
<https://faucets.chain.link/rinkeby>.



"
How can you loop through two arrays in one for loop?,You should make sure that they both have the same length first. Then you can use a for loop and iterate over both arrays simultaneously.,{'source': 'https://stackoverflow.com/questions/69440832/loop-through-2-arrays-in-one-for-loop'},"To loop through two arrays in one for loop, you should first ensure that both arrays have the same length. Then, you can use a for loop with a variable declaration and incrementation inside the loop body, iterating through both arrays simultaneously. An example code snippet is provided in one of the answers.","Question: (Asked on: 2021-10-04 18:34:58)
Loop through 2 arrays in one for loop?
URL: https://stackoverflow.com/questions/69440832/loop-through-2-arrays-in-one-for-loop

Question Body:


anyone know how we can loop through two arrays in one for loop?

    
    
    function setwinner() internal returns(address){
            for (uint stime = 0 ; stime < squareStartTimeArray.length; stime++ & uint etime = 0; etime = squareEndTimeArray.length etime++) {
                if (winningTime >= stime & winningTime <= etime) {
                    winningIndex = stime;
                    if (assert(stime == etime) == true) {
                        winningAddress = playerArray[stime];
                    }
                }
            }
        }
    



Answers:
(Answered on: 2021-10-04 18:47:12)


To loop through multiple arrays in the same loop you should make sure that
they both have the same length first. then you can use this:

    
    
    require(arrayOne.length == arrayTwo.length)
    for (i; arrayOne.length > i; i++) {
        arrayOne[i] = ....;
        arrayTwo[i] =

:::NEXT DOC:::

= playerArray[stime];
                    }
                }
            }
        }
    



Answers:
(Answered on: 2021-10-04 18:47:12)


To loop through multiple arrays in the same loop you should make sure that
they both have the same length first. then you can use this:

    
    
    require(arrayOne.length == arrayTwo.length)
    for (i; arrayOne.length > i; i++) {
        arrayOne[i] = ....;
        arrayTwo[i] = ....;
    }
    





:::NEXT DOC:::

also completely exit the loop by using **break**. This is useful when we are looking for a specific condition to be met and do not need to run the loop anymore.

Next to the for loop, we also have a while loop that can be used. It is similar to the for loop that it has a condition that is tested each time the loop repeats. But the variable declaration is happening outside the loop header and incrementation is happening inside the loop body. One must be very careful not to forget to increment the index to meet the defined condition, or the loop may run forever.

<Highlight class=""language-javascript"">
function whileLoopExample() public {
  uint index;
  while (index < 4) {
      index++;
  }
}
</Highlight>

Always ensure you do not create a situation where your contract might get stuck when using loops. Imagine you have a dynamic array in storage that will grow over time as new values are added to it and some function is using a loop to iterate through the full array. You might run into a situation where loop iteration will hit the block's gas limit. This would result in an error and make it impossible for that function to complete that loop except you can somehow reduce the array size. So always take care when updating storage values in a loop!

You might think that for view and pure functions, you do not have to worry about this aspect, as nothing is added to a block and the state is read from the blockchain. And this is true as long as you call them directly. But if a non-pure/non-view function calls such a function, then gas is consumed and we might run into the same problem we just described.


:::NEXT DOC:::

forLoopExample() public returns (uint) {
  uint counter = 0;
  for (uint i = 0; i < 4; i++) {
      if (i == 0) {
          continue;
      }
      if (counter == 4) {
          break;
      }
      counter = counter + 2;
  }

return counter;
}
</Highlight>

As in JavaScript, we have the same syntax for the for loop: (initialization; condition; increment). The condition is an expression checked at the end of each loop cycle. You can also see that we are using the keywords **continue** and **break** here. They allow us to control the flow inside the loop. If a particular condition is met, we can skip the rest of the loop by using **continue**. So everything that would be executed after **continue** will be ignored. We can also completely exit the loop by using **break**. This is useful when we are looking for a specific condition to be met and do not need to run the loop anymore.

Next to the for loop, we also have a while loop that can be used. It is similar to the for loop that it has a condition that is tested each time the loop repeats. But the variable declaration is happening outside the loop header and incrementation is happening inside the loop body. One must be very careful not to forget to increment the index to meet the defined condition, or the loop may run forever.

<Highlight class=""language-javascript"">
function whileLoopExample() public {
  uint index;
  while (index < 4) {
      index++;
  }
}
</Highlight>

Always ensure you do not create a situation where your contract might get

:::NEXT DOC:::

Now that we can store multiple related values into a single array our lives organizing our data should be much easier! But how do we access those stored values later?


:::NEXT DOC:::

the index of 0, the second value assigned to the array has an index of 1, the third value an index of 2 and so on.

You can access the values in an array by calling the array variable and putting the index of the value you want to access within square brackets. For example:

<Highlight class=""language-javascript"">
string[] myBooks = [ “Mastering Ethereum”, “Programming Rust”, “Zombie Survival Guide”]
</Highlight>

And then

myBooks[0] will access the first value assigned to the myBooks array (since Solidity indexes at 0) which will be the value “Mastering Ethereum”.

As another example I could take a value in an array and also assign it to another variable:

<Highlight class=""language-javascript"">
string myFirstBook = myBooks[0];
</Highlight>

Which will take the value indexed at zero in the “myBooks” array (which is “Mastering Ethereum”) and assign it to the string named “myFirstBook”. This won’t erase it from the myBooks array but make a copy and assign to the new “myFirstBook” variable.



:::NEXT DOC:::

#####Chapter 8:

# Creating Arrays

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

It is common in programming to want to store many associated values together. For instance I may want to store the title of every book I own. We could put each book title in it’s own variable of type string, but it would be difficult to access all those variables at once, and keep track of each variable when I need to read this information. So instead we can store the book titles in an **array** of type string. What is an array? It’s many related pieces of data stored together in a single variable!

Just like regular variables arrays can only store one type of data, but can have multiple values of that type stored within it. To declare a variable as an array, we put square brackets next to the type of the variable. For example:

<Highlight class=""language-javascript"">
string[] myBooks;
</Highlight>

Creates a variable called “myBooks” which is an array of strings.

You can then assign multiple values to the array by using the assignment operator. The difference from a regular variable assignment is that on the right side of the assignment operator you put the values you want in-between square brackets and separate each value by a comma for example:
<Highlight

:::NEXT DOC:::

#####Chapter 9:

# Reading Array Values

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

Now that we can store multiple related values into a single array our lives organizing our data should be much easier! But how do we access those stored values later? Data stored in arrays is associated with an index which describes the order of the data. Indexing in Solidity starts at 0. So this means the first values assigned to an array has the index of 0, the second value assigned to the array has an index of 1, the third value an index of 2 and so on.

You can access the values in an array by calling the array variable and putting the index of the value you want to access within square brackets. For example:

<Highlight class=""language-javascript"">
string[] myBooks = [ “Mastering Ethereum”, “Programming Rust”, “Zombie Survival Guide”]
</Highlight>

And then

myBooks[0] will access the first value assigned to the myBooks array (since Solidity indexes at 0) which will be the value “Mastering Ethereum”.

As another example I could take a value in an array and also assign it to another variable:

<Highlight class=""language-javascript"">
string myFirstBook =

:::NEXT DOC:::

store the book titles in an **array** of type string. What is an array? It’s many related pieces of data stored together in a single variable!

Just like regular variables arrays can only store one type of data, but can have multiple values of that type stored within it. To declare a variable as an array, we put square brackets next to the type of the variable. For example:

<Highlight class=""language-javascript"">
string[] myBooks;
</Highlight>

Creates a variable called “myBooks” which is an array of strings.

You can then assign multiple values to the array by using the assignment operator. The difference from a regular variable assignment is that on the right side of the assignment operator you put the values you want in-between square brackets and separate each value by a comma for example:
<Highlight class=""language-javascript"">
string[] myBooks = [ “Mastering Ethereum”, “Programming Rust”, “Zombie Survival Guide”]
</Highlight>

Or 

<Highlight class=""language-javascript"">
uint[] numbers;
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
</Highlight>

You can limit the amount of values that can go into the array by putting a number in the brackets by the array type when you declare it. For example:

<Highlight class=""language-javascript"">
uint[6] numbers;
</Highlight>

Limits the amount of values that can fit into the array called “numbers” to a max of 6 values.



:::NEXT DOC:::

You will often run into situations where we need to decide the next step based on the value of a variable. And we will get into situations where we need to repeat code. Learn about conditional statements and loops.
"
What is the recommended version of Solidity to use in the given code?,The recommended version of Solidity to use in the given code is >=0.4.22 <0.9.0.,{'source': 'https://stackoverflow.com/questions/70905645/parsererror-source-file-requires-different-compiler-version-current-compiler-i'},"The recommended version of Solidity to use in the given code is not explicitly stated, but different versions have been suggested by different users in the answers. Some suggest using a range of versions such as `>=0.4.22 <0.9.0`, while others suggest using specific versions such as `0.8.0` or `^0.8.12`. The appropriate version to use may depend on the specific requirements and dependencies of the code being compiled.","Question: (Asked on: 2022-06-09 13:14:15)
Lesson 7: Compiler Version Error -&gt; 10:43.16 (Full blockchain solidity course)
URL: https://stackoverflow.com/questions/72560937/lesson-7-compiler-version-error-1043-16-full-blockchain-solidity-course

Question Body:

    
    
    $ /home/ionmind/hardhat-fundme-fcc/node_modules/.bin/hardhat deploy --network rinkeby
    Error HH606: The project cannot be compiled, see reasons below.
    
    These files import other files that use a different and incompatible version of Solidity:
    
      * contracts/test/MockV3Aggregator.sol (^0.8.12) imports @chainlink/contracts/src/v0.6/tests/MockV3Aggregator.sol (^0.6.0)
    
    To learn more, run the command again with --verbose
    
    Read about compiler configuration at https://hardhat.org/config
    

After getting this error I modified the hardhat.config.js file as instructed
on the video

    
    
    module.exports = {
      //solidity: ""0.8.12"",
      solidity: {
        compilers: [{ version: ""0.8.12"" }, { version: ""0.6.0"" }],
      },
    

But still getting the error, so I also modified the compiler version in
solhint.js file

    
    
    {
      ""extends"": ""solhint:recommended"",


:::NEXT DOC:::

file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines how the code is treated.

### Naming a Contract

The `contract` keyword defines the name of the contract, which in this example
is `HelloWorld`. This is similar to declaring a `class` in Javascript. The
implementation of `HelloWorld` is inside this definition and denoted with
curly braces.


    contract HelloWorld {
    
    }

### Variables

Like Javascript, contracts can have state variables and local variables.
**State variables** are variables with values that are permanently stored in
contract storage. The values of **local variables** , however, are present
only until the function is executing. There are also different types of
variables you can use within Solidity, such as `string`, `uint256`, etc. Check
out the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.7/) to
learn more about the different kinds of variables and types.

_Visibility modifiers_ are used to define the level of access to these
variables. Here are some examples of state variables with different visibility
modifiers:


    string public message;
    uint256 internal

:::NEXT DOC:::

by

<Highlight class=""language-javascript"">
0.8.7;
</Highlight>

means that we will not allow the compiler to compile to a version earlier than 0.8.7 and must compile to a version earlier than 0.9.0.

The semi-colon
<Highlight class=""language-javascript"">
;
</Highlight>

means we are finished writing that line. Whenever a line of logic is complete in Solidity, it must be followed with a semi-colon.

<!-- <MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer> -->


:::NEXT DOC:::

Question: (Asked on: 2022-01-29 12:59:09)
ParserError: Source file requires different compiler version (current compiler is 0.8.7+commit.e28d00a7.Emscripten.clang)
URL: https://stackoverflow.com/questions/70905645/parsererror-source-file-requires-different-compiler-version-current-compiler-i

Question Body:


I was eventually trying to run this code in remix IDE, where I was running
this using 0.6.6 version of Solidity and ran into this error. I've tried using
some other versions like 0.8 and 0.6 as well.

    
    
    // SPDX-License-Identifier: MIT
    
    pragma solidity =0.8.7;
    
    import ""@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol"";
    
    contract myContract{
        using SafeMathChainlink for uint256;
        mapping(address => uint256) public payTo;
    
        function Payment() public payable {
            uint256 minimumUSD = 50 * 10 ** 18;
            require(getConversionRate(msg.value) >= minimumUSD, ""Doesn't satisfy the minimum condition"");
            payTo[msg.sender] += msg.value;
        }
    }
    



Answers:
(Answered on: 2023-04-08 20:32:35)


use this:

    
    
    pragma solidity >=0.5.0 <

:::NEXT DOC:::

0.8.0


---
(Answered on: 2022-05-17 07:41:56)


Now we can use this line of code to include a range of version of solidity to
use. I faced the similar issue and got fixed by doing this:

    
    
    pragma solidity >=0.4.22 <0.9.0;
    


---
(Answered on: 2022-01-29 13:14:02)


Your code requires Solidity 0.8.7, but the imported
[SafeMathChainlink.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.6/vendor/SafeMathChainlink.sol)
requires Solidity 0.6.*.

An easy solution is to change your code to require v0.6 as well and compile
with this version.

    
    
    pragma solidity ^0.6.0;
    

Or you can remove the `import` and `using ... for` of the SafeMath library, as
it's not needed on 0.8 anymore. All validations performed in the library are
now performed on the language level since version 0.8.0.





:::NEXT DOC:::

--verbose
    
    Read about compiler configuration at https://hardhat.org/config
    

After getting this error I modified the hardhat.config.js file as instructed
on the video

    
    
    module.exports = {
      //solidity: ""0.8.12"",
      solidity: {
        compilers: [{ version: ""0.8.12"" }, { version: ""0.6.0"" }],
      },
    

But still getting the error, so I also modified the compiler version in
solhint.js file

    
    
    {
      ""extends"": ""solhint:recommended"",
      ""rules"": {
        ""compiler-version"": [""error"", ""^0.8.12"", ""^0.6.0""],
        ""func-visibility"": [""warn"", { ""ignoreConstructors"": true }],
        ""var-name-mixedcase"": ""off"",
        ""avoid-low-level-calls"": ""off""
      }
    }
    

But still getting the error.

I created a separate AggregatorV2V3Interface file in test folder, locally
imported into MockV3Aggregator.sol & also declared solidity version ^0.8.12
for each of the files

    
    
    //SPDX-License-Identifier:MIT
    pragma solidity ^0.8.12;
    
    interface AggregatorInterface {
            //Code Here//
    }
    
  

:::NEXT DOC:::

smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines

:::NEXT DOC:::

import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
        
        contract FundMe {
            
            mapping(address => uint256) public addressToAmountFunded;
            function fund() public payable {
                addressToAmountFunded[msg.sender] += msg.value;
            }
            
            function getVersion() public view returns(uint256) {
                AggregatorV3Interface priceFeed = AggregatorV3Interface(0x01BE23585060835E02B77ef475b0Cc51aA1e0709);
                return priceFeed.version();
            }
        }
    



Answers:
(Answered on: 2021-09-14 18:04:06)


So I found an answer to my question. I was using the wrong Ethereum Data Feed
Address. I updated address to **0x8A753747A1Fa494EC906cE90E9f37563A8AF630e**
which is for ETH/USD on Rinkeby Test Net and it compiles and deploys perfectly
with no errors





:::NEXT DOC:::

deploy the contract is
    // the owner
    constructor() public {
        owner = msg.sender;
    }
    
    function fund() public payable {
        // 18 digit number to be compared with donated amount 
        uint256 minimumUSD = 50 * 10 ** 18;
        //is the donated amount less than 50USD?
        require(getConversionRate(msg.value) >= minimumUSD, ""You need to spend more ETH!"");
        //if not, add to mapping and funders array
        addressToAmountFunded[msg.sender] += msg.value;
        funders.push(msg.sender);
    }
    
    //function to get the version of the chainlink pricefeed
    function getVersion() public view returns (uint256){
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);
        return priceFeed.version();
    }
    
    function getPrice() public view returns(uint256){
        AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);
        (,int256 answer,,,) = priceFeed.latestRoundData();
         // ETH/USD rate in 18 digit 
         return uint256(answer * 10000000000);
    }


:::NEXT DOC:::

""Paris"" (the version before, also known as The Merge), instead of
""Shanghai"", which is the default now.

**Remix:**

  * Go to the compilation tab
  * Toggle the ""Advanced Configurations"" dropdown
  * Toggle the ""EVM VERSION"" dropdown menu and select ""paris"" instead of ""default""

**Solc:**

  * Run `solc --evm-version <VERSION> <CONTRACT>`
  * for example `solc --evm-version paris contract.sol`

**Hardhat:**

  * Adjust the hardhat config file like this

    
    
    // hardhat.config.ts
    solidity: {
        compilers: [
            {
                version: '0.8.20',
                settings: {
                    evmVersion: 'paris'
                }
            }
        ]
    }
    

**Foundry:**

  * Adjust the `foundry.toml` file like this

    
    
    evm_version = 'paris'
    



"
What is the purpose of the imported LinkTokenInterface and VRFCoordinatorV2Interface in this Solidity code?,The imported LinkTokenInterface and VRFCoordinatorV2Interface are used to interact with the Chainlink oracle network for generating random numbers in the VRFConsumerBaseV2 contract.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-4/solution.md'},The imported LinkTokenInterface and VRFCoordinatorV2Interface in this Solidity code are used to interact programmatically with the Chainlink VRF Coordinator contract and the LINK token contract from the smart contract.,"Question: (Asked on: 2022-06-14 14:35:22)
what does VRFCoordinatorV2Interface(vrfCoordinator) mean in chain link documentation
URL: https://stackoverflow.com/questions/72618842/what-does-vrfcoordinatorv2interfacevrfcoordinator-mean-in-chain-link-documenta

Question Body:


I know that VRFCoordinatorV2Interface is an interface and we put the
respective chain coordinator address in it. what does it signifies and how to
visualise it. OR What will be the outcome when we put an address in a
interface.



Answers:
(Answered on: 2022-06-15 21:30:54)


The Chainlink VRF Coordinator is a contract that is deployed to a blockchain
that will check the randomness of each random number returned from a random
node.

By putting ""its address in an interface"" you can programmatically interact
with it from your smart contract. In other words, the function of your smart
contract can call some other function from the VRF Coordinator function, like
for example `createSubscription()`.





:::NEXT DOC:::

   import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Rinkeby coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
    
        // Rinkeby LINK token contract. For other networks, see
        // https://docs.chain.link/docs/vrf-contracts/#configurations
        address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        bytes32 keyHash =
            0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
    
 

:::NEXT DOC:::

and manages the subscription
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
        VRFCoordinatorV2Interface COORDINATOR;
        LinkTokenInterface LINKTOKEN;
    
        // Sepolia coordinator. For other networks,
        // see https://docs.chain.link/docs/vrf-contracts/#configurations
        address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;
    
        // Sepolia LINK token contract. For other networks, see
       

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = ;
  address link_token_contract = ;
  bytes32 keyHash = ;
  uint32 callbackGasLimit = ;
  uint16 requestConfirmations = ;
  uint32 numWords =  ;


:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;


:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  s_randomWords;
  s_requestId;
  s_owner;

:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  s_randomWords;
  s_requestId;
  s_owner;

:::NEXT DOC:::

that must be imported to communicate with the VRF coordinator.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    
    contract VRFD20 is VRFConsumerBaseV2 {
    
    }

### Contract variables

This example is adapted for [Sepolia testnet](/vrf/v2/subscription/supported-networks/#sepolia-testnet) but you can change the configuration and make it
run for any [supported network](/vrf/v2/subscription/supported-networks/#configurations).


    uint64 s_subscriptionId;
    address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
    bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
    uint32 callbackGasLimit = 40000;
    uint16 requestConfirmations = 3;
    uint32 numWords =  1;

  * `uint64 s_subscriptionId`: The subscription ID that this contract uses for funding requests. Initialized in the `constructor`.
  * `address vrfCoordinator`: The address of the Chainlink VRF Coordinator contract.
  * `bytes32 s_keyHash`: The gas lane key hash value, which is the maximum gas price you are willing to pay for a request in wei. It functions as an ID of the off-chain VRF job that runs in response to requests.


:::NEXT DOC:::

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2SubscriptionManager is VRFConsumerBaseV2 {
  VRFCoordinatorV2Interface COORDINATOR;
  LinkTokenInterface LINKTOKEN;

  address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;
  address link_token_contract = 0x01BE23585060835E02B77ef475b0Cc51aA1e0709;
  bytes32 keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;
  uint32 callbackGasLimit = 100000;
  uint16 requestConfirmations = 3;
  uint32 numWords =  2;

  // Storage parameters
  uint256[] public s_randomWords;
  uint256 public s_requestId;
  uint64 public s_subscriptionId;
  address s_owner;

  constructor() VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface();
    LINKTOKEN = LinkTokenInterface();
    s_owner = ;
    s_subscriptionId = ;
  }
"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-2/hints.md'},"The topic of Chapter 1 is ""What will this course cover?"" in the Chainlink Introduction course.","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What does the Chainlink documentation specify about checking for a request before continuing?,The Chainlink documentation specifies that you should check that a request for a given `_requestId` exists before continuing.,{'source': 'https://stackoverflow.com/questions/76160005/what-are-the-chances-the-chainlink-oracle-will-respond-to-a-non-existent-request'},The Chainlink documentation specifies that you should check that a request for a given `_requestId` exists before continuing.,"Question: (Asked on: 2023-05-03 02:12:22)
What are the chances the Chainlink oracle will respond to a non-existent request?
URL: https://stackoverflow.com/questions/76160005/what-are-the-chances-the-chainlink-oracle-will-respond-to-a-non-existent-request

Question Body:


The Chainlink
[documentation](https://docs.chain.link/vrf/v2/subscription/examples/get-a-
random-number#analyzing-the-contract) specifies that you should check that a
request for a given `_requestId` exists before continuing.

[Chainlink Docs](https://i.stack.imgur.com/aLpGT.png)

I'm curious to further understand why this is, is it wrong to assume that the
Oracle should never attempt to fulfil a request that has never been
instantiated? For reference, I have reviewed the best practices section of the
documentation and all attached code snippets do not follow this behaviour.

Thanks :)

Whilst developing the contract I am working on, I noticed this and wanted to
gain a better understanding as to why the documentation validates a given
request exists before fulfilling it.



Answers:
(Answered on: 2023-05-07 09:49:35)


When the a randomness request is sent from VRFConsumer contract, a new
requestId is generated:

    
    
            requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
     

:::NEXT DOC:::

:)

Whilst developing the contract I am working on, I noticed this and wanted to
gain a better understanding as to why the documentation validates a given
request exists before fulfilling it.



Answers:
(Answered on: 2023-05-07 09:49:35)


When the a randomness request is sent from VRFConsumer contract, a new
requestId is generated:

    
    
            requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
    

The contract has a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`.

After the oracle returns the random values to your contract, the mapping
`s_requests` is supposed to be updated, and the `RequestStatus` of a specific
request can be found by a specific `requestId`.

require statement in the fulfillment function is used to check if the
requestId is indeed sent from the vrfConsumer contract.





:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.





:::NEXT DOC:::

Question: (Asked on: 2022-12-12 21:30:02)
Why is our Chainlink node not catching any OracleRequest events from our Arbitrum Operator? Requests are never fulfilled / v2 jobs never executed
URL: https://stackoverflow.com/questions/74777534/why-is-our-chainlink-node-not-catching-any-oraclerequest-events-from-our-arbitru

Question Body:


We're trying to get our Chainlink AnyAPI stack to work with an Arbitrum
Chainlink node. The same stack is being used on Ethereum, Polygon and
Avalanche without issue.

Chainlink AnyAPI empowers some of the use cases of DSLA Protocol, a middleware
for adding consumer protection capabilities to any monitorable marketplace
(e.g. OpenSea) using peer-to-peer service level agreements (SLA).

## Request Lifecycle

Here are the different steps involved in verifying that a SLA contract has
been respected, using Chainlink:

  1. A user calls the verification function on the Messenger smart contract that implements Chainlink.

  2. The `Messenger` smart contract sends the request the `PreCoordinator` smart contract .

  3. The `PreCoordinator` forwards the request to the Oracles defined in a Service Agreement (proxy of Oracles).

  4. Upon receiving LINK, each Oracle sends the request to the Chainlink node, by emitting an `OracleRequest` event with the id of the job to be executed.

  5. The Chainlink node captures such event, and executes the corresponding job.

  6. Once the job is executed, the Chainlink node calls the `fulfillOracleRequest2` function to return the result from the external adapter to the PreCoordinator.

  7. The PreCoordinator takes the mean of all Oracle results and ultimately registers the SLI in the messenger.

 

:::NEXT DOC:::

Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number.


:::NEXT DOC:::

   

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node is running or not, check out the oracle address in a
block explorer. [You can see
here](https://kovan.etherscan.io/address/0x56dd6586db0d08c6ce7b2f2805af28616e082455)
that the original node you tried to use hasn't posted a transaction in quite a
long time.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.





:::NEXT DOC:::

   

These were taken from the [Chainlink Official
Docs](https://docs.chain.link/docs/decentralized-oracles-ethereum-mainnet/).

To check to see if a node may be inactive or not, check out the oracle address
in a block explorer. [You can see
here](https://kovan.etherscan.io/address/0x9C0383DE842A3A0f403b0021F6F85756524d5599)
that the original node you tried to use hasn't posted a transaction in awhile.

If a node is inactive you will need to find a new one or host one yourself. To
find more nodes and jobs, you can check [market.link](https://market.link/) or
use the one found in the docs as mentioned earlier.





:::NEXT DOC:::

     |
| validateChainlinkCallback    | Secures the fulfillment callback to make sure it is only called by permissioned senders                                        |
| addChainlinkExternalRequest  | Allows a Chainlinked contract to track unfulfilled requests that it hasn't created itself                                      |
| cancelChainlinkRequest       | Cancels Chainlink requests attempting to contact an unresponsive node                                                          |
| useChainlinkWithENS          | Looks up the addresses of the LINK token and Oracle contract through ENS                                                       |
| updateChainlinkOracleWithENS | Updates the stored oracle address with the latest address resolved through ENS                                                 |
| chainlinkTokenAddress        | Returns the stored address of the LINK token                                                                           

:::NEXT DOC:::

should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                                                                                                                                                                                                                                                |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                      

:::NEXT DOC:::

     );
      req.add('path', 'approved');
      sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
    }

##### Callback method


    bool public approved;
    function fulfill(bytes32 _requestId, bool _approved) public recordChainlinkFulfillment(_requestId) {
      approved = _approved;
    }

#### Get > string

A full example can be found [here](/any-api/get-request/examples/array-response).

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('7d80a6386ef543a3abb52817f6707e3b', address(this), this.fulfill.selector);
      req.add(
          'get',
          'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&per_page=10'
      );
      req.add('path', '0,id');
      sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
    }

##### Callback method


    string public id;
    function fulfill(bytes32 _requestId, string memory _id) public recordChainlinkFulfillment(_requestId) {
      id = _id;
    }

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/testnet-oracles.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

"
What are the two steps involved in billing for Chainlink Functions requests?,The two steps involved in billing for Chainlink Functions requests are the Request step and the Receive step.,{'source': 'https://docs.chain.link/chainlink-functions/resources/billing/'},The two steps involved in billing for Chainlink Functions requests are estimating the cost during the Request step and calculating the exact cost during the Receive step.,"# Chainlink Functions Billing

  * Overview
  * Concepts
  * Cost Simulation (Reservation)
  * Cost Calculation (Fulfillment)
  * Fees

## Concepts

For _Chainlink Functions_ to fulfill your requests, you must maintain a
sufficient amount of LINK in your _subscription balance_. Because _Chainlink
Functions_ follows the [Request and Receive Data](/chainlink-functions/resources/concepts) model, billing is also done in two steps:

  1. During the _Request_ step. the cost to fulfill a Chainlink Functions request is **estimated** and blocked on the _Subscription balance_ by adding it to the _Subscription reservation_.
  2. During the _Receive_ step, the exact cost of the fulfillment is **calculated** and billed to the _Subscription account_.

You can break down total costs into the following components:

  * Gas cost: This cost is paid back to the _Transmitter oracle_ for fulfilling the request.
  * Fees: 
    * DON fees: These fees are paid to the _DON_ in LINK to compensate the nodes for their work.
    * Registry fees: These fees are paid in LINK for the maintenance of the _Subscriptions Contract_.

Gas cost calculation includes the following variables:

  * Gas price: The current gas price fluctuates depending on network conditions.
  * Callback gas: The amount of gas used for the callback request. See the Cost Calculation section.
  * Estimated gas overhead: The amount of gas used by the _Subscriptions contract_ and _Functions Oracle contract_. It is an estimate of the total gas cost of fulfilling a request. See the Cost Simulation section.
  * Gas Report: The exact amount of gas used by the _Functions Oracle contract_ when fulfilling a request. See the Cost Calculation section.
  * Gas after payment: The amount of gas used to cover additional operations such as decrementing the

:::NEXT DOC:::

contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription

:::NEXT DOC:::

  
    ⣾ Request 0xa89547c0270c1a5135ec7a47b9110db495facd811493832f54cc4c0b729b7786 has been initiated. Waiting for fulfillment from the Decentralized Oracle Network...
    
    ℹ Transaction confirmed, see https://mumbai.polygonscan.com/tx/0xa35ac46ec20a258cd9ffcc4a4396b998e3a60343a936009fb5fc76550c780d7f for more details.
    
    Actual amount billed to subscription #443:
    ┌──────────────────────┬────────────────────────────┐
    │         Type         │           Amount           │
    ├──────────────────────┼────────────────────────────┤
    │  Transmission cost:  │  0.00006493686812304 LINK  │
    │      Base fee:       │          0.2 LINK          │
    │                      │                            │
    │     Total cost:      │  0.20006493686812304 LINK  │
    └──────────────────────┴────────────────────────────┘
    
    
    ✔ Request

:::NEXT DOC:::

contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates with the _Functions Billing Registry_ , which
assigns a unique identifier (aka _Subscription ID_ ).

### Fund Subscription

You must fund your subscription accounts with enough LINK tokens:

  1. Connect your EOA to the _Subscription App_.
  2. Fund your subscription account. The _Subscriptions App_ abstracts the following: 


:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's

:::NEXT DOC:::

Fees

note

| Item          | Ethereum Sepolia testnet   | Polygon Mumbai testnet   | Avalanche Fuji testnet   |
|:--------------|:---------------------------|:-------------------------|:-------------------------|
| Registry fees | 0.2 LINK                   | 0.2 LINK                 | 0.2 LINK                 |
| DON fees      | 0 LINK                     | 0 LINK                   | 0 LINK                   |
## What's next

  * [› What's next?](/chainlink-functions/resources/service-limits)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/billing.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties

:::NEXT DOC:::

as sending an email or storing data on
the cloud, is currently not recommended. An HTTP method is idempotent if the
intended effect on the server when you make a single request is the same as
the effect when you make several identical requests. Each oracle node runs the
same computation in the [Off-chain Reporting protocol](/architecture-overview/off-chain-reporting). If your Chainlink Function makes non-idempotent
requests, it will cause redundant requests such as sending multiple emails or
storing the same data multiple times.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  3. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/4-post-data_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/4-post-data).
    
        git checkout tutorials

## Tutorial

This tutorial

:::NEXT DOC:::

service you want to use is [Chainlink Any
Api](https://docs.chain.link/any-api/introduction), and in the service the
cost of LINK depends on the node operator you are using.

There is a fee required by node operator. When you send a request, you
actually require Chainlink node to provide a service. Usually the service is
not free and the fee of a request is set by the node operator. The fee varies
across different node operators. If you are only a consumer to use service
provided by node operators, you just need to check the fee of [different node
operators](https://market.link/overview?searchView=true).

you, of course, also has to pay gas fee for your transaction, but that it it
costed in ETH rather than LINK (as you asking how much LINK it will cost, I
assume you know it).

If you are a node operator and want to run the service for yourself, you may
want to consider the following 2 factors:

  1. Congestion of the system mentioned by @Yilmaz. When the blockchain you are using is very busy, the gas price is high so that the more gas fee, which is the result of `(gas price) x(gas limit)`, will be cost more.

  2. The logic of fulfill function in your contract. Fulfillment function is the ""callback"" function of Chainlink Any Api. Oracle node will fetch the data demand in the request and then call the fulfill function in consumer contract. In fulfill function, logics varies from simply saving the data in a variable or doing some calculations. The more complex logics, the more gas limit required.

Hope it helps!


---
(Answered on: 2023-01-31 02:43:32)


> The problem is I can't approximate how much LINK it will cost me to get
> response from 1 oracle.

Nobody can. When you make a request to oracle, you are calling a smart
contract function and this

:::NEXT DOC:::

the more gas fee, which is the result of `(gas price) x(gas limit)`, will be cost more.

  2. The logic of fulfill function in your contract. Fulfillment function is the ""callback"" function of Chainlink Any Api. Oracle node will fetch the data demand in the request and then call the fulfill function in consumer contract. In fulfill function, logics varies from simply saving the data in a variable or doing some calculations. The more complex logics, the more gas limit required.

Hope it helps!


---
(Answered on: 2023-01-31 02:43:32)


> The problem is I can't approximate how much LINK it will cost me to get
> response from 1 oracle.

Nobody can. When you make a request to oracle, you are calling a smart
contract function and this will cost you gas which varies depending on the
congestion in the system. if system is busy, it will cost more gas. Also when
you interact with the chainlink, you are actually passing data to chainlink
smart contract which makes some calculations, so you pay for those gas too.

Calling one oracle is sending a request to one oracle. oracle is a chainlink
node operator, and it set its own price. But sending a request to only one
node is not a decentralized approach even though each node have multiple data
resources. you should make a request to several nodes meaning that you need to
pay each node operator. when you make a request to several nodes, you receive
the average of those responses.



"
Why does calling an external API in Chainlink not cause inconsistency?,"Because oracle responses are stored on-chain. Chainlink oracle network places the data on-chain in a transaction, and then it goes through the same validation process as every other transaction.",{'source': 'https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency'},"Calling an external API in Chainlink does not cause inconsistency because the oracle responses are stored on-chain. The Chainlink oracle network places the data on-chain in a transaction, and then it goes through the same validation process as every other transaction. This ensures that all nodes have access to the same data and can reach a consensus. Additionally, to make the process decentralized, many Chainlink nodes should be used to verify the data, ideally from many different data sources.","Question: (Asked on: 2021-11-26 22:39:12)
Why does calling an external API in chainlink not cause inconsistency?
URL: https://stackoverflow.com/questions/70130661/why-does-calling-an-external-api-in-chainlink-not-cause-inconsistency

Question Body:


Suppose I have a smart contract that uses Chainlink's ""Call Any External API""
capability to get some data from an external URL. My understanding is that
each Ethereum full node runs each smart contract to verify the status; it does
so to verify the latest block. But what if, between the time one full node
runs the contract and another one does, the data returned by calling tha
external API changes. Then it would seem that different full nodes would get
different results for that smart contract, resulting in inconsistent states.
Why does that not happen?



Answers:
(Answered on: 2021-12-10 18:05:16)


Because oracle responses are stored on-chain.

You are right, if fetching external data was part of the validation process,
no nodes would be able to reach a consensus. So instead, a Chainlink oracle
network places the data on-chain in a transaction, and then it goes through
the same validation process as every other transaction.

You can read more about how Chainlink's [Basic Request
Model](https://docs.chain.link/docs/architecture-request-model/) looks, but
this is basically the reason why having an oracle system built into a
blockchain is impossible.





:::NEXT DOC:::

Question: (Asked on: 2022-07-13 19:41:55)
When a make a call to a public API, how does chainlink verifies the response or it does not?
URL: https://stackoverflow.com/questions/72971781/when-a-make-a-call-to-a-public-api-how-does-chainlink-verifies-the-response-or

Question Body:


Example --> I made a API call to
<https://jsonplaceholder.typicode.com/posts/1> and got my desired response.  
But how does chainlink verifies the information that it is indeed correct.  
If not, is it not essentially removing one of the main benefits blockchain has
**'decentrialization'**?



Answers:
(Answered on: 2022-07-13 21:19:41)


**TLDR:** The basic example from the [docs](https://docs.chain.link) is
nothing but a building block of how to do it. It's an example of pulling from
a single API through a single node. To make this decentralized, you'd have to
pull many APIs through many different nodes.

The Chainlink Any API call feature should be considered the bare bones of a
Chainlink node. One piece of the whole picture. Analogously, a single Ethereum
node processing transactions would be centralized, and a single Chainlink node
responding with API data would be as well.

So we need many Ethereum nodes to process transactions to verify the
transactions are being processed correctly and many Chainlink nodes to verify
the data are being processed correctly. So if you want to get data through
Chainlink, you should use many nodes, and ideally many different data sources
as well - and that's how you can verify the data is correct.





:::NEXT DOC:::

use [Chainlink Any-
API](https://docs.chain.link/docs/make-a-http-get-request/) calls to bring it
into your smart contract

To do so, you need to know 3 things

  1. The API endpoint that contains the data, and the inputs required
  2. The outputs that the API returns, including their types (integer, string etc), as well as the path in the resulting JSON that contains the data you want
  3. A Chainlink oracle on the network you're contract is on that has a compatible job that you can use (whether one you run yourself or someone elses)

Once you have these things, you can use the example consumer contract in the
docs linked above, and then change the values to suit. ie here is an example
contract that will make an API call to PancakeSwap to get the price of
PancakeSwap token on BSC testnet:

1 - API address and inputs. In this case, according to your linked docs, the
URL of the API call is
`https://api.pancakeswap.info/api/v2/tokens/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82`.
The only input required is the token address in the URL

2 - We want the price, which is an integer and in the 'price' JSON element. We
will multiply the price by 10**8 when we bring it on-chain because Solidity
can't handle decimals

3 - Because this is a simple API call, we can use a community run CL node that
takes a HTTP GET request, parses the JSON to find an element we specify, then
multiplies the result and converts it to the type we want before returning it
on-chain. Taking a look at the [BSC testnet jobs

:::NEXT DOC:::

Question: (Asked on: 2021-11-02 20:20:58)
Requesting data with Chainlink, response not what expected
URL: https://stackoverflow.com/questions/69816494/requesting-data-with-chainlink-response-not-what-expected

Question Body:


I've been trying to integrate Chainlink into my contract, managed to get the
random number thingy working, but the API call doesn't work for me. Here's
what I got:

    
    
    contract ValorantCards is Ownable, ERC1155, VRFConsumerBase, ChainlinkClient {
    using Chainlink for Chainlink.Request;
    
    address private linkToken;
    
    // Chainlink VRF
    bytes32 private keyHash;
    uint256 private vrfFee;
    
    uint256 public randomResult;
    
    // Chainlink API calls
    address private oracle;
    bytes32 private jobId;
    uint256 private oracleFee;
    
    uint256 public playerLevel;
    
    constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        address _oracle,
        bytes32 _jobId,
        uint256 _oracleFee
    ) ERC1155("""") VRFConsumerBase(_vrfCoordinator, _linkToken) {
        setPublicChainlinkToken();
    
        linkToken = _linkToken;
        keyHash = _keyHash;
        vrfFee = 0.1 *

:::NEXT DOC:::

From the accompanying youtube video
(0x2f90A6D021db21e1B2A077c5a37B3C7E75D15b7e &
29fa9aa13bf1468788b7cc4a500a45b8) And from
[chainlink](https://market.link/jobs/8b2792ab-24a3-4ed7-b7f4-f56f44828d9b)
market (set to kovan network). (0xA1d76ABD287d87d6E1d92262F7D53Cbe4f290505 &
fc3ea215bb9e44e088107b29bb495e2d)

I'm not sure where things go wrong, I don't think it's the code since it's
copy pasted from the example. But non of the adreses have worked.

    
    
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract APIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
      
        uint256 public volume;
    
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        constructor() {
            setPublicChainlinkToken();
            oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
            jobId = ""d5270d1c311941d0b08bead21fea7747"";
    

:::NEXT DOC:::

Question: (Asked on: 2022-12-12 21:30:02)
Why is our Chainlink node not catching any OracleRequest events from our Arbitrum Operator? Requests are never fulfilled / v2 jobs never executed
URL: https://stackoverflow.com/questions/74777534/why-is-our-chainlink-node-not-catching-any-oraclerequest-events-from-our-arbitru

Question Body:


We're trying to get our Chainlink AnyAPI stack to work with an Arbitrum
Chainlink node. The same stack is being used on Ethereum, Polygon and
Avalanche without issue.

Chainlink AnyAPI empowers some of the use cases of DSLA Protocol, a middleware
for adding consumer protection capabilities to any monitorable marketplace
(e.g. OpenSea) using peer-to-peer service level agreements (SLA).

## Request Lifecycle

Here are the different steps involved in verifying that a SLA contract has
been respected, using Chainlink:

  1. A user calls the verification function on the Messenger smart contract that implements Chainlink.

  2. The `Messenger` smart contract sends the request the `PreCoordinator` smart contract .

  3. The `PreCoordinator` forwards the request to the Oracles defined in a Service Agreement (proxy of Oracles).

  4. Upon receiving LINK, each Oracle sends the request to the Chainlink node, by emitting an `OracleRequest` event with the id of the job to be executed.

  5. The Chainlink node captures such event, and executes the corresponding job.

  6. Once the job is executed, the Chainlink node calls the `fulfillOracleRequest2` function to return the result from the external adapter to the PreCoordinator.

  7. The PreCoordinator takes the mean of all Oracle results and ultimately registers the SLI in the messenger.

 

:::NEXT DOC:::

the result back to your contract.
There might be multiple reasons, but most likely something is wrong when the
Chainlink node calls the function `fulfillOracleRequest2` in the
[Operator.sol](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
and fails to write the result back to your contract.

Please check the following:

  1. Check if you fund your Chainlink node. You can check the balance of the chainlink node in the top right of the Chainlink node UI which is usually with port number 6688(eg. http://localhost:6688). Because the Chainlink node changes the state of the blockchain when calling the function in the contract operator, there has to be a minimum balance of ETH remaining in your Chainlink node. The solution to the issue is just to transfer some ETH(not LINK) tokens to your chainlink node address. [](https://i.stack.imgur.com/nXWT5.jpg)

  2. Check if you grant the Chainlink node permission to call function `fulfillOracleRequest2` in the contract operator. Search your Chainlink node address in the blockchain explorer like [etherscan](https://etherscan.io/), [goerliscan](https://goerli.etherscan.io/), [polygonscan](https://polygonscan.com/), etc. and if the node has no permission to call function `fulfillOracleRequest`, error `Fail with error 'Not authorized sender'` will be thrown. The solution to the issue is to use the function `setAuthorizedSenders` to grant the node address permission to call the function `fulfillOracleRequest2`.





:::NEXT DOC:::

on: 2021-10-28 06:48:56)


Generally, When we create new job on node it assign externalJobId to job which
is like '07269a61-586c-4831-bc26-7d2b581fbd1c'. But when you call function in
consumer contract you have to provide this externalJobId in function without
dashes so it will be like '07269a61586c4831bc267d2b581fbd1c'. This is not
mentioned in chainlink docs in noticeable way

<https://docs.chain.link/docs/fulfilling-requests/>

[](https://i.stack.imgur.com/1EwZr.png)





:::NEXT DOC:::

Question: (Asked on: 2022-12-25 12:25:30)
Why is recordChainlinkfulfillment not being executed?
URL: https://stackoverflow.com/questions/74913265/why-is-recordchainlinkfulfillment-not-being-executed

Question Body:


Anyone any idea why the recordChainlinkfulfillment is not being executed?

I've checked the API call and it's yield the correct results. I managed to got
this working with the chainlink job for fetching 1 value, but not for multiple
values.

As far as I can tell and was able to check, the API url was correctly set and
the request function was correctly executed. My contract is funded with enough
LINK.

    
    
        // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.9;
    
    
    import ""@openzeppelin/contracts/access/Ownable.sol"";
    import ""@openzeppelin/contracts/utils/Counters.sol"";
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    contract RealEstateBonus is ChainlinkClient, Ownable {
        using Chainlink for Chainlink.Request;
    
        bytes32 private jobId;
        uint256 private fee;
        string public url;
        string public urlresult;
        string public lastselldate;
        string public lastapn;
        bytes32 public lastrequestid;
    
        event

:::NEXT DOC:::

 * [APIConsumner2.sol](https://rinkeby.etherscan.io/address/0xb306e2a5cc3adf26798a9adf567b9c0876c3566b)

When I call the requestData() method on both contracts they seems to work, the
transactions goes through and Link gets taken from the contracts, I am however
unable to determine whether the actual data I am requesting from the external
APIs gets returned, either by looking in the transaction event or trying to
access the value that I am setting.

I am a bit bamboozled at this point, any guidance or suggestions would be
greatly appreciated.



Answers:
(Answered on: 2021-10-11 16:18:26)


Thanks for the flag. The node that was hosting this is deprecated, the article
has been updated, and the docs have the latest example.

Please use:

    
    
    oracle = 0xc57B33452b4F7BB189bB5AfaE9cc4aBa1f7a4FD8;
    jobId = ""d5270d1c311941d0b08bead21fea7747"";
    



"
What is the purpose of the `cacheTTL` parameter in the Bridge task?,The `cacheTTL` parameter is a duration-formatted string indicating the maximum acceptable staleness for cached bridge responses in case of intermittent failures.,{'source': 'https://docs.chain.link/chainlink-nodes/oracle-jobs/all-tasks/'},The `cacheTTL` parameter in the Bridge task is used to indicate the maximum acceptable staleness for cached bridge responses in case of intermittent failures.,"set `AllowOrigins = '*'` to allow the UI to work from any URL, but it
is recommended for security reasons to make it explicit instead.

### BridgeCacheTTL


    BridgeCacheTTL = '0s' # Default

BridgeCacheTTL controls the cache TTL for all bridge tasks to use old values
in newer observations in case of intermittent failure. It's disabled by
default.

### BridgeResponseURL


    BridgeResponseURL = 'https://my-chainlink-node.example.com:6688' # Example

BridgeResponseURL defines the URL for bridges to send a response to. This
_must_ be set when using async external adapters.

Usually this will be the same as the URL/IP and port you use to connect to the
Chainlink UI.

### HTTPWriteTimeout

⚠️ **_ADVANCED_** : _Do not change this setting unless you know what you are
doing._


    HTTPWriteTimeout = '10s' # Default

HTTPWriteTimeout controls how long the Chainlink node's API server can hold a
socket open for writing a response to an HTTP request. Sometimes, this must be
increased for pprof.

### HTTPPort


    HTTPPort = 6688 # Default

HTTPPort is the port used for the Chainlink Node API, CLI, and GUI.

### SecureCookies


    SecureCookies = true # Default

SecureCookies requires the use of secure cookies for authentication. Set to
false to enable standard HTTP requests along with `TLSPort = 0`.

### SessionTimeout


    SessionTimeout = '15m' # Default

SessionTimeout determines the amount of idle time to elapse before session
cookies expire. This signs out GUI users from their sessions.

### SessionReaperExpiration


    SessionReaperExpiration = '240h' # Default

SessionReaperExpiration represents how long an API session lasts before
expiring and requiring a new

:::NEXT DOC:::

 * Default: `""1m""`

`AUTHENTICATED_RATE_LIMIT_PERIOD` defines the period to which authenticated
requests get limited.

### BRIDGE_CACHE_TTL

  * Default: 0s

When set to `d` units of time, this variable enables using cached bridge
responses that are at most `d` units old. Caching is disabled by default.

Example `BRIDGE_CACHE_TTL=10s`, `BRIDGE_CACHE_TTL=1m`

### BRIDGE_RESPONSE_URL

  * Default: _none_

`BRIDGE_RESPONSE_URL` defines the URL for bridges to send a response to.

Usually this will be the same as the URL/IP and port you use to connect to the
Chainlink UI, such as `https://my-chainlink-node.example.com:6688`.

### HTTP_SERVER_WRITE_TIMEOUT

**ADVANCED**

Do not change this setting unless you know what you are doing.

  * Default: `""10s""`

`HTTP_SERVER_WRITE_TIMEOUT` controls how long the Chainlink node's API server
can hold a socket open for writing a response to an HTTP request. Sometimes,
this must be increased for pprof.

### CHAINLINK_PORT

  * Default: `""6688""`

Port used for the Chainlink Node API, CLI, and GUI.

### SECURE_COOKIES

  * Default: `""true""`

Requires the use of secure cookies for authentication. Set to false to enable
standard HTTP requests along with `CHAINLINK_TLS_PORT=0`.

### SESSION_TIMEOUT

  * Default: `""15m""`

This value determines the amount of idle time to elapse before session cookies
expire. This signs out GUI users from their sessions.

###

:::NEXT DOC:::

`MaxAgeDays`
variable can still cause them to get deleted.

## WebServer


    [WebServer]
    AllowOrigins = 'http://localhost:3000,http://localhost:6688' # Default
    BridgeCacheTTL = '0s' # Default
    BridgeResponseURL = 'https://my-chainlink-node.example.com:6688' # Example
    HTTPWriteTimeout = '10s' # Default
    HTTPPort = 6688 # Default
    SecureCookies = true # Default
    SessionTimeout = '15m' # Default
    SessionReaperExpiration = '240h' # Default

### AllowOrigins


    AllowOrigins = 'http://localhost:3000,http://localhost:6688' # Default

AllowOrigins controls the URLs Chainlink nodes emit in the `Allow-Origins`
header of its API responses. The setting can be a comma-separated list with no
spaces. You might experience CORS issues if this is not set correctly.

You should set this to the external URL that you use to access the Chainlink
UI.

You can set `AllowOrigins = '*'` to allow the UI to work from any URL, but it
is recommended for security reasons to make it explicit instead.

### BridgeCacheTTL


    BridgeCacheTTL = '0s' # Default

BridgeCacheTTL controls the cache TTL for all bridge tasks to use old values
in newer observations in case of intermittent failure. It's disabled by
default.

### BridgeResponseURL


    BridgeResponseURL = 'https://my-chainlink-node.example.com:6688' # Example

BridgeResponseURL defines the URL for bridges to send a response to. This
_must_ be set when using async external adapters.

Usually this will be the same as the URL/IP and port you use to connect to the
Chainlink UI.

###

:::NEXT DOC:::

allowUnrestrictedNetworkAccess (optional): permits the task to access a URL
> at localhost, which could present a security risk. Note that Bridge tasks
> allow this by default.

ie:

    
    
    my_http_task [type=""http""
                  method=PUT
                  url=""http://chain.link""
                  requestData=""{\\""foo\\"": $(foo), \\""bar\\"": $(bar), \\""jobID\\"": 123}""
                  allowUnrestrictedNetworkAccess=true
                  ]
    

You can also use this flag in JSON





:::NEXT DOC:::

of the task is `fetch`. The output of each task is stored in the
variable corresponding to the name of the task. In some cases, tasks return
complex values like maps or arrays. By using dot access syntax, you can access
the elements of these values. For example:


    // Assume that this task returns the following object:
    //  { ""ethusd"": 123.45, ""btcusd"": 678.90 }
    parse [type=""jsonparse"" path=""data"" data=""$(fetch)""]
    
    // Now, we want to send the ETH/USD price to one bridge and the BTC/USD price to another:
    submit_ethusd [type=""bridge"" name=""ethusd"" requestData=""{ \\""data\\"": { \\""value\\"": $(parse.ethusd) }}""]
    submit_btcusd [type=""bridge"" name=""btcusd"" requestData=""{ \\""data\\"": { \\""value\\"": $(parse.btcusd) }}""]
    
    parse -> submit_ethusd
    parse -> submit_btcusd

### Quotes

Some tasks, like the `bridge` tasks above, require you to specify a JSON
object. Because the keys of JSON objects must be enclosed in double quotes,
you must use the alternative `<` angle bracket `>` quotes. Angle brackets also
enable multi-line strings, which can be useful when a JSON object parameter is
large:


    submit_btcusd [type=""bridge""
                   name=""btcusd""
                   requestData=""{\\""data\\"":{\\""value\\"": $(foo), \\""price\\"": $(bar), \\""timestamp\\"": $(baz)}}""
        

:::NEXT DOC:::

`FEATURE_WEBHOOK_V2=true` in your `.env` file.


    type = ""webhook""
    schemaVersion = 1
    name = ""Soccer-Data-EA-Web""
    observationSource = """"""
    fetch        [type=bridge name=""soccer-data"" requestData=""{\\""id\\"": \\""0\\"", \\""data\\"": { \\""playerId\\"": \\""12345678\\""}}""]
    
        fetch
    """"""

Adding the following into the TOML spec manually sets the parameters passed
into the bridge task. It is equivalent to using `request.add` as shown above
or adding the data with the `--d` flag if you're using
[curl](https://curl.se/).


    requestData=""{\\""id\\"": \\""0\\"", \\""data\\"": { \\""playerId\\"": \\""12345678\\""}}""

There will be a big `Run` button on your job definition, which you can use to
kick off the job.



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/node-operators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

   data_1 [type=""http"" method=GET url=""https://chain.link/eth_usd""       index=0]
    data_2 [type=""http"" method=GET url=""https://chain.link/eth_dominance"" index=1]
    multiword_abi_encode [type=""eth_abi_encode"" method=""fulfill(uint256,uint256)""]
    
    data_1 -> multiword_abi_encode
    data_2 -> multiword_abi_encode

`timeout`: The maximum duration that the task is allowed to run before it is
considered to be errored. Overrides the `maxTaskDuration` value in the job
spec.

## Writing pipelines

Pipelines are composed of tasks arranged in a DAG (directed acyclic graph).
Pipelines are expressed in [DOT
syntax](https://en.wikipedia.org/wiki/DOT_%28graph_description_language%29#Directed_graphs).

Each node in the graph is a task with a user-specified ID and a set of
configuration parameters and attributes:


    my_fetch_task [type=""http"" method=GET url=""https://chain.link/eth_usd""]

The edges between tasks define how data flows from one task to the next. Some
tasks can have multiple inputs, such as `median`. Other tasks are limited to 0
(`http`) or 1 (`jsonparse`).


    data_source_1  [type=""http"" method=GET url=""https://chain.link/eth_usd""]
    data_source_2  [type=""http"" method=GET url=""https://coingecko.com/eth_usd""]
    medianize_data [type=""median""]
    submit_to_ea   [type=""bridge"" name=""my_bridge""]
    
    data_source_1

:::NEXT DOC:::

use the bridge, add a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task) to your job. The `bridge` task defined in the
example below is defined as `fetch` and the name of the bridge is `soccer-
data`.


    type = ""directrequest""
    schemaVersion = 1
    name = ""Soccer-Data-EA""
    contractAddress = ""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""soccer-data"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""playerId\\"": $(decode_cbor.playerId)}}""]
        parse        [type=jsonparse path=""data,0,Games"" data=""$(fetch)""]
        encode_data 

:::NEXT DOC:::

pipeline task DAG, which is specified in DOT syntax. See below for information on writing pipeline DAGs.
  * `maxTaskDuration`: The default maximum duration that any task is allowed to run. If the duration is exceeded, the task is errored. This value can be overridden on a per-task basis using the `timeout` attribute. See the [Shared attributes](/chainlink-nodes/oracle-jobs/tasks#shared-attributes) section for details.
  * `externalJobID`: An optional way for a user to deterministically provide the ID of a job. The ID must be unique. For example, you can specify an `externalJobID` if you want to run the same `directrequest` job on two different Chainlink nodes with different bridge names. The spec contents differ slightly, but you can use the same `externalJobID` on both jobs, specify that in your on-chain requests, and both nodes will pick it up. If you do not provide an `externalJobID`, the node generates the ID for you.
  * `gasLimit`: Optional gas limit for any outgoing transactions spawned by this job. When specified, it overrides `ETH_GAS_LIMIT_DEFAULT` env variable.
  * `forwardingAllowed`: Optional. When `true`, it allows forwarding transactions submitted by the job.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/jobs.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Question: (Asked on: 2023-01-17 21:38:18)
Chainlink async bridge task returns HTTP Error 422
URL: https://stackoverflow.com/questions/75152488/chainlink-async-bridge-task-returns-http-error-422

Question Body:


I have to integrate my Chainlink Bridge task with an asynchronous call.
Looking at the official [documentation](https://docs.chain.link/chainlink-
nodes/oracle-jobs/task-types/task_bridge), there's the parameter named `async`
and I can set it to `true` to invoke it asynchronously.

I also found this [link](https://docs.chain.link/chainlink-nodes/external-
adapters/developers/#asynchronous-callbacks) which explains how to create
`Asynchronous callbacks`.

I created the following job step:

    
    
    fetch           [type=""bridge""
                     name=""generate-hash""
                     requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": {\\""fileList\\"": $(decode_cbor.fileList)}}""
                     async=true
                    ]
    

I also set the environment variable
[BRIDGE_RESPONSE_URL](https://docs.chain.link/chainlink-
nodes/v1/configuration#bridge_response_url) equals to my Chainlink Oracle
address. Looking at the documentation, I must set when using async external
adapters.

If I start the job execution, I can"
What is the purpose of the `performUpkeep` function?,"The `performUpkeep` function is called by the Automation Nodes to increase all elements whose balances are lower than the LIMIT, and to rebalance the elements if necessary.",{'source': 'https://docs.chain.link/chainlink-automation/flexible-upkeeps/'},"The purpose of the `performUpkeep` function is to increase the balances of elements that have balances lower than the specified limit, by calculating the increment needed, decreasing the contract liquidity accordingly, and rebalancing the element. This function is called by the Automation Nodes when the `checkUpkeep` function returns `true`.","| Description                                                                                         |
|:----------------|:----------------------------------------------------------------------------------------------------|
| checkUpkeep     | Runs off-chain at every block to determine if the performUpkeep function should be called on-chain. |
| performUpkeep   | Contains the logic that should be executed on-chain when checkUpkeep returns true.                  |
### `checkUpkeep` function

This function contains the logic that runs off-chain during every block as an
`eth_call`[(link)](https://eth.wiki/json-rpc/API#eth_call) to determine if
`performUpkeep` should be executed on-chain. To reduce on-chain gas usage,
attempt to do your gas intensive calculations off-chain in `checkUpkeep` and
pass the result to `performUpkeep` on-chain.

Gas limits for checkUpkeep

The `checkUpkeep` function is subject to the `checkGasLimit` in the [registry
configuration](/chainlink-automation/supported-networks/#configurations).

Because `checkUpkeep` is only off-chain in simulation it is best to treat this
as a `view` function and not modify any state. This might not always be
possible if you want to use more advanced Solidity features like
`DelegateCall`[(link)](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries). It is a best
practice to import

:::NEXT DOC:::

Chainlink Automation can trigger the `performUpkeep` function. The boolean is set to true whenever the time interval is met.
    
        upkeepNeeded = (block.timestamp - lastUpkeepTimeStamp) > updateInterval;

  * `performUpkeep`: Sends the request to the oracle by calling the `FunctionsClient` `sendRequest` function. You can read the API reference for [sending a request](/chainlink-functions/api-reference/FunctionsClient/#sendrequest). Also, it updates `lastUpkeepTimeStamp` with the current timestamp, increments `upkeepCounter`, and sets `latestRequestId` to the last request ID.
    
        lastUpkeepTimeStamp = block.timestamp;
    upkeepCounter = upkeepCounter + 1;
    ...
    bytes32 requestId = s_oracle.sendRequest(
    subscriptionId,
    requestCBOR,
    fulfillGasLimit
    );
    ...
    latestRequestId = assignedReqID;

`fulfillRequest` is invoked by Chainlink Functions during the callback. This
function is defined in `FunctionsClient` as `virtual` (read `fulfillRequest`
[API reference](/chainlink-functions/api-reference/FunctionsClient/#fulfillrequest)). So, your smart contract must
override the function to implement the callback. The implementation of the
callback is straightforward: the contract stores the latest response and error
in `latestResponse` and `latestError` and increments `responseCounter` before
emitting the `OCRResponse` event.


    latestResponse = response;
    latestError = err;
    responseCounter = responseCounter + 1;
    emit OCRResponse(requestId, response, err);

### config.js

See the

:::NEXT DOC:::

true;
                return (true, performData) ;`//should perform upkeep for the setTime() function`
            } if (roundWinningIndex[coinRound].length != 0) {
                upkeepNeeded = true;
                return (true, performData);`//should perform upkep for the a withdrawal function
            }
    

How do I configure the perform upkeep to know which function to call? How do I
make sure it calls the correct function?



Answers:
(Answered on: 2021-11-24 21:36:27)


There are a number of ways you can have the keepers call the correct function.
One way would be to add information in your `performData` designating which
function to call.

The performUpkeep looks like this:

    
    
    function performUpkeep(bytes calldata performData) external override {
            // conditional to call one function
            // conditional to call a different function
        }
    

## 1\. The Better way

When the Chainlink keepers call `checkUpkeep` they pass the returned
information of `performData` to the input of `performUpkeep`. You can
[encode](https://docs.soliditylang.org/en/v0.8.10/units-and-global-
variables.html?highlight=abi.encode#abi-encoding-and-decoding-functions) just
about anything to pass as inputs to the

:::NEXT DOC:::

when the checkUpkeep returns true to execute the upkeep



Answers:
(Answered on: 2022-11-12 04:08:40)


In order to solve the problem like ""Why Chainlink checkUpkeep does not
execute"", I suggest doing the following things to debug your upkeep.

  1. Since `checkUpkeep` and `performUpkeep` are both triggered by [Chainlink automation](https://automation.chain.link/), you need to check your automation subscription first. In the automation app, double check the contract address is correct.
  2. Because the chainlink node has to change the state of blockchain(call `performUpkeep` in your consumer contract), it has to pay the gas fee. It is important to make sure there is a minimum balance of LINK in your subscription.
  3. Test if `checkUpkeep` works as expected. If the pre-defined condition for automation is satisfied in your smart contract, `checkUpkeep` should return true. Chainlink automation only calls `performUpkeep` when `checkUpkeep` returns `true`, so the upkeep does not work if `checkUpkeep` cannot return true. Call `checkUpkeep` by yourself to test if it works properly. If you cannot get `true` as returned value, automation cannot get `true` either.
  4. Test if `performUpkeep` works as expected. The mechanism of Chainlink automation is to call `performUpkeep` when `checkUpkeep` returns `true`, so you must make sure the `performUpkeep` can be called by automation. Try to call the `performUpkeep` manually to see if it works properly.

Hope it helps!





:::NEXT DOC:::

actions must be performed only when specific conditions are met. Check
all of the preconditions within `performUpkeep` to ensure that state change
occurs only when necessary.

In this pattern, it is undesirable for the state change to occur until the
next time the Upkeep is checked by the network and the conditions are met. It
is a best practice to stop any state change or effects by performing the same
checks or similar checks that you use in `checkUpkeep`. These checks validate
the conditions before doing the work.

For example, if you have a contract where you create a timer in `checkUpkeep`
that is designed to start a game at a specific time, validate the condition to
ensure third-party calls to your `performUpkeep` function do not start the
game at a different time.

### Perform upkeep ONLY when data is verified via `performData`

Some actions must be performed using data you intend to use. Revalidate that
the `performData` is allowed before execution.

For example, if you have a `performUpkeep` that funds a wallet and the address
of the wallet is received via the `performData` parameter, ensure you have a
list of permissable addresses to compare against to prevent third-party
calling your function to send money to their address.

### When performing actions in Automation-compatible contracts is not harmful

Sometimes actions must be performed when conditions are met, but performing
actions when conditions are not met is still acceptable. Condition checks
within `performUpkeep` might not be required, but it can still be a good
practice to short circuit expensive and unnecessary on-chain processing when
it is not required.

It might be desirable to call `performUpkeep` when the `checkUpkeep`
conditions haven't yet been tested by Chainlink Automation, so any specific
checks that you perform are entirely use case specific.

### Always test your contract

As with all smart contract testing, it is important to test the boundaries of
your smart contract in

:::NEXT DOC:::

   }
        else{
            upkeepNeeded = false;
        }
      }
    
    function **performUpkeep**(bytes calldata /* performData */) external override {
        require(msg.sender == 0x4Cb093f226983713164A62138C3F718A5b595F73);
        lottery_state = LOTTERY_STATE.DRAWING;
        Random(random).getRandomNumber();
      }
    

As I mentioned earlier, this code is being used in another contract which is
currently receiving upkeep so I am puzzled as to why it is not working in the
new contract.



Answers:
(Answered on: 2021-12-13 23:44:27)


If your upkeeps are not being performed make sure to double-check the next
items:

  * Are Chainlink Keepers currently available on the network you are deploying to?
  * Is your smart contract `KeeperCompatible`?
  * Call `checkUpkeep`. Did it return `true` or `false`?
  * Can you `performUpkeep`?
  * Did you register your contract for upkeeps?
  * Did you fund it?





:::NEXT DOC:::

to do your gas intensive calculations off-chain in `checkUpkeep` and
pass the result to `performUpkeep` on-chain.

Gas limits for checkUpkeep

The `checkUpkeep` function is subject to the `checkGasLimit` in the [registry
configuration](/chainlink-automation/supported-networks/#configurations).

Because `checkUpkeep` is only off-chain in simulation it is best to treat this
as a `view` function and not modify any state. This might not always be
possible if you want to use more advanced Solidity features like
`DelegateCall`[(link)](https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries). It is a best
practice to import the
`AutomationCompatible.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/AutomationCompatible.sol)
contract and use the `cannotExecute` modifier to ensure that the method can be
used only for simulation purposes.


    function checkUpkeep(
      bytes calldata checkData
    ) external view override returns (bool upkeepNeeded, bytes memory performData);
    

Below are the parameters and return values of the `checkUpkeep` function.
Click each value to learn more about its design patterns and best practices:

**Parameters:**

  * `checkData`: Fixed and specified at upkeep registration and used in every `checkUpkeep`. Can be empty (0x).

**Return Values:**

  * `upkeepNeeded`: Boolean that when True will trigger the on-chain `performUpkeep` call.
  * `performData`: Bytes that will be used as input parameter when calling `performUpkeep`. If you would like to encode data to decode later, try `abi.encode`.

####

:::NEXT DOC:::

     performData = checkData;
        }
    
        function performUpkeep(bytes calldata performData) external override {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            performData;
            getLatestPrice();
        }
    }
    



Answers:
(Answered on: 2021-11-11 23:55:20)


your upkeep job would be getting called, but the problem is you're not doing
anything with the getLatestPrice function. This is a view function that just
returns the current feed price. If you were to add a line in your
performUpkeep function to actually store the result of getLatestPrice() in a
variable in the contract, then you would see that it is getting called





:::NEXT DOC:::

contract logic go down different code paths. This can be used in creative ways based on your use case needs.

**Example** : You could support multiple types of upkeep within a single
contract and pass a function selector through the `checkData` function.

#### `performData`

The response from `checkUpkeep` is passed to the `performUpkeep` function as
`performData`. This allows you to perform complex and gas intensive
calculations as a simulation off-chain and only pass the needed data on-chain.

You can create a highly flexible off-chain computation infrastructure that can
perform precise actions on-chain by using `checkData` and `performData`. Both
of these computations are entirely programmable.

### `performUpkeep` function

When `checkUpkeep` returns `upkeepNeeded == true`, the Automation node
broadcasts a transaction to the blockchain to execute your `performUpkeep`
function on-chain with `performData` as an input.

Gas limits for performUpkeep

During registration you have to specify the maximum gas limit that we should
allow your contract to use. We simulate `performUpkeep`during `checkUpkeep`
and if the gas exceeds this limit the function will not execute on-chain. One
method to determine your upkeep's gas limit is to simulate the `performUpkeep`
function and add enough overhead to take into account increases that might
happen due to changes in `performData` or on-chain data. The gas limit you
specify cannot exceed the `performGasLimit` in the [configuration of the
registry](/chainlink-automation/supported-networks/#configurations).

Ensure that your `performUpkeep` is _idempotent_. Your `performUpkeep`
function should change state such that `checkUpkeep` will not return `true`
for the same subset of work once said work is complete. Otherwise the Upkeep
will remain eligible and result in multiple

:::NEXT DOC:::

               upkeepNeeded = true;
                functionToCall = 0;
                return (true, performData) ;
            } if (roundWinningIndex[coinRound].length != 0) {
                upkeepNeeded = true;
                functionToCall = 1;
                return (true, performData);
            }
    
    

Then:

    
    
    function performUpkeep(bytes calldata performData) external override {
            if(functionToCall == 0){
                setTime();
            } 
            if(functionToCall == 1){
                withdraw();
            }
        }
    



"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-13/hints.md'},"The topic of Chapter 1 is ""What will this course cover?"" in the Chainlink Introduction course.","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What is a constructor in Solidity?,A constructor is a special function executed upon contract creation that allows us to set initial values for the state variables.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-9/course.md'},A constructor in Solidity is a special function executed upon contract creation that allows for setting initial values for state variables. It is used to avoid the need to write a new contract with updated initial values in the Solidity code.,"#####Chapter 9:

# Constructors

It is likely that you want to deploy the same contract with different initial values. Until now, you only learned how to set initial values. So you would always need to write a new contract with updated initial values in the Solidity code. This is unpractical. Fortunately, Solidity offers a constructor, a special function executed upon contract creation.

<Highlight class=""language-javascript"">
contract Foo {
uint public amount;
   constructor(uint _amount) {
       amountFoo = _amount;
   }
}
 
contract Bar {
uint public amount;
   constructor(uint _amount) {
       amountBar = _amount;
   }
}
</Highlight>

There can only be one constructor per contract and a constructor is defined using the constructor keyword. The arguments are passed during contract creation, allowing us to set initial values for the state variables. There is always a constructor in place. If you do not define one, there is a default constructor. Once the contract is created, the code is deployed on the blockchain.

Child contracts inhering from a parent contract can also call their parent constructors. You can do this either directly when defining the contract or in the child contract constructor:

<Highlight class=""language-javascript"">
contract A is Foo(42) {
}
 
contract B is Bar {
  constructor(uint \_amount) Bar(\_amount) {}
}
</Highlight>

It is important to note that parent constructors are always called in order of inheritance. So if you use the child constructor to pass the values, you should always check the order of inheritance They are always called from right to left. Let’s look at an example:

<Highlight

:::NEXT DOC:::

is always a constructor in place. If you do not define one, there is a default constructor. Once the contract is created, the code is deployed on the blockchain.

Child contracts inhering from a parent contract can also call their parent constructors. You can do this either directly when defining the contract or in the child contract constructor:

<Highlight class=""language-javascript"">
contract A is Foo(42) {
}
 
contract B is Bar {
  constructor(uint \_amount) Bar(\_amount) {}
}
</Highlight>

It is important to note that parent constructors are always called in order of inheritance. So if you use the child constructor to pass the values, you should always check the order of inheritance They are always called from right to left. Let’s look at an example:

<Highlight class=""language-javascript"">
contract C is Foo, Bar {
 constructor() Bar(5) Foo(42) {}
}
</Highlight>

So here the constructor of Bar is called first with the value 5, then the Foo constructor is called with the value 42 and then the constructor of C is called. Remember this when using constructors because it might introduce weird behavior to your contracts if you have a different assumption.


:::NEXT DOC:::

It is likely that you want to deploy the same contract with different initial values. Until now, you only learned how to set initial values. So you would always need to write a new contract with updated initial values in the Solidity code. This is unpractical. Fortunately, Solidity offers a constructor, a special function executed upon contract creation.


:::NEXT DOC:::

Constructors are logic that is run whenever a smart contract is first deployed to a blockchain.


:::NEXT DOC:::

the contract when it is
first created.

In `HelloWorld`, the constructor takes in a `string` as a parameter and sets
the `message` state variable to that string.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }

### Functions

**Functions** can access and modify the state of the contract or call other
functions on external contracts. `HelloWorld` has a function named
`updateMessage`, which updates the current message stored in the state.


    constructor(string memory initialMessage) {
      message = initialMessage;
    }
    
    function updateMessage(string memory newMessage) public {
      message = newMessage;
    }

Functions use visibility modifiers to define the access level. Learn more
about functions visibility
[here](https://docs.soliditylang.org/en/latest/contracts.html#function-visibility).

### Interfaces

An **interface** is another concept that is familiar to programmers of other
languages. Interfaces define functions without their implementation, which
leaves inheriting contracts to define the actual implementation themselves.
This makes it easier to know what functions to call in a contract. Here's an
example of an interface:


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    interface numberComparison {
        function isSameNum(uint a, uint b) external view returns (bool);
    }
    
    contract Test is numberComparison {
        constructor()

:::NEXT DOC:::

#####Chapter 1:

# Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Inspired by the power of smart contracts and blockchain, it’s time to dive in.
    </div>
  </div>
</ContentWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent. If you are familiar with some programming, it may help to know that Solidity is an **object-oriented programming language**. If you are not familiar with what that means, don’t worry, we’ll cover it in a future course.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!




:::NEXT DOC:::

popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
    * [Writing Solana contracts in Rust](https://docs.solana.com/developing/on-chain-programs/developing-rust)
    * [Writing Solana contracts in C](https://docs.solana.com/developing/on-chain-programs/developing-c)

## What does a smart contract look like?

The structure of a smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
       

:::NEXT DOC:::

# Solidity Introduction

<GradientTextWrapp>
  Solidity is an object-oriented, high-level language for implementing smart contracts. Learn about the basics here.
</GradientTextWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

#####Chapter 9: Building a Basic Contract

# The Constructor

Constructors are logic that is run whenever a smart contract is first deployed to a blockchain. We will set the constructor to the following values:

<Highlight class=""language-javascript"">
constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
    LINKTOKEN = LinkTokenInterface(link);
    s_owner = msg.sender;
    s_subscriptionId = subscriptionId;
  }
</Highlight>

Let's break down this constructor. It takes one parameter, subscriptionId, which is the ID of the subscription we will set up in a later chapter. It then passes in the address stored in the vrfCoordinator to the VRFConsumerBaseV2 contract's constructor to set it up. 

The COORDINATOR variable is set to the VRFCoordinatorV2Interface also initialized to the address stored in the vrfCoordinator.

The LINKTOKEN variable is set to LinkTokenInterface that we imported and the interface is initialized with the link token address we specificied earlier.

The s\_owner variable is set to msg.sender which is the address of the wallet account which will deploy the contract.

The s\_subscriptionId is set to subscriptionId which we fed into the constructor as a parameter.

:::NEXT DOC:::

smart contract is similar to that of a class in Javascript,
with a few differences. For example, the following `HelloWorld` contract is a
simple smart contract that stores a single variable and includes a function to
update the value of that variable.


    // SPDX-License-Identifier: MIT
    
    pragma solidity 0.8.7;
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract HelloWorld {
        string public message;
    
        constructor(string memory initialMessage) {
            message = initialMessage;
        }
    
        function updateMessage(string memory newMessage) public {
            message = newMessage;
        }
    }
    

### Solidity versions

The first thing that every Solidity file must have is the Solidity version
definition. The `HelloWorld.sol` contract uses version `0.8.7`, which is
defined in the contract as `pragma solidity 0.8.7;`

You can see the latest versions of the Solidity compiler
[here](https://github.com/ethereum/solc-bin/blob/gh-pages/bin/list.txt/?target=_blank). You might also notice smart contracts that
are compatible with a range of versions.


    pragma solidity >=0.7.0 <0.9.0;

This means that the code is written for Solidity version 0.7.0, or a newer
version of the language up to, but not including version 0.9.0. The `pragma`
selects the compiler, which defines"
What does Chainlink VRF allow you to customize?,Several randomness parameters.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-7/description.md'},Chainlink VRF allows you to customize several randomness parameters.,"Learn how Chainlink VRF allows you to customize several randomness parameters.


:::NEXT DOC:::

Learn how Chainlink VRF allows you to customize several randomness parameters.


:::NEXT DOC:::

So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?


:::NEXT DOC:::

Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number.


:::NEXT DOC:::

#####Chapter 3:

# Chainlink VRF

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     So you’ve realized that you need Chainlink VRF to build your raffle. But what makes Chainlink VRF so special?
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson randomness provided by an outside service needs to be verifiable and decentralized, and that’s exactly what Chainlink VRF is! VRF stands for Verifiable Randomness Function. Essentially Chainlink VRF provides cryptographic proof alongside every random number generated, that the random number wasn’t tampered with (and indeed generated in a random way).

How does this cryptographic proof work? It’s quite mathematically complicated and outside the scope of this lesson, but you can read more about it in the “Technical Walkthrough” section of this [blog post](https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/). The cryptographic proof is then verified by a smart contract on-chain, which means it is verified by every node on the blockchain! This completes our verifiable and decentralized criteria. So now we understand that Chainlink VRF is verifiably random and decentralized how do we use it?


:::NEXT DOC:::

with a random number, the amount of LINK token to be paid to the VRF can be dynamic based on network conditions. When demand to get transactions into a blockchain is high, and thus gas prices are high, more LINK will be deducted to compensate the gas the VRF has to pay to get it's random number transaction on-chain. Or if you don't want the contract to request random numbers when the gas price is high, you can specify that via the Gas Lane. The more random numbers the contract requests at once the more expensive it will be. And finally the higher the computational load of the function the consumer contract runs when recieving a random number; the more gas it will cost for the VRF to submit a random number.

The subscription model added in Chainlink VRFv2 is a powerful tool, enabling any consumer contract requesting a random number to determine how it wants that random number! 

:::NEXT DOC:::

based on something (could be user input or on-chain data, it doesn't
matter) before the call to the oracle is made (the call passes the seed to the
oracle). Once the oracle generates a random number, the VRF function can then
use math and cryptography to actually verify that the random number was
created based from the initial seed, and that it's not just some random number
plucked from the air (and potentially malicious). This is the magic of VRF,
being able to verify a random number was created with a previously committed
seed. So combining a VRF function with an oracle is the best possible way for
a safe and secure source of randomness in a smart contract.

[Chainlink VRF](https://chain.link/chainlink-vrf) is the industry standard for
randomness on blockchains, and I highly suggest you look into it. If it's cost
you're worried about, I think its cheaper to use on other chains like Polygon
or BSC. Also if you speak to the Chainlink Labs team, they can possibly work
out some agreement that is more feasible for bootstrapped projects





:::NEXT DOC:::

                                                                                                                               |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                                                                                                          | Suitable for infrequent one-off requests                                                                                                                                                                    |
| Supports multiple VRF consuming contracts connected to one subscription account                   

:::NEXT DOC:::

While it’s effortless for Chainlink’s VRF to utilize on-chain randomness for your smart contract, it does not mean there are no pitfalls or potential attack vectors. Let’s explore how validators could potentially manipulate the generation of random numbers and other surprises. You can read more about it here.


:::NEXT DOC:::

how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation"
What issue is the user facing when integrating Chainlink into their contract?,The API call doesn't work for them.,{'source': 'https://stackoverflow.com/questions/69816494/requesting-data-with-chainlink-response-not-what-expected'},The user is facing issues verifying their smart contract on Rinkeby Testnet using Chainlink v0.8.,"Question: (Asked on: 2021-11-02 20:20:58)
Requesting data with Chainlink, response not what expected
URL: https://stackoverflow.com/questions/69816494/requesting-data-with-chainlink-response-not-what-expected

Question Body:


I've been trying to integrate Chainlink into my contract, managed to get the
random number thingy working, but the API call doesn't work for me. Here's
what I got:

    
    
    contract ValorantCards is Ownable, ERC1155, VRFConsumerBase, ChainlinkClient {
    using Chainlink for Chainlink.Request;
    
    address private linkToken;
    
    // Chainlink VRF
    bytes32 private keyHash;
    uint256 private vrfFee;
    
    uint256 public randomResult;
    
    // Chainlink API calls
    address private oracle;
    bytes32 private jobId;
    uint256 private oracleFee;
    
    uint256 public playerLevel;
    
    constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        address _oracle,
        bytes32 _jobId,
        uint256 _oracleFee
    ) ERC1155("""") VRFConsumerBase(_vrfCoordinator, _linkToken) {
        setPublicChainlinkToken();
    
        linkToken = _linkToken;
        keyHash = _keyHash;
        vrfFee = 0.1 *

:::NEXT DOC:::

use [Chainlink Any-
API](https://docs.chain.link/docs/make-a-http-get-request/) calls to bring it
into your smart contract

To do so, you need to know 3 things

  1. The API endpoint that contains the data, and the inputs required
  2. The outputs that the API returns, including their types (integer, string etc), as well as the path in the resulting JSON that contains the data you want
  3. A Chainlink oracle on the network you're contract is on that has a compatible job that you can use (whether one you run yourself or someone elses)

Once you have these things, you can use the example consumer contract in the
docs linked above, and then change the values to suit. ie here is an example
contract that will make an API call to PancakeSwap to get the price of
PancakeSwap token on BSC testnet:

1 - API address and inputs. In this case, according to your linked docs, the
URL of the API call is
`https://api.pancakeswap.info/api/v2/tokens/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82`.
The only input required is the token address in the URL

2 - We want the price, which is an integer and in the 'price' JSON element. We
will multiply the price by 10**8 when we bring it on-chain because Solidity
can't handle decimals

3 - Because this is a simple API call, we can use a community run CL node that
takes a HTTP GET request, parses the JSON to find an element we specify, then
multiplies the result and converts it to the type we want before returning it
on-chain. Taking a look at the [BSC testnet jobs

:::NEXT DOC:::

Question: (Asked on: 2022-12-25 16:55:37)
Integrating Celo with Chainlink
URL: https://stackoverflow.com/questions/74914660/integrating-celo-with-chainlink

Question Body:


I have participated in a hackathon. So, we decided to use Celo + Chainlink.
But in Chianlink I saw there they don't have any smart contract in CELO
network.

Expect: A chainlink smart contract link like one of these:
<https://docs.chain.link/resources/link-token-contracts>.



Answers:
(Answered on: 2022-12-27 20:27:56)


Currently, there isn't a popular Chainlink network on the Celo network. You
could run your own node there if you'd like and [start a network
yourself](https://docs.chain.link/chainlink-nodes/).





:::NEXT DOC:::

Question: (Asked on: 2021-09-21 16:17:59)
Chainlink v0.8 Smart Contract Deployment Issue
URL: https://stackoverflow.com/questions/69272249/chainlink-v0-8-smart-contract-deployment-issue

Question Body:


I am having issues verifying my smart contract on Rinkeby Testnet using
@chainlink. My contract is deploying to Rinkeby fine but runs into issues when
I have publish_source on. The contract verifies fine when using v0.6 and
Solidity 0.6.6, I seem to only have issues with v0.8. Anyone know why this
might be happening?

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";
    
    /**
     * @title MyContract is an example contract which requests data from
     * the Chainlink network
     * @dev This contract is designed to work on multiple networks, including
     * local test networks
     */
    contract MyContract is ChainlinkClient, ERC721 {
        using Chainlink for Chainlink.Request;
    
        address constant RINKEBY_ORACLE =
            0x3A56aE4a2831C3d3514b5D7Af5578E45eBDb7a40;
        bytes32 constant RINKEBY_JOB_ID =
           

:::NEXT DOC:::

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.


:::NEXT DOC:::

# Chainlink Introduction

<GradientTextWrapp>
  Chainlink, smart contracts, blockchains, and the entire world of cryptocurrency have been a hot topic of discussion for several years now.
</GradientTextWrapp>

Whether it’s companies like EY and Microsoft looking to use smart contracts to improve their business processes, artists and athletes like LaMelo Ball creating their own “NFTs,” or up and coming companies looking to disrupt long-standing establishments such as the insurance industry, Chainlink and smart contracts are working to become the backbone for world-changing applications.

 


:::NEXT DOC:::

aggregated by a smart contract, which forms the feed's latest
and trusted answer.

Each oracle operator is rewarded for publishing data. On mainnet, [sponsors
are paying the LINK
associated](https://ethereum.stackexchange.com/questions/90728/what-is-the-
cost-of-using-a-chainlink-oracle/90752#90752) to keep those feeds live,
decentralized, and secure, so they are not free. This allows the network to be
a shared resource where everyone chips in a tiny bit and makes them even
cheaper than running even your own centralized feed.

That being said, the price feeds are currently a simple `view` function, and
anyone can technically use them as access controls are on the roadmap to be
built at some point. It’s not really economical or fair for those backers who
are paying to support them for everyone else. Until access controls are built,
please reach out if you are using them on mainnet and learn how you can
contribute to keep them reliable honest, and secure.

**With API calls** , Chainlink enables your contracts to access any external
data source, through their decentralized oracle network. Making a HTTP GET
request will fail unless your deployed contract has enough LINK to pay for it,
therefore one needs to fund that smart contract.

If your contract is calling a public API endpoint, an Oracle job may already
exist for it. To check available jobs and GET request prices, visit
<https://market.link/>





:::NEXT DOC:::

    * @title MyContract is an example contract which requests data from
     * the Chainlink network
     * @dev This contract is designed to work on multiple networks, including
     * local test networks
     */
    contract MyContract is ChainlinkClient, ERC721 {
        using Chainlink for Chainlink.Request;
    
        address constant RINKEBY_ORACLE =
            0x3A56aE4a2831C3d3514b5D7Af5578E45eBDb7a40;
        bytes32 constant RINKEBY_JOB_ID =
            bytes32(""187bb80e5ee74a139734cac7475f3c6e"");
    
        uint256 constant FEE = 0.1 * 10**18;
    
        uint256 public tokenCounter;
    
        bytes32 public data;
        string public image_url;
    
        struct Clip {
            string name;
            string url;
        }
    
        Clip[] public clips;
    
        mapping(bytes32 => string) public requestIdToClipName;
        mapping(bytes32 => address) public requestIdToSender;
        mapping(bytes32 => string) public requestIdToTokenURI;
        event requestedCollectible(bytes32 indexed requestId);
    
    

:::NEXT DOC:::

Question: (Asked on: 2022-12-12 21:30:02)
Why is our Chainlink node not catching any OracleRequest events from our Arbitrum Operator? Requests are never fulfilled / v2 jobs never executed
URL: https://stackoverflow.com/questions/74777534/why-is-our-chainlink-node-not-catching-any-oraclerequest-events-from-our-arbitru

Question Body:


We're trying to get our Chainlink AnyAPI stack to work with an Arbitrum
Chainlink node. The same stack is being used on Ethereum, Polygon and
Avalanche without issue.

Chainlink AnyAPI empowers some of the use cases of DSLA Protocol, a middleware
for adding consumer protection capabilities to any monitorable marketplace
(e.g. OpenSea) using peer-to-peer service level agreements (SLA).

## Request Lifecycle

Here are the different steps involved in verifying that a SLA contract has
been respected, using Chainlink:

  1. A user calls the verification function on the Messenger smart contract that implements Chainlink.

  2. The `Messenger` smart contract sends the request the `PreCoordinator` smart contract .

  3. The `PreCoordinator` forwards the request to the Oracles defined in a Service Agreement (proxy of Oracles).

  4. Upon receiving LINK, each Oracle sends the request to the Chainlink node, by emitting an `OracleRequest` event with the id of the job to be executed.

  5. The Chainlink node captures such event, and executes the corresponding job.

  6. Once the job is executed, the Chainlink node calls the `fulfillOracleRequest2` function to return the result from the external adapter to the PreCoordinator.

  7. The PreCoordinator takes the mean of all Oracle results and ultimately registers the SLI in the messenger.

 

:::NEXT DOC:::

Question: (Asked on: 2022-09-15 16:22:42)
Create an oracle on a new chain
URL: https://stackoverflow.com/questions/73734527/create-an-oracle-on-a-new-chain

Question Body:


If I deploy a contract like this one on a new chain:

<https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code>

Then I will still need some way to feed it data. How would I do this?



Answers:
(Answered on: 2022-09-16 05:24:19)


What you deployed is a Chainlink Aggregator contract, you do not need to
deploy Aggregator contract to get the token price data.

If you want to get some token price data in your contract, you should use
AggregatorInterface in your contract and then fetch price data from the
Aggregator contract deployed by Chainlink team. Instructions can be found
[here](https://docs.chain.link/docs/get-the-latest-price/).



"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidityIntroduction/Chapters/Chapter-10/hints.md'},"The topic of Chapter 1 is ""What will this course cover?"" in the Chainlink Introduction course.","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What are the three methods used to provide off-chain reserves data?,"The three methods used to provide off-chain reserves data are third-party attestation, custodian, and self-attestation.",{'source': 'https://docs.chain.link/data-feeds/proof-of-reserve/'},"The three methods used to provide off-chain reserves data are third-party attestation, custodian data, and self-attestation.","assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no additional valuation and is simply reported on-chain.
  * ⚠️ Self-attested: Reserve data is read from an API that the token issuer hosts. Self-attested feeds carry additional risk.

### Cross-chain reserves

Cross-chain reserves are sourced from the network where the reserves are held.
Chainlink node operators can report cross-chain reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read

:::NEXT DOC:::

# Proof of Reserve Feeds

  * Overview
  * Types of Proof of Reserve Feeds
  * Off-chain reserves
  * Cross-chain reserves
  * Using Proof of Reserve Feeds

Chainlink Proof of Reserve Feeds provide the status of the reserves for
several assets. You can read these feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

To find a list of available Proof of Reserve Feeds, see the [Proof of Reserve
Feed Addresses](/data-feeds/proof-of-reserve/addresses) page.

## Types of Proof of Reserve Feeds

Reserves are available for both cross-chain assets and off-chain assets. This
categorization describes the data attestation variations of Proof of Reserve
feeds and helps highlight some of the inherent market risks surrounding the
data quality of these feeds.

Reserves are available for both off-chain assets and cross-chain assets. Token
issuers prove the reserves for their assets through several different methods.

### Off-chain reserves

Off-Chain reserves are sourced from APIs through an [external
adapter](/chainlink-nodes/external-adapters/external-adapters).

Off-chain reserves provide their data using the following methods:

  * Third-party: An auditor, accounting firm, or other third party attests to reserves. This is done by combining both fiat and investment assets into a numeric value that is reported against the token.
  * Custodian: Reserves data are pulled directly from the bank or custodian. The custodian has direct access to the bank or vault holding the assets. Generally, this works when the underlying asset pulled requires no

:::NEXT DOC:::

name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                

:::NEXT DOC:::

reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
      

:::NEXT DOC:::

name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                  

:::NEXT DOC:::

                                         |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions.

:::NEXT DOC:::

1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

       ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use

:::NEXT DOC:::

the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify"
What are the two steps involved in billing for Chainlink Functions requests?,The two steps involved in billing for Chainlink Functions requests are the Request step and the Receive step.,{'source': 'https://docs.chain.link/chainlink-functions/resources/billing/'},"The two steps involved in billing for Chainlink Functions requests are: 
1. During the Request step, the cost to fulfill a Chainlink Functions request is estimated and blocked on the Subscription balance by adding it to the Subscription reservation.
2. During the Receive step, the exact cost of the fulfillment is calculated and billed to the Subscription account.","# Chainlink Functions Billing

  * Overview
  * Concepts
  * Cost Simulation (Reservation)
  * Cost Calculation (Fulfillment)
  * Fees

## Concepts

For _Chainlink Functions_ to fulfill your requests, you must maintain a
sufficient amount of LINK in your _subscription balance_. Because _Chainlink
Functions_ follows the [Request and Receive Data](/chainlink-functions/resources/concepts) model, billing is also done in two steps:

  1. During the _Request_ step. the cost to fulfill a Chainlink Functions request is **estimated** and blocked on the _Subscription balance_ by adding it to the _Subscription reservation_.
  2. During the _Receive_ step, the exact cost of the fulfillment is **calculated** and billed to the _Subscription account_.

You can break down total costs into the following components:

  * Gas cost: This cost is paid back to the _Transmitter oracle_ for fulfilling the request.
  * Fees: 
    * DON fees: These fees are paid to the _DON_ in LINK to compensate the nodes for their work.
    * Registry fees: These fees are paid in LINK for the maintenance of the _Subscriptions Contract_.

Gas cost calculation includes the following variables:

  * Gas price: The current gas price fluctuates depending on network conditions.
  * Callback gas: The amount of gas used for the callback request. See the Cost Calculation section.
  * Estimated gas overhead: The amount of gas used by the _Subscriptions contract_ and _Functions Oracle contract_. It is an estimate of the total gas cost of fulfilling a request. See the Cost Simulation section.
  * Gas Report: The exact amount of gas used by the _Functions Oracle contract_ when fulfilling a request. See the Cost Calculation section.
  * Gas after payment: The amount of gas used to cover additional operations such as decrementing the

:::NEXT DOC:::

contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription

:::NEXT DOC:::

  
    ⣾ Request 0xa89547c0270c1a5135ec7a47b9110db495facd811493832f54cc4c0b729b7786 has been initiated. Waiting for fulfillment from the Decentralized Oracle Network...
    
    ℹ Transaction confirmed, see https://mumbai.polygonscan.com/tx/0xa35ac46ec20a258cd9ffcc4a4396b998e3a60343a936009fb5fc76550c780d7f for more details.
    
    Actual amount billed to subscription #443:
    ┌──────────────────────┬────────────────────────────┐
    │         Type         │           Amount           │
    ├──────────────────────┼────────────────────────────┤
    │  Transmission cost:  │  0.00006493686812304 LINK  │
    │      Base fee:       │          0.2 LINK          │
    │                      │                            │
    │     Total cost:      │  0.20006493686812304 LINK  │
    └──────────────────────┴────────────────────────────┘
    
    
    ✔ Request

:::NEXT DOC:::

contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates with the _Functions Billing Registry_ , which
assigns a unique identifier (aka _Subscription ID_ ).

### Fund Subscription

You must fund your subscription accounts with enough LINK tokens:

  1. Connect your EOA to the _Subscription App_.
  2. Fund your subscription account. The _Subscriptions App_ abstracts the following: 


:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's

:::NEXT DOC:::

Fees

note

| Item          | Ethereum Sepolia testnet   | Polygon Mumbai testnet   | Avalanche Fuji testnet   |
|:--------------|:---------------------------|:-------------------------|:-------------------------|
| Registry fees | 0.2 LINK                   | 0.2 LINK                 | 0.2 LINK                 |
| DON fees      | 0 LINK                     | 0 LINK                   | 0 LINK                   |
## What's next

  * [› What's next?](/chainlink-functions/resources/service-limits)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/billing.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties

:::NEXT DOC:::

as sending an email or storing data on
the cloud, is currently not recommended. An HTTP method is idempotent if the
intended effect on the server when you make a single request is the same as
the effect when you make several identical requests. Each oracle node runs the
same computation in the [Off-chain Reporting protocol](/architecture-overview/off-chain-reporting). If your Chainlink Function makes non-idempotent
requests, it will cause redundant requests such as sending multiple emails or
storing the same data multiple times.

## Before you begin

Request Access

Chainlink Functions is currently in a limited BETA. Apply
[here](http://functions.chain.link/) to add your EVM account address to the
Allow List.

  1. **[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set up your environment with the necessary tools for these tutorials. You can re-use the same consumer contract for each of these tutorials.

  2. Make sure your subscription has enough LINK to pay for your requests. Read [Get Subscription details](/chainlink-functions/resources/subscriptions#get-subscription-details) to learn how to check your subscription balance. If your subscription runs out of LINK, follow the [Fund a Subscription](/chainlink-functions/resources/subscriptions#fund-a-subscription) guide.

  3. Check out the _tutorials_ branch of the [Chainlink Functions Starter Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit). You can locate this tutorial in [the _/tutorials/4-post-data_ directory](https://github.com/smartcontractkit/functions-hardhat-starter-kit/tree/tutorials/tutorials/4-post-data).
    
        git checkout tutorials

## Tutorial

This tutorial

:::NEXT DOC:::

service you want to use is [Chainlink Any
Api](https://docs.chain.link/any-api/introduction), and in the service the
cost of LINK depends on the node operator you are using.

There is a fee required by node operator. When you send a request, you
actually require Chainlink node to provide a service. Usually the service is
not free and the fee of a request is set by the node operator. The fee varies
across different node operators. If you are only a consumer to use service
provided by node operators, you just need to check the fee of [different node
operators](https://market.link/overview?searchView=true).

you, of course, also has to pay gas fee for your transaction, but that it it
costed in ETH rather than LINK (as you asking how much LINK it will cost, I
assume you know it).

If you are a node operator and want to run the service for yourself, you may
want to consider the following 2 factors:

  1. Congestion of the system mentioned by @Yilmaz. When the blockchain you are using is very busy, the gas price is high so that the more gas fee, which is the result of `(gas price) x(gas limit)`, will be cost more.

  2. The logic of fulfill function in your contract. Fulfillment function is the ""callback"" function of Chainlink Any Api. Oracle node will fetch the data demand in the request and then call the fulfill function in consumer contract. In fulfill function, logics varies from simply saving the data in a variable or doing some calculations. The more complex logics, the more gas limit required.

Hope it helps!


---
(Answered on: 2023-01-31 02:43:32)


> The problem is I can't approximate how much LINK it will cost me to get
> response from 1 oracle.

Nobody can. When you make a request to oracle, you are calling a smart
contract function and this

:::NEXT DOC:::

the more gas fee, which is the result of `(gas price) x(gas limit)`, will be cost more.

  2. The logic of fulfill function in your contract. Fulfillment function is the ""callback"" function of Chainlink Any Api. Oracle node will fetch the data demand in the request and then call the fulfill function in consumer contract. In fulfill function, logics varies from simply saving the data in a variable or doing some calculations. The more complex logics, the more gas limit required.

Hope it helps!


---
(Answered on: 2023-01-31 02:43:32)


> The problem is I can't approximate how much LINK it will cost me to get
> response from 1 oracle.

Nobody can. When you make a request to oracle, you are calling a smart
contract function and this will cost you gas which varies depending on the
congestion in the system. if system is busy, it will cost more gas. Also when
you interact with the chainlink, you are actually passing data to chainlink
smart contract which makes some calculations, so you pay for those gas too.

Calling one oracle is sending a request to one oracle. oracle is a chainlink
node operator, and it set its own price. But sending a request to only one
node is not a decentralized approach even though each node have multiple data
resources. you should make a request to several nodes meaning that you need to
pay each node operator. when you make a request to several nodes, you receive
the average of those responses.



"
What are the trade-offs that bridge designs must compromise between?,"Bridge designs must compromise between trust-minimization, generalizability, extensibility, latency, and costs.",{'source': 'https://docs.chain.link/resources/bridge-risks/'},"Bridge designs must compromise between trust-minimization, generalizability, extensibility, latency, and costs.","developers from different blockchain ecosystems to build new platforms and products for users

As an analogy, you can use [the blockchains as cities mental
model](https://medium.com/dragonfly-research/blockchains-are-cities-564327013f86):

  * Layer-1 blockchains are like cities.
  * Layer-2 solutions are equivalent to skyscrapers. As described in the mental model, “Each rollup is like a vertical blockchain that extends from the ground L1”.
  * Bridges are like roads and streets that connect different cities and skyscrapers.

## Trade-offs

With the growing number of layer-1 and layer-2 chains, the number of bridges
has also grown, [surpassing one hundred](https://debridges.com/). So, how do
you choose the correct bridge?

When choosing a bridge, there is no perfect solution, only trade-offs. As
explained in the [interoperability trilemma](https://blog.connext.network/the-interoperability-trilemma-657c2cf69f17) and [Ethereum foundation
docs](https://ethereum.org/en/developers/docs/bridges/#trade-offs), bridge
designs must compromise between the following characteristics:

  * **Trust-minimization:** The system does not introduce new trust or security assumptions beyond those of the underlying blockchains. Read trust-minimization for more details.
  * **Generalizability:** The system enables the transfer of complex arbitrary data. Data could be messages or assets/funds.
  * **Extensibility:** How hard is it to integrate a new blockchain?
  * **Latency:** How long does it take to complete a transaction?
  * **Costs:** How much does it cost to transfer data across chains via a bridge?

## Risks

When choosing a bridge, be aware of the following risks.

### Smart contract risks

Bugs and vulnerabilities can

:::NEXT DOC:::

bridge
designs must compromise between the following characteristics:

  * **Trust-minimization:** The system does not introduce new trust or security assumptions beyond those of the underlying blockchains. Read trust-minimization for more details.
  * **Generalizability:** The system enables the transfer of complex arbitrary data. Data could be messages or assets/funds.
  * **Extensibility:** How hard is it to integrate a new blockchain?
  * **Latency:** How long does it take to complete a transaction?
  * **Costs:** How much does it cost to transfer data across chains via a bridge?

## Risks

When choosing a bridge, be aware of the following risks.

### Smart contract risks

Bugs and vulnerabilities can expose users' assets to different kinds of
exploits. Read this [detailed analysis](https://certik.medium.com/qubit-bridge-collapse-exploited-to-the-tune-of-80-million-a7ab9068e1a0) for an
example of a bridge exploit where the attacker could leverage a logical error
in the bridge’s smart contract.

### Systemic financial risks

To transfer tokens cross-chain, many bridges lock tokens on the source chain
and mint derivative or wrapped tokens on the destination chain representing
the locked tokens. A hack of the locked tokens or an infinite mint attack on
the wrapped tokens can make all wrapped tokens worthless and expose entire
blockchains to risk.

### Early stage

Given that bridges are relatively new, there are many unanswered questions
related to how bridges will perform in different market conditions.

### Trust-minimization (Counterparty risk)

To overcome cross-chain interoperability challenges, some bridges use off-
chain actors or validators. These actors introduce new trust assumptions in
addition to the underlying blockchain trust assumptions. These

:::NEXT DOC:::

and trust assumptions in their designs. After you read
these sections, you will have a better understanding of bridge risks and which
aspects you should evaluate when using a bridge.

## What is a Cross-chain bridge

With the [proliferation](https://defillama.com/chains) of layer-1 blockchains
and layer-2 scaling solutions, the web3 ecosystem has become multi-chain. Each
blockchain comes with its own approach to scalability, security, and trust.

However, blockchains are not natively capable of communicating with each
other, which makes [blockchain interoperability
protocols](https://blog.chain.link/blockchain-interoperability/) critical for
allowing dApps to interact with any on-chain environment and tap into each
blockchain's unique assets and features.

A [bridge](https://blog.chain.link/cross-chain-bridge/) is a core element of
cross-chain interoperability. Bridges exist to connect blockchain networks and
enable connectivity between them.

Bridges enable the following:

  * Cross-chain transfer of assets and information
  * dApps can leverage the strengths and benefits of different chains
  * Collaboration between developers from different blockchain ecosystems to build new platforms and products for users

As an analogy, you can use [the blockchains as cities mental
model](https://medium.com/dragonfly-research/blockchains-are-cities-564327013f86):

  * Layer-1 blockchains are like cities.
  * Layer-2 solutions are equivalent to skyscrapers. As described in the mental model, “Each rollup is like a vertical blockchain that extends from the ground L1”.
  * Bridges are like roads and streets that connect different cities and skyscrapers.

## Trade-offs

With the growing number of layer-1 and layer-2 chains, the number of bridges
has also grown, [surpassing one hundred](https://debridges.com/). So, how

:::NEXT DOC:::

# Cross-chain bridges and associated risks

  * Overview
  * What is a Cross-chain bridge
  * Trade-offs
  * Risks
  * Smart contract risks
  * Systemic financial risks
  * Early stage
  * Trust-minimization (Counterparty risk)

When working with Chainlink on layer-2 chains and sidechains, you must export
your LINK tokens from Ethereum to the target chain using a cross-chain bridge.
Follow this [video](https://www.youtube.com/watch?v=WKvIGkBWRUA) for an
example of moving LINK tokens from Ethereum to Polygon.

Cross-chain bridges come with their own risks. In fact, bridge attacks
constitute some of the [largest cryptocurrency
hacks](https://rekt.news/leaderboard/) by value. When moving your LINK tokens
or any asset across chains, understand the risks that you are taking with your
assets. Chainlink Labs does not endorse any bridge. Ultimately, you are
responsible for assessing the bridge that you use to move your assets.

Read the What is a cross-chain bridge, Trade-offs, and Risks sections to learn
more about bridges and trust assumptions in their designs. After you read
these sections, you will have a better understanding of bridge risks and which
aspects you should evaluate when using a bridge.

## What is a Cross-chain bridge

With the [proliferation](https://defillama.com/chains) of layer-1 blockchains
and layer-2 scaling solutions, the web3 ecosystem has become multi-chain. Each
blockchain comes with its own approach to scalability, security, and trust.

However, blockchains are not natively capable of communicating with each
other, which makes [blockchain interoperability
protocols](https://blog.chain.link/blockchain-interoperability/) critical for
allowing dApps to interact with any on-chain environment and tap into each
blockchain's unique assets and features.

A

:::NEXT DOC:::

computation that is
capable of supporting more complex cross-chain applications.

Cryptography risk

Some externally verified bridges are secured by multisig wallets.
[Ronin](https://whitepaper.axieinfinity.com/technology/ronin-ethereum-sidechain) is one example. Multisig wallets are also referred to as m-of-n
multisigs, with M being the required number of signatures or keys and N being
the total number of signatures or keys (m≤n). This means that an attacker only
needs to exploit M keys to be able to hack the whole system. In this case,
users must trust that the third party is decentralized enough, signers are
independent of each other, and that each signer has proper key management in
place. Read this [detailed analysis](https://rekt.news/ronin-rekt/) for an
example of a bridge exploit where the attacker could compromise M keys.

Optimistic bridges

Optimistic bridges rely on honest watchers to monitor the bridges' operations
and report any fraud. Because the watchers of an optimistic system are
permissionless, there is no way to know if there is not at least one single
watcher monitoring the system. Therefore, the cost of a successful attack is
limitless as it requires an attacker to know who the watchers are and hack all
of them.

Here are some examples of externally verified bridges that use different
techniques to increase trust-minimization :

  * [Binance bridge](https://www.binance.com/en/blog/ecosystem/introducing-binance-bridge-20-421499824684903626) is a trusted bridge using the security standards of Binance.
  * [Polygon POS bridge](https://wiki.polygon.technology/docs/develop/ethereum-polygon/pos/getting-started/) uses a proof of stake (PoS) consensus algorithm for network security.
  *

:::NEXT DOC:::

financial risks

To transfer tokens cross-chain, many bridges lock tokens on the source chain
and mint derivative or wrapped tokens on the destination chain representing
the locked tokens. A hack of the locked tokens or an infinite mint attack on
the wrapped tokens can make all wrapped tokens worthless and expose entire
blockchains to risk.

### Early stage

Given that bridges are relatively new, there are many unanswered questions
related to how bridges will perform in different market conditions.

### Trust-minimization (Counterparty risk)

To overcome cross-chain interoperability challenges, some bridges use off-
chain actors or validators. These actors introduce new trust assumptions in
addition to the underlying blockchain trust assumptions. These bridges act as
a custodian and are, therefore, trust-based. In contrast, some bridge designs
rely on underlying blockchains' validators and, therefore, do not add any
trust assumptions. To summarize:

  * Trusted (custodial) bridges require a third party to validate movements over the bridge. Users are required to give up control of their crypto assets, so trust is involved as they rely on the bridge operator's reputation.
  * Trustless (non-custodial) bridges leverage smart contracts to store and release funds on either side of the bridge. These bridges are trust-minimized because they don't make new trust assumptions beyond the underlying blockchains.

Trustlessness in bridges does not exist in an absolute form (trusted vs.
trustless). As explained in the blockchain-interoperability
[blog](https://blog.chain.link/blockchain-interoperability/), there are four
general interoperability solutions for validating the state of a source
blockchain and relaying the subsequent transaction to the destination
blockchain:

#### Web2 Verification

Web2 verification is when someone uses a web2 service to execute a

:::NEXT DOC:::

give up control of their crypto assets, so trust is involved as they rely on the bridge operator's reputation.
  * Trustless (non-custodial) bridges leverage smart contracts to store and release funds on either side of the bridge. These bridges are trust-minimized because they don't make new trust assumptions beyond the underlying blockchains.

Trustlessness in bridges does not exist in an absolute form (trusted vs.
trustless). As explained in the blockchain-interoperability
[blog](https://blog.chain.link/blockchain-interoperability/), there are four
general interoperability solutions for validating the state of a source
blockchain and relaying the subsequent transaction to the destination
blockchain:

#### Web2 Verification

Web2 verification is when someone uses a web2 service to execute a cross-chain
transaction. The most common example in practice is when users leverage
centralized exchanges to swap or bridge their own tokens. The user simply
deposits their assets into an address on the source chain that's under the
control of the exchange and then withdraws the same tokens or different tokens
(via a swap on the exchange) to an address on a destination chain controlled
by the user.

Web2 verification can be fairly convenient for personal transactions and
requires less technical expertise. However, it is limited only to swapping and
bridging tokens which requires trust in a centralized custodian.

#### External verification

External verification is where a group of validator nodes are responsible for
verifying transactions. These validators do not belong to either of the two
blockchains’ validator sets and they also have their trust assumptions
irrespective of the underlying blockchains.

External verification typically requires an honest majority assumption, where
a majority of the external validator nodes must behave honestly for the
integrity of the cross-chain interaction to be upheld. However, additional
techniques can be used to increase trust-minimization, such as:



:::NEXT DOC:::

there is no way to know if there is not at least one single
watcher monitoring the system. Therefore, the cost of a successful attack is
limitless as it requires an attacker to know who the watchers are and hack all
of them.

Here are some examples of externally verified bridges that use different
techniques to increase trust-minimization :

  * [Binance bridge](https://www.binance.com/en/blog/ecosystem/introducing-binance-bridge-20-421499824684903626) is a trusted bridge using the security standards of Binance.
  * [Polygon POS bridge](https://wiki.polygon.technology/docs/develop/ethereum-polygon/pos/getting-started/) uses a proof of stake (PoS) consensus algorithm for network security.
  * [Nomad](https://docs.nomad.xyz/nomad-101/introduction) is an optimistic bridge. It uses [optimistic verification](https://docs.nomad.xyz/the-nomad-protocol/verification-mechanisms/optimistic-verification) where messages are optimistically signed on the origin chain and a timeout period is enforced on the destination. During this period, a set of actors called watchers can inspect the messages and flag any detected fraud.

#### Local verification

Local verification is when the counterparties in a cross-chain interaction
verify the state of one another. If both deem the other valid, the cross-chain
transaction is executed, resulting in peer-to-peer cross-chain transactions.
Cross-chain swaps using local verification are often referred to as atomic
swaps.

This model has a high level of trust-minimization given reasonable blockchain
assumptions, as the swap either happens or both transactions fail.
Furthermore, the model works so long as both parties are economically
adversarial: they cannot collude to steal funds during atomic swaps.

Note that local verification is not very generalizable to a variety of

:::NEXT DOC:::

a certain period of time. Thus, local verification
is mostly used in cross-chain liquidity protocols involving liquidity pools
that exist independently on each chain.

[Hop](https://docs.hop.exchange/faq#what-is-hop-protocol) or [Connext
legacy](https://docs.connext.network/0.1.x-legacy/developers/intro) are
examples of locally verified bridges.

#### Native verification

In this design, the validators of the destination blockchains are responsible
for verifying the state of the source blockchain to confirm a given
transaction. This is typically done by running a light client of the source
chain in the virtual machine of the destination chain or running them both
side-by-side. Native verification is the most trust-minimized form of cross-
chain communication, but it is more expensive, offers less development
flexibility, and is more suited to blockchains with similar state machines,
such as between Ethereum and EVM-based layer-2 networks or only among Cosmos
SDK-based blockchains.

The [NEAR Rainbow Bridge](https://near.org/blog/eth-near-rainbow-bridge/) is
an example of a natively verified bridge. A smart contract with Ethereum light
client functionality is deployed on the NEAR blockchain and a smart contract
with NEAR protocol light client functionality is deployed on Ethereum. These
light clients hold the latest block headers and verify that cross-chain
transactions are done across both chains. The trust model relies only on
Ethereum and Near validators.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/bridge-risks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

basis considering the liquidity,
depth, and trading volatility of the underlying asset compared to its
derivative. In addition, users must consider the security mechanism that is
designed to keep the wrapped or bridged asset coupled to its underlying asset.
Review these parameters regularly as asset dynamics continuously evolve.

### Extreme Events Causing Price Deviations in Wrapped or Bridged Assets

Chainlink Price Feeds are designed to provide the market-wide price of various
assets, as determined by a volume-weighted average across a wide range of
exchanges. On blockchain networks where assets are wrapped and/or bridged from
another environment using a cross-chain token bridge, Chainlink Price Feeds
built for the underlying asset will continue to report the market-wide price
of the underlying asset as opposed to the price of the wrapped/bridged asset.
This methodology reduces risks around market manipulation because
wrapped/bridged tokens are often less liquid than the underlying asset.

However, users should be aware that certain extreme events may result in price
deviations between the wrapped/bridged asset and its underlying counterpart.
For example, the exploitation or hack of a cross-chain token bridge may cause
a collapse in demand for a particular wrapped asset. As such, users should
construct their applications with safeguards, such as circuit breakers to
proactively pause functionality to mitigate risk during such scenarios.
Circuit breakers can be created using Chainlink Automation to monitor data
feeds for unexpected scenarios.

An additional mechanism for securing a protocol utilizing wrapped assets is by
incorporating [Chainlink Proof of Reserve](https://chain.link/proof-of-reserve). Chainlink Proof of Reserve enables the real-time reserve monitoring
of off-chain and cross-chain assets, including those that have been
wrapped/bridged. By comparing the wrapped token’s supply against a"
What are some ways to automatically purchase LINK tokens for a smart contract?,"Some ways to automatically purchase LINK tokens for a smart contract include: programatically swapping on a DEX like Uniswap, pre-funding the contract with LINK, doing it external to the blockchain, making use of meta-transactions, or paying an upfront cost to ensure the coordinator contracts are well funded with LINK.",{'source': 'https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically'},"Some ways to automatically purchase LINK tokens for a smart contract include: 
1) programatically swapping on a DEX like Uniswap, 
2) pre-funding the contract with LINK beforehand, 
3) having an external process running to fund the contract with LINK periodically, 
4) using meta-transactions with an external relayer, and 
5) paying an upfront cost to ensure the contract is well-funded with LINK and manually topping it up as needed using users' deposited funds.","of my contract to purchase LINK themselves.

Thanks!



Answers:
(Answered on: 2021-05-09 12:37:13)


A contract itself can't 'automatically have LINK transferred to it', because
to transfer LINK from one account to another, the owner of the LINK must be
the one that signs the transaction, however, there are a few other ways to
achieve the end result you're looking for.

1 - Rather than a straight transfer, you can do a swap on a DEX like Uniswap
programatically, ie <https://docs.uniswap.org/protocol/V2/guides/smart-
contract-integration/trading-from-a-smart-contract>

2 - If you know how much LINK will be required for the contract, you can
simply pre-fund it beforehand, or when it's created. Am guessing this isn't
the case for you though.

3 - Do it external to the blockchain. ie you can have a process running that
funds the contract with link every so often, checking if its empty or near
empty

4 - You can make use of meta-transactions so that the people playing the game
don't need any LINK. See [this example](https://github.com/pappas999/Link-Gas-
Station). Take note this still uses an external relayer like I mentioned in
the last point

5 - I've seen examples where others just pay an upfront cost to ensure the
coordinator contracts are well funded with LINK, and then they manually just
top them up as needed, using users deposited eth/funds as a kind of payment to
offset them having to send LINK to the contract.





:::NEXT DOC:::

Question: (Asked on: 2021-05-09 12:01:16)
How to make a Smart Contract purchase LINK (or other ERC20) tokens automatically?
URL: https://stackoverflow.com/questions/67457457/how-to-make-a-smart-contract-purchase-link-or-other-erc20-tokens-automatically

Question Body:


I am trying to interact with the Chainlink VRF function.

I have a Coordinator contract that needs random numbers to draw cards out of a
deck. The Coordinator calls a Random Number Generation Oracle that implements
Chainlink's VRFConsumerBase contract.

I want my Coordinator/Oracle to purchase LINK tokens automatically using the
Ether that the user sent for the draw price so that it can always provide the
required LINK fee to the VRF function and it does not need a human to manually
top up the contract with LINK.

Is there any working example/tutorial on how one could achieve this? I really
wish to avoid forcing the users of my contract to purchase LINK themselves.

Thanks!



Answers:
(Answered on: 2021-05-09 12:37:13)


A contract itself can't 'automatically have LINK transferred to it', because
to transfer LINK from one account to another, the owner of the LINK must be
the one that signs the transaction, however, there are a few other ways to
achieve the end result you're looking for.

1 - Rather than a straight transfer, you can do a swap on a DEX like Uniswap
programatically, ie <https://docs.uniswap.org/protocol/V2/guides/smart-
contract-integration/trading-from-a-smart-contract>

2 - If you know how much LINK will be required for the contract, you

:::NEXT DOC:::

Consuming contracts directly pay with LINK when they request random values. You must directly fund your consumer contracts and ensure that there are enough LINK tokens to pay for randomness requests.

## Choosing the correct method

Depending on your use case, one method might be more suitable than another.
Consider the following characteristics when you choose a method:

| Subscription method                                                                                                                                                    | Direct funding method                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Suitable for regular requests                                                  

:::NEXT DOC:::

 * Know how to [deploy solidity contracts using Remix and Metamask](/getting-started/deploy-your-first-contract)
  * Learn how to make [compatible contracts](/chainlink-automation/compatible-contracts)
  * [Register UpKeep for a Contract](/chainlink-automation/register-upkeep)

Chainlink Automation is supported on several [networks](/chainlink-automation/supported-networks).

ERC677 Link

  * Get [LINK](/resources/link-token-contracts) on the supported testnet that you want to use.
  * For funding on Mainnet, you need ERC-677 LINK. Many token bridges give you ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be ERC-677 compatible](https://pegswap.chain.link/).

## Problem: On-chain computation leads to high gas fees

In the guide for [Creating Compatible Contracts](/chainlink-automation/compatible-contracts), you deployed a basic [counter
contract](/chainlink-automation/compatible-contracts/#example-contract) and
verified that the counter increments every 30 seconds. However, more complex
use cases can require looping over arrays or performing expensive computation.
This leads to expensive gas fees and can increase the premium that end-users
have to pay to use your dApp. To illustrate this, deploy an example contract
that maintains internal balances.

The contract has the following components:

  * A fixed-size(1000) array `balances` with each element of the array starting with a balance of 1000.
  * The `withdraw()` function decreases the balance of one or more indexes in the `balances` array. Use this to simulate changes to the balance of each element in the array.
  * Automation Nodes are responsible for regularly re-balancing the elements using two functions: 
    * The

:::NEXT DOC:::

deploy the contract that you want to automate. You will also
need the ABI for your contract if it has not been verified. Your contract does
not need to be [compatible](/chainlink-automation/compatible-contracts) with
the `AutomationCompatibleInterface` contract.

  1. Open the Chainlink Automation app.

[Open the Chainlink Automation App](https://automation.chain.link)

  2. [Register](/chainlink-automation/job-scheduler) a new Upkeep in the [Chainlink Automation App](https://automation.chain.link) and select **Time-based** trigger. Provide the address of your deployed contract, provide the ABI if it is not verified, and choose the function that you want to automate along with the relevant function inputs, if any.

  3. Specify the time schedule using [CRON](/chainlink-automation/job-scheduler/#specifying-the-time-schedule).

  4. Complete the remaining details. Your upkeep name will be publicly visible, but your email and project name will not be publicly visible. Your gas limit needs to include an extra [150K](/chainlink-automation/job-scheduler/#entering-upkeep-details) for execution.

  5. Fund your Upkeep with ERC-677 LINK. See the [LINK token contracts](/resources/link-token-contracts) page to determine where to acquire ERC-677 LINK.

  6. After your Upkeep is registered, [manage](/chainlink-automation/manage-upkeeps) it in the Chainlink Automation App.

For more details on time-based automation, click [here](/chainlink-automation/job-scheduler).

### Custom logic trigger

To use a custom logic trigger, you must make your contract
[compatible](/chainlink-automation/compatible-contracts) with the
`AutomationCompatibleInterface` contract.

  1. Open the Chainlink Automation

:::NEXT DOC:::

# Fund Your Contracts

  * Overview
  * Retrieve the contract address
  * Send funds to your contract

Some smart contracts require funding at their addresses so they can operate
without you having to call functions manually and pay for the transactions
through MetaMask. This guide explains how to fund Solidity contracts with LINK
or ETH.

## Retrieve the contract address

  1. In Remix, deploy your contract and wait until you see a new contract in the **Deployed Contracts** section.
  2. On the left side panel, use the **Copy** button located near the contract title to copy the contract address to your clipboard.

## Send funds to your contract

  1. Open MetaMask.
  2. Select the network that you want to send funds on. For example, select the Sepolia testnet.
  3. Click the **Send** button to initiate a transaction.
  4. Paste your contract address in the address field.
  5. In the **Asset** drop down menu, select the type of asset that you need to send to your contract. For example, you can send LINK. If LINK is not listed, follow the guide to [Acquire testnet LINK](/resources/acquire-link).
  6. In the **Amount** field, enter the amount of LINK that you want to send.
  7. Click **Next** to review the transaction details and the Gas cost.
  8. If the transaction details are correct, click **Confirm** and wait for the transaction to process.

Transaction fee didn't update?

You may need to click **Fastest** , **Fast** , **Slow** , or **Advanced
Options** after entering the **Amount** to update the gas limit for the token
transfer to be successful.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/fund-your-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Making flexible, secure, and low-cost contracts

  * Overview
  * Prerequisites
  * Problem: On-chain computation leads to high gas fees
  * Solution: Perform complex computations with no gas fees
  * Conclusion

In this guide, you will learn how the flexibility of [Chainlink
Automation](https://chain.link/automation) enables important design patterns
that reduce gas fees, enhance the resilience of dApps, and improve end-user
experience. Smart contracts themselves cannot self-trigger their functions at
arbitrary times or under arbitrary conditions. Transactions can only be
initiated by another account.

Start by integrating an example contract to Chainlink Automation that has not
yet been optimized. Then, deploy a comparison contract that shows you how to
properly use the flexibility of Chainlink Automation to perform complex
computations without paying high gas fees.

## Prerequisites

This guide assumes you have a basic understanding of [Chainlink
Automation](https://chain.link/keepers). If you are new to Keepers, complete
the following guides first:

  * Know how to [deploy solidity contracts using Remix and Metamask](/getting-started/deploy-your-first-contract)
  * Learn how to make [compatible contracts](/chainlink-automation/compatible-contracts)
  * [Register UpKeep for a Contract](/chainlink-automation/register-upkeep)

Chainlink Automation is supported on several [networks](/chainlink-automation/supported-networks).

ERC677 Link

  * Get [LINK](/resources/link-token-contracts) on the supported testnet that you want to use.
  * For funding on Mainnet, you need ERC-677 LINK. Many token bridges give you ERC-20 LINK tokens. Use PegSwap to [convert Chainlink tokens (LINK) to be ERC-677

:::NEXT DOC:::

more through our [additional
Automation resources](https://chain.link/automation#masterclass).



## Select a trigger

Chainlink Automation will reliably execute smart contract functions using a
variety of triggers.

  * Time-based trigger: Use a time based trigger to execute your function according to a time schedule. This feature is also called the Job Scheduler and it is a throwback to the Ethereum Alarm Clock. Time-based trigger contracts do not need to be [compatible](/chainlink-automation/compatible-contracts/#example-contract) with the `AutomationCompatibleInterface` contract.
  * Custom logic trigger: Use a custom logic trigger to provide custom solidity logic that Automation Nodes evaluate (off-chain) to determine when to execute your function on-chain. Your contract must meet the requirements to be [compatible](/chainlink-automation/compatible-contracts) with the `AutomationCompatibleInterface` contract. Custom logic examples include checking the balance on a contract, only executing limit orders when their levels are met, any one of our [coded examples](/chainlink-automation/util-overview), and many more.

### Time-based Trigger

Before you begin, deploy the contract that you want to automate. You will also
need the ABI for your contract if it has not been verified. Your contract does
not need to be [compatible](/chainlink-automation/compatible-contracts) with
the `AutomationCompatibleInterface` contract.

  1. Open the Chainlink Automation app.

[Open the Chainlink Automation App](https://automation.chain.link)

  2. [Register](/chainlink-automation/job-scheduler) a new Upkeep in the [Chainlink Automation App](https://automation.chain.link) and select **Time-based** trigger. Provide the address of your deployed contract, provide the ABI if it is not verified, and choose the function that you want to automate along with the relevant function inputs, if any.

 

:::NEXT DOC:::

for execution.

  5. Fund your Upkeep with ERC-677 LINK. See the [LINK token contracts](/resources/link-token-contracts) page to determine where to acquire ERC-677 LINK.

  6. After your Upkeep is registered, [manage](/chainlink-automation/manage-upkeeps) it in the Chainlink Automation App.

For more details on time-based automation, click [here](/chainlink-automation/job-scheduler).

### Custom logic trigger

To use a custom logic trigger, you must make your contract
[compatible](/chainlink-automation/compatible-contracts) with the
`AutomationCompatibleInterface` contract.

  1. Open the Chainlink Automation app.

[Open the Chainlink Automation App](https://automation.chain.link)

  2. [Register](/chainlink-automation/register-upkeep) a new Upkeep in the [Chainlink Automation App](https://automation.chain.link) and select **Custom logic** trigger. Provide the address of your [compatible](/chainlink-automation/compatible-contracts) contract and complete the remaining details. Your upkeep name will be publicly visible, but your email and project name will **not** be publicly visible. Ensure you specify the appropriate gas limit for your function to execute on chain.

  3. Fund your Upkeep with ERC-677 LINK. See the [LINK token contracts](/resources/link-token-contracts) page to determine where to acquire ERC-677 LINK.

  4. After your Upkeep is registered, [manage](/chainlink-automation/manage-upkeeps) it in the Chainlink Automation App.

  5. For more details on custom logic automation, read the [Creating Compatible Contracts](/chainlink-automation/compatible-contracts) guide.

WARNING

Do **NOT** attempt to send LINK to your contract. For Chainlink Automation,
contracts are funded through the

:::NEXT DOC:::

use [Chainlink Any-
API](https://docs.chain.link/docs/make-a-http-get-request/) calls to bring it
into your smart contract

To do so, you need to know 3 things

  1. The API endpoint that contains the data, and the inputs required
  2. The outputs that the API returns, including their types (integer, string etc), as well as the path in the resulting JSON that contains the data you want
  3. A Chainlink oracle on the network you're contract is on that has a compatible job that you can use (whether one you run yourself or someone elses)

Once you have these things, you can use the example consumer contract in the
docs linked above, and then change the values to suit. ie here is an example
contract that will make an API call to PancakeSwap to get the price of
PancakeSwap token on BSC testnet:

1 - API address and inputs. In this case, according to your linked docs, the
URL of the API call is
`https://api.pancakeswap.info/api/v2/tokens/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82`.
The only input required is the token address in the URL

2 - We want the price, which is an integer and in the 'price' JSON element. We
will multiply the price by 10**8 when we bring it on-chain because Solidity
can't handle decimals

3 - Because this is a simple API call, we can use a community run CL node that
takes a HTTP GET request, parses the JSON to find an element we specify, then
multiplies the result and converts it to the type we want before returning it
on-chain. Taking a look at the [BSC testnet jobs"
What is the purpose of the 'validateMultiWordResponseId' modifier in the mock operator contract?,The 'validateMultiWordResponseId' modifier is used to ensure that the first word of the response matches the requestId.,{'source': 'https://stackoverflow.com/questions/74828671/testing-chainlink-api-calls-using-hardhat'},"The 'validateMultiWordResponseId' modifier in the mock operator contract is used to ensure that the requestId passed as an argument to the fulfillOracleRequest2 function matches the requestId retrieved from the first word of the response data. This is necessary because Solidity does not allow comparing strings or different data types directly, so the modifier uses keccak256 hashing to compare the two requestIds.","contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:

    
    
      modifier validateMultiWordResponseId(bytes32 requestId, bytes calldata _data) {
        require(_data.length >= 32, ""Response must be > 32 bytes""); 
        bytes memory firstDataWord = new bytes(32);
        for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript

:::NEXT DOC:::

:)

Whilst developing the contract I am working on, I noticed this and wanted to
gain a better understanding as to why the documentation validates a given
request exists before fulfilling it.



Answers:
(Answered on: 2023-05-07 09:49:35)


When the a randomness request is sent from VRFConsumer contract, a new
requestId is generated:

    
    
            requestId = COORDINATOR.requestRandomWords(
                keyHash,
                s_subscriptionId,
                requestConfirmations,
                callbackGasLimit,
                numWords
            );
    

The contract has a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`.

After the oracle returns the random values to your contract, the mapping
`s_requests` is supposed to be updated, and the `RequestStatus` of a specific
request can be found by a specific `requestId`.

require statement in the fulfillment function is used to check if the
requestId is indeed sent from the vrfConsumer contract.





:::NEXT DOC:::

data to `operator.sol`

`operator.sol` is below:

    
    
    // SPDX-License-Identifier: MIT pragma solidity ^0.7.0;
    import ""@chainlink/contracts/src/v0.7/Operator.sol"";
    


---
(Answered on: 2022-05-27 07:09:53)


AFAIK `oracle.sol` does not support ""large responses"" and hence won't support
multi-word responses.

You need to switch to `operator.sol`, use `sendOperatorRequest(req,
ORACLE_PAYMENT);` in your client contract and use `fulfillOracleRequest2` in
your node's jobspec.

You can read more about the whole setup in [this blog
post](https://ijonas.com/fetching-multiple-off-chain-values-from-a-smart-
contract).





:::NEXT DOC:::

   
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract MultiWordConsumer is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        bytes32 private jobId;
        uint256 private fee;
    
        // multiple params returned in a single oracle response
        uint256 public btc;
        uint256 public usd;
        uint256 public eur;
    
        event RequestMultipleFulfilled(
            bytes32 indexed requestId,
            uint256 btc,
            uint256 usd,
            uint256 eur
        );
    
        /**
         * @notice Initialize the link token and target oracle
         * @dev The oracle address must be an Operator contract for multiword response
         *
         *


:::NEXT DOC:::

the `MultiWordConsumer` in the example can call any public API as long as the URLs and paths are correct.
  6. After few seconds, call the `btc`, `usd` , and `eur` functions. You should get a non-zero responses. The job spec for the Chainlink node in this example can be found [here](/chainlink-nodes/job-specs/multi-word-job).

### Response Types

Make sure to choose an oracle job that supports the data type that your
contract needs to consume. Multiple data types are available such as:

  * **`uint256`** \- Unsigned integers
  * **`int256`** \- Signed integers
  * **`bool`** \- True or False values
  * **`string`** \- String
  * **`bytes32`** \- Strings and byte values. If you need to return a string, use `bytes32`. Here's [one method](https://gist.github.com/alexroan/a8caf258218f4065894ecd8926de39e7) of converting `bytes32` to `string`. Currently, any return value must fit within 32 bytes. If the value is bigger than that, make multiple requests.
  * **`bytes`** \- Arbitrary-length raw byte data

## Setting the LINK token address, Oracle, and JobId

The [`setChainlinkToken`](/any-api/api-reference/#setchainlinktoken) function
sets the LINK token address for the [network](/resources/link-token-contracts/) you are deploying to. The [`setChainlinkOracle`](/any-api/api-reference/#setchainlinkoracle) function sets a specific Chainlink oracle that
a contract makes an API call from. The `jobId` refers to a specific job for
that node to run.

Each job is unique and returns different types of data. For example, a job
that returns a `bytes32` variable from an API would have a different `jobId`
than a

:::NEXT DOC:::

Question: (Asked on: 2021-11-25 07:47:35)
Chainlink Multi Variable Responses smart contract request not fulfilled by oracle.sol
URL: https://stackoverflow.com/questions/70107436/chainlink-multi-variable-responses-smart-contract-request-not-fulfilled-by-oracl

Question Body:


I have created an chainlink external adaptor and I have defined a Multi-Word
word request job. Now I have created a Multi Variable responses contract (i.e.
externalAPIConsumer.sol) for the job but when calling the
requestValidationData(), job runs and completes successfully but the
transaction fails because oracle.sol contract gives error as follow:

    
    
    Warning! Error encountered during contract execution [execution reverted] 
    

Here is externalAPIConsumer.sol:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    
    contract ExternalAPIConsumer is ChainlinkClient {
        using Chainlink for Chainlink.Request;
    
        uint256 public allInSystem;
        uint256 public isProject;
        uint256 public senderAuthority;
        uint256 public receiverAuthority;
    
        address private oracle;
        bytes32 private jobId;
        uint256 private fee;
    
        event requestFulfilled(
            uint256 isProject,
   

:::NEXT DOC:::

that
a contract makes an API call from. The `jobId` refers to a specific job for
that node to run.

Each job is unique and returns different types of data. For example, a job
that returns a `bytes32` variable from an API would have a different `jobId`
than a job that retrieved the same data, but in the form of a `uint256`
variable.

Check the [Find Existing Jobs page](/any-api/find-oracle/) to learn how to
find a job suitable to your use case.

## What's next

  * [› Multi-Variable Responses](/any-api/get-request/examples/multi-variable-responses/)
  * [› Fetch data from an Array](/any-api/get-request/examples/array-response/)
  * [› Large Responses](/any-api/get-request/examples/large-responses/)
  * [› Make an Existing Job Request](/any-api/get-request/examples/existing-job-request/)
  * [› API Reference](/any-api/api-reference/)
  * [› Testnet Oracles](/any-api/testnet-oracles/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/get-request/examples/single-word-response.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

   uint256 public s_requestId;
    
    function requestRandomWords() external onlyOwner returns (uint256) {
      uint256 requestId = COORDINATOR.requestRandomWords(
        keyHash,
        s_subscriptionId,
        requestConfirmations,
        callbackGasLimit,
        numWords
      );
      s_requestIdToAddress[requestId] = msg.sender;
    
      // Store the latest requestId for this example.
      s_requestId = requestId;
    
      // Return the requestId to the requester.
      return requestId;
    }
    
    function fulfillRandomWords(
        uint256 requestId,
        uint256[] memory randomWords
      ) internal override {
      // You can return the value to the requester,
      // but this example simply stores it.
      s_requestIdToRandomWords[requestId] = randomWords;
    }

You could also map the `requestId` to an index to keep track of the order in
which a request was made.


    mapping(uint256 => uint256) s_requestIdToRequestIndex;
    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;
    uint256 public requestCounter;
    
    function requestRandomWords() external onlyOwner {
      uint256 requestId = COORDINATOR.requestRandomWords(
        keyHash,
        s_subscriptionId,
        requestConfirmations,
       

:::NEXT DOC:::

 1. Deploy your APIConsumer contract to a testnet and make use of an already deployed operator contract. A list can be found on chainlinks website [https://docs.chain.link/any-api/testnet-oracles/]. Then select a jobId for a node job that can provide the API data you need e.g. bytes32, Int, multi words etc. The jobId can be specified in your APIConsumer contract.
  2. Deploy your own operator contract, setup your own node (chainlink has an option for setting up temporary development nodes), and then create a custom job for your API. You will then need to put you node address as an authorised sender in your operator contract to permit data to be returned from your node.
  3. For local testing you will need to write a function in your test script that sends a mock response to your mock operator contract. Make sure you setAuthorisedSenders for the account you use to send the fulfillOracleRequest transaction, to test properly I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:



:::NEXT DOC:::

       for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript snippet for test script 
    //If local network - Set Authorised senders on Mock Oracle to account[1]
        const [owner, mockNode] = await ethers.getSigners();
        const mockNodeAccount = mockNode.address
        await mockOracle.setAuthorizedSenders([mockNodeAccount])
        
        
        const transaction: ContractTransaction = await apiConsumer.requestWithWords(ANY_ARGS_FOR_API)
        const transactionReceipt: ContractReceipt = await transaction.wait(1)
        const requestId = transactionReceipt.events[0].topics[1]
    
        const apiFilter = apiConsumer.filters.ChainlinkRequested()
        const apiEvents = await apiConsumer.queryFilter(apiFilter)
        console.log(apiEvents)
    
      "
What is the benefit of smart contracts over traditional agreements?,"Smart contracts are transparent and open to the public by default, reducing counterparty risk since neither party has control over the execution of an agreement, and can create more efficient, automated processes that save business cost.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-4/course.md'},"Smart contracts provide reliable, guaranteed execution, transparency, tamper-proofness, and trust minimization over traditional agreements.","#####Chapter 4:

# Smart Contracts - The Future

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Check out this video on what smart contracts are and how they are changing the nature of agreements and the Internet. 
    </div>
  </div>
</ContentWrapp>

<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/Un7-hW6GAec"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>

Smart contracts result from the evolution of digital agreements. A smart contract is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract

:::NEXT DOC:::

is a self-executing contract with the terms of the agreement being directly written into computer code. Smart contracts provide the following benefits:

<ListItemsContainer>
  <div class=""wrapp"">
    <p class=""list__label""><b>Reliable, Guaranteed Execution</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
   In traditional agreements, the execution and enforcement of the terms detailed within the contract is highly dependent on the signing parties; this may not happen immediately or at all. In terms of smart contracts, none of the parties have control over the execution or enforcement of contract terms.
   <b>Example:</b> In the insurance industry, the contract isn’t immediately executed after the conditions have been met. Rather, a lengthy review process is initiated and it could take months, even years before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial

:::NEXT DOC:::

before a contract is executed.
        </p>
      </li>
    </ul>
  </div>
    <div class=""wrapp"">
    <p class=""list__label""><b>Transparency</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Traditional agreements can be opaque and difficult to access in an attempt to obscure details from users. Smart contracts are transparent and open to the public by default.
          <b>Example</b>: If the opaque Collaterlize Debt Obligations (CDOs) that played a large role in the 2008 financial crisis were programmed as smart contracts, they would be completely transparent and any member of the public would have had the ability to audit them.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>


:::NEXT DOC:::

Smart contracts result from the evolution of digital agreements. A Smart contract is a self-executing contract with the terms of the agreement being directly written into computer code.


:::NEXT DOC:::

   <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.
          <b>Example</b>: Robinhood can no longer stop people from trading Gamestop, unless it is coded into the agreement.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label"">Efficiency:</p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
         The characteristics of smart contracts outlined earlier can create more efficient, automated processes that save business cost. 
         <b>Example:</b> Businesses could use a smart contract to settle inter-company transactions without needing to spend time and money on complicated systems of trusted neutral third parties to hold both sides accountable.
          </p>
      </li>
    </ul>
  </div>
</ListItemsContainer>

<MissionContainer>  
  <div className=""title"">Activities:</div>
  <ul className=""mission-goals"">
    <li>
      Think about an industry where agreements and contracts play a crucial role in ensuring its success. 
    </li>
    <li>
      Brainstorm ways smart contracts

:::NEXT DOC:::

   </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Tamper-Proofness</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
        Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.  
        <b>Example:</b> An equities exchange platform would not be able to stop someone from using their platform unless explicitly coded into the smart contract.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label""><b>Trust Minimization</b></p>
    <ul class=""list__items"">
      <li class=""list__item"">
        <p>
          Smart contracts reduce counterparty risk since neither party has control over the execution of an agreement.
          <b>Example</b>: Robinhood can no longer stop people from trading Gamestop, unless it is coded into the agreement.
        </p>
      </li>
    </ul>
  </div>
  <div class=""wrapp"">
    <p class=""list__label"">Efficiency:</p>
    <ul class=""list__items"">
      <li class=""list__item"">
    

:::NEXT DOC:::

#####Chapter 1:

What will this course cover?
=============================

***Chainlink, smart contracts, blockchains, and the entire world of cryptocurrency have been a hot topic of discussion for several years now.***

Whether it’s companies like EY and Microsoft looking to use smart contracts to improve their business processes, artists and athletes like LaMelo Ball creating their own“NFTs”, or up and coming companies looking to disrupt long standing industries such as insurance, Chainlink and smart contracts are looking to be the backbone for world changing applications.

The future of the internet, dubbed Web3.0, is being built in front of our eyes so let's dive in and start building the future! But wait, Chainlink? Smart contracts? Doesn’t blockchain have something to do with that Bitcoin stuff some people buy? In this course we will build up the intuition on what Chianlink is and the problems it solves.

## What are Contracts?
Agreements, deals, promises; these are concepts that humans seem to universally have an intuition on across cultures. Maybe as a child you agreed to trade 3 of your toys for 1 friend’s rare toy.

![The San Juan Mountains are beautiful!](/image_md.png ""test image"")

Or maybe you’ve agreed to lend your car to your friend as long as they don’t put more than 100 miles on it and bring it back with a full tank. Or maybe you make an agreement with your health coach that you wont eat more than 2,500 calories a day.

<BlueParagraph>
    These are all examples of agreements and agreements can be spoken orally, written down on paper, or even typed in digital documents. Enforcement of agreements are handled outside of courts: you will probably lose

:::NEXT DOC:::

contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program automated actions when receiving and transferring
assets.

Smart contracts can connect to real-world market prices of assets to produce
powerful applications. Securely connecting smart contracts with off-chain data
and services is what makes them _hybrid_ smart contracts. This is done using
oracles.

## What language is a smart contract written in?

The most popular language for writing smart contracts on Ethereum and EVM
Chains is [Solidity](https://docs.soliditylang.org/en/v0.8.7/). It was created
by the Ethereum Foundation specifically for smart contract development and is
constantly being updated. Other languages exist for writing smart contracts on
Ethereum and EVM Chains, but Solidity is the language used for Chainlink smart
contracts.

If you've ever written Javascript, Java, or other object-oriented scripting
languages, Solidity should be easy to understand. Similar to object-oriented
languages, Solidity is considered to be a _contract_ -oriented language.

Some networks are not EVM-compatible and use languages other than Solidity for
smart contracts:

  * [Solana](/data-feeds/solana)
   

:::NEXT DOC:::

# Chainlink Overview

  * Overview
  * What is a smart contract? What is a hybrid smart contract?
  * What language is a smart contract written in?
  * What does a smart contract look like?
  * Solidity versions
  * Naming a Contract
  * Variables
  * Constructors
  * Functions
  * Interfaces
  * What does ""deploying"" mean?
  * What is a LINK token?
  * What are oracles?
  * How do smart contracts use oracles?
  * What is Remix?
  * What is MetaMask?

Welcome to the Smart Contract Getting Started guide. This overview explains
the basic concepts of smart contract development and oracle networks.

**Skip ahead:** To get your hands on the code right away, you can skip this
overview:

  * [Deploy Your First Smart Contract](/getting-started/deploy-your-first-contract): If you are new to smart contracts, deploy your first smart contract in an interactive web development environment.
  * [Learn how to use Data Feeds](/getting-started/consuming-data-feeds): If you are already familiar with smart contracts and want to learn how to create _hybrid_ smart contracts, use Chainlink Data Feeds to get asset price data on-chain.

## What is a smart contract? What is a hybrid smart contract?

When deployed to a blockchain, a _smart contract_ is a set of instructions
that can be executed without intervention from third parties. The smart
contract code defines how it responds to input, just like the code of any
other computer program.

A valuable feature of smart contracts is that they can store and manage on-
chain assets (like [ETH or ERC20
tokens](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)),
just like you can with an Ethereum wallet. Because they have an on-chain
address like a wallet, they can do everything any other address can. This
enables you to program

:::NEXT DOC:::

save business cost. 
         <b>Example:</b> Businesses could use a smart contract to settle inter-company transactions without needing to spend time and money on complicated systems of trusted neutral third parties to hold both sides accountable.
          </p>
      </li>
    </ul>
  </div>
</ListItemsContainer>

<MissionContainer>  
  <div className=""title"">Activities:</div>
  <ul className=""mission-goals"">
    <li>
      Think about an industry where agreements and contracts play a crucial role in ensuring its success. 
    </li>
    <li>
      Brainstorm ways smart contracts can be used in those industries and how it can improve the current state of the industry.
    </li>
  </ul>
</MissionContainer>

# Blockchain Introduction 
&nbsp;
<VideoBox>
  <iframe  src=""https://www.youtube.com/embed/4ff9esY_4aU"" title=""YouTube video player"" frameborder=""0"" allow=""accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture"" allowfullscreen></iframe>
</VideoBox>
&nbsp;
The previous section explained the beneficial properties of smart contracts, but how can self-executing code that doesn’t rely on a trusted intermediary be created and implemented? To achieve this feat, another technology was invented: the <ColorWord>blockchain</ColorWord>. A blockchain is a global network of computers that stores data and transactions in a shared ledger that is <i>decentralized</i>. This means"
What is the LINK token address for BNB Chain?,0x404460C6A5EdE2D891e8297795264fDe62ADBB75,{'source': 'https://docs.chain.link/vrf/v2/subscription/supported-networks/'},The LINK token address for BNB Chain is 0x404460C6A5EdE2D891e8297795264fDe62ADBB75.,"| 5                                          |
| Address      | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## BNB Chain

### BNB Chain mainnet

BNB is used to pay for transactions on the BNB Chain mainnet.

ERC-677 LINK on BNB Chain

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
you cannot use it with Chainlink services or oracle nodes. Use the
[**Chainlink PegSwap service**](https://pegswap.chain.link/) to convert
bridged LINK to the official ERC-677 LINK token on BNB Chain.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 56                                         |
| Address       

:::NEXT DOC:::

      |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | bscscan.freshstatus.io                     |
### BNB Chain testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/chapel). Testnet BNB is
availalbe at [testnet.binance.org/faucet-
smart](https://testnet.binance.org/faucet-smart).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 97                                         |
| Address      | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06 |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18         

:::NEXT DOC:::

    |
|:----------------------------|:-------------------------------------------|
| Registry Address            | 0xE16Df59B887e3Caa439E0b29B42bA2e7976FD8b2 |
| Registrar Address           | 0x57A4a13b35d25EE78e084168aBaC5ad360252467 |
| Payment Premium %           | 20                                         |
| Block Count Per Turn        | 100                                        |
| Check Gas Limit             | 6500000                                    |
| Perform Gas Limit           | 5000000                                    |
| Gas Ceiling Multiplier      | 3                                          |
| Minimum Upkeep Spend (LINK) | 0.0                                        |
### BNB Chain

#### BNB Chain mainnet

| Item                        | Value 

:::NEXT DOC:::

|
| Registrar Address           | 0xDb8e8e2ccb5C033938736aa89Fe4fa1eDfD15a1d |
| Payment Premium %           | 30                                         |
| Block Count Per Turn        | 20                                         |
| Check Gas Limit             | 6500000                                    |
| Perform Gas Limit           | 5000000                                    |
| Gas Ceiling Multiplier      | 3                                          |
| Minimum Upkeep Spend (LINK) | 0.1                                        |
#### BNB Chain testnet

| Item                        | Value                                      |
|:----------------------------|:-------------------------------------------|
| Registry Address           

:::NEXT DOC:::

                                    |
| Coordinator Gas Overhead   | 90000                                      |
### BNB Chain

Important

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
cannot be used with Chainlink oracles. However, it can be [**converted to the
official LINK token on BNB Chain using Chainlink's PegSwap
service**](https://pegswap.chain.link/).

| Item                       | Value                                      |
|:---------------------------|:-------------------------------------------|
| LINK Token                 | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75 |
| VRF Wrapper                | 0x721DFbc5Cfe53d32ab00A9bdFa605d3b8E1f3f42 |
| VRF Coordinator            | 0xc587d9053cd1118f25F645F9E08BB98c9712A4EE |
| Wrapper Premium Percentage | 0                                          |
| Coordinator Flat Fee       | 0.005 LINK    

:::NEXT DOC:::

to the
official LINK token on BNB Chain using Chainlink's PegSwap
service**](https://pegswap.chain.link/).

| Item            | Value                                                                                |
|:----------------|:-------------------------------------------------------------------------------------|
| LINK Token      | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75                                           |
| VRF Coordinator | 0x747973a5A2a4Ae1D3a8fDF5479f1514F65Db9C31                                           |
| Key Hash        | 0xc251acd21ec4fb7f31bb8868288bfdbaeb4fbfec2df3735ddbd4f7dc8d60103c                   |
| Fee             | 0.2 LINK - initial fees on BNB Chain are meant to cover the highest gas cost prices. |
## BNB Chain Testnet

BNB Chain Faucet

Testnet LINK is available from <https://faucets.chain.link/chapel>

| Item            | Value                 

:::NEXT DOC:::

                        |
| VRF Coordinator | 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255                         |
| Key Hash        | 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4 |
| Fee             | 0.0001 LINK                                                        |
## BNB Chain Mainnet

Important

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
cannot be used with Chainlink oracles. However, it can be [**converted to the
official LINK token on BNB Chain using Chainlink's PegSwap
service**](https://pegswap.chain.link/).

| Item            | Value                                                                                |
|:----------------|:-------------------------------------------------------------------------------------|
| LINK Token      | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75                    

:::NEXT DOC:::

|
| Premium               | 0.25 LINK                                                          |
| Max Gas Limit         | 2500000                                                            |
| Minimum Confirmations | 3                                                                  |
| Maximum Confirmations | 200                                                                |
| Maximum Random Values | 500                                                                |
### BNB Chain

Important

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
cannot be used with Chainlink oracles. However, it can be [**converted to the
official LINK token on BNB Chain using Chainlink's PegSwap
service**](https://pegswap.chain.link/).

| Item         

:::NEXT DOC:::

|
| Wrapper Premium Percentage | 0                                          |
| Coordinator Flat Fee       | 0.25 LINK                                  |
| Minimum Confirmations      | 3                                          |
| Maximum Confirmations      | 200                                        |
| Maximum Random Values      | 10                                         |
| Wrapper Gas overhead       | 40000                                      |
| Coordinator Gas Overhead   | 90000                                      |
### BNB Chain

Important

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
cannot be used with Chainlink oracles. However, it can be [**converted to the
official LINK token on BNB Chain using Chainlink's PegSwap
service**](https://pegswap.chain.link/).

| Item          

:::NEXT DOC:::

        |
| Address        | 0xb0897686c545045aFc77CF20eC7A532E3120E0F1 |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | polygon.io/system                          |
### Mumbai testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/mumbai). Testnet MATIC is
available at the [Polygon faucet](https://faucet.polygon.technology/).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 80001                                      |
| Address      | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB |
| Name         | Chainlink Token                           "
What is the purpose of the code shown?,The code is a jobspec for a Chainlink node that fetches data from a YouTube channel and fulfills an oracle request with the data.,{'source': 'https://stackoverflow.com/questions/70017509/reverted-transaction-on-chainlink-node-while-fulfilling-request'},There is no code shown in the context information provided. The information provided describes the topics covered in two different chapters of a course on Solidity programming.,"Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions).


:::NEXT DOC:::

Now let's dive into programming in Solidity. Learn about the very first line of a smart contract.


:::NEXT DOC:::

You will often run into situations where we need to decide the next step based on the value of a variable. And we will get into situations where we need to repeat code. Learn about conditional statements and loops.


:::NEXT DOC:::

Programs, in very broad terms, do two things: store data and change data. We store data in programs by utilizing variables and change data by defining logic in functions. In smart contracts, when we define variables outside of a function they can be used to store data for that contract, to be accessed at a later time.


:::NEXT DOC:::

We can actually give more information to the Solidity compiler on how we want to use our variables (and later functions). We can tell the compiler how we want our variables to be accessed. Many blockchains, such as Ethereum, act as one monolithic computer.


:::NEXT DOC:::

#####Chapter 13:

# Conclusion

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp> -->

Congrats for making it this far! That’s a lot of Solidity concepts! The main gist of this course is that there are really only two things you are ever defining when programming smart contracts (or just programming in general): state (variables) and logic (functions). In future courses, we will go into more detail on more complex variables such as storing structs within arrays and more special functions such as the constructor and events. And as always, you know the best way to learn is by doing! Feel free to go to https://remix.ethereum.org/, and just mess around with writing code there. It may feel overwhelming at first, but don’t worry it’s just to get a feel for what’s to come!


:::NEXT DOC:::

#####Chapter 1:

# Solidity

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    Inspired by the power of smart contracts and blockchain, it’s time to dive in.
    </div>
  </div>
</ContentWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent. If you are familiar with some programming, it may help to know that Solidity is an **object-oriented programming language**. If you are not familiar with what that means, don’t worry, we’ll cover it in a future course.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!




:::NEXT DOC:::

There are actually quite a few pre-build operators in Solidity you can utilize to make programming smart contracts that much easier.


:::NEXT DOC:::

In programming an operator is a symbol that represents an action or process. In the case of the assignment operator whatever is to the left of the equals sign is being assigned the value of whatever is on the right of the equal sign.
"
What is the topic of Chapter 1?,The topic of Chapter 1 is what the course will cover.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrf102/Chapters/Chapter-8/hints.md'},"The topic of Chapter 1 is ""What will this course cover?"" in the Chainlink Introduction course.","#####Chapter 1:

# What will this course cover?

Video


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What are NFT Floor Price Feeds and what are they used for?,"NFT Floor Price Feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink’s oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. They can be used for use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.",{'source': 'https://docs.chain.link/data-feeds/nft-floor-price/'},"NFT Floor Price Feeds are a type of data feed provided by Chainlink that estimate a conservative and risk averse floor price for an NFT collection. They are used for various use cases that rely on high-quality NFT data, such as lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more. These feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink's oracle infrastructure to eliminate extreme price outliers and make them resistant to market manipulation.","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma

:::NEXT DOC:::

testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH         

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data

:::NEXT DOC:::

     | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility

:::NEXT DOC:::

                                 |
|:---------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| Azuki Floor Price          | ETH           | 2%          |        3600 |    18 | 0x9F6d70CDf08d893f0063742b51d3E9D1e18b7f74 |
| BAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xB677bfBc9B09a3469695f40477d05bc9BcB15F50 |
| CloneX Floor Price         | ETH           | 2%          |        3600 |    18 | 0xE42f272EdF974e9c70a6d38dCb47CAB2A28CED3F |
| CoolCats Floor Price       | ETH           | 2%          |        3600 |    18 | 0x13F38938A18ff26394c5ac8df94E349A97AaAb4e |
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price

:::NEXT DOC:::

      | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%     

:::NEXT DOC:::

    (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = nftFloorPriceFeed.latestRoundData();
            return nftFloorPrice;
        }
    }
    

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for NFT Floor Price Feeds](/data-feeds/nft-floor-price/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
    

:::NEXT DOC:::

  | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
| ⚫VeeFriends Floor Price                 | ETH           | 2%          |       86400 |    18 | 0x35bf6767577091E7f04707c0290b3f889e968307 |
| ⚫World of Women Floor Price             | ETH           | 2%          |"
What is the ternary operator in Solidity and how is it used?,"The ternary operator is represented by the symbol '?'. It is used to assign a value to a variable based on a condition. For example, in the given code, if x is smaller than 5 then return 0 otherwise return 1.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/solidity102/Chapters/Chapter-4/course.md'},"The ternary operator in Solidity is a conditional statement that allows for the execution of different code based on whether a condition is met or not. It is represented by the question mark symbol (?) and is used to assign values to a variable or to return a value in a function. The expression means if a certain condition is true, then return one value, otherwise return another value. It can also be used in place of a simple if/else statement.","#####Chapter 4:

# Conditional statements and loops

While we are now familiar with storage and basic data types in Solidity, we still have to learn about flow control. We will often run into situations where we need to decide the next step based on the value of a variable. This is where we can use conditional statements. The syntax is very similar to languages like JavaScript. Let’s have a look:

<Highlight class=""language-javascript"">
function foo(int x) public pure returns (uint) {
 if (x < 5) {
   return 0;
 } else if (x < 10) {
   return 1;
 } else {
   return 2;
 }
}
</Highlight>

As you can see, this allows us to execute different codes based on if a condition is met. If we do not have an else if case but a simple if/else case, Solidity also supports the ternary operator.

<Highlight class=""language-javascript"">
function bar(uint x) public pure returns (uint) {
  return x < 5 ? 0 : 1;
}
</Highlight>

The question mark **?** is called the ternary operator (learn more about operators in chapter 10). The expression means if x is smaller than 5 then return 0 otherwise return 1. We can also use these conditional statements to assign values to a variable:

<Highlight class=""language-javascript"">
function bar(uint x) public pure returns (uint) {
  uint conditionalResult = x < 5 ? 0 : 1;
  return conditionalResult;
}
</Highlight>

Here we are using the ternary expression to assign the value to the local variable called **conditionalResult**.

Next, to flow control, we often encounter a situation where repetition is needed. Loops are useful when we must

:::NEXT DOC:::

x) public pure returns (uint) {
  return x < 5 ? 0 : 1;
}
</Highlight>

The question mark **?** is called the ternary operator (learn more about operators in chapter 10). The expression means if x is smaller than 5 then return 0 otherwise return 1. We can also use these conditional statements to assign values to a variable:

<Highlight class=""language-javascript"">
function bar(uint x) public pure returns (uint) {
  uint conditionalResult = x < 5 ? 0 : 1;
  return conditionalResult;
}
</Highlight>

Here we are using the ternary expression to assign the value to the local variable called **conditionalResult**.

Next, to flow control, we often encounter a situation where repetition is needed. Loops are useful when we must repeat a block of code several times. Solidity offers two types of loops. For Loops and While Loops.

<Highlight class=""language-javascript"">
function forLoopExample() public returns (uint) {
  uint counter = 0;
  for (uint i = 0; i < 4; i++) {
      if (i == 0) {
          continue;
      }
      if (counter == 4) {
          break;
      }
      counter = counter + 2;
  }

return counter;
}
</Highlight>

As in JavaScript, we have the same syntax for the for loop: (initialization; condition; increment). The condition is an expression checked at the end of each loop cycle. You can also see that we are using the keywords **continue** and **break** here. They allow us to control the flow inside the loop. If

:::NEXT DOC:::

There are actually quite a few pre-build operators in Solidity you can utilize to make programming smart contracts that much easier.


:::NEXT DOC:::

You will often run into situations where we need to decide the next step based on the value of a variable. And we will get into situations where we need to repeat code. Learn about conditional statements and loops.


:::NEXT DOC:::

In programming an operator is a symbol that represents an action or process. In the case of the assignment operator whatever is to the left of the equals sign is being assigned the value of whatever is on the right of the equal sign.


:::NEXT DOC:::

#####Chapter 12:

# Operators: Arithmetic and Relational

<!-- <ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Connect your artwork to the price of gold or ETH or overall Market Cap. Mention the concept of “Hybrid Smart Contracts”. 
    </div>
  </div>
</ContentWrapp> -->

In the last chapter we built a function that added two numbers. But within that function, we actually used a + (plus sign) to add the numbers. The plus sign is another operator, just like the equals sign assignment operator, and the logic it runs is intuitively to add numbers! There are actually quite a few pre-build operators in Solidity you can utilize to make programming smart contracts that much easier. Here are some useful operators in the Arithimetic and Relational catagories:

**Arithmetic Operators: These operators perfom basics arithmetic operations**

* Addittion (+): Used to add two Numbers
* Subtraction (-): Used to subtract two Numbers
* Multiplication (*): Used to Multiply two Numbers
* Division (/): Used to divide a number by another number
* Modulus (%): Returns the remainder after division
* Increment (++): Increases an interger by 1
* Decrement (--): Decreases an interger by 1

Relational Operators: These operators are used to compare values

* Equal (==): Check if values are equal, if they are it returns true (1) and if not returns false

:::NEXT DOC:::

# Solidity Introduction

<GradientTextWrapp>
  Solidity is an object-oriented, high-level language for implementing smart contracts. Learn about the basics here.
</GradientTextWrapp>

In Solidity 101 we learned about the basics of smart contracts in Solidity. We looked into the Ethereum Virtual Machine and how it deals with state (variables) and logic (functions). Basic concepts like the minimal structure of a contract and how to write functions to manipulate values. And we learned about data types, operators and looked into more depth into arrays.

In this course, we want to dive deeper and expand our knowledge and learn about futher basics like conditional statements, loops and complex data structures like arrays and maps. In the second part, we will see how data is stored and variables handled in contracts. Next, we will learn how to handle errors in Solidity.

The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

# Solidity Introduction

<GradientTextWrapp>
  Solidity is an object-oriented, high-level language for implementing smart contracts. Learn about the basics here.
</GradientTextWrapp>

In Chainlink 101, we discussed how and why Smart Contracts are revolutionizing the nature of agreements, and the Internet. But how do we write smart contracts? Well, smart contracts are programmed, and while there are now several smart contract programming languages, the most popular language today is Solidity. Ethereum developers created Soldity from the ground up to work with Ethereum, the first major smart contract blockchain! This is a major reason why contracts written in Solidity have become so prominent.

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

Now let's dive into programming in Solidity. Learn about the very first line of a smart contract.


:::NEXT DOC:::

We can actually give more information to the Solidity compiler on how we want to use our variables (and later functions). We can tell the compiler how we want our variables to be accessed. Many blockchains, such as Ethereum, act as one monolithic computer.
"
What is the purpose of the 'callbackGasLimit' parameter in the 'requestRandomWords()' function?,The 'callbackGasLimit' parameter specifies the limit for how much gas to use for the callback request to the contract's 'fulfillRandomWords()' function.,{'source': 'https://docs.chain.link/vrf/v2/subscription/examples/get-a-random-number/'},The 'callbackGasLimit' parameter in the 'requestRandomWords()' function is used to set the maximum gas limit supported for the callback function that will be called when the random words are received. It ensures that the callback function will not run out of gas and specifies the amount of gas that can be consumed by the callback function.,"requestRandomWords() external onlyOwner {
   s_requestId = COORDINATOR.requestRandomWords(
     keyHash,
     s_subscriptionId,
     requestConfirmations,
     callbackGasLimit,
     numWords
   );
 }
</Highlight>

You can see that we don’t need to provide any parameters here though the COORDINATOR expects 5 of them. We have hard coded these values in the contract, but you could also ask the caller of the function to provide these values depending on your implementation. Let’s look into each parameter.

- **keyHash** defines which gas lane to use, which specifies the maximum gas price
- **s_subscriptionId** is set when the contract is deployed and a new subscription is created.
- **requestConfirmations** is three by default but you can set it higher.
- **callbackGasLimit** allows to set the the limit so more complex contracts can be developed using a single transaction to get verifiable randomness to their contract.
- **numWords** defines the number of random values which we want to get in one request.

So now that we have a function to request random words, we still need to implement a function to actually get the random words. This function is then called as a callback by the COORDINATOR to set the random values.

<Highlight class=""language-javascript"">
 uint256[] public s_randomWords;
 function fulfillRandomWords(
   uint256, /* requestId */
   uint256[] memory randomWords
 ) internal override {
   s_randomWords = randomWords;
 }
</Highlight>

The results are stored as a uint256 array. It can now be used by other functions or applications for further processing. If you wanted to have a

:::NEXT DOC:::

limits the maximum number of random values you can receive in each request.
  * Each coordinator has a `maxGasLimit` parameter, which is the maximum allowed `callbackGasLimit` value for your requests. You must specify a sufficient `callbackGasLimit` to fund the callback request to your consuming contract. This depends on the number of random values you request and how you process them in your `fulfillRandomWords()` function. If your `callbackGasLimit` is not sufficient, the callback fails but your subscription is still charged for the work done to generate your requested random values.

## What's next

  * [› Get a Random Number](/vrf/v2/subscription/examples/get-a-random-number)
  * [› Supported Networks](/vrf/v2/subscription/supported-networks)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/subscription.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

VRF job that runs in response to requests. We will use **0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc**

**uint32 callbackGasLimit**: The limit for how much gas to use for the callback request to your contract's **fulfillRandomWords()** function. It must be less than the **maxGasLimit** limit on the coordinator contract. In this example, the **fulfillRandomWords()** function stores two random values, which cost about 20,000 gas each, so a limit of 100,000 gas is sufficient. Adjust this value for larger requests depending on how your fulfillRandomWords() function processes and stores the received random values. If your **callbackGasLimit** is not sufficient, the callback will fail and your subscription is still charged for the work done to generate your requested random values. We will use a limit of **100000**.

**uint16 requestConfirmations**: How many confirmations the Chainlink node should wait before responding. The longer the node waits, the more secure the random value is. It must be greater than the **minimumRequestBlockConfirmations** limit on the coordinator contract. We will set this to **3**
**uint16 numWords**: How many random values to request. If you can use several random values in a single callback, you can reduce the amount of gas that you spend per random value. The total cost of the callback request depends on how your **fulfillRandomWords()** function processes and stores the received random values, so adjust your **callbackGasLimit** accordingly. We will set this to **2**


:::NEXT DOC:::

`fulfillRandomWords()` function processes and stores the received random values. If your `callbackGasLimit` is not sufficient, the callback will fail and your consuming contract is still charged for the work done to generate your requested random values.

  * `uint16 requestConfirmations`: How many confirmations the Chainlink node should wait before responding. The longer the node waits, the more secure the random value is. It must be greater than the `minimumRequestBlockConfirmations` limit on the coordinator contract.

  * `uint32 numWords`: How many random values to request. If you can use several random values in a single callback, you can reduce the amount of gas that you spend per random value. The total cost of the callback request depends on how your `fulfillRandomWords()` function processes and stores the received random values, so adjust your `callbackGasLimit` accordingly.

The contract includes the following functions:

  * `requestRandomWords()`: Takes your specified parameters and submits the request to the VRF v2 Wrapper contract.

  * `fulfillRandomWords()`: Receives random values and stores them with your contract.

  * `getRequestStatus()`: Retrive request details for a given `_requestId`.

  * `withdrawLink()`: At any time, the owner of the contract can withdraw outstanding LINK balance from it.

Security Considerations

Be sure to review your contracts to make sure they follow the best practices
on the [security considerations](/vrf/v2/security) page.

## Clean up

After you are done with this contract, you can retrieve the remaining testnet
LINK to use with other examples.

  1. Call `withdrawLink()` function. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, the remaining LINK will be transfered from your consuming contract to your wallet address.

## What's next

  * [› Security Considerations](/vrf/v2/security)
  *

:::NEXT DOC:::

{
            LinkTokenInterface link = LinkTokenInterface(linkAddress);
            require(
                link.transfer(msg.sender, link.balanceOf(address(this))),
                ""Unable to transfer""
            );
        }
    }
    

The parameters define how your requests will be processed. You can find the
values for your network in the [Supported networks](/vrf/v2/direct-funding/supported-networks) page.

  * `uint32 callbackGasLimit`: The limit for how much gas to use for the callback request to your contract's `fulfillRandomWords()` function. It must be less than the `maxGasLimit` limit on the coordinator contract minus the `wrapperGasOverhead`. See the [VRF v2 Direct funding limits](/vrf/v2/direct-funding/#limits) for more details. Adjust this value for larger requests depending on how your `fulfillRandomWords()` function processes and stores the received random values. If your `callbackGasLimit` is not sufficient, the callback will fail and your consuming contract is still charged for the work done to generate your requested random values.

  * `uint16 requestConfirmations`: How many confirmations the Chainlink node should wait before responding. The longer the node waits, the more secure the random value is. It must be greater than the `minimumRequestBlockConfirmations` limit on the coordinator contract.

  * `uint32 numWords`: How many random values to request. If you can use several random values in a single callback, you can reduce the amount of gas that you spend per random value. The total cost of the callback request depends on how your `fulfillRandomWords()` function processes and stores the received random values, so adjust your `callbackGasLimit`

:::NEXT DOC:::

       function requestRandomWords(
            uint32 _callbackGasLimit,
            uint16 _requestConfirmations,
            uint32 _numWords
        ) external onlyOwner returns (uint256 requestId) {
            requestId = requestRandomness(
                _callbackGasLimit,
                _requestConfirmations,
                _numWords
            );
            uint256 paid = VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit);
            uint256 balance = LINK.balanceOf(address(this));
            if (balance < paid) revert InsufficientFunds(balance, paid);
            s_requests[requestId] = RequestStatus({
                paid: paid,
                randomWords: new uint256[](0),
                fulfilled: false
            });
            requestIds.push(requestId);
            lastRequestId = requestId;
            emit RequestSent(requestId, _numWords, paid);
            return requestId;
        }
    
        function

:::NEXT DOC:::

   uint256 public s_requestId;
    
    function requestRandomWords() external onlyOwner returns (uint256) {
      uint256 requestId = COORDINATOR.requestRandomWords(
        keyHash,
        s_subscriptionId,
        requestConfirmations,
        callbackGasLimit,
        numWords
      );
      s_requestIdToAddress[requestId] = msg.sender;
    
      // Store the latest requestId for this example.
      s_requestId = requestId;
    
      // Return the requestId to the requester.
      return requestId;
    }
    
    function fulfillRandomWords(
        uint256 requestId,
        uint256[] memory randomWords
      ) internal override {
      // You can return the value to the requester,
      // but this example simply stores it.
      s_requestIdToRandomWords[requestId] = randomWords;
    }

You could also map the `requestId` to an index to keep track of the order in
which a request was made.


    mapping(uint256 => uint256) s_requestIdToRequestIndex;
    mapping(uint256 => uint256[]) public s_requestIndexToRandomWords;
    uint256 public requestCounter;
    
    function requestRandomWords() external onlyOwner {
      uint256 requestId = COORDINATOR.requestRandomWords(
        keyHash,
        s_subscriptionId,
        requestConfirmations,
       

:::NEXT DOC:::

   
            return (lth,lastNum);
        }
    }
    



Answers:
(Answered on: 2022-08-23 08:02:04)


I see that you are testing on Rinkeby. I advise you to test on Goerli. Rinkeby
is marked as deprecated (cf. <https://docs.chain.link/docs/vrf/v2/supported-
networks/>).

I've tested your contract and remarked that `fulfillRandomWords` runs out of
gas. In fact, The maximum number of random words that can be received per
request is 500, and the maximum gas limit supported for your callback function
is 2,500,000. Therefore, you must ensure that the callback function will not
run out of gas (meaning: your callback function cannot consume more than
2,500,000 of gas). In your example, you are trying to store 500 random words.
Setting a value from non-zero to zero takes about 20,000 of gas (cf. [Ethereum
yellow paper Appendix H](https://ethereum.github.io/yellowpaper/paper.pdf)).
With 2,500,000 of gas, you can store up to 125 words. And that’s why the
attached contract will not work with NUM_WORDS=500 (fulfillRandomWords runs
out of gas). If you want to store 10001 random values, I’d suggest making
multiple requests. For instance: inside `requestRandomWords` you can loop over
`vrfCoordinator.requestRandomWords` multiple times (e.g.: with NUM_WORDS=100
for 100 runs. and 1 for the last run). Your callback function will be called
multiple times (=number of requestIds) so make sure to implement a logic that
waits for all the requests to be fulfilled (e.g., you can update a state
variable

:::NEXT DOC:::

of the callback request in the fulfillRandomWords()
      // function.
      uint32 callbackGasLimit = 100000;
    
      // The default is 3, but you can set this higher.
      uint16 requestConfirmations = 3;
    
      // For this example, retrieve 2 random values in one request.
      // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.
      uint32 numWords =  2;
    
      uint256[] public s_randomWords;
      uint256 public s_requestId;
      address s_owner;
    
      constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        LINKTOKEN = LinkTokenInterface(link);
        s_owner = msg.sender;
        s_subscriptionId = subscriptionId;
      }
    
      // Assumes the subscription is funded sufficiently.
      function requestRandomWords() external onlyOwner {
        // Will revert if subscription is not set and funded.
        s_requestId = COORDINATOR.requestRandomWords(
          keyHash,
          s_subscriptionId,
          requestConfirmations,
          callbackGasLimit,
          numWords
        );
 

:::NEXT DOC:::

               callbackGasLimit,
                numWords
            );
            s_requests[requestId] = RequestStatus({
                randomWords: new uint256[](0),
                exists: true,
                fulfilled: false
            });
            requestIds.push(requestId);
            lastRequestId = requestId;
            emit RequestSent(requestId, numWords);
            return requestId;
        }
    
    function fulfillRandomWords(
    uint256 \_requestId,
    uint256\[\] memory \_randomWords
    ) internal override {
    require(s_requests\[\_requestId\].exists, ""request not found"");
    require(!s_requests\[\_requestId\].fulfilled, ""request already fulfilled"");
    
            s_requests[_requestId].fulfilled = true;
            s_requests[_requestId].randomWords = _randomWords;
        
            for (uint256 i = 0; i < _randomWords.length; i++) {
                uint256 result = (_randomWords[i] %"
What is the purpose of this chapter?,The purpose of this chapter is to teach the reader how to get a verifiably secure random number for use in a smart contract.,{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/vrfIntroduction/Chapters/Chapter-13/course.md'},The purpose of this chapter is to provide a broad overview of the course and what will be learned.,"A broad overview of the course and what you will learn here.


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

Throughout this course, we will learn the basics of Solidity syntax and then apply it to some activities. The best way to learn to program is to program! With that said, let's dive right in!


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints


:::NEXT DOC:::

#####Chapter 1:

# What will this course cover?

Hints
"
What error message did the user receive when calling the getVersion function in the FundMe smart contract?,The user received the error message 'call to FundMe.getVersion errored: execution reverted'.,{'source': 'https://stackoverflow.com/questions/69182406/solidiy-fundme-smart-contract-remix-chainlink-call-to-fundme-getversion-err'},"The user received the error message ""call to FundMe.getVersion errored: execution reverted"" when calling the getVersion function in the FundMe smart contract.","Question: (Asked on: 2021-09-14 17:49:25)
Solidiy FundMe Smart Contract - Remix - Chainlink `call to FundMe.getVersion errored: execution reverted`
URL: https://stackoverflow.com/questions/69182406/solidiy-fundme-smart-contract-remix-chainlink-call-to-fundme-getversion-err

Question Body:


I am learning to use Chain Link to get price conversions and also to implement
other functions provided by Chainlink. I have 2.9992 ETH on Rinkeby Test Net
and I am successfully able to compile and deploy the code using Remix IDE
using Injected Web3 Environment.

Whenever I call the function **getVersion** or any other function defined in
ChainLink. I get an error like this

> `""call to FundMe.getVersion errored: execution reverted""`
    
    
        pragma solidity >=0.6.6 <0.9.0;
        
        import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
        
        contract FundMe {
            
            mapping(address => uint256) public addressToAmountFunded;
            function fund() public payable {
                addressToAmountFunded[msg.sender] += msg.value;
            }
            
            function getVersion() public view returns(uint256) {
           

:::NEXT DOC:::

import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
        
        contract FundMe {
            
            mapping(address => uint256) public addressToAmountFunded;
            function fund() public payable {
                addressToAmountFunded[msg.sender] += msg.value;
            }
            
            function getVersion() public view returns(uint256) {
                AggregatorV3Interface priceFeed = AggregatorV3Interface(0x01BE23585060835E02B77ef475b0Cc51aA1e0709);
                return priceFeed.version();
            }
        }
    



Answers:
(Answered on: 2021-09-14 18:04:06)


So I found an answer to my question. I was using the wrong Ethereum Data Feed
Address. I updated address to **0x8A753747A1Fa494EC906cE90E9f37563A8AF630e**
which is for ETH/USD on Rinkeby Test Net and it compiles and deploys perfectly
with no errors





:::NEXT DOC:::

                                  // The funders' address will be added to the funders array - Note that these values will be reset every time withdraw is called
        }
    
        // ***** getVersion *****
        // The following function is contained inside of the imported library AggregatorV3Interface
        // When called, the function will return the current version of the contract/library AggregatorV3Interface
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getVersion() public view returns(uint256)
        {      
            return AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e).version();     // .version method is contained inside of AggregatorV3Interface, the address can be find here
            //                                                                                                                                             

:::NEXT DOC:::

      
        mapping(address => uint256) public addressToAmountFunded;
        address[] public funders;
        address public owner;
        
        constructor() public {
            owner = msg.sender;
        }
        
        function fund() public payable {
            uint256 minimumUSD = 50 * 10 ** 18;
            require(getConversionRate(msg.value) >= minimumUSD, ""You need to spend more ETH!"");
            addressToAmountFunded[msg.sender] += msg.value;
            funders.push(msg.sender);
        }
        
        function getVersion() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);
            return priceFeed.version();
        }
        
        function getPrice() public view returns(uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);
            (,int256 answer,,,) =

:::NEXT DOC:::

 function getVersion() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);
            return priceFeed.version();
        }
        
        function getPrice() public view returns(uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);
            (,int256 answer,,,) = priceFeed.latestRoundData();
             return uint256(answer * 10000000000);
        }
        
        // 1000000000
        function getConversionRate(uint256 ethAmount) public view returns (uint256){
            uint256 ethPrice = getPrice();
            uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;
            return ethAmountInUsd;
        }
        
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
        
        function withdraw() payable onlyOwner public {
           

:::NEXT DOC:::

   
        function fund() public payable {
            uint256 mimimumUSD = 50 * 10**18;
            require(
                getConversionRate(msg.value) >= mimimumUSD,
                ""You need to spend more ETH!""
            );
            addressToAmountFunded[msg.sender] += msg.value;
            funders.push(msg.sender);
        }
    
        function getVersion() public view returns (uint256) {
            return priceFeed.version();
        }
    
        function getPrice() public view returns (uint256) {
            (, int256 answer, , , ) = priceFeed.latestRoundData();
            return uint256(answer * 10000000000);
        }
    
        // 1000000000
        function getConversionRate(uint256 ethAmount)
            public
            view
            returns (uint256)
        {
            uint256 ethPrice = getPrice();
            uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;
    

:::NEXT DOC:::

   
    contract FundMe {
    
        mapping(address => uint256) public addressToAmountFunded;
        address[] public funders;
        address public owner;
        AggregatorV3Interface internal priceFeed;
        uint balance;
        
        // if you're following along with the freecodecamp video
        // Please see https://github.com/PatrickAlphaC/fund_me
        // to get the starting solidity contract code, it'll be slightly different than this!
        constructor(address _priceFeed) {
            priceFeed = AggregatorV3Interface(_priceFeed);
            owner = msg.sender;
        }
    
        function fund() public payable {
            uint256 mimimumUSD = 50 * 10**18;
            require(
                getConversionRate(msg.value) >= mimimumUSD,
                ""You need to spend more ETH!""
            );
            addressToAmountFunded[msg.sender] += msg.value;
            balance += msg.value;
            funders.push(msg.sender);
        }
    
        function

:::NEXT DOC:::

    Warning! Error encountered during contract execution [execution reverted] 
    

I tried looking for problems with my code and found none.

    
    
    // SPDX-License-Identifier: MIT
    
    pragma solidity >=0.6.6 <0.9.0;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    //import ""@chainlink/contracts/src/v0.8/vendor/SafeMathChainlink.sol""; won't need in later complier versions.
    contract FundMe {
        
    
        mapping(address => uint256) public addressToAmountFunded;
    
        function fund() public payable {
            uint256 minimumUSD = 50 * 10 ** 18;
            require( getConversionRate(msg.value) >= minimumUSD,""You need to send more Eth"");
            addressToAmountFunded[msg.sender] += msg.value;
        }
    
        function getVersion() public view returns (uint256){
            AggregatorV3Interface priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);
            return priceFeed.version();
        }
    
        function getPrice() public view returns (uint256){
            AggregatorV3Interface priceFeed =

:::NEXT DOC:::

{
        const contract = await getContract()
        getPrice(contract)
    }
    
    const fundButton = document.getElementById('fund')
    fundButton.addEventListener('click', async () => {
        const fundMe = await getContract()
    })
    
    init()
    

I get the following error in the browser console and have no idea whats the
cause. [](https://i.stack.imgur.com/BZZn1.png)



Answers:
(Answered on: 2021-11-22 13:19:51)


Your deploy script passing the `0x056...` address as the `priceFeed` param of
the constructor.

So the `getPrice()` contract function is then trying to call the
`latestRoundData()` on the `0x056...` address, expecting a response.

However, your contract is deployed on the testnet, and there's no contract on
the `0x056...` address on the testnet
([link](https://testnet.bscscan.com/address/0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE#code))
to return a value, which causes the ""main"" call to revert.





:::NEXT DOC:::

{
            uint256 mimimumUSD = 50 * 10**18;
            require(
                getConversionRate(msg.value) >= mimimumUSD,
                ""You need to spend more ETH!""
            );
            addressToAmountFunded[msg.sender] += msg.value;
            balance += msg.value;
            funders.push(msg.sender);
        }
    
        function getVersion() public view returns (uint256) {
            return priceFeed.version();
        }
    
        function getPrice() public view returns (uint256) {
            (, int price, , , ) = priceFeed.latestRoundData();
            return uint256(price * 10000000000);
        }
    
        // 1000000000
        function getConversionRate(uint256 ethAmount)
            public
            view
            returns (uint256)
        {
            uint256 ethPrice = getPrice();
            uint256 ethAmountInUsd = (ethPrice * ethAmount) /"
What is the error message that the user gets when trying to call the function AaveLendingPool.borrow()?,TypeError: Type int256 is not implicitly convertible to expected type uint256.,{'source': 'https://stackoverflow.com/questions/69783472/get-chainlink-eth-usd-price-feed-answer-as-uint256-instead-of-int-solidity'},There is no information provided about an error message related to the AaveLendingPool.borrow() function. The question and context information are about a different smart contract and function.,"   
    contract FundMe {
    
        mapping(address => uint256) public addressToAmountFunded;
        address[] public funders;
        address public owner;
        AggregatorV3Interface internal priceFeed;
        uint balance;
        
        // if you're following along with the freecodecamp video
        // Please see https://github.com/PatrickAlphaC/fund_me
        // to get the starting solidity contract code, it'll be slightly different than this!
        constructor(address _priceFeed) {
            priceFeed = AggregatorV3Interface(_priceFeed);
            owner = msg.sender;
        }
    
        function fund() public payable {
            uint256 mimimumUSD = 50 * 10**18;
            require(
                getConversionRate(msg.value) >= mimimumUSD,
                ""You need to spend more ETH!""
            );
            addressToAmountFunded[msg.sender] += msg.value;
            balance += msg.value;
            funders.push(msg.sender);
        }
    
        function

:::NEXT DOC:::

           
            users.push(user);                     
            totalDeposited.push(amountDeposit);
    
            deadline = block.timestamp + (numberOfSeconds * 1 seconds);
    
            int256 chainLinkEthPrice = EACAggregatorProxy(chainLinkETHUSDAddress).latestAnswer();
            ethPrice = uint(chainLinkEthPrice / 100000000);
            //return ethPrice = price;
            //price.push(ethPrice);
        }
    
        // Withdraw function for each user 
        function withdraw() public payable {
            require(block.timestamp >= deadline);
            uint amountToWithdraw = lockAmounts[msg.sender];
            lockAmounts[msg.sender] = 0; 
            payable(msg.sender).transfer(amountToWithdraw); 
        }
    }
    





:::NEXT DOC:::

smart contract:

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.12;
    
    import ""./FutNFTTransfer.sol"";
    import ""./VRFConsumer.sol"";
    
    contract FutNFTMatch is FutNFTTransfer, VRFConsumer {
        uint256 public levelPercentSuitablePosition = 75;
        uint256 public levelPercentNoPosition = 50;
        mapping(string => string[]) public formationToPositions;
        string[] public formations;
        string[] public allPositions;
        uint256 public lineupFee = 0.2 ether;
        uint256 public matchFee = 3 ether;
        address[] public lineupSet;
        mapping(address => uint256) public ownersToDeposits;
    
        modifier playersOwned(uint256[11] memory _playerIds) {
            for (uint256 i = 0; i < _playerIds.length; i++) {
                require(ownerOf(_playerIds[i]) == msg.sender, ""Players not owned!"");
            }
            _;
        }
    
        modifier lineUpSet(address _owner) {
            require(lineUps[_owner].isValid, ""Linup not set"");
 

:::NEXT DOC:::

of getPrice : given
        // the amount of ETH, the function will return the current value of such amount of ETH
        // in USD
        // ! ! ! ! ! This function will only work if the ENVIROMENT used is local (METAMASK) - JVMs will not return any value and will lead to a possible error ! ! ! ! !
        function getConvertionRate(uint256 ETH_Amount) public view returns(uint256)
        {
            uint256 ETH_Price = getPrice();                         // Calls getPrice function
            uint256 ETH_AmountInUSD = ETH_Price * ETH_Amount;       // Current ETH pirce * ETH amount
            return ETH_AmountInUSD;                                 // Returns the value of amount ETH in USD
        }
    
        // ***** withdraw *****
        // The following function allows the deployer of the contract (owner) to withdraw
        // the amount of ETH funded to the contract, moreover when the function is called,
        // the funders array will be reset
        function withdraw() payable onlyOwner public                // Check for onlyOwner modifier description at line 77
        {
            payable(msg.sender).transfer(address(this).balance);

:::NEXT DOC:::

uint timeStamp,
                uint80 answeredInRound
            ) = priceFeed.latestRoundData();
            return price;
        }
    

And the function I want to call is this one:

    
    
     AaveLendingPool.borrow(address(USDT),getLatestPrice(), 1, 0, address(this));
    

this is the error I get:

    
    
    TypeError: Type int256 is not implicitly convertible to expected type uint256.
    

I need to convert the int to unit



Answers:
(Answered on: 2021-11-01 02:09:56)


You can typecast the `int` to `uint` using this syntax: `uint256(input)`

Example:

    
    
    pragma solidity ^0.8;
    
    contract MyContract {
        function foo() external {
            borrow(uint256(getLatestPrice()));
        }
        
        function getLatestPrice() internal returns (int256) {
            return 1;
        }
        
        function borrow(uint256 _number) internal {
        }
    }
    





:::NEXT DOC:::

      address _player = ownerOf(_monId);
            rollDice(_player);
    

I have the certainty that the error occurs inside the rollDice function, more
specifically in the call to **requestRandomness**. Apart from that, I cannot
seem to find why the error is hapenning, nor any references to the error
message ( _Below agreed payment_ ) inside any of the dependency contracts.
Cannot find any references online either.

Any help is appreciated, thanks.



Answers:
(Answered on: 2022-01-25 12:56:03)


`Below agreed payment` error message comes from the `sufficientLINK` modifier
of the `VRFCoordinator.sol` contract. You can see it
[here](https://rinkeby.etherscan.io/address/0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B#code#L1157)
and
[here](https://rinkeby.etherscan.io/address/0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B#code#L1016).

Double-check the constructor parameters, especially the `fee` value.

Also, make sure to [fund](https://docs.chain.link/docs/fund-your-contract/)
your smart contract with Rinkeby LINK tokens which you can claim from the
[faucet](https://faucets.chain.link/rinkeby).





:::NEXT DOC:::

Question: (Asked on: 2022-01-23 04:53:39)
underlying.transferFrom in compound docs guide throws this error: ProviderError: Error: Transaction reverted without a reason string hardhat
URL: https://stackoverflow.com/questions/70819228/underlying-transferfrom-in-compound-docs-guide-throws-this-error-providererror

Question Body:


I'm trying to lend to the compound protocol in an App I'm building.

Also following the compound doc & guide here: [Compound Blog
Post](https://medium.com/compound-finance/supplying-assets-to-the-compound-
protocol-ec2cf5df5aa)

After forking the mainnet locally and impersonating an address with large
USDT, I'm now trying to lend to the compound protocol.

In my test, this line `underlying.transferFrom` always fails with this error:
`ProviderError: Error: Transaction reverted without a reason string`

Any suggestions on what could be the reason? I've asked on the compound
discord, and gotten no reply.

Also done lots of research, couldn't find a similar issue... don't know what
else to do.

Below is a sample of my code

Dev Environment: Hardhat  
OS: Windows 10

    
    
    //SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;
    import ""hardhat/console.sol"";
    import ""../interfaces/ICompound.sol"";
    
    contract CompoundController {
        mapping(address => mapping(address => UserInvestedTokenDetails))
            public UserInvestments;
    
        struct UserInvestedTokenDetails {


:::NEXT DOC:::

seems to work fine and the console returns no errors. I am testing
the smart contract on the Kovan network. The problem is encountered when the
user tries to withdraw the ethereums. When he withdraws, only the deposited
ones are returned without the extra ethers being added.

I am new to Solidity so I appreciate any criticism or advice. If there is
something already existing similar to what I am trying to create please let me
know.

    
    
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.6;
    
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    
    
    interface EACAggregatorProxy {
        function latestAnswer() external view returns (int256);
    }
    
    contract oracleLink {
    
        address public manager;
        uint256 public managerDeposit;
        uint256[] public managerDeposits;
    
        constructor() payable {
            manager = msg.sender;
            managerDeposit = msg.value;
            managerDeposits.push(managerDeposit);
        }
    
        function depositVault() public payable {
            require(msg.sender == manager);
        }
    
        address public user;


:::NEXT DOC:::

{
        const contract = await getContract()
        getPrice(contract)
    }
    
    const fundButton = document.getElementById('fund')
    fundButton.addEventListener('click', async () => {
        const fundMe = await getContract()
    })
    
    init()
    

I get the following error in the browser console and have no idea whats the
cause. [](https://i.stack.imgur.com/BZZn1.png)



Answers:
(Answered on: 2021-11-22 13:19:51)


Your deploy script passing the `0x056...` address as the `priceFeed` param of
the constructor.

So the `getPrice()` contract function is then trying to call the
`latestRoundData()` on the `0x056...` address, expecting a response.

However, your contract is deployed on the testnet, and there's no contract on
the `0x056...` address on the testnet
([link](https://testnet.bscscan.com/address/0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE#code))
to return a value, which causes the ""main"" call to revert.





:::NEXT DOC:::

                // Returns the value of amount ETH in USD
        }
    
        // ***** withdraw *****
        // The following function allows the deployer of the contract (owner) to withdraw
        // the amount of ETH funded to the contract, moreover when the function is called,
        // the funders array will be reset
        function withdraw() payable onlyOwner public                // Check for onlyOwner modifier description at line 77
        {
            payable(msg.sender).transfer(address(this).balance);    // This line of code allows the withdrawal, this refers to the contract
    
            for(uint256 funderIndex = 0; funderIndex < funders.length; funderIndex++)   // The following cycle allows the reset of the money
            {                                                                           // value sent by the funders, accessible through mapping
                address funder = funders[funderIndex];
                AddressToAmountFunded[funder] = 0;
            }
    
            funders = new address[] (0);"
What was the issue with the code that caused the error when running the call through the External Adapter?,The issue was with the line that made the artist ID uppercase.,{'source': 'https://stackoverflow.com/questions/69321235/trouble-with-chainlink-external-adapter-making-an-api-call-to-spotify'},The question does not provide enough information to determine the exact issue with the code that caused the error when running the call through the External Adapter.,"Question: (Asked on: 2021-09-24 21:23:50)
Trouble with Chainlink External Adapter making an API call to Spotify
URL: https://stackoverflow.com/questions/69321235/trouble-with-chainlink-external-adapter-making-an-api-call-to-spotify

Question Body:


I made an external adapter from the [Javascript External Adapter Template from
Chainlink](https://github.com/PatrickAlphaC/CL-EA-NodeJS-Template), trying to
use the Client Credentials flow for Spotify's API to return artist data,
documentation listed below.
<https://developer.spotify.com/documentation/general/guides/authorization-
guide/#client-credentials-flow> <https://developer.spotify.com/console/get-
artist/>

and I am able to make the call just fine with this code through Axios
[](https://i.stack.imgur.com/wRacs.png)

but when I try to run the same call through the External Adapter which uses
Axios for it's API calls as well, I get this error.
[](https://i.stack.imgur.com/BPUl6.png)

Here is a snippet of the main code of the external adapter from index.js

    
    
    const customParams = {
      artist: [''],
      
      endpoint: false
    }
    
    const createRequest = (input, callback) => {
      // The Validator helps you validate the Chainlink request data
    
      const apiID = process.env.API_ID
      const apiKey = process.env.API_KEY
    
      let token =

:::NEXT DOC:::

Question: (Asked on: 2022-11-09 23:44:03)
Chainlink node external adapter executes successfully, but keeps returning 0
URL: https://stackoverflow.com/questions/74382639/chainlink-node-external-adapter-executes-successfully-but-keeps-returning-0

Question Body:


I'm trying to build an external adapter for a chainlink node to import API
information. On the chainlink node and API, everything seems like it worked,
however when I try to call the stored value from the smart contract, it's
always 0 despite the logs indicating that it ran successfully.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""Mimi-Fund-EA""
    externalJobID = ""834d2179-321d-49ac-bf63-140635e3a606""
    forwardingAllowed = false
    maxTaskDuration = ""0s""
    contractAddress = ""0xAf644831B57E5625ac64cDa68248b810bE4D4D01""
    minContractPaymentLinkJuels = ""0""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                     

:::NEXT DOC:::

}'

-Edit-

Just to show that the code isn't all totally wrong, I am able to make a call
through the external adapter to this url
<https://jsonplaceholder.typicode.com/posts/5>, passing in the 5 with this
command.

    
    
    curl -X POST -H ""content-type:application/json"" ""http://localhost:8080/"" --data '{ ""id"": 0, ""data"": { """": ""5""} }'

[](https://i.stack.imgur.com/mVyMN.png)



Answers:
(Answered on: 2021-09-24 22:41:53)


The issue was with this line, making the artist ID all uppercase.

    
    
    const artistID = validator.validated.data.artist.toUpperCase() // Changed this 
    const artistID = validator.validated.data.artist // To this





:::NEXT DOC:::

   

Added the Job definition:

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""soccer-data-ea-2""
    contractAddress = ""0x4664A91f79999fd9DD4587dDf3daA3D01Ec50825""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=""ethabidecodelog""
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=""cborparse"" data=""$(decode_log.data)""]
        fetch        [type=bridge name=hackathon requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": {\\""PlayerId\\"": $(decode_cbor.PlayerId)}}""]
        parse        [type=""jsonparse"" path=""data,0,Games"" data=""$(fetch)""]
        encode_data  [type=""ethabiencode"" abi=""(uint256 value)"" data=""{ \\""value\\"": $(parse) }""]
        encode_tx   

:::NEXT DOC:::

Question: (Asked on: 2021-11-01 06:14:40)
&quot;Could not resolve path error&quot; in the jsonparse section in job run for Chainlink external adapter
URL: https://stackoverflow.com/questions/69793208/could-not-resolve-path-error-in-the-jsonparse-section-in-job-run-for-chainlink

Question Body:


I have a job for an external adapter added to my local Chainlink node. It
errors out when I make an initial request. My problem comes down to a syntax
error or using the incorrect path. But I'm not aware of where to find out what
the syntax should be. Or am I getting the path wrong?

Below is my job definition.

    
    
    type = ""directrequest""
    schemaVersion = 1
    name = ""f1latestresults""
    contractAddress = ""0x765aCc258f3a7b2D8d103D1A9310fc51b07D5425""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor 

:::NEXT DOC:::

Adapter which uses
Axios for it's API calls as well, I get this error.
[](https://i.stack.imgur.com/BPUl6.png)

Here is a snippet of the main code of the external adapter from index.js

    
    
    const customParams = {
      artist: [''],
      
      endpoint: false
    }
    
    const createRequest = (input, callback) => {
      // The Validator helps you validate the Chainlink request data
    
      const apiID = process.env.API_ID
      const apiKey = process.env.API_KEY
    
      let token = 'BQDlkzka093OuR4tL7XyaI-Tag4R166FQGBSogBP6hEBxhsCjH8XfMRqs_apKFk0T87FGIrwPtT1bkuGCeE';
    
    
      const validator = new Validator(callback, input, customParams)
      const jobRunID = validator.validated.id
      const endpoint = validator.validated.data.endpoint
      const artistID = validator.validated.data.artist.toUpperCase()
      const url = `https://api.spotify.com/v1/artists/${artistID}`
    
      const params = {
        artistID
      }
    
      // curl -X ""GET""

:::NEXT DOC:::

""columns"": [""blood"",""heath""],
""linesAmount"":500 } }` it returns me a correct payload, in the format that is
expected from the external adapter:

    
    
    {
        ""jobRunID"": 0,
        ""data"": {
            ""ipfsHash"": ""anIpfshashShouldBeHere"",
            ""providers"": [
                ""0x03996eF07f84fEEe9f1dc18B255A8c01A4986701""
            ],
            ""result"": ""anIpfshashShouldBeHere""
        },
        ""result"": ""anIpfshashShouldBeHere"",
        ""statusCode"": 200
    }
    

The problem is, in the chainlink node, specifically in the `fetch` method it
gives me an error: `error making http request: Post ""http://localhost:8080"":
dial tcp 127.0.0.1:8080: connect: connection refused`

Is it related to the docker container? I don't see why it wouldn't be able to
request resuources from another port in the same machine. Am I missing some
configuration maybe? From what I've read from the docs it's possible to run
the adapter locally. Below, a picture with more information:

[](https://i.stack.imgur.com/MnUK7.png)



Answers:
(Answered on: 2022-05-27 07:43:44)


If you're External Adapter (EA) is running on

:::NEXT DOC:::

       at Module._compile (internal/modules/cjs/loader.js:1137:30)
        at Object.Module._extensions..js (internal/modules/cjs/loader.js:1157:10)
    

The README mentions that some require environmental variables, but I don't see
anything mentioned in `coingecko` and I'm not having any luck with the other
adapters either.



Answers:
(Answered on: 2021-10-09 17:11:16)


Thanks to help in the Discord, I was able to resolve my issue. I was using an
old version of node and needed to upgrade! The separate, but related,
[Chainlink Node Operator
repo](https://github.com/smartcontractkit/chainlink#install) README has Node
v12 hardcoded in its setup process, which won't work when running the External
Adapter repo.





:::NEXT DOC:::

Question: (Asked on: 2023-03-20 23:59:34)
Chainlink jobs returns error if external adapter takes too long for response
URL: https://stackoverflow.com/questions/75796310/chainlink-jobs-returns-error-if-external-adapter-takes-too-long-for-response

Question Body:


I am encountering this error when running a job via my own chainlink node even
though the external adapter is returning the data properly. `HTTP request
timed out or interrupted` This error is triggered during the ""fetch"" function
of the job. I have figured that the error is triggered because my external
adapter is taking some time to respond. Is there any way I can make my
chainlink node wait longer?

I tried a response with dummy data that did not require any API to fetch and
the job ran perfectly. The error has been fixed by the given answer.

However now after the job sends the data back to my oracle,
FulfillOracleRequest2 is not executing.
[](https://i.stack.imgur.com/naP0g.png)



Answers:
(Answered on: 2023-03-21 12:09:25)


Try increasing the DEFAULT_HTTP_TIMEOUT setting in your nodes configuration

<https://docs.chain.link/chainlink-
nodes/v1/configuration#default_http_timeout>





:::NEXT DOC:::

Question: (Asked on: 2021-11-25 05:14:50)
Chain Link Job decode_log.data not found
URL: https://stackoverflow.com/questions/70106105/chain-link-job-decode-log-data-not-found

Question Body:


I am trying to use an external adapter to take in parameters for off-chain
computation. The job seems to fail before it even gets to the external adapter
because it is unable to find a data key that seems to exist. (below)

    
    
    requestData: key decode_cbor / keypath decode_cbor.userId: keypath not found
    
    data: key decode_log / keypath **decode_log.data**: keypath not found
    
    decode_log ethabidecodelog
   "
What is the difference between an agreement and a contract?,"Contracts are agreements that are enforceable in a court of law, while agreements are oftentimes informal and not legally binding.",{'source': 'https://github.com/oceanByte/chainlink-education/blob/a0b8886bd664423b40c8bd3661fdb7d61e975ea2/src/api/src/shared/course/courses/chainlinkIntroduction/Chapters/Chapter-2/course.md'},"An agreement is a concept that can be spoken orally, written down on paper, or even typed in digital documents, but its enforcement is oftentimes informal and based on factors such as reputation impact. On the other hand, a contract is an agreement that is enforceable in a court of law and once made, it is expected to be executed as written and enforced by a court of law.","concepts that humans seem to universally have an intuition on across cultures. Maybe as a child you agreed to trade 3 of your toys for 1 friend’s rare toy.

![The San Juan Mountains are beautiful!](/image_md.png ""test image"")

Or maybe you’ve agreed to lend your car to your friend as long as they don’t put more than 100 miles on it and bring it back with a full tank. Or maybe you make an agreement with your health coach that you wont eat more than 2,500 calories a day.

<BlueParagraph>
    These are all examples of agreements and agreements can be spoken orally, written down on paper, or even typed in digital documents. Enforcement of agreements are handled outside of courts: you will probably lose trust in your friend who brings back your car with 600 miles on it and an almost empty tank of gas.
</BlueParagraph>

Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Thus enforcement of standard agreements is often kind of “wishy washy” and based on many hard measure factors such as reputation impact.

Contracts are agreements that are enforceable in a court of law. Maybe you’ve signed a leasing contract to rent an apartment or house. Perhaps you’ve run a restaurant and signed a futures contract with food suppliers to get corn at a specific price and time no matter what happens in the corn market.

Or perhaps you’ve signed an employment agreement with the company you work for on what your pay rate will be and what benefits you will have. Either way, once these contractual agreements have been made it is expected that if they are not executed how they were written they will be enforced by a court of law i.e. a government and

:::NEXT DOC:::

#####Chapter 2:

# What are Contracts?

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
    </div>
  </div>
</ContentWrapp>

Agreements, deals, promises: these are concepts that humans universally have an intuition for across cultures. Maybe you agreed to trade three of your toys for one friend’s rare toy as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as

:::NEXT DOC:::

as a child. Perhaps you’ve decided to lend your car to a friend as long as they don’t put more than 100 miles on it and return it with a full tank. You may have even agreed with your health coach not to eat more than 2,500 calories per day.

These are all examples of agreements. Agreements can be spoken orally, written down on paper, or even typed in digital documents. The enforcement of such agreements is oftentimes informal and “wishy washy.” Disagreement is handled outside of courts or other formal institutions: a friend who brings back your car with 600 miles on it and an almost empty tank of gas loses your trust. Your health coach will be very disappointed in you if you’ve eaten 5,000 calories a day for the past week. Though factors such as reputation, magnitude, and parties within an agreement can affect its enforcement, there is no guarantee that an agreement will be fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting

:::NEXT DOC:::

5,000 calories a day for the past week. Thus enforcement of standard agreements is often kind of “wishy washy” and based on many hard measure factors such as reputation impact.

Contracts are agreements that are enforceable in a court of law. Maybe you’ve signed a leasing contract to rent an apartment or house. Perhaps you’ve run a restaurant and signed a futures contract with food suppliers to get corn at a specific price and time no matter what happens in the corn market.

Or perhaps you’ve signed an employment agreement with the company you work for on what your pay rate will be and what benefits you will have. Either way, once these contractual agreements have been made it is expected that if they are not executed how they were written they will be enforced by a court of law i.e. a government and the power they have.


:::NEXT DOC:::

or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue"" href=""https://www.jama.work/blog/on-robinhood-and-availability""> Robinhood Gamestop downtime incident</a>.

<MissionContainer>
  <div className=""title"">What are the SLAs you have agreed to?</div>
    <div className=""description"">
    Think about any digital services you subscribe to, for example video streaming or banking services. Do you know the terms of the SLAs between you and the service provider? If not, take the time and read over one of them.
    </div>
</MissionContainer>


:::NEXT DOC:::

fulfilled.

Contracts are agreements that are enforceable in a court of law. You may have signed a leasing contract to rent an apartment or house. Restaurateurs typically sign contracts with food suppliers to obtain necessary ingredients at a specific price and time no matter what happens in different food markets. You may sign an employment agreement with a company to establish your pay rate and employee benefits. In any form, once these contractual agreements have been made, they are enforced by a court of law. Any clause that is not fulfilled within a contract can be disputed and discussed within the court.

<MissionContainer>
  <div className=""title"">Arbitration Court</div>
    <div className=""description"">
    In fact, legal contracts have become so notoriously difficult to enforce more companies have been putting ""arbitration"" clauses in their contracts. This means a private arbitration court is used to uphold the contract rather than a public judicial court. There has been a lot of controversy surrounding arbitration courts. You can read more about the history of arbitration courts in <a href=""https://www.americanbar.org/groups/tort_trial_insurance_practice/publications/the_brief/2018-19/summer/a-brief-history-arbitration/""> this article by the American Bar Association </a>.
    </div>
</MissionContainer>


:::NEXT DOC:::

#####Chapter 3:

# Digital Agreements - What we have Today

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
    When you buy an artwork on an online platform, you must agree to the Service Level Agreements. They are usually overly complex and can be challenging to understand. They primarily benefit the platform owner, not the users.
    </div>
  </div>
</ContentWrapp>

Digital agreements have been the most common format of agreements in the past decade. From bank agreements to social media, to Netflix, and crypto exchanges, companies who provide services on the internet typically use digital agreements to detail the exact conditions of the service to be provided. These are called SLAs or Service Level Agreements.

What makes a digital agreement different from a regular agreement or contractual agreement? Well they’re like regular agreements….but in a digital format. These agreements can be enforced in a court of law under certain circumstances. However, this doesn’t often happen due to the costs of going to court coupled with the low value these contracts represent for individual consumers.

Customers also tend not to read these agreements due to lengthy, complex legalese. Oftentimes digital agreements give consumers very little recourse at all! Due to these reasons, the power of digital agreements is heavily skewed towards the institutions who create them rather than being a fair, equitable agreement between institutions and their consumers. A prime example of this is the <a style=""color:blue""

:::NEXT DOC:::

#####Chapter 1:

What will this course cover?
=============================

***Chainlink, smart contracts, blockchains, and the entire world of cryptocurrency have been a hot topic of discussion for several years now.***

Whether it’s companies like EY and Microsoft looking to use smart contracts to improve their business processes, artists and athletes like LaMelo Ball creating their own“NFTs”, or up and coming companies looking to disrupt long standing industries such as insurance, Chainlink and smart contracts are looking to be the backbone for world changing applications.

The future of the internet, dubbed Web3.0, is being built in front of our eyes so let's dive in and start building the future! But wait, Chainlink? Smart contracts? Doesn’t blockchain have something to do with that Bitcoin stuff some people buy? In this course we will build up the intuition on what Chianlink is and the problems it solves.

## What are Contracts?
Agreements, deals, promises; these are concepts that humans seem to universally have an intuition on across cultures. Maybe as a child you agreed to trade 3 of your toys for 1 friend’s rare toy.

![The San Juan Mountains are beautiful!](/image_md.png ""test image"")

Or maybe you’ve agreed to lend your car to your friend as long as they don’t put more than 100 miles on it and bring it back with a full tank. Or maybe you make an agreement with your health coach that you wont eat more than 2,500 calories a day.

<BlueParagraph>
    These are all examples of agreements and agreements can be spoken orally, written down on paper, or even typed in digital documents. Enforcement of agreements are handled outside of courts: you will probably lose

:::NEXT DOC:::

Smart contracts result from the evolution of digital agreements. A Smart contract is a self-executing contract with the terms of the agreement being directly written into computer code.


:::NEXT DOC:::

When you buy an artwork, you sign a contract between you and the artist or seller. This contract provides you with proof of ownership of the artwork. But it is possible to forge it and not follow the agreement. The seller could decide not to send the artwork to you though you already paid for it.
"
What is the purpose of the 'requestVolumeData' function?,To create a Chainlink request to retrieve API response and find the target data.,{'source': 'https://stackoverflow.com/questions/69297267/chainlink-api-get-request-isnt-returning-a-value'},"The purpose of the 'requestVolumeData' function is to build and send a Chainlink request to retrieve data from an API, and then process the response by extracting the desired data and multiplying it by a large number to remove decimal places. The function returns a request ID.","find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) {
            Chainlink.Request memory req = buildChainlinkRequest(
                jobId,
                address(this),
                this.fulfill.selector
            );
    
            // Set the URL to perform the GET request on
            req.add(
                ""get"",
                ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
            );
    
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"": xxx.xxx,
            //     }
            //    }
            //   }
            //

:::NEXT DOC:::

                                                                 *
         ************************************************************************************/
        function requestVolumeData() public returns (bytes32 requestId) {
            
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
        
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //      {""ETH"":
            //          {""USD"":
            //              {
            //                  ...,
            //                  ""VOLUME24HOUR"": xxx.xxx,
            //                 

:::NEXT DOC:::

 }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            // ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
            
            request.add(""get"", ""http://api.weatherstack.com/current?access_key=7940b0c1136901badcb304724132b234&query=Mumbai"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"": xxx.xxx,
            //     }
   

:::NEXT DOC:::

      */
        constructor() {
            // setPublicChainlinkToken();
            setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
            oracle = 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7;
            jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
            fee = 0.1 * 10 ** 18; // 0.1 LINK
        }
        
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
            
            request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR"");
            
            // Multiply the result by 1000000000000000000 to remove decimals
            int timesAmount = 10**18;
           

:::NEXT DOC:::

              STOP!                                         * 
         *         THIS FUNCTION WILL FAIL IF THIS CONTRACT DOES NOT OWN LINK               *
         *         ----------------------------------------------------------               *
         *         Learn how to obtain testnet LINK and fund this contract:                 *
         *         ------- https://docs.chain.link/docs/acquire-link --------               *
         *         ---- https://docs.chain.link/docs/fund-your-contract -----               *
         *                                                                                  *
         ************************************************************************************/
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
         

:::NEXT DOC:::

             * 
         *         THIS FUNCTION WILL FAIL IF THIS CONTRACT DOES NOT OWN LINK               *
         *         ----------------------------------------------------------               *
         *         Learn how to obtain testnet LINK and fund this contract:                 *
         *         ------- https://docs.chain.link/docs/acquire-link --------               *
         *         ---- https://docs.chain.link/docs/fund-your-contract -----               *
         *                                                                                  *
         ************************************************************************************/
        function requestVolumeData() public returns (bytes32 requestId) {
            
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
          

:::NEXT DOC:::

           jobId = ""88cafd3ae04b453d952126372a9c1ab0"";
            fee = 0.1 * 10 ** 18; // (Varies by network and job)
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"": xxx.xxx,
            //     }
            //    }
            //   }
      

:::NEXT DOC:::

           jobId = ""c51694e71fa94217b0f4a71b2a6b565a"";
            fee = 0.1 * 10 ** 18; // (Varies by network and job)
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""VOLUME24HOUR"":

:::NEXT DOC:::

             *
         *                                                                                  *
         ************************************************************************************/
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""http://dummy.restapiexample.com/api/v1/employees"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //      {""ETH"":
            //          {""USD"":
            //              {
            //                  ...,
            //                  ""VOLUME24HOUR"": xxx.xxx,
      

:::NEXT DOC:::

jobId = ""7401f318127148a894c00c292e486ffd"";
            fee = 0.1 * 10 ** 18; // (Varies by network and job)
        }
        
        /**
         * Create a Chainlink request to retrieve API response, find the target
         * data, then multiply by 1000000000000000000 (to remove decimal places from data).
         */
        function requestVolumeData() public returns (bytes32 requestId) 
        {
            Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            // Set the URL to perform the GET request on
            request.add(""get"", ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD"");
            
            // Set the path to find the desired data in the API response, where the response format is:
            // {""RAW"":
            //   {""ETH"":
            //    {""USD"":
            //     {
            //      ""MARKET"": ""CCCAGG"",
            //     }
       "
What is the purpose of the contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code?,The contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code is a Chainlink Aggregator contract.,{'source': 'https://stackoverflow.com/questions/73734527/create-an-oracle-on-a-new-chain'},The purpose of the contract deployed at https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code is to serve as a Chainlink Aggregator contract for fetching token price data.,"Question: (Asked on: 2022-09-15 16:22:42)
Create an oracle on a new chain
URL: https://stackoverflow.com/questions/73734527/create-an-oracle-on-a-new-chain

Question Body:


If I deploy a contract like this one on a new chain:

<https://rinkeby.etherscan.io/address/0x8A753747A1Fa494EC906cE90E9f37563A8AF630e#code>

Then I will still need some way to feed it data. How would I do this?



Answers:
(Answered on: 2022-09-16 05:24:19)


What you deployed is a Chainlink Aggregator contract, you do not need to
deploy Aggregator contract to get the token price data.

If you want to get some token price data in your contract, you should use
AggregatorInterface in your contract and then fetch price data from the
Aggregator contract deployed by Chainlink team. Instructions can be found
[here](https://docs.chain.link/docs/get-the-latest-price/).





:::NEXT DOC:::

                       |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 84531                                      |
| Address        | 0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3 |
| Name           | Chainlink Token on the BASE Goerli testnet |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | goerli.basescan.org                        |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/link-token-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

to approve the transaction and spend your testnet ETH required to deploy the contract.

  9. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  10. Click the `message` variable. Remix retrieves and prints the initial message that you set.

The contract has an address just like your wallet address. If you save this
address, you can return to your deployed contract at any time to retrieve
variables or execute functions. To see details about your deployed contract,
copy the contract address from the list in Remix and search for it in the
[Etherscan Sepolia Testnet Explorer](https://sepolia.etherscan.io/).

## Run functions in your contract

Because you deployed the contract to an actual blockchain, several nodes on
the test network confirmed your payment for the smart contract. The contract,
its variables, and its functions remain in the blockchain permanently. To
change the `message` variable that is stored with your contract, run the
`updateMessage` function.

  1. In your deployed contract, enter a new message next to the `updateMessage` function.

  2. Click the `updateMessage` button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.

  3. In the new MetaMask prompt, click **Confirm** to approve the transaction.

  4. Click the `message` variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

Now you know how to deploy example contracts to a test network and run the
functions in those contracts. You can write your own contracts and test them
using this same process.

Next, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds)
guide to learn how to connect your smart contracts to Chainlink Data Feeds and
retrieve on-chain data that

:::NEXT DOC:::

             return false;
            }
        }
    }
    

For this example, `override` is necessary in the `Test` contract function
because it overrides the base function contained in the `numberComparison`
interface. The contract uses `pure` instead of `view` because the `isSameNum`
function in the `Test` contract does not return a storage variable.

## What does ""deploying"" mean?

**Deploying** a smart contract is the process of pushing the code to the
blockchain, at which point it resides with an on-chain address. Once it's
deployed, the code cannot be changed and is said to be _immutable_.

As long as the address is known, its functions can be called through an
interface, on [Etherscan](https://etherscan.io/), or through a library like
[web3js](https://web3js.readthedocs.io/),
[web3py](https://web3py.readthedocs.io/), [ethers](https://docs.ethers.io),
and more. Contracts can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the

:::NEXT DOC:::

import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";
        
        contract FundMe {
            
            mapping(address => uint256) public addressToAmountFunded;
            function fund() public payable {
                addressToAmountFunded[msg.sender] += msg.value;
            }
            
            function getVersion() public view returns(uint256) {
                AggregatorV3Interface priceFeed = AggregatorV3Interface(0x01BE23585060835E02B77ef475b0Cc51aA1e0709);
                return priceFeed.version();
            }
        }
    



Answers:
(Answered on: 2021-09-14 18:04:06)


So I found an answer to my question. I was using the wrong Ethereum Data Feed
Address. I updated address to **0x8A753747A1Fa494EC906cE90E9f37563A8AF630e**
which is for ETH/USD on Rinkeby Test Net and it compiles and deploys perfectly
with no errors





:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

 

:::NEXT DOC:::

      LINK.balanceOf(address(this))
                );
        }
    }
    

Your RemixIDE file explorer should display the opened contracts:

### Select the correct RemixIDE environment

Under _DEPLOY & RUN TRANSACTIONS_:

  1. Set the Environment to _Injected Provider - Metamask_ :

  2. On Metamask, connect your Ganache account to the Remix IDE.

  3. Click on Connect. The RemixIDE environment should be set to the correct environment, and the account should be the Ganache account.

### Deploy VRFCoordinatorV2Mock

  1. Open _VRFCoordinatorV2Mock.sol_.

  2. Under _DEPLOY & RUN TRANSACTIONS_, select _VRFCoordinatorV2Mock_.

  3. Under _DEPLOY_ , fill in the `_BASEFEE` and `_GASPRICELINK`. These variables are used in the _VRFCoordinatorV2Mock_ contract to represent the base fee and the gas price (in LINK tokens) for the VRF requests. You can set: `_BASEFEE=100000000000000000` and `_GASPRICELINK=1000000000`.

  4. Click on _transact_ to deploy the _VRFCoordinatorV2Mock_ contract.

  5. A Metamask popup will open. Click on _Confirm_.

  6. Once deployed, you should see the _VRFCoordinatorV2Mock_ contract under _Deployed Contracts_.

  7. Note the address of the deployed contract.

### Deploy MockV3Aggregator

The _MockV3Aggregator_ contract is designed for testing purposes, allowing you
to simulate an oracle price feed without interacting with the existing
Chainlink network.

  1. Open

:::NEXT DOC:::

address are regularly confused):

`0x6a61789194260F0BE95a18d0116d883A4b5284ed` is the address of your Chainlink
node (you can see in the key tab of the GUI), which needs to be funded with
ETH in order to send transactions on-chain. The Chainlink node listens to
event logs emitted by the oracle smart contract used in the job spec, the
oracle address is not the account you used to deploy it, but the address of
the newly deployed oracle smart contract, make sure to follow these steps:
<https://docs.chain.link/docs/fulfilling-requests/#deploy-your-own-oracle-
contract>

You can find the oracle contract address in Remix and the block explorer of
the underlying network, that's what you need to use in your consumer contract
in order to make successful requests, the LINK rewards can then be withdrawn
from the oracle contract.





:::NEXT DOC:::

contract: You will compile and deploy this example contract to the StarkNet Goerli testnet where it can read and store values from one of the [data feed proxy contracts](https://docs.chain.link/data-feeds/price-feeds/addresses?network=starknet). The proxy address is defined in the constructor when you deploy the contract.
  * The [deployConsumer.ts](https://github.com/smartcontractkit/chainlink-starknet/tree/develop/examples/contracts/proxy-consumer/scripts/deployConsumer.ts) script: This script uses [StarkNet.js](https://www.starknetjs.com/) to identify your OpenZeppelin wallet and deploy the compiled contract.
  * The [readLatestRound.ts](https://github.com/smartcontractkit/chainlink-starknet/tree/develop/examples/contracts/proxy-consumer/scripts/readLatestRound.ts) script: This script submits an invoke transaction on the `get_stored_round` function in your contract and prints the result.

Build, deploy, and invoke the example contract:

  1. Find the account address and private key for your funded StarkNet testnet account. By default, the OpenZeppelin wallet contains these values at `~/.starknet_accounts/starknet_open_zeppelin_accounts.json`.

  2. Export your address to the `DEPLOYER_ACCOUNT_ADDRESS` environment variable and your private key to the `DEPLOYER_PRIVATE_KEY` environment variable.
    
        export DEPLOYER_ACCOUNT_ADDRESS=<YOUR_WALLET_ADDRESS>
    
        export DEPLOYER_PRIVATE_KEY=<YOUR_KEY>

  3. In the `./chainlink-starknet/examples/contracts/proxy-consumer/` directory, run `yarn build` to run Hardhat and create `./starknet-artifacts/` with the compiled contracts. The"
What is the recommended way to match randomness requests with their corresponding fulfillments?,We recommend using the `requestID` to match randomness requests with their corresponding fulfillments.,{'source': 'https://docs.chain.link/vrf/v1/security/'},The recommended way to match randomness requests with their corresponding fulfillments is to use the `requestID`.,"after you have made a randomness request
  * `fulfillRandomness` must not revert
  * Use `VRFConsumerBase` in your contract, to interact with the VRF service

## Use `requestId` to match randomness requests with their fulfillment in
order

If your contract could have multiple VRF requests in flight simultaneously,
you must ensure that the order in which the VRF fulfillments arrive cannot be
used to manipulate your contract's user-significant behavior.

Blockchain miners/validators can control the order in which your requests
appear on-chain, and hence the order in which your contract responds to them.

For example, if you made randomness requests `A`, `B`, `C` in short
succession, there is no guarantee that the associated randomness fulfillments
will also be in order `A`, `B`, `C`. The randomness fulfillments might just as
well arrive at your contract in order `C`, `A`, `B` or any other order.

We recommend using the `requestID` to match randomness requests with their
corresponding fulfillments.

## Choose a safe block confirmation time, which will vary between blockchains

In principle, miners and validators of your underlying blockchain could
rewrite the chain's history to put a randomness request from your contract
into a different block, which would result in a different VRF output. Note
that this does not enable a miner to determine the random value in advance. It
only enables them to get a fresh random value that may or not be to their
advantage. By way of analogy, they can only re-roll the dice, not predetermine
or predict which side it will land on.

You must choose an appropriate confirmation time for the randomness requests
you make (i.e. how many blocks the the VRF service waits before writing a
fulfillment to the chain) to make such rewrite attacks unprofitable in the
context of your application and its value-at-risk.

On

:::NEXT DOC:::

     bytes32 requestId =  requestRandomness(keyHash, fee);
        requestIdToAddress[requestId] = msg.sender;
    }
    
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        address requestAddress = requestIdToAddress[requestId];
    }

If you want to keep order when a request was made, you might want to use a
mapping of `requestId` to the index/order of this request.


    mapping(bytes32 => uint256) public requestIdToRequestNumberIndex;
    uint256 public requestCounter;
    
    function getRandomNumber() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
        bytes32 requestId =  requestRandomness(keyHash, fee);
        requestIdToRequestNumberIndex[requestId] = requestCounter;
        requestCounter += 1;
    }
    
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        uint256 requestNumber = requestIdToRequestNumberIndex[requestId];
    }

If you want to keep generated random numbers of several VRF requests, you
might want to use a mapping of `requestId` to the returned random number.


    mapping(bytes32 => uint256) public requestIdToRandomNumber;
    
    function getRandomNumber() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
        return requestRandomness(keyHash, fee);
 

:::NEXT DOC:::

# VRF Security Considerations

  * Overview
  * Use requestId to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * fulfillRandomWords must not revert
  * Use VRFConsumerBaseV2 in your contract, to interact with the VRF service
  * Use VRFv2WrapperConsumer.sol in your contract, to interact with the VRF service

Gaining access to high quality randomness on-chain requires a solution like
Chainlink's VRF, but it also requires you to understand some of the ways that
miners or validators can potentially manipulate randomness generation. Here
are some of the top security considerations you should review in your project.

  * Use `requestId` to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * The `fulfillRandomWords` function must not revert
  * Use `VRFConsumerBaseV2` in your contract to interact with the VRF service

## Use `requestId` to match randomness requests with their fulfillment in
order

If your contract could have multiple VRF requests in flight simultaneously,
you must ensure that the order in which the VRF fulfillments arrive cannot be
used to manipulate your contract's user-significant behavior.

Blockchain miners/validators can control the order in which your requests
appear on-chain, and hence the order in which your contract responds to them.

For example, if you made randomness requests `A`, `B`, `C` in short
succession, there is no guarantee that the associated randomness fulfillments
will also be in order `A`, `B`, `C`. The randomness

:::NEXT DOC:::

  }
    
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        uint256 requestNumber = requestIdToRequestNumberIndex[requestId];
    }

If you want to keep generated random numbers of several VRF requests, you
might want to use a mapping of `requestId` to the returned random number.


    mapping(bytes32 => uint256) public requestIdToRandomNumber;
    
    function getRandomNumber() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, ""Not enough LINK - fill contract with faucet"");
        return requestRandomness(keyHash, fee);
    }
    
    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        requestIdToRandomNumber[requestId] = randomness;
    }

Feel free to use whatever data structure you prefer.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v1/best-practices.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Randomness is essential for many types of applications. Think about how many games have randomness built-in. Rolling dice in dungeons and dragons, a random starting hand of poker, or a random next block in Tetris, randomness is an essential component of a majority of games.


:::NEXT DOC:::

         requests[requestId] = Variable.C;
            }
        }
    
        function fulfillRandomWords(
            uint256 requestId,
            uint256[] memory randomWords
        ) internal override {
            Variable variable = requests[requestId];
            if (variable == Variable.A) {
                fulfillA(requestId, randomWords[0]);
            } else if (variable == Variable.B) {
                fulfillB(requestId, randomWords[0]);
            } else if (variable == Variable.C) {
                fulfillC(requestId, randomWords[0]);
            }
        }
    
        function fulfillA(uint256 requestId, uint256 randomWord) private {
            // execution path A
            variableA = randomWord;
            emit FulfilledA(requestId, randomWord);
        }
    
        function fulfillB(uint256 requestId, uint256 randomWord) private {
            // execution path B
            variableB = randomWord;
            emit FulfilledB(requestId,

:::NEXT DOC:::

# VRF Security Considerations [v1]

  * Overview
  * Use requestId to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * fulfillRandomness must not revert
  * Use VRFConsumerBase in your contract, to interact with the VRF service

VRF v2 replaces and enhances VRF v1.

See the [VRF v2 documentation](/vrf/v2/introduction) to learn more.

Gaining access to high quality randomness on-chain requires a solution like
Chainlink's VRF, but it also requires you to understand some of the ways that
randonmess generation can be manipulated by miners/validators. Here are some
of the top security considerations you should review in your project.

  * Use `requestId` to match randomness requests with their fulfillment in order
  * Choose a safe block confirmation time, which will vary between blockchains
  * Do not re-request randomness
  * Don't accept bids/bets/inputs after you have made a randomness request
  * `fulfillRandomness` must not revert
  * Use `VRFConsumerBase` in your contract, to interact with the VRF service

## Use `requestId` to match randomness requests with their fulfillment in
order

If your contract could have multiple VRF requests in flight simultaneously,
you must ensure that the order in which the VRF fulfillments arrive cannot be
used to manipulate your contract's user-significant behavior.

Blockchain miners/validators can control the order in which your requests
appear on-chain, and hence the order in which your contract responds to them.

For example, if you made randomness requests `A`, `B`, `C` in short
succession, there is no guarantee that the associated randomness

:::NEXT DOC:::

Question: (Asked on: 2021-12-11 06:24:49)
VRF fulfillRandomness guarantees
URL: https://stackoverflow.com/questions/70313054/vrf-fulfillrandomness-guarantees

Question Body:


Is it guaranteed that Chainlink will eventually callback the
`fulfillRandomness(bytes32, uint256)` function? How do we detect if a failure
happened and respond to it? I don’t want my application to get stuck if the
nodes fail and don’t respond. (Apologies if this is a dumb question, but I’ve
read the docs here [https://docs.chain.link/docs/chainlink-vrf-best-practices]
and don’t see anything on the topic).

Reference: <https://docs.chain.link/docs/get-a-random-number/>



Answers:
(Answered on: 2022-08-11 11:56:37)


According to [here](https://docs.chain.link/docs/chainlink-
vrf/#subscriptions), in case of you don't have enough fund for your consumer
requests, your requests remain pending for up to 24 hours before expire, and
requests will process automatically after have sufficient LINK.

It doesn't explain what happens to the request after 24 hours, but my guess is
the request expires and won't get another chance to process forever.





:::NEXT DOC:::

      }
        }
    
        function fulfillA(uint256 requestId, uint256 randomWord) private {
            // execution path A
            variableA = randomWord;
            emit FulfilledA(requestId, randomWord);
        }
    
        function fulfillB(uint256 requestId, uint256 randomWord) private {
            // execution path B
            variableB = randomWord;
            emit FulfilledB(requestId, randomWord);
        }
    
        function fulfillC(uint256 requestId, uint256 randomWord) private {
            // execution path C
            variableC = randomWord;
            emit FulfilledC(requestId, randomWord);
        }
    }
    

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/vrf/v2/best-practices.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

in a casino and see that red has appeared ten times behind in a row, you might believe that it’s more likely that the next color will be black. But as soon as you apply statistics, you must admit that there is no reason to assume that the next color is more likely to be black. The occurrence is random.

Several other fallacies should make us very cautious in trusting our intuitive understanding of statistics and randomness. As dependencies get more complex or hidden and the numbers increase, we tend to lose the ability to assess probabilities correctly and intuitively. So we will look a little deeper into randomness and the difficulty for deterministic systems like blockchains to create randomness at the beginning of this course. Once we understand the challenges, we will look into potential solutions to this problem and especially learn more about Verifiable Random Functions. Equipped with this new knowledge, we will get practical and will understand how to create subscriptions and add consumer contracts programmatically. At this point, you should have a good understanding of randomness and how to use VRF v2 in your applications. So the final chapters will focus on common pitfalls you should avoid while using VRF v2.
"
