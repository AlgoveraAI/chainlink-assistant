question,answer,result,right_or_wrong,retrieved_docs,rd_right_or_wrong
give me a sample solidity contract to use Chainlink price feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","
The following is a sample Solidity contract to use Chainlink price feeds:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*",partial,"# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right
give me a sample solidity contract to use Chainlink VRF?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFD20 is VRFConsumerBaseV2 {

}
uint64 s_subscriptionId;
address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
uint32 callbackGasLimit = 40000;
uint16 requestConfirmations = 3;
uint32 numWords =  1;
)
(
give me a sample solidity contract to request data from a public API in a smart contract using chainlink?,
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req.add(
            ""get"",
            ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {""RAW"":
        //   {""ETH"":
        //    {""USD"":
        //     {
        //      ""VOLUME24HOUR"": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR""); // Chainlink nodes prior to 1.0.0 support this format
        req.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR""); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req.addInt(""times"", timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            ""Unable to transfer""
        );
    }
}","

// SPDX-License-Identifier: MIT
// An example of a consumer contract that directly pays for each request.
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol"";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract VRFv2DirectFundingConsumer is VRFV",partial,"`VRFv2Consumer.sol` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Provider** environment, select the `VRFv2Consumer` contract from the contract list, and specify your `subscriptionId` so the constructor can set it.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must add this address as an approved consuming contract on your subscription account.

  6. Open the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/) and click the ID of your new subscription under the **My Subscriptions** list. The subscription details page opens.

  7. Under the **Consumers** section, click **Add consumer**.

  8. Enter the address of your consuming contract that you just deployed and click **Add consumer**. MetaMask opens and asks you to confirm the transaction.

Your example contract is deployed and approved to use your subscription
balance to pay for VRF v2 requests. Next, request random values from Chainlink
VRF.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF processes your request. Chainlink VRF fulfills the request and returns the random values to your contract in a callback to the `fulfillRandomWords()` function. At this point, a new key `requestId` is added to the mapping `s_requests`.

Depending on current testnet conditions, it might take a few minutes for the
callback to return the requested random values to your contract. You can see a
list of pending requests for your subscription ID at
[vrf.chain.link](https://vrf.chain.link/).

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated: The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` specifying the `requestId` to display the random words.

You deployed a simple contract that can request and receive random values from
Chainlink VRF. To see more advanced examples where the contract can complete
the entire process including subscription setup and management, see the
[Programmatic Subscription](/vrf/v2/subscription/examples/programmatic-subscription) page.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, your MetaMask wallet is the subscription owner and you
created a consuming contract to use that subscription. The consuming contract
uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that relies on a subscription for funding.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    import

:::NEXT DOC:::

in Remix, compile the `VRFv2DirectFundingConsumer` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Web3 Environment** and select the `VRFv2DirectFundingConsumer` contract from the contract list.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must fund your consuming contract with enough LINK tokens in order to request for randomness. Next, fund your contract.

## Fund Your Contract

Requests for randomness will fail unless your consuming contract has enough
LINK.

  1. [Acquire testnet LINK](/resources/acquire-link).
  2. [Fund your contract with testnet LINK](/resources/fund-your-contract). For this example, funding your contract with 2 LINK should be sufficient.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them, and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _400,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _400000_ and select **Save**.
Finally, confirm the transaction.

After you approve the transaction, Chainlink VRF processes your request.
Chainlink VRF fulfills the request and returns the random values to your
contract in a callback to the `fulfillRandomWords()` function. At this point,
a new key `requestId` is added to the mapping `s_requests`. Depending on
current testnet conditions, it might take a few minutes for the callback to
return the requested random values to your contract.

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated. The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` and specify the `requestId` to display the random words.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, the consuming contract uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import

:::NEXT DOC:::

randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, your MetaMask wallet is the subscription owner and you
created a consuming contract to use that subscription. The consuming contract
uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that relies on a subscription for funding.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2Consumer is VRFConsumerBaseV2, ConfirmedOwner {
        event RequestSent(uint256 requestId, uint32 numWords);
        event RequestFulfilled(uint256 requestId, uint256[] randomWords);
    
        struct RequestStatus {
            bool fulfilled; // whether the request has been successfully fulfilled
            bool exists; // whether a requestId exists
            uint256[] randomWords;
        }
        mapping(uint256 => RequestStatus)
            public s_requests; /* requestId --> requestStatus */
        VRFCoordinatorV2Interface COORDINATOR;
    
        // Your subscription ID.
        uint64 s_subscriptionId;
    
        // past requests Id.
        uint256[] public requestIds;
        uint256 public lastRequestId;
    
        // The gas lane to use, which specifies the maximum gas price to bump to.
        // For a list of available gas lanes on each network,
        // see https://docs.chain.link/docs/vrf/v2/subscription/supported-networks/#configurations
        bytes32 keyHash =
            0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;
    
        // Depends on the number of requested values that you want sent to the
        // fulfillRandomWords() function. Storing each word costs about 20,000 gas,
        // so 100,000 is a safe default for this example contract. Test and adjust
        // this limit based on the network that you select, the size of the request,
        // and the processing of the callback request in the fulfillRandomWords()


:::NEXT DOC:::

# Get a Random Number

  * Overview
  * Requirements
  * Create and deploy a VRF v2 compatible contract
  * Fund Your Contract
  * Request random values
  * Analyzing the contract
  * Clean up

You are viewing the VRF v2 guide - Direct funding method.

To learn how to request random numbers with a subscription, see the
[Subscription Method](/vrf/v2/subscription/) guide.

Security Considerations

Be sure to review your contracts with the [security
considerations](/vrf/v2/security/) in mind.

This guide explains how to get random values using a simple contract to
request and receive random values from Chainlink VRF v2 without managing a
subscription. To explore more applications of VRF, refer to our
[blog](https://blog.chain.link/).

## Requirements

This guide assumes that you know how to create and deploy smart contracts on
Ethereum testnets using the following tools:

  * [The Remix IDE](https://remix.ethereum.org/)
  * [MetaMask](https://metamask.io/)
  * [Sepolia testnet ETH](/resources/link-token-contracts/#sepolia-testnet)

If you are new to developing smart contracts on Ethereum, see the [Getting
Started](/getting-started/conceptual-overview) guide to learn the basics.

## Create and deploy a VRF v2 compatible contract

For this example, use the
[VRFv2DirectFundingConsumer.sol](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2DirectFundingConsumer.sol)
sample contract. This contract imports the following dependencies:

  * `VRFV2WrapperConsumerBase.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol)
  * `ConfirmedOwner.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwner.sol)

The contract also includes pre-configured values for the necessary request
parameters such as `callbackGasLimit`, `requestConfirmations`, the number of
random words `numWords`, the VRF v2 Wrapper address `wrapperAddress`, and the
LINK token address `linkAddress`. You can change these parameters if you want
to experiment on different testnets.

Build and deploy the contract on Sepolia.

  1. Open the [`VRFv2DirectFundingConsumer.sol` contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2DirectFundingConsumer.sol) in Remix.

[ Open in Remix
](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2DirectFundingConsumer.sol)
[What is Remix?](/getting-started/conceptual-overview#what-is-remix)

  2. On the **Compile** tab in Remix, compile the `VRFv2DirectFundingConsumer` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Web3 Environment** and select the `VRFv2DirectFundingConsumer` contract from the contract list.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must fund your consuming contract with enough LINK tokens in order to request for randomness. Next, fund your contract.

## Fund Your Contract

Requests for randomness will fail unless your consuming contract has enough
LINK.

  1. [Acquire testnet",partial
give me a sample solidity contract to use NFT Floor Price Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}","
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: Azuki Floor Price / ETH
     * Address: 0xA8B9A447C73191744D5B79BcE864F343455E1150
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0xA8B9A447C73191744D5B79BcE864F343455E1150
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,",partial,"# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) =

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility Feeds](/data-feeds/rates-feeds)
documentation.

See the [Rate and Volatility Contract Addresses](/data-feeds/rates-feeds/addresses) page for a list of available networks and addresses.

### L2 sequencer uptime feeds

L2 sequencer feeds track the last known status of the sequencer on an L2
network at a given point in time. This helps you prevent mass liquidations by
providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds feeds, see the [L2 Sequencer
Uptime Feeds](/data-feeds/l2-sequencer-feeds) documentation.

## Components of a data feed

Data Feeds are an example of a decentralized oracle network and include the
following components:

  * **Consumer** : A consumer is an on-chain or off-chain application that uses Data Feeds. Consumer contracts use the [`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) to call functions on the proxy contract and retrieve information from the aggregator contract. For a complete list of functions available in the `AggregatorV3Interface`, see the [Data Feeds API Reference](/data-feeds/api-reference/#aggregatorv3interface).
  * **Proxy contract** : Proxy contracts are on-chain proxies that point to the aggregator for a particular data feed. Using proxies enables the underlying aggregator to be upgraded without any service interruption to consuming contracts. Proxy contracts can vary from one data feed to another, but the [`AggregatorProxy.sol` contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol) on Github is a common example.
  * **Aggregator contract** : An aggregator is a contract that receives periodic data updates from the oracle network. Aggregators store aggregated data on-chain so that consumers can retrieve it and act upon it within the same transaction. For a complete list of functions and variables available on most aggregator contracts, see the [Data Feeds API Reference](/data-feeds/api-reference/#accesscontrolledoffchainaggregator).

To learn how to create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

## Reading proxy and aggregator configurations

Because the proxy and aggregator contracts are all on-chain, you can see the
current configuration by reading the variables through an
[ABI](https://docs.soliditylang.org/en/latest/abi-spec.html) or using a
blockchain explorer for your network. For example, you can see the

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |",partial
give me a sample solidity contract to use Proof of Reserve Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}","
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredIn",partial,"the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page

:::NEXT DOC:::

the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right
Give sample code for an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","

pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) =",partial,"the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    from web3 import Web3
    
    # Change this to use your own RPC URL
    web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
    # AggregatorV3Interface ABI
    abi = '[{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""description"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint80"",""name"":""_roundId"",""type"":""uint80""}],""name"":""getRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""latestRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""version"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""}]'
    # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0 <0.8.0`, use
[OpenZeppelin's SafeMath

:::NEXT DOC:::

/*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct

:::NEXT DOC:::

/*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct

:::NEXT DOC:::

MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
   ",right
Give code examples to demonstrate how to deploy a consumer contract on-chain that reads a data feed and stores the value?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","
Solidity:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp",partial,"# Code Examples

  * Overview
  * Reading data feeds on-chain
  * Solidity
  * Vyper
  * Reading data feeds off-chain
  * Javascript
  * Python
  * Golang
  * Getting a different price denomination
  * More Aggregator Functions

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same. To read a
feed, specify the following variables:

  * **RPC endpoint URL:** This determines which network that your smart contracts will run on. You can use a [node provider service](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) or point to your own [client](https://ethereum.org/en/developers/docs/nodes-and-clients/). If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the [Remix IDE](https://remix-project.org/) will automatically detect them for you.
  * **LINK token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
    

:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete

:::NEXT DOC:::

smart contract when you deploy it. This contract has a constructor that sets an initial message when you deploy the contract.

  7. Click the **Deploy** button to deploy the contract and its initial message to the blockchain network. MetaMask opens and asks you to confirm payment to deploy the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  8. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  9. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  10. Click the `message` variable. Remix retrieves and prints the initial message that you set.

The contract has an address just like your wallet address. If you save this
address, you can return to your deployed contract at any time to retrieve
variables or execute functions. To see details about your deployed contract,
copy the contract address from the list in Remix and search for it in the
[Etherscan Sepolia Testnet Explorer](https://sepolia.etherscan.io/).

## Run functions in your contract

Because you deployed the contract to an actual blockchain, several nodes on
the test network confirmed your payment for the smart contract. The contract,
its variables, and its functions remain in the blockchain permanently. To
change the `message` variable that is stored with your contract, run the
`updateMessage` function.

  1. In your deployed contract, enter a new message next to the `updateMessage` function.

  2. Click the `updateMessage` button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.

  3. In the new MetaMask prompt, click **Confirm** to approve the transaction.

  4. Click the `message` variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

Now you know how to deploy example contracts to a test network and run the
functions in those contracts. You can write your own contracts and test them
using this same process.

Next, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds)
guide to learn how to connect your smart contracts to Chainlink Data Feeds and
retrieve on-chain data that your smart contracts can act on.

## What's next

  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/deploy-your-first-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right
Write code to show how to use web3.js to retrieve feed data from a price feed?,"/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
    name: ""getRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""latestRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""version"",
    outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
]
const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log(""Latest Round Data"", roundData)
  })","
/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],",partial,"On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
   

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
    const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
        name: ""getRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""latestRoundData"",
        outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name:",wrong
What is the LINK token contract on ethereum mainnet?,0x514910771AF9Ca656af840dff83E8264EcF986CA,"
The LINK token contract on Ethereum Mainnet is an ERC677 token with the address 0x514910771AF9Ca656af840dff83E8264EcF986CA, the name ""Chainlink Token"", the symbol ""LINK"", and 18 decimals of precision.",right,"# LINK Token Contracts

  * Overview
  * Ethereum
  * Ethereum Mainnet
  * Sepolia testnet
  * Goerli testnet
  * BNB Chain
  * BNB Chain mainnet
  * BNB Chain testnet
  * Polygon (Matic)
  * Polygon mainnet
  * Mumbai testnet
  * RSK
  * RSK mainnet
  * Gnosis Chain (xDai)
  * Gnosis Chain mainnet
  * Avalanche
  * Avalanche mainnet
  * Fuji testnet
  * Fantom
  * Fantom mainnet
  * Fantom testnet
  * Arbitrum
  * Arbitrum mainnet
  * Arbitrum Goerli testnet
  * Optimism
  * Optimism mainnet
  * Optimism Goerli testnet
  * Harmony
  * Harmony mainnet
  * Moonriver
  * Moonriver mainnet
  * Moonbeam
  * Moonbeam mainnet
  * Metis
  * Andromeda mainnet
  * BASE
  * BASE Goerli testnet

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=Contracts) to talk to an expert
about the networks that support the LINK token.

LINK tokens are used to pay node operators for retrieving data for smart
contracts and also for deposits placed by node operators as required by
contract creators. The smallest denomination of LINK is called a Juel, and
1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to
Wei, which is the [smallest denomination of
ETH](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations).

The LINK token is an ERC677 token that inherits functionality from the ERC20
token standard and allows token transfers to contain a data payload. Read more
about the [ERC677 transferAndCall token
standard](https://github.com/ethereum/EIPs/issues/677).

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

## Ethereum

### Ethereum Mainnet

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1                                          |
| Address        | 0x514910771AF9Ca656af840dff83E8264EcF986CA |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | ethstats.dev                               |
### Sepolia testnet

Testnet LINK and ETH are available at
[faucets.chain.link](https://faucets.chain.link/sepolia). Testnet ETH is also
available from several public

:::NEXT DOC:::

and
LINK from Ethereum Mainnet to Metis mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1088                                       |
| Address        | 0x79892E8A3Aea66C8F6893fa49eC6208ef07EC046 |
| Name           | Chainlink Token on Metis Mainnet           |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | andromeda-explorer.metis.io                |
## BASE

### BASE Goerli testnet

Testnet ETH is used to pay for transactions on BASE. Testnet ETH is available
from one of the [BASE Network Faucets](https://docs.base.org/tools/network-faucets). Alternatively, you can get testnet ETH from the faucets listed at
[faucetlink.to/goerli](https://faucetlink.to/goerli) and use the [BASE
Bridge](https://bridge.base.org/deposit) to transfer testnet ETH from Ethereum
Goerli to BASE Goerli.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 84531                                      |
| Address        | 0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3 |
| Name           | Chainlink Token on the BASE Goerli testnet |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | goerli.basescan.org                        |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/link-token-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

| LINK                                       |
| Decimals     | 18                                         |
## BNB Chain

### BNB Chain mainnet

BNB is used to pay for transactions on the BNB Chain mainnet.

ERC-677 LINK on BNB Chain

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
you cannot use it with Chainlink services or oracle nodes. Use the
[**Chainlink PegSwap service**](https://pegswap.chain.link/) to convert
bridged LINK to the official ERC-677 LINK token on BNB Chain.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 56                                         |
| Address        | 0x404460C6A5EdE2D891e8297795264fDe62ADBB75 |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | bscscan.freshstatus.io                     |
### BNB Chain testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/chapel). Testnet BNB is
availalbe at [testnet.binance.org/faucet-
smart](https://testnet.binance.org/faucet-smart).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 97                                         |
| Address      | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06 |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Polygon (Matic)

### Polygon mainnet

MATIC is used to pay for transactions on Polygon. You can use the [Polygon
Bridge](https://wallet.polygon.technology/polygon/bridge/) to transfer

:::NEXT DOC:::

# Acquire testnet LINK

  * Overview
  * Configure MetaMask to use LINK tokens
  * Get testnet LINK from a faucet

The Getting Started guides show you how to send ETH on the Sepolia testnet,
but some contracts might require you to use LINK token instead. This page
shows you how to obtain testnet LINK and send it to your MetaMask wallet.

## Configure MetaMask to use LINK tokens

To see your LINK token balance in MetaMask, you must manually add the token.

  1. Open up MetaMask.

  2. At the bottom of the MetaMask windows, click **Import tokens**.

  3. Find the LINK token contract address for the network that you want to use. On Sepolia, the LINK token address is: `0x779877A7B0D9E8603169DdbD7836e478b4624789`. See the [LINK Token Contracts](/resources/link-token-contracts) page to find the addresses for different testnets.

  4. Paste the token contract address into MetaMask in the Token Address input. The token symbol and decimals of precision will auto-populate.

  5. Click **Next**. A new window will appear, showing the LINK token details.

  6. Click **Import Tokens** to confirm adding the new token.

MetaMask should now display the new LINK token balance.

## Get testnet LINK from a faucet

  1. Go to <https://faucets.chain.link/>.
  2. In Metamask, select the network where you want to receive testnet LINK.
  3. Click **Connect wallet** so the faucet app can detect the network and wallet address.
  4. If you want to receive testnet funds at a different address, paste it in the **Wallet address** section. This field defaults to your connected wallet address.
  5. In the **Request type** section, select the testnet funds that you want to receive.
  6. Complete the Captcha and click **Send request**. The funds are transferred from the faucet to the wallet address that you specified.

After the transaction is confirmed on-chain, the faucet app shows ""Request
complete"" and the transaction hash of your request.



## What's next

  * [› Deploy your first contract](/getting-started/deploy-your-first-contract)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/acquire-link.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",
What is the chainlink price feed address for 1INCH / ETH?,0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8,"
The Chainlink price feed address for 1INCH / ETH is 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8.",right,"        |
|:---------------------------------------|:---------------------------------------------------------|:---------------|:------------|:------------|------:|:-------------------------------------------|
| 🟢1INCH / ETH                          | 1inch                                                    | Crypto         | 2%          | 86400s      |    18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8 |
| 🟢1INCH / USD                          | 1inch                                                    | Crypto         | 1%          | 86400s      |     8 | 0xc929ad75B72593967DE83E7F7Cda0493458261D9 |
| 🟢AAPL / USD                           | Apple                                                    | Equities       | 0.5%        | 86400s      |     8 | 0x139C8512Cde1778e9b9a8e721ce1aEbd4dD43587 |
| 🟢AAVE / ETH                           | Aave                                                     | Crypto         | 2%          | 86400s      |    18 | 0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012 |
| 🟢AAVE / USD                           | Aave                                                     | Crypto         | 1%          | 3600s       |     8 | 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 |
| 🟢ADA / USD                            | Cardano                                                  | Crypto         | 1%          | 86400s      |     8 | 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55 |
| 🟢ADX / USD                

:::NEXT DOC:::

                              | Crypto         | 1%          | 86400s      |     8 | 0x10a43289895eAff840E8d45995BBa89f9115ECEe |
| 🟢ERN / USD                            | Ethernity Chain                                          | Crypto         | 2%          | 86400s      |     8 | 0x0a87e12689374A4EF49729582B474a1013cceBf8 |
| 🟢ETH / BTC                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0xAc559F25B1619171CbC396a50854A3240b6A4e99 |
| 🟢ETH / USD                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 |
| 🟢EUR / USD                            | Euro                                                     | Forex          | 0.15%       | 86400s      |     8 | 0xb49f677943BC038e9857d61E7d053CaA2C1734C1 |
| 🟢EURT / USD                           | Tether Euro                                              | Crypto         | 2%          | 86400s      |     8 | 0x01D391A48f4F7339aC64CA2c83a07C22F95F587a |
| 🟢FARM / ETH                           | Harvest Finance                                          | Crypto         | 2%          | 86400s      |    18 |

:::NEXT DOC:::

|
| JPY / USD   |     nan |    nan | 0.5%        | 86400s      |     8 | 0x982B232303af1EFfB49939b81AD6866B2E4eeD0B |
| LINK / ETH  |     nan |    nan | 1%          | 3600s       |    18 | 0xb4c4a493AB6356497713A78FFA6c60FB53517c63 |
| LINK / USD  |     nan |    nan | 1%          | 3600s       |     8 | 0x48731cF7e84dc94C5f84577882c14Be11a5B7456 |
| SNX / USD   |     nan |    nan | 1%          | 3600s       |     8 | 0xdC5f59e61e51b90264b38F0202156F07956E2577 |
| USDC / USD  |     nan |    nan | 1%          | 86400s      |     8 | 0xAb5c49580294Aff77670F839ea425f5b78ab3Ae7 |
| XAU / USD   |     nan |    nan | 0.3%        | 3600s       |    18 | 0x7b219F57a8e9C7303204Af681e9fA69d17ef626f |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Price Feed Contract Addresses

  * Overview
  * Ethereum Mainnet 
  * Sepolia Testnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Using Data Feeds](/data-feeds/using-data-feeds) guide.

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Best practices for ETF and Forex feeds

  * Off-chain equity and ETF assets are traded only during standard market hours from 9:30AM to 4:00PM EDT Monday through Friday. **Do not** use these feeds outside of those windows.
  * Assets on the Forex (Foreign Exchange) markets are traded only from 5PM EDT on Sunday through 4PM EDT on Friday. Additionally, some currencies might trade only during local banking hours. **Do not** use Forex feeds outside of market hours for the specific currency.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Pair                                   | Asset                                                    | Type           | Deviation   | Heartbeat   |   Dec | Address                                    |
|:---------------------------------------|:---------------------------------------------------------|:---------------|:------------|:------------|------:|:-------------------------------------------|
| 🟢1INCH / ETH                          | 1inch                                                    | Crypto         | 2%          | 86400s      |    18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8 |
| 🟢1INCH /",
What is the proof of reserve address for CacheGold PoR USD on Goerli Testnet?,Not provided in the context,"
0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6",wrong,"                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES        

:::NEXT DOC:::

Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                        

:::NEXT DOC:::

name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve",right
What is the rate and Volatility Feed Address for 30-Day ETH APR?,0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29,"
The rate and Volatility Feed Address for 30-Day ETH APR is 0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29.",right,"# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is

:::NEXT DOC:::

nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2 |
| ETH-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 | 0xd599cEF88Bbd27F1392A544bD0F343ec8893124C |
| LINK-USD 7-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x03121C1a9e6b88f56b27aF5cc065ee1FaF3CB4A9 |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Rate and Volatility Feed Addresses

  * Overview
  * Sepolia Testnet 

To learn how to use these feeds, see the [Using Data Feeds](/data-feeds/using-data-feeds) guide.

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Track the status of this network at <https://ethstats.dev/>

## Sepolia Testnet

| Pair                                     |   Asset |   Type | Deviation   | Heartbeat   |   Dec | Address                                    |
|:-----------------------------------------|--------:|-------:|:------------|:------------|------:|:-------------------------------------------|
| 30-Day ETH APR                           |     nan |    nan | 50%         | 86400s      |     7 | 0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29 |
| 90-Day ETH APR                           |     nan |    nan | 50%         | 86400s      |     7 | 0x7422A64372f95F172962e2C0f371E0D9531DF276 |
| BTC Interest Rate Benchmark Curve 1 Day  |     nan |    nan | 0.01%       | 86400s      |     8 | 0x7DE89d879f581d0D56c5A7192BC9bDe3b7a9518e |
| BTC Interest Rate Benchmark Curve 1 Week |     nan |    nan | 0.01%       | 86400s      |     8 | 0x2583E47DF3F959B055F4Efa90C4927658669F499 |
| BTC Interest Rate Benchmark Curve 2 Week |     nan |    nan | 0.01%       | 86400s      |     8 | 0x39545d0c11CD62d787bB971B6a802150e1f54D8f |
| BTC-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x28f9134a15cf0aAC9e1F0CD09E17f32925254C77 |
| BTC-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 |

:::NEXT DOC:::

is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is met.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find heartbeat and deviation information for each
feed. If you have questions or would like to request an enhancement to
Realized Volatility Feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Rate and Volatility Feeds](/data-feeds/rates-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",
What is the NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net?,0x352f2Bc3039429fC2fe62004a1575aE74001CfcE,"

The NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net is 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE. This address is different from the floor price addresses for CryptoPunks, Cryptoadz, and Doodles, which are 0x5c13b249846540F81c093Bc342b5d963a7518145, 0x870bc8BfEe8A7Bbd63Dc1ef09F2fF37DeBCfEF35, and not provided, respectively.",partial,"  |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
|

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |

:::NEXT DOC:::

|
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price      | ETH           | 2%          |        3600 |    18 | 0x870bc8BfEe8A7Bbd63Dc1ef09F2fF37DeBCfEF35 |
| Doodles Floor Price        | ETH           | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

|
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
| ⚫VeeFriends Floor Price                 | ETH           | 2%          |       86400 |    18 | 0x35bf6767577091E7f04707c0290b3f889e968307 |
| ⚫World of Women Floor Price             | ETH           | 2%          |       86400 |    18 | 0xDdf0B85C600DAF9e308AFed9F597ACA212354764 |
## Goerli Testnet

| NFT Floor Pricing Feed     | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:---------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| Azuki Floor Price          | ETH           | 2%          |        3600 |    18 | 0x9F6d70CDf08d893f0063742b51d3E9D1e18b7f74 |
| BAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xB677bfBc9B09a3469695f40477d05bc9BcB15F50 |
| CloneX Floor Price         | ETH           | 2%          |        3600 |    18 | 0xE42f272EdF974e9c70a6d38dCb47CAB2A28CED3F |
| CoolCats Floor Price       | ETH           | 2%          |        3600 |    18 | 0x13F38938A18ff26394c5ac8df94E349A97AaAb4e |
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price      | ETH           | 2%          |        3600 |    18 | 0x870bc8BfEe8A7Bbd63Dc1ef09F2fF37DeBCfEF35 |
| Doodles Floor Price        | ETH           |",right
What is Chainlink?,"Chainlink is a decentralized oracle network that enables smart contracts on Ethereum to securely connect to external data sources, APIs, and payment systems.

Smart contracts are self-executing contracts with the terms of the agreement directly written into code. They're hosted on blockchain platforms, like Ethereum, and provide many advantages such as trustless execution, efficiency, and transparency. However, one limitation of smart contracts is that they cannot access off-chain data (data outside of the blockchain) directly due to the blockchain's deterministic nature.

Chainlink solves this problem by providing reliable and secure bridges between smart contracts and off-chain data sources. This connection is achieved through a network of decentralized oracle nodes, which fetch and verify real-world data before delivering it to smart contracts.

For example, a smart contract for a decentralized weather betting application could use Chainlink to access real-world weather data. Chainlink nodes retrieve the necessary data from weather APIs and deliver it to the smart contract, which then executes based on the provided data.

Chainlink also has its own native cryptocurrency called LINK, which is used to pay for services within the ecosystem.","
Chainlink is a decentralized oracle network that provides access to high-quality data feeds, trust-minimized compute infrastructure, and automated smart contract services. It enables developers to build hybrid smart contracts that can access off-chain data and services, and provides users with access to a variety of use cases such as connecting to public data, transforming data, connecting to password-protected data sources, connecting to external decentralized databases, connecting to Web2 applications, and fetching data from Web2 systems.",right,"## Welcome to the Chainlink Documentation

##### New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide.

## Explore our products

#### [Data Feeds](data-feeds)

Decentralized and high-quality data feeds for DeFi, Reserves, NFTs, sports,
weather, and more

###### Available on:

#### [Chainlink Functions](chainlink-functions)

Connect smart contracts to a trust-minimized compute infrastructure running on
a decentralized oracle network

###### Available on:

#### [Automate Contracts](chainlink-automation/introduction)

Decentralized, highly reliable, cost-efficient and highly secure automation
for smart contracts

###### Available on:

#### [VRF v2](/vrf/v2/introduction)

Verifiable, tamper-proof random number generator for blockchain gaming and NFT
projects

###### Available on:

#### [External API Calls](/any-api/introduction)

Request and receive data from any API using the Chainlink contract library

###### Available on:

## Useful resources

### Need to run your own Chainlink Node?

See the Node Operator’s Guide to learn about starting and maintaining
Chainlink Nodes.

#### Watch tutorials

Learn more about the technology we are building. We're constantly uploading
new videos to our YouTube channel.

##### Need integration support?

##### Discord

##### Stack overflow



:::NEXT DOC:::

# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

process    | DeFi       | Medium       |
| Enabling automated NFT lotteries with Chainlink Keepers and VRF            | NFT        | Medium       |
| How ApeSwap Integrated Chainlink Keepers for BANANA Maximizer Vaults       | DeFi       | Medium       |
### Game resources

  * [CryptoZombies](https://cryptozombies.io/)
  * [DamnVulnerableDefi](https://damnvulnerabledefi.xyz/challenges/8.html)
  * [Ethernaut](https://ethernaut.openzeppelin.com/)

### Coding bootcamps

  * [ChainShot](https://www.chainshot.com/courses)
  * [Consensys Bootcamp](https://consensys.net/academy/bootcamp/)
  * [Ivan On Tech](https://academy.moralis.io/courses/chainlink-101)

### Starter kits

Our Starter Kits help jumpstart your full-stack development process. You can
get starter kits for Brownie (Python), Truffle (Javascript), and Hardhat
(Javascript). See the [Engineering
Tutorials](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J) playlist to learn more about each kit and how to use them.

  * [Chainlink Brownie Starter Kit (Python)](https://github.com/smartcontractkit/chainlink-mix)
  * [Chainlink Truffle Starter Kit (Javascript)](https://github.com/smartcontractkit/truffle-starter-kit)
  * [Chainlink Hardhat Starter Kit (Javascript)](https://github.com/smartcontractkit/hardhat-starter-kit)

### External tutorials

  * [Ethereum Developers](https://ethereum.org/en/developers/tutorials/)
  * [useWeb3](https://www.useweb3.xyz/)

### More inspiration

Looking for more ways to use Chainlink? Here are some resources that discuss
Chainlink's use cases as well as the winning projects we've had in our
previous hackathons. There is also a link to the Marketplace where you can
find the latest data provider nodes and explore the network.

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past Hackathon Winning Projects](/resources/example-projects)

## Outreach

The Chainlink community is an inviting group of engineers that is always
looking to help users expand their knowledge on Chainlink and solve related
issues. Refer back to the [Getting Help](/resources/getting-help) page for the
latest information about how to get support.

### Get support

  * [Stack Overflow](https://stackoverflow.com/questions/tagged/chainlink)
  * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

### Join the community

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/other-tutorials.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature",
What is a runlog initiator in chainlink?,"The RunLog initiator is an integral component of the Chainlink Node job specifications. It is specifically designed to listen for Ethereum log events (in this case, the Chainlink-specific event ""RunRequest"") that are emitted by the Chainlink Oracle contract when someone requests data from a Chainlink Node.

This initiator responds to requests for external data made by smart contracts on the Ethereum blockchain. When a smart contract emits a RunRequest event, this is picked up by the RunLog initiator, which then triggers a job run on the Chainlink node.

The RunLog initiator allows smart contracts to specify the data they want to retrieve and also helps in the preparation of data before it is sent back to the requesting contract. The data request and delivery process is handled securely and trustlessly, maintaining the decentralization and security principles of blockchain technology.

The Chainlink Oracle contract is an Ethereum smart contract that serves as an intermediary between the Chainlink node and the smart contract requesting data. It manages requests for data and the delivery of responses back to the requesting contract.","
A RunLog initiator is a type of initiator in Chainlink that triggers a one-off job run at a specified time. It works similarly to EthLog, but adds some helpful glue in to stitch together the off-chain job with the on-chain contracts. When a RunLog job is created, Chainlink begins watching the blockchain for any log events that include that job’s ID. If any of the events that come back match the log event signature of the Chainlink oracle contract, then the Chainlink node parses the data out of that log and passes it into a new log run.",right,"         ""type"": ""runlog"",
            ""params"": {
                ""address"": ""0xCAFE000000000000000000000000000000000001"",
                ""requesters"": [
                    ""0xCAFE000000000000000000000000000000000002"",
                    ""0xCAFE000000000000000000000000000000000003""
                ]
            }
        }
    ]

## Web

The `Web` initiator enables jobs to be triggered via web requests,
specifically `POST`s to `/v2/specs/:jobID/runs`. Requests coming in to create
new job runs must be authenticated by cookie.

note

For convenience, there is a ""Run"" button in the operator web UI for the job
which will trigger a job run.

### Web Parameters

`Web` currently takes no parameters.

### Example


    ""initiators"": [
        {
            ""type"": ""web""
        }
    ]

## What's next

  * [› Introduction to External Initiators](/chainlink-nodes/external-initiators/external-initiators-introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/initiators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

        },
          {
            ""bridge"": ""amberdata_cl_ea""
          },
          {
            ""bridge"": ""coinapi_cl_ea""
          }
        ],
        ""threshold"": 1,
        ""absoluteThreshold"": 0,
        ""precision"": 18,
        ""pollTimer"": {
          ""period"": ""1m0s""
        },
        ""idleTimer"": {
          ""duration"": ""24h0m0s""
        }
      }
    }

## RunAt

The `RunAt` initiator triggers a one off job run at the time specified.

### RunAt Parameters

`RunAt` takes one parameter, `time`. `time` accepts a ISO8601 string or a Unix
timestamp.

### Example


    ""initiators"": [
        {
            ""type"": ""runat"",
            ""params"": {
                ""time"": ""2019-09-20T12:20:00.000Z""
            }
        }
    ]

## RunLog

The `RunLog` initiator is the easiest initiator to use when integrating
Chainlink with on-chain contracts. It works similarly to EthLog, but adds some
helpful glue in to stitch together the off-chain job with the on-chain
contracts.

When a `RunLog` job is created, Chainlink begins watching the blockchain for
any log events that include that job’s ID. If any of the events that come back
match the log event signature of the Chainlink oracle contract, then the
Chainlink node parses the data out of that log and passes it into a new log
run.

A new run created by a `RunLog` is automatically given the parameters needed
for an `EthTx` task to report the run back to the contract that originally
created the event log.

### RunLog Parameters

`RunLog` initiators take an optional `address` parameter and `requesters`
parameter. The `address` parameter is a single Ethereum address and the
`requesters` parameter is an array of Ethereum addresses. By adding the
`address` parameter, you make the event filter of the RunLog initiator more
restrictive, only listening for events from that address, instead of any
address. By adding the `requesters` parameter, you only allow requests to come
from an address within the array.

### Example


    ""initiators"": [
        {
            ""type"": ""runlog"",
            ""params"": {
                ""address"": ""0xCAFE000000000000000000000000000000000001"",
                ""requesters"": [
                    ""0xCAFE000000000000000000000000000000000002"",
                    ""0xCAFE000000000000000000000000000000000003""
                ]
            }
        }
    ]

## Web

The `Web` initiator enables jobs

:::NEXT DOC:::

# Building External Initiators

  * Overview
  * JSON jobs (REMOVED)

An external initiator can trigger a run for any webhook job that it has been
linked to.

The URL for triggering a run is such:


    curl -X POST -H ""Content-Type: application/json"" --data '{""myKey"": ""myVal""}' http://localhost:6688/v2/jobs/<job external UUID>/runs

You will need to specify two headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

## JSON jobs (REMOVED)

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

We will be using the [Chainlink external
initiator](https://github.com/smartcontractkit/external-initiator) repo for
reference. You can see some examples of existing initiators in the
[blockchain](https://github.com/smartcontractkit/external-initiator/tree/master/blockchain) folder.

External initiators are simple web initiators that can be activated by any job
instead of just one. To set one up, you need to have a service similar to an
external adapter that sends an `HTTPPost` message runs API call to your
chainlink node service. Here is a sample URL for a web job could look like:


    curl -b cookiefile -X POST -H ""Content-Type: application/json"" --data '{""myKey"":""myVal""}' http://localhost:6688/v2/jobs/%s/runs

Where `%s` is the jobId.

External initiators make the same API call, with 2 added headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

These are keys generated when you register your external initiator with your
node.

Triggering a run through an external initiator is as simple as making this API
call to your node. All jobs with this EI configured will then be kicked off in
this way. A simple external initiator in psedo code could look like this:


    while(True):
        send_api_call_with_external_initiator_access_key_headers()
        sleep(4)

And have this job run on the same machine as your node.

## What's next

  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/building-external-initiators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

are the individual steps that
the Chainlink node follows to process data in order to produce a result.

In the example above, we see that the only initiator is a RunLog. This means
that the spec can only be started when a specific event log is emitted from a
specified address. The specified address will be the address of the oracle
contract on Ropsten, which manages requests from contracts and responses from
Chainlink nodes.

The five tasks (referred to as [core adapters](/chainlink-nodes/oracle-jobs/v1/adapters)) in the example above follow a common pattern for requesting
data from the Chainlink network, and returning a single result. Each task
takes three fields: `type`, `confirmations`, and `params`. The `type` is the
adapter or [bridge](/resources/glossary/#bridge) name and is required.
`confirmations` is optional, and will default to 0. `params` is also optional,
and will default to an empty object if not specified. See the [core
adapters](/chainlink-nodes/oracle-jobs/v1/adapters) page for a complete list
of `params` for each adapter.

  1. The **HTTPGet** adapter uses the value in the `get` field to perform a standard HTTP GET request at the value specified. The body of that result is passed on to the next task, JSONParse.
  2. The **JSONParse** adapter takes a dot-delimited string or an array of strings, and will walk the given path to store the value at the end. In this case, there is only one field to save, ""last"". JSONParse will then pass the value stored in the ""last"" field to the Multiply adapter.
  3. The **Multiply** adapter will, as its name describes, multiply the given value by the value of the `times` field, in this case, 100.
  4. The multiplied value will be passed to the **EthUint256** adapter, which will format it specifically for the `uint256` data type on Ethereum. Notice there are no parameters supplied to the EthUint256 adapter, as it does not accept any.
  5. Finally, that formatted value is written to the blockchain with the **EthTx** adapter. The parameters for the EthTx adapter are given by the oracle contract when the run is initiated through the RunLog initiator.

Note: If specifying multiple adapters of the same type, the parameters can be
specified in the job spec itself if the key values need to be different. The
requester can also use run parameters for these requests, but shared keys will
be the same for any adapter that uses them.

Additional parameters may be specified on the job as well. These include:

  * **startAt** : The beginning date at which the job can be executed, specified in ISO 8601 standard. Jobs can not be ran before this date. Defaults to null if unspecified.
  * **endAt** : The ending date at which the job can be executed, specified in ISO 8601 standard. Jobs can not be ran after this date. Defaults to null if unspecified.
  * **minPayment** : The payment amount for this job, specified in LINK to the 18th decimal. If supplied, this will override the global `MIN_CONTRACT_PAYMENT` configuration set on the node, regardless if the value is lower or higher.

## What's next

  * [› Core Adapters](/chainlink-nodes/oracle-jobs/v1/adapters)
  * [› Initiators](/chainlink-nodes/oracle-jobs/v1/initiators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/job-specifications.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",
What are Chainlink data feeds?,"Chainlink Price Feeds, often just called Chainlink data feeds, are decentralized oracle networks that provide smart contracts with access to high-quality, tamper-proof data.

These data feeds are primarily used to provide real-time price information for various cryptocurrencies, commodities, and other assets. They allow smart contracts to access the current market price of assets without having to interact with external APIs themselves, thus enhancing security, reliability, and transparency.

Here's how Chainlink data feeds work:

Multiple independent, Sybil-resistant oracle nodes fetch data from various high-quality data sources.

Each oracle node retrieves the data independently, which eliminates the risk of a single point of failure.

The individual data points are then aggregated into a single data point, which is written onto the blockchain.

This final, aggregated data point is the one that smart contracts interact with.

The data feeds use a decentralization approach at both the data source and oracle levels, ensuring the data is reliable and resistant to manipulation. This way, even if one data source or one oracle node reports incorrect data, the impact on the overall feed is minimal, ensuring the integrity of the data.

Chainlink data feeds are used widely across the decentralized finance (DeFi) space, powering various protocols, lending platforms, stablecoins, and more. As of my training cut-off in September 2021, Chainlink is one of the most prominent providers of decentralized oracle solutions.","
Chainlink Data Feeds are decentralized data feeds that provide real-world data such as asset prices, reserve balances, NFT floor prices, and L2 sequencer health to smart contracts. They are categorized into Verified, Monitored, Provisional, Custom, and Specialized Feeds based on the level of risk associated with them. Users must evaluate the properties of a feed to make sure it aligns with their intended use case and understand the additional market and volatility risks inherent with such assets.",right,"Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like [AAVE](https://aave.com/) use Data Feeds to ensure the total
value of the collateral.

Data Feeds aggregate many data sources and publish them on-chain using a
combination of the [Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) and [Off-Chain
Reporting](/architecture-overview/off-chain-reporting?parent=dataFeeds).

To learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract

:::NEXT DOC:::

# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem.",
What is a Chainlink subscription account?,An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.,"
A Chainlink subscription account is an address that creates and manages a Subscription account. Any account can add LINK tokens to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds. The subscription balance is the amount of LINK maintained on the Subscription account, and the subscription reservation is the amount of LINK blocked on the Subscription balance. The effective balance is the amount of LINK available on the Subscription account, which is calculated as Subscription balance - Subscription reservation. Subscription consumers are consumer contracts that are approved to use funding from the Subscription account while making Chainlink Functions requests.",right,"address that creates and manages a _Subscription account_. Any account can add LINK tokens to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * Subscription balance: The amount of LINK maintained on your _Subscription account_. Requests from consumer contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your _Subscription balance_ to pay for the requests and keep your applications running.
  * Subscription reservation: The amount of LINK blocked on the _Subscription balance_. It corresponds to the total LINK amount to be paid by in-flight requests.
  * Effective balance: The amount of LINK available on your _Subscription account_. `Effective balance = Subscription balance - Subscription reservation`.
  * Subscription consumers: Consumer contracts are approved to use funding from your _Subscription account_ while making _Chainlink Functions_ requests. The consumers receive response data in a callback.

## What's next

  * [› Architecture](/chainlink-functions/resources/architecture)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/concepts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Managing Subscriptions

  * Overview
  * Before you begin
  * Subscriptions
  * Create a subscription
  * Create and fund a subscription
  * Get Subscription details
  * Fund a Subscription
  * Add a consumer contract to a Subscription
  * Remove a consumer contract from a Subscription
  * Transfer ownership of a Subscription
  * Cancel a Subscription

This guide explains how to manage Chainlink Functions subscriptions.
Currently, the best way to create and manage subscriptions is by using the
[Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-subscription-management-commands) commands.

## Before you begin

**[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set
up your environment with the necessary tools for creating and managing
subscriptions and completing the tutorials.

## Subscriptions

You can find Subscription Management commands, descriptions, and parameters in
the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-subscription-management-commands) reference documentation.

### Create a subscription

Run the `functions-sub-create` task to create a new subscription account:


    npx hardhat functions-sub-create --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-create --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Creating Functions billing subscription
    Waiting 2 blocks for transaction 0x018a04da4d1a3e8c14ceb8fbca786a897566a37c0b4cb9a9a36ca35a43806a3b to be confirmed...
    Subscription created with ID: 27
    
    Created subscription with ID: 27
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.0 LINK
    0 authorized consumer contracts:
    []

### Create and fund a subscription

Run the `functions-sub-create` task with the `amount` parameter to create a
new subscription account and fund it. The `amount` is in LINK.

Optionally, you can also add your consumer contract by including the
`--contract` flag with the address of your consumer contract. You can always
add more consumer contracts later.


    npx hardhat functions-sub-create --amount REPLACE_LINK_AMOUNT --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-create --amount 0.5 --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Creating Functions billing subscription
    Waiting 1 blocks for transaction 0xc5990756f7728da53d8fdce3c715ef47b29094ad2a895435c1d871e2d2c5f725 to be confirmed...
    Subscription created with ID: 28
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 0.5 LINK
    Waiting 2 blocks for transaction 0x822a0d667d8b4ba0849e486b65a7a7d495cb322528d15254dbc7a7a01b7e1458 to be confirmed...
    Subscription 28 funded with 0.5 LINK
    
    Created subscription with ID: 28
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.5 LINK
    0

:::NEXT DOC:::

to be confirmed...
    Subscription created with ID: 28
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 0.5 LINK
    Waiting 2 blocks for transaction 0x822a0d667d8b4ba0849e486b65a7a7d495cb322528d15254dbc7a7a01b7e1458 to be confirmed...
    Subscription 28 funded with 0.5 LINK
    
    Created subscription with ID: 28
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.5 LINK
    0 authorized consumer contracts:
    []

### Get Subscription details

Run the `functions-sub-info` task with the `subid` (subscription ID) parameter
to fetch the following items:

  * Subscription balance
  * Subscription owner
  * A list of authorized client contract addresses


    npx hardhat functions-sub-info --subid REPLACE_SUBSCRIPTION_ID --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-info --subid 28 --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    
    Subscription 28 owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.5 LINK
    0 authorized consumer contracts:
    [

### Fund a Subscription

Run the `functions-sub-fund` task with `subid` (subscription ID) and `amount`
parameters. Note that `amount` is in LINK.


    npx hardhat functions-sub-fund --subid REPLACE_SUBSCRIPTION_ID --amount REPLACE_LINK_AMOUNT --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-fund --subid 28 --amount 0.1  --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Funding subscription 28 with 0.1 LINK
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Waiting 2 blocks for transaction 0x2940a9c8d5cbe521f68552f53c329de0261b179baeb40cafe1b7a1dc3d3bde24 to be confirmed...
    
    Subscription 28 has a total balance of 0.6 LINK

### Add a consumer contract to a Subscription

#### Prerequisites

You must deploy a Chainlink Functions consumer contract before you can add it
to your subscription. You can skip on-chain contract verification with the
`--verify false` flag.

If you do need to [verify](https://blog.chain.link/how-to-verify-a-smart-contract-on-etherscan) your contract on-chain, sign up for a free API key for
your network scanner and include it in your `.env.enc` file:

  1. Sign up for an API key:

    * Polygon Mumbai: Sign up for a [free Polygonscan API key](https://polygonscan.com/login).
    * Sepolia: Sign up for a [free Etherscan API key](https://etherscan.io/login).
  2. Include it in your `.env.enc` by running `npx env-enc set` and set `POLYGONSCAN_API_KEY` or `ETHERSCAN_API_KEY` depending on your network.

Deploy a consumer contract:


    npx hardhat functions-deploy-client --verify false --network REPLACE_NETWORK

Example:


    $ npx hardhat

:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates",
How can i request data from a public API in a smart contract using chainlink?,"Here are the general steps to request data from a public API using Chainlink within a smart contract:

Install Chainlink: First, you need to have Chainlink installed and properly configured. This would typically involve running a Chainlink Node or using nodes provided by others.

Create a Smart Contract: Write a smart contract in Solidity (the programming language for Ethereum smart contracts) that includes the Chainlink library and uses its functions to make a data request.

Request Data: Within the smart contract, make a request to Chainlink, specifying the public API you want to fetch data from and the Chainlink node that will fulfill the request. You would typically do this using Chainlink's buildChainlinkRequest function, and then sending it via the sendChainlinkRequestTo function.

Handle the Response: Write a callback function in your smart contract to receive and handle the data from the Chainlink oracle. This function is specified when you make the data request.

Fund Your Contract: Since Chainlink nodes require payment in LINK tokens for data requests, you'll need to transfer some LINK to your smart contract.","
To request data from a public API in a smart contract using Chainlink, you must import the ChainlinkClient contract, which exposes a struct called Chainlink.Request. This request should include the Link token address, Oracle address, Job id, Request fee, Task parameters, and Callback function signature. You can then use the Chainlink.Request struct to make an HTTP GET request to the external API and receive a single response.",right,"# Chainlink Any API Documentation

  * Overview
  * Requesting off-chain data
  * Building external adapters

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=AnyAPI) to talk to an expert
about using Chainlink Any API to get your data on chain.

**Connecting to any API** with Chainlink enables your contracts to access to
_any_ external data source through our decentralized oracle network. We
understand making smart contracts compatible with off-chain data adds to the
complexity of building smart contracts. We created a framework with minimal
requirements, yet unbounded flexibility, so developers can focus more on the
functionality of smart contracts rather than what feeds them. Chainlink’s
decentralized oracle network provides smart contracts with the ability to push
and pull data, facilitating the interoperability between on-chain and off-
chain applications.

Whether your contract requires sports results, the latest weather, or any
other publicly available data, the [Chainlink contract
library](https://github.com/smartcontractkit/chainlink/tree/master/contracts)
provides the tools required for your contract to consume it.

Prerequisites

You should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                                                                                                                                                                                                                                                |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                                                                                                                             |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                          

:::NEXT DOC:::

your contract must import
[ChainlinkClient](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol).
This contract exposes a struct called `Chainlink.Request`, which your contract
should use to build the API request. The request should include the following
parameters:

  * Link token address
  * Oracle address
  * Job id
  * Request fee
  * Task parameters
  * Callback function signature

Note on Funding Contracts

Making a GET request will fail unless your deployed contract has enough LINK
to pay for it. **Learn how to[Acquire testnet LINK](/resources/acquire-link)
and [Fund your contract](/resources/fund-your-contract)**.

Assume that a user wants to call the API above and retrieve only the 24h ETH
trading volume from the response.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * THIS EXAMPLE USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract APIConsumer is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
        bytes32 private jobId;
        uint256 private fee;
    
        event RequestVolume(bytes32 indexed requestId, uint256 volume);
    
        /**
         * @notice Initialize the link token and target oracle
         *
         * Sepolia Testnet details:
         * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
         * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
         * jobId: ca98366cc7314957b8c012c72f05aeeb
         *
         */
        constructor() ConfirmedOwner(msg.sender) {
            setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
            setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
            jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        }
    
        /**
      

:::NEXT DOC:::

# Single Word Response

  * Overview
  * Example

This guide explains how to make an HTTP GET request to an external API from a
smart contract using Chainlink's [Request & Receive Data](/any-api/introduction) cycle and receive a single response.

Prerequisites

You should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

## Example

This example shows how to:

  * Fetch a single word response in a single call.

The [Cryptocompare GET /data/pricemultifull API](https://min-api.cryptocompare.com/documentation?key=Price&cat=multipleSymbolsFullPriceEndpoint)
returns the current trading info (price, vol, open, high, low) of any list of
cryptocurrencies in any other currency that you need. To check the response,
you can directly paste the following URL in your browser `https://min-
api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD` or run this
command in your terminal:


    curl -X 'GET' \
      'https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD' \
      -H 'accept: application/json'

The response should be similar to the following example:


    {
      ""RAW"": {
        ""ETH"": {
          ""USD"": {
            ""TYPE"": ""5"",
            ""MARKET"": ""CCCAGG"",
            ""FROMSYMBOL"": ""ETH"",
            ""TOSYMBOL"": ""USD"",
            ""FLAGS"": ""2049"",
            ""PRICE"": 2867.04,
            ""LASTUPDATE"": 1650896942,
            ""MEDIAN"": 2866.2,
            ""LASTVOLUME"": 0.16533939,
            ""LASTVOLUMETO"": 474.375243849,
            ""LASTTRADEID"": ""1072154517"",
            ""VOLUMEDAY"": 195241.78281014622,
            ""VOLUMEDAYTO"": 556240560.4621655,
            ""VOLUME24HOUR"": 236248.94641103,
            ...
    }

To consume an API with multiple responses, your contract must import
[ChainlinkClient](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol).
This contract exposes a struct called `Chainlink.Request`, which your contract
should use to build the API request. The request should include the following
parameters:

  * Link token address
  * Oracle address
  * Job id
  * Request fee
  * Task parameters
  * Callback function signature

Note on Funding Contracts

Making a GET request will fail unless your deployed contract has enough LINK
to pay for it. **Learn how to[Acquire testnet LINK](/resources/acquire-link)
and [Fund your contract](/resources/fund-your-contract)**.

Assume that a user wants to call the API

:::NEXT DOC:::

to learn how to fund your contract.

This is an example of a basic HTTP GET request. However, it requires defining
the API URL directly in the smart contract. This can, in fact, be extracted
and configured on the Job level inside the Oracle node. You can follow the
_APIConsumer_ tutorial [here](/any-api/get-request/examples/single-word-response).

### External adapters

If all the parameters are defined within the Oracle job, the only things a
smart contract needs to define to consume are:

  * JobId
  * Oracle address
  * LINK fee
  * Fulfillment function

This will make your smart contract much more succinct. The `requestVolumeData`
function from the code example above would look more like this:


    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
    
        // Extra parameters don't need to be defined here because they are already defined in the job
    
        return sendChainlinkRequest(req, fee);
    }

You can follow a full _Existing Job Tutorial_ [here](/any-api/get-request/examples/existing-job-request). More on External Adapters can be found
[here](/chainlink-nodes/external-adapters/external-adapters).

## Further reading

To learn more about connecting smart contracts to external APIs, read our blog
posts:

  * [Connect a Smart Contract to the Twitter API](https://blog.chain.link/connect-smart-contract-to-twitter-api/)
  * [Connect a Tesla Vehicle API to a Smart Contract](https://blog.chain.link/create-tesla-smart-contract-rental/)
  * [OAuth and API Authentication in Smart Contracts](https://blog.chain.link/oauth-and-api-authentication-in-smart-contracts-2/)

To explore more applications of external API requests, check out our [other
tutorials](/getting-started/other-tutorials/#api-requests).

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction)
  * [› Make an Existing Job Request](/any-api/get-request/examples/existing-job-request)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/advanced-tutorial.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",
What is an adapter in chainlink?,"Core adapters are the built-in functionality that every Chainlink node supports. Strung together, they act as tasks that need to be performed to complete a Job.

Adapters that are prefixed with ""Eth"" refer to tasks that post data onto the chain.","
An adapter in Chainlink is a service that the core of the Chainlink node communicates with via its API with a simple JSON specification. Adapters enable easy integration of custom computations and specialized APIs into the Chainlink node. Adapters can be added to a Chainlink node by creating a bridge in the Node Operators Interface.",right,"# External Adapters Introduction

  * Overview

External adapters are how Chainlink enables easy integration of custom
computations and specialized APIs. External adapters are services which the
core of the Chainlink node communicates via its API with a simple JSON
specification. If you want a step by step, be sure to check out our [blog
post](https://blog.chain.link/build-and-use-external-adapters/).

Information on external adapters is broken up into three main categories:
contract creators, developers, and node operators.

  * [Contract Creators](/chainlink-nodes/external-adapters/contract-creators) will need to know how to specify an external adapter in their request for external data.
  * [Developers](/chainlink-nodes/external-adapters/developers) will need to know how to implement an external adapter for an API.
  * [Node Operators](/chainlink-nodes/external-adapters/node-operators) will need to know how to add an external adapter to their node so that they can provide specialized services to smart contracts.

## What's next

  * [› External Adapters in Solidity](/chainlink-nodes/external-adapters/contract-creators)
  * [› Building External Adapters](/chainlink-nodes/external-adapters/developers)
  * [› Bridges: Adding External Adapters to Nodes](/chainlink-nodes/external-adapters/node-operators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/external-adapters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Blockchain Integration With Chainlink External Adapters                   | Identification       | Advanced     |
| How to Connect a Tesla Vehicle API to a Smart Contract Via a Chainlink External Adapter | Transportation       | Advanced     |
| OAuth and API Authentication in Smart Contracts                                         | Security             | Advanced     |
| Connect APIs to your Smart Contracts using Chainlink                                    | NFT                  | Advanced     |
#### Automation (Keepers)

| Name                                                                       | Type       | Difficulty   |
|:---------------------------------------------------------------------------|:-----------|:-------------|
| Automation Introduction Video                                              | Automation | Beginner     |
| Smart Contract Automation Master Class Module #1                           | Automation | Beginner     |
| Smart Contract Automation Master Class Module #2                           | Automation | Beginner     |
| Smart Contract Automation Master Class Module #3                           | Automation | Beginner     |
| Smart Contract Automation Master Class Module #4                           | Automation | Beginner     |
| Entropyfi Saves Engineering Hours with Chainlink Keepers                   | Gaming     | Medium       |
| Enabling Limit Orders on CivTrade With Chainlink Keepers                   | Trading    | Medium       |
| Pickle Finance UniV3 Jars Powered by Chainlink Keepers                     | Finance    | Medium       |
| JamonSwap Introduces New Limit Order Functionality Using Chainlink Keepers | DeFi       | Medium       |
| How Cratos used Chainlink Keepers to automate the token vesting process    | DeFi       | Medium       |
| Enabling automated NFT lotteries with Chainlink Keepers and VRF            | NFT        | Medium       |
| How ApeSwap Integrated Chainlink Keepers for BANANA Maximizer Vaults       | DeFi       | Medium       |
### Game resources

  * [CryptoZombies](https://cryptozombies.io/)
  * [DamnVulnerableDefi](https://damnvulnerabledefi.xyz/challenges/8.html)
  * [Ethernaut](https://ethernaut.openzeppelin.com/)

### Coding bootcamps

  *

:::NEXT DOC:::

# Bridges: Adding External Adapters to Nodes

  * Overview
  * Testing External Adapters and Bridges

You can add external adapters to a Chainlink node by creating a bridge in the
Node Operators Interface. Each bridge must have a unique name and a URL for
the external adapter. If a job has a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task), the node searches for a bridge by name and uses
that bridge as your external adapter. Bridge names are case insensitive.

To create a bridge on the node, go to the **Create Bridge** tab in the Node
Operators Interface. Specify a name for the bridge, the URL for your external
adapter, and optionally specify the minimum contract payment and number of
confirmations for the bridge. Minimum contract payment is a fee paid in LINK
for the Chainlink node making a call to the external adapter via the bridge.
This fee is in addition to the fee specified at the global node level for
processing job requests.



The bridge name must be unique to the local node. The bridge URL is the URL of
your external adapter, which can be local or on a separate machine.

To add jobs that use the bridge, add a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task) to your job. The `bridge` task defined in the
example below is defined as `fetch` and the name of the bridge is `soccer-
data`.


    type = ""directrequest""
    schemaVersion = 1
    name = ""Soccer-Data-EA""
    contractAddress = ""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                      abi=""OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)""
                      data=""$(jobRun.logData)""
                      topics=""$(jobRun.logTopics)""]
    
        decode_cbor  [type=cborparse data=""$(decode_log.data)""]
        fetch        [type=bridge name=""soccer-data"" requestData=""{\\""id\\"": $(jobSpec.externalJobID), \\""data\\"": { \\""playerId\\"": $(decode_cbor.playerId)}}""]
        parse        [type=jsonparse path=""data,0,Games"" data=""$(fetch)""]
        encode_data  [type=ethabiencode abi=""(uint256 value)"" data=""{ \\""value\\"": $(parse) }""]
        encode_tx    [type=ethabiencode
                      abi=""fulfillOracleRequest(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes32 data)""
                      data=""{\\""requestId\\"": $(decode_log.requestId), \\""payment\\"": $(decode_log.payment), \\""callbackAddress\\"": $(decode_log.callbackAddr), \\""callbackFunctionId\\"": $(decode_log.callbackFunctionId), \\""expiration\\"": $(decode_log.cancelExpiration), \\""data\\"": $(encode_data)}""
    

:::NEXT DOC:::

         ""type"": ""web"",
          ""params"": {
          }
        }
      ],
      ""tasks"": [
        {
          ""type"": ""sleep"",
          ""params"": {
            ""until"": ""1605651000""
          }
        }
      ]
    }

## What's next

  * [› Introduction to External Adapters](/chainlink-nodes/external-adapters/external-adapters)
  * [› Initiators](/chainlink-nodes/oracle-jobs/v1/initiators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/adapters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",
What is a task in chainlink?,"In the Chainlink ecosystem, a ""task"" refers to a specific action or a series of actions that a Chainlink node performs as part of a job.

A job in Chainlink is defined by a Job Specification, which is a list of tasks that the Chainlink node is to perform. These tasks can range from fetching data from an API endpoint, parsing JSON data, performing computations, or even making a transaction on the blockchain.

For example, a Job Specification could have the following tasks:

HttpGet: Fetch data from a specific URL.
JsonParse: Parse the returned JSON data.
Multiply: Multiply the parsed number to account for decimal places.
EthUint256: Convert the resulting number to a format that's suitable for Ethereum.
EthTx: Send the resulting data to a specific function in a smart contract on the Ethereum network.
Each task is performed in the order specified in the Job Specification, and the output of one task is passed as the input to the next task in the list.

Chainlink nodes are compensated in LINK tokens for the computational resources used to perform these tasks. This incentivizes Chainlink nodes to reliably execute jobs and provide accurate data to smart contracts.","

A task in Chainlink is a replacement for core adapters from v1 jobs. Tasks are composed in arbitrary order into pipelines and consist of one or more threads of execution where tasks are executed in a well-defined order. Tasks can be Chainlink's built-in tasks or custom adapters built by node operators and community members. All tasks share a few common attributes, such as an index and a timeout. Chainlink also provides a range of use cases and past hackathon winning projects to explore, as well as a supportive community to help users expand their knowledge and solve related issues.",right,"# Tasks

  * Overview
  * What is a Task?
  * Shared attributes
  * Writing pipelines

## What is a Task?

Tasks

Tasks replace the [core adapters](/chainlink-nodes/oracle-jobs/v1/adapters)
from v1 jobs.

Tasks are a replacement for core adapters that is more flexible. Tasks can be
composed in arbitrary order into pipelines. Pipelines consist of one or more
threads of execution where tasks are executed in a well-defined order.

You can use Chainlink's [built-in tasks](/chainlink-nodes/oracle-jobs/all-tasks), or you can create your own [external adapters](/chainlink-nodes/external-adapters/external-adapters) for tasks which are accessed
through a `bridge`.

## Shared attributes

All tasks share a few common attributes:

`index`: when a task has more than one input (or the pipeline overall needs to
support more than one final output), and the ordering of the values matters,
the index parameter can be used to specify that ordering.


    data_1 [type=""http"" method=GET url=""https://chain.link/eth_usd""       index=0]
    data_2 [type=""http"" method=GET url=""https://chain.link/eth_dominance"" index=1]
    multiword_abi_encode [type=""eth_abi_encode"" method=""fulfill(uint256,uint256)""]
    
    data_1 -> multiword_abi_encode
    data_2 -> multiword_abi_encode

`timeout`: The maximum duration that the task is allowed to run before it is
considered to be errored. Overrides the `maxTaskDuration` value in the job
spec.

## Writing pipelines

Pipelines are composed of tasks arranged in a DAG (directed acyclic graph).
Pipelines are expressed in [DOT
syntax](https://en.wikipedia.org/wiki/DOT_%28graph_description_language%29#Directed_graphs).

Each node in the graph is a task with a user-specified ID and a set of
configuration parameters and attributes:


    my_fetch_task [type=""http"" method=GET url=""https://chain.link/eth_usd""]

The edges between tasks define how data flows from one task to the next. Some
tasks can have multiple inputs, such as `median`. Other tasks are limited to 0
(`http`) or 1 (`jsonparse`).


    data_source_1  [type=""http"" method=GET url=""https://chain.link/eth_usd""]
    data_source_2  [type=""http"" method=GET url=""https://coingecko.com/eth_usd""]
    medianize_data [type=""median""]
    submit_to_ea   [type=""bridge"" name=""my_bridge""]
    
    data_source_1 -> medianize_data
    data_source_2 -> medianize_data
    medianize_data -> submit_to_ea



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/tasks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# API Calls: Using Any API

  * Overview
  * How does the request and receive cycle work for API calls?
  * What are jobs?
  * What are tasks?
  * Tasks
  * Contract example
  * External adapters
  * Further reading

Requirements

This guide requires basic knowledge about smart contracts. If you are new to
smart contract development, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds) and [Random Numbers](/getting-started/intermediates-tutorial) guides before you begin.

In this guide, you will learn how to request data from a public API in a smart
contract. This includes understanding what Tasks and External adapters are and
how Oracle Jobs use them. You will also learn how to find the Oracle Jobs and
Tasks for your contract and how to request data from an Oracle Job.

## How does the request and receive cycle work for API calls?

The request and receive cycle describes how a smart contract requests data
from an oracle and receives the response in a separate transaction. If you
need a refresher, check out the [Basic Request Model](/architecture-overview/architecture-request-model).

For contracts that use [Chainlink VRF](/vrf/v2/introduction), you request
randomness from a VRF oracle and then await the response. The fulfillment
function is already given to us from the `VRFConsumerBase` contract, so
oracles already know where to send the response to. However, with API calls,
the contract itself _defines_ which function it wants to receive the response
to.

Before creating any code, you should understand how Oracle jobs can get data
on-chain.

## What are jobs?

Chainlink nodes require [**Jobs**](/chainlink-nodes/oracle-jobs/jobs) to do
anything useful. In the case of a Request and Receive job, the [Direct
Request](/chainlink-nodes/oracle-jobs/all-jobs#direct-request-jobs) job
monitors the blockchain for a request from a smart contract. Once it catches a
request, it runs the tasks (both core and external adapters) that the job is
configured to run and eventually returns the response to the requesting
contract.

## What are tasks?

Each oracle job has a configured set of tasks it must complete when it is run.
These tasks are split into two subcategories:

  * [**Tasks**](/chainlink-nodes/oracle-jobs/all-tasks) \- These are tasks that come built-in to each node. (examples: http, ethabidecode, etc).
  * [**External Adapters**](/chainlink-nodes/external-adapters/external-adapters) \- These are custom adapters built by node operators and community members, which perform specific tasks like calling a particular endpoint with a specific set of parameters (like authentication secrets that shouldn't be publicly visible).

### Tasks

If a job needs to make a GET request to an API, find a specific unsigned
integer field in a JSON response, then submit that back to the requesting
contract, it would need a job containing the following Tasks:

  * [HTTP](/chainlink-nodes/oracle-jobs/all-tasks/#http-task) calls the API. the `method` must be set to _GET_.
  * [JSON Parse](/chainlink-nodes/oracle-jobs/all-tasks/#json-parse-task) parses the JSON and extracts a value at a given keypath.
  * [Multiply](/chainlink-nodes/oracle-jobs/all-tasks/#multiply-task) multiplies the input by a multiplier. Used to remove the decimals.
  * [ETH ABI Encode](/chainlink-nodes/oracle-jobs/all-tasks/#eth-abi-encode-task) converts the data to a bytes payload according to ETH ABI encoding.
  * [ETH

:::NEXT DOC:::

# What is Chainlink Functions?

  * Overview
  * When to use Chainlink Functions
  * Supported networks

Get Started

Chainlink Functions is available on testnet as a limited BETA preview. Apply
[here](https://chainlinkcommunity.typeform.com/requestaccess) to request
access and get started.

Chainlink Functions provides your smart contracts with access to a trust-
minimized compute infrastructure. Your smart contract sends your code to a
[Decentralized Oracle Network (DON)](/chainlink-functions/resources/concepts),
and each DON's oracle runs the same code in a serverless environment. The DON
aggregates all the independent runs and returns the final result to your smart
contract. Your code can be anything from simple computation to fetching data
from API providers.

Chainlink Functions provides access to off-chain computation without having to
run and configure your own Chainlink Node. To pay for requests, you fund a
subscription account with LINK. Your subscription is billed only when the DON
fulfills your request.

To learn more about how _Chainlink Functions_ works, read the
[concepts](/chainlink-functions/resources/concepts) and the
[architecture](/chainlink-functions/resources/architecture) pages.

See the [Tutorials](/chainlink-functions/tutorials) page to find some simple
tutorials that show you different GET and POST requests that run on _Chainlink
Functions_.

## When to use Chainlink Functions

note

Chainlink Functions is a self-service solution. You are responsible for
independently reviewing any JavaScript code that you write and submit in a
request. This includes API dependencies that you send to be executed by
Chainlink Functions. Community-created Javascript code examples might not be
audited, so you must independently review this code before you use it.

Chainlink Functions is offered ""as is"" and ""as available"" without conditions
or warranties of any kind. Neither Chainlink Labs, the Chainlink Foundation,
nor Chainlink node operators are responsible for unintended outputs that are
generated by Functions due to errors in Javascript code submitted by
developers or downstream issues with API dependencies. Users must ensure that
the data sources specified in requests are of sufficient quality and have the
proper availability for your use case. Users are responsible for complying
with the licensing agreements for all data providers that they connect with
through Chainlink Functions.

_Chainlink Functions_ enables a variety of use cases. Use _Chainlink
Functions_ to:

  * Connect to any public data. For example, you can connect your smart contracts to weather statistics for parametric insurance or real-time sports results for Dynamic NFTs.
  * Connect to public data and transform it before consumption. You could calculate Twitter sentiment after reading data from the Twitter API, or derive asset prices after reading price data from [Chainlink Price Feeds](/data-feeds/price-feeds).
  * Connect to a password-protected data source; from IoT devices like smartwatches to enterprise resource planning systems.
  * Connect to an external decentralized database, such as IPFS, to facilitate off-chain processes for a dApp or build a low-cost governance voting system.
  * Connect to your Web2 application and build complex hybrid smart contracts.
  * Fetch data from almost any Web2 system such as AWS S3, Firebase, or Google Cloud Storage.

You can find several community examples at
[useChainlinkFunctions.com](https://www.usechainlinkfunctions.com/)

Testnet BETA Preview

Chainlink Functions is available on testnet only as a limited BETA preview to
ensure that this new platform is robust and secure for developers. While on
testnet and in BETA, developers must follow best practices and not use the
BETA for any production application or secure any value. Chainlink Functions
is likely to evolve and improve. Breaking changes might occur while the
service is in BETA. Monitor these docs to stay updated on feature

:::NEXT DOC:::

process    | DeFi       | Medium       |
| Enabling automated NFT lotteries with Chainlink Keepers and VRF            | NFT        | Medium       |
| How ApeSwap Integrated Chainlink Keepers for BANANA Maximizer Vaults       | DeFi       | Medium       |
### Game resources

  * [CryptoZombies](https://cryptozombies.io/)
  * [DamnVulnerableDefi](https://damnvulnerabledefi.xyz/challenges/8.html)
  * [Ethernaut](https://ethernaut.openzeppelin.com/)

### Coding bootcamps

  * [ChainShot](https://www.chainshot.com/courses)
  * [Consensys Bootcamp](https://consensys.net/academy/bootcamp/)
  * [Ivan On Tech](https://academy.moralis.io/courses/chainlink-101)

### Starter kits

Our Starter Kits help jumpstart your full-stack development process. You can
get starter kits for Brownie (Python), Truffle (Javascript), and Hardhat
(Javascript). See the [Engineering
Tutorials](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J) playlist to learn more about each kit and how to use them.

  * [Chainlink Brownie Starter Kit (Python)](https://github.com/smartcontractkit/chainlink-mix)
  * [Chainlink Truffle Starter Kit (Javascript)](https://github.com/smartcontractkit/truffle-starter-kit)
  * [Chainlink Hardhat Starter Kit (Javascript)](https://github.com/smartcontractkit/hardhat-starter-kit)

### External tutorials

  * [Ethereum Developers](https://ethereum.org/en/developers/tutorials/)
  * [useWeb3](https://www.useweb3.xyz/)

### More inspiration

Looking for more ways to use Chainlink? Here are some resources that discuss
Chainlink's use cases as well as the winning projects we've had in our
previous hackathons. There is also a link to the Marketplace where you can
find the latest data provider nodes and explore the network.

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past Hackathon Winning Projects](/resources/example-projects)

## Outreach

The Chainlink community is an inviting group of engineers that is always
looking to help users expand their knowledge on Chainlink and solve related
issues. Refer back to the [Getting Help](/resources/getting-help) page for the
latest information about how to get support.

### Get support

  * [Stack Overflow](https://stackoverflow.com/questions/tagged/chainlink)
  * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

### Join the community

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/other-tutorials.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",
What is The request and receive cycle in chainlink?,"The request and receive cycle in Chainlink describes the process of how a smart contract requests data from an off-chain source and receives the result. This cycle is facilitated by Chainlink nodes and involves several steps:

Request: A smart contract makes a data request to a Chainlink node. This request is typically encoded in a function call and includes the specific data being requested, and a callback function in the smart contract to receive the data. The contract also sends LINK tokens to the Chainlink node to pay for the data request.

Chainlink Node Receives the Request: The Chainlink node listens for these requests. When it detects one, it initiates the process to fulfill it.

Data Retrieval: The Chainlink node retrieves the requested data from the specified off-chain source. This could be a web API, a different blockchain, a database, or any other data source.

Aggregation (optional): If multiple Chainlink nodes are used to retrieve the same data (to increase data reliability), an aggregation contract might be used to calculate the final result from multiple responses. This could be a simple average, a weighted average, or any other method of combining the data.

Response: The Chainlink node (or aggregation contract) sends the data back to the smart contract. This is done by calling the callback function specified in the original request. The data is now available for the smart contract to use in its logic.

This cycle allows smart contracts to interact with the outside world in a decentralized and trustless manner, greatly expanding their potential use-cases. By using Chainlink, a smart contract can incorporate real-world data into its logic, make decisions based on this data, and even interact with systems outside of the blockchain.","
The request and receive cycle in Chainlink is the process by which a smart contract requests data from an oracle and receives the response in a separate transaction. The cycle begins when a smart contract calls the ChainlinkClient contract to make a request to a known Chainlink oracle through the transferAndCall function, implemented by the LINK token. The request contains encoded information that is required for the cycle to succeed. The oracle contract then emits an OracleRequest event containing information about the request, which is monitored by the off-chain oracle node. The node then performs a job, such as making a GET request to an API, retrieving some data from it, parsing the response, converting the result into blockchain compatible data, and submitting it in a transaction back to the oracle contract, using the fulfillOracleRequest function. Finally, the ChainlinkClient contract receives the response using the callback function defined in the original request.",right,"# API Calls: Using Any API

  * Overview
  * How does the request and receive cycle work for API calls?
  * What are jobs?
  * What are tasks?
  * Tasks
  * Contract example
  * External adapters
  * Further reading

Requirements

This guide requires basic knowledge about smart contracts. If you are new to
smart contract development, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds) and [Random Numbers](/getting-started/intermediates-tutorial) guides before you begin.

In this guide, you will learn how to request data from a public API in a smart
contract. This includes understanding what Tasks and External adapters are and
how Oracle Jobs use them. You will also learn how to find the Oracle Jobs and
Tasks for your contract and how to request data from an Oracle Job.

## How does the request and receive cycle work for API calls?

The request and receive cycle describes how a smart contract requests data
from an oracle and receives the response in a separate transaction. If you
need a refresher, check out the [Basic Request Model](/architecture-overview/architecture-request-model).

For contracts that use [Chainlink VRF](/vrf/v2/introduction), you request
randomness from a VRF oracle and then await the response. The fulfillment
function is already given to us from the `VRFConsumerBase` contract, so
oracles already know where to send the response to. However, with API calls,
the contract itself _defines_ which function it wants to receive the response
to.

Before creating any code, you should understand how Oracle jobs can get data
on-chain.

## What are jobs?

Chainlink nodes require [**Jobs**](/chainlink-nodes/oracle-jobs/jobs) to do
anything useful. In the case of a Request and Receive job, the [Direct
Request](/chainlink-nodes/oracle-jobs/all-jobs#direct-request-jobs) job
monitors the blockchain for a request from a smart contract. Once it catches a
request, it runs the tasks (both core and external adapters) that the job is
configured to run and eventually returns the response to the requesting
contract.

## What are tasks?

Each oracle job has a configured set of tasks it must complete when it is run.
These tasks are split into two subcategories:

  * [**Tasks**](/chainlink-nodes/oracle-jobs/all-tasks) \- These are tasks that come built-in to each node. (examples: http, ethabidecode, etc).
  * [**External Adapters**](/chainlink-nodes/external-adapters/external-adapters) \- These are custom adapters built by node operators and community members, which perform specific tasks like calling a particular endpoint with a specific set of parameters (like authentication secrets that shouldn't be publicly visible).

### Tasks

If a job needs to make a GET request to an API, find a specific unsigned
integer field in a JSON response, then submit that back to the requesting
contract, it would need a job containing the following Tasks:

  * [HTTP](/chainlink-nodes/oracle-jobs/all-tasks/#http-task) calls the API. the `method` must be set to _GET_.
  * [JSON Parse](/chainlink-nodes/oracle-jobs/all-tasks/#json-parse-task) parses the JSON and extracts a value at a given keypath.
  * [Multiply](/chainlink-nodes/oracle-jobs/all-tasks/#multiply-task) multiplies the input by a multiplier. Used to remove the decimals.
  * [ETH ABI Encode](/chainlink-nodes/oracle-jobs/all-tasks/#eth-abi-encode-task) converts the data to a bytes payload according to ETH ABI encoding.
  * [ETH

:::NEXT DOC:::

# Basic Request Model

  * Overview
  * Contracts Overview
  * ChainlinkClient
  * LINK Token
  * Oracle Contract
  * Off-Chain Oracle Node
  * Consumer UML

## Contracts Overview

All source code is open source and available in the [Chainlink Github
repository](https://github.com/smartcontractkit/chainlink).

### ChainlinkClient

[`ChainlinkClient`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol)
is a parent contract that enables smart contracts to consume data from
oracles. It's available in the Chainlink smart contract library which can be
[installed using the latest package managers](/resources/create-a-chainlinked-project).

The client constructs and makes a request to a known Chainlink oracle through
the `transferAndCall` function, implemented by the LINK token. This request
contains encoded information that is required for the cycle to succeed. In the
`ChainlinkClient` contract, this call is initiated with a call to
`sendChainlinkRequestTo`.

To build your own client contract using `ChainlinkClient`, see [Introduction
to Using Any API](/any-api/introduction), or view the [ChainlinkClient API
Reference](/any-api/api-reference) for the `ChainlinkClient` contract.

### LINK Token

LINK is an [ERC-677](https://github.com/ethereum/EIPs/issues/677) compliant
token which implements `transferAndCall`, a function that allows tokens to be
transferred whilst also triggering logic in the receiving contract within a
single transaction.

Learn more about [ERC-677 and the LINK token](/resources/link-token-contracts).

### Oracle Contract

[`Oracle`
contracts](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/Oracle.sol)
are owned by oracle node operators, which run alongside off-chain oracle
nodes.

#### Request

The client contract that initiates this cycle must create a request with the
following items:

  * The oracle address.
  * The job ID, so the oracle knows which tasks to perform.
  * The callback function, which the oracle sends the response to.

To learn about how to find oracles to suit your needs, see [Find Existing
Jobs](/any-api/find-oracle).

Oracle contracts are responsible for handling on-chain requests made through
the LINK token, by implementing `onTokenTransfer` as a
[`LinkTokenReceiver`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/LinkTokenReceiver.sol).
Upon execution of this function, the oracle contract **emits an`OracleRequest`
event** containing information about the request. This event is crucial, as it
is monitored by the off-chain oracle node which acts upon it.

#### Fulfillment

For fulfillment, the oracle contract has a `fulfillOracleRequest` function
which is used by the node to fulfill a request once it has the result of the
job. This function returns the result to the `ChainlinkClient` using the
callback function defined in the original request.

### Off-Chain Oracle Node

The off-chain oracle node is responsible for listening for events emitted by
its corresponding on-chain smart contract. Once it detects an `OracleRequest`
event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API,
retrieve some data from it, parse the response, convert the result into
blockchain compatible data, then submit it in a transaction back to the oracle
contract, using the `fulfillOracleRequest` function.

For more information on how to become a node operator, learn how to [run a
Chainlink node](/chainlink-nodes/v1/running-a-chainlink-node).

## Consumer

:::NEXT DOC:::

# Data Feeds Architecture

  * Overview
  * Basic Request Model
  * Decentralized Data Model
  * Off-Chain Reporting

## Basic Request Model

Chainlink connects smart contracts with external data using its decentralized
oracle network. Chainlink API requests are handled 1:1 by an oracle.

The [Basic Request Model](/architecture-overview/architecture-request-model)
describes the on-chain architecture of requesting data from a single oracle
source.

To learn how to make a GET request using a single oracle, see [Make a GET
Request](/any-api/get-request/introduction).

## Decentralized Data Model

For a more robust and trustworthy answer, you can aggregate data from many
oracles. With on-chain aggregation, data is aggregated from a decentralized
network of independent oracle nodes. This architecture is applied to Chainlink
Data Feeds, which can aggregate data such as asset price data.

The [Decentralized Data Model](/architecture-overview/architecture-decentralized-model) describes how data is aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's oracle initiates the API call on a serverless environment.
  5. Each serverless environment calls the API provider to fetch the API response.
  6. The _DON_ runs the [Off-chain Reporting protocol(OCR)](/chainlink-functions/resources/concepts) to aggregate all the API responses.
  7. The aggregate API response is transmitted by a DON's oracle node to the _FunctionsOracle_ contract.
  8. The _FunctionsOracle_ contract calls the _FunctionsBillingRegistry_ 's `fulfillAndBill` function to calculate the fulfillment costs and finalize the billing (To learn more, read [Cost calculation](/chainlink-functions/resources/billing#cost-calculation-fulfillment)).
  9. The _FunctionsBillingRegistry_ contract calls back the consumer contract.

**Note** : Chainlink Functions requests are not limited to API requests. The
diagram depicts an example of API requests, but you can request the DON to run
any computation.

## Subscription Management

Chainlink Functions requests receive funding from [subscription
accounts](/chainlink-functions/resources/concepts). As explained in
[Concepts](/chainlink-functions/resources/concepts), the _Subscription App_ is
a User Interface that abstracts the communications with the _Subscriptions
contract_ (aka _Functions Billing Registry_ contract). The _Functions Billing
Registry_ lets you manage your subscription accounts.

note

The _Subscriptions App_ is not available now, we recommend using the
[functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to communicate with the [Functions Billing Registry
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol).

### Create Subscription

EOAs (Externally Owned Accounts) create subscriptions using the _Subscriptions
App_. The App communicates",
What are jobs in Chainlink?,"In the Chainlink ecosystem, a ""job"" refers to a specific series of tasks that a Chainlink node is assigned to perform. Each job is defined by a Job Specification, which is written in JSON format and details the specific tasks a node should complete.

Chainlink jobs are generally used to fetch data from an off-chain API, perform certain operations on the data, and then deliver the data to a smart contract on the blockchain.

A typical Chainlink job might look something like this:

HTTP GET: This task instructs the Chainlink node to make a GET request to a specific API endpoint.

JSON Parse: After the HTTP GET task, the Chainlink node will have a JSON response from the API. This task instructs the node to parse the JSON and extract a specific piece of data.

Multiply: Often, the data received needs to be multiplied to convert it into a format suitable for the blockchain (since blockchains cannot handle decimal numbers).

ETHUint256: This task is used to convert the multiplied number to an Ethereum-compatible data type.

ETH TX: This task instructs the Chainlink node to send the final data to a smart contract on the Ethereum blockchain.

Each task in the job is performed in the specified order, and the output of one task is passed as the input to the next task in the chain.

Chainlink nodes are rewarded in LINK tokens for executing jobs. This provides an incentive for node operators to reliably fulfill data requests, and contributes to the decentralized and trustless nature of the Chainlink network.","
Jobs in Chainlink include operating a Chainlink node, fulfilling job requests, adding external adapters to a node, participating in a hackathon, applying for a grant, creating community content, becoming a developer expert, joining the Chainlink Community Advocate program, running a Chainlink focused developer bootcamp, and running an in-person meetup or watch party.",wrong,"exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually hosted](https://blog.chain.link/smart-contract-developer-bootcamp-on-demand/) the first [Chainlink Developer
Bootcamp](http://chain.link/bootcamp). If you're passionate about educating
others about smart contracts and Chainlink, you can contribute by running your
own developer Bootcamp. You can also contribute by translating an existing
Bootcamp and running it in another language. Before you run your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

the main node software and smart contracts that you can tackle. Each
major repository in the Chainlink GitHub should also have some good first
issues tagged for developers to be able to take on.

All code changes must follow the [style guide]
(<https://github.com/smartcontractkit/chainlink/wiki/Code-Style-Guide>), All
PRs must be in an appropriately named branch with a format like 'feat/feature-
description' or 'devel/issue-description'. After you submit a PR, you should
get a response by a team member within a day or two acknowledging that the PR
has been received. After that, monitor the PR for any additional questions or
updates that come up while the team and the community review the changes.

## Contributing to the documentation

The [Chainlink documentation](https://docs.chain.link/) is the go-to place for
developers who want to learn how to build applications using Chainlink, and
node operators wanting useful information on running a Chainlink node. The
documentation is [open
source](https://github.com/smartcontractkit/documentation), allowing for other
developers and community members to contribute to adding or improving it. You
can contribute to the Chainlink documentation in various ways:

  * Improving the readability of pages
  * Fixing typos or grammar errors
  * Adding new guides or tutorials that you would find useful
  * Translating the documentation into other languages

The process for contributing to the documentation follows the process defined
earlier in the Submitting a Pull Request section. Each page also has a
'Suggest Edits' link on the top right, and will directly take you to the page
in the [documentation
repository](https://github.com/smartcontractkit/documentation), where you can
create a new PR with the suggested changes. Before you create a PR for the
documentation, read the [contributing
guidelines](https://github.com/smartcontractkit/documentation/blob/main/CONTRIBUTING.md).

If you want to translate the documentation into a new language that is not yet
supported, feel free to [reach out to the
team](mailto:devrel@smartcontract.com) beforehand, so we can make sure you get
the support you need.

## Creating Community Content

Chainlink has a strong and vibrant community of developers and community
advocates. Community members often create Chainlink-focused content in various
forms and publish it for the wider community on various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have

:::NEXT DOC:::

process    | DeFi       | Medium       |
| Enabling automated NFT lotteries with Chainlink Keepers and VRF            | NFT        | Medium       |
| How ApeSwap Integrated Chainlink Keepers for BANANA Maximizer Vaults       | DeFi       | Medium       |
### Game resources

  * [CryptoZombies](https://cryptozombies.io/)
  * [DamnVulnerableDefi](https://damnvulnerabledefi.xyz/challenges/8.html)
  * [Ethernaut](https://ethernaut.openzeppelin.com/)

### Coding bootcamps

  * [ChainShot](https://www.chainshot.com/courses)
  * [Consensys Bootcamp](https://consensys.net/academy/bootcamp/)
  * [Ivan On Tech](https://academy.moralis.io/courses/chainlink-101)

### Starter kits

Our Starter Kits help jumpstart your full-stack development process. You can
get starter kits for Brownie (Python), Truffle (Javascript), and Hardhat
(Javascript). See the [Engineering
Tutorials](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J) playlist to learn more about each kit and how to use them.

  * [Chainlink Brownie Starter Kit (Python)](https://github.com/smartcontractkit/chainlink-mix)
  * [Chainlink Truffle Starter Kit (Javascript)](https://github.com/smartcontractkit/truffle-starter-kit)
  * [Chainlink Hardhat Starter Kit (Javascript)](https://github.com/smartcontractkit/hardhat-starter-kit)

### External tutorials

  * [Ethereum Developers](https://ethereum.org/en/developers/tutorials/)
  * [useWeb3](https://www.useweb3.xyz/)

### More inspiration

Looking for more ways to use Chainlink? Here are some resources that discuss
Chainlink's use cases as well as the winning projects we've had in our
previous hackathons. There is also a link to the Marketplace where you can
find the latest data provider nodes and explore the network.

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past Hackathon Winning Projects](/resources/example-projects)

## Outreach

The Chainlink community is an inviting group of engineers that is always
looking to help users expand their knowledge on Chainlink and solve related
issues. Refer back to the [Getting Help](/resources/getting-help) page for the
latest information about how to get support.

### Get support

  * [Stack Overflow](https://stackoverflow.com/questions/tagged/chainlink)
  * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

### Join the community

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/other-tutorials.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",wrong
How can i Acquire testnet LINK from Chainlink?,"you can acquire testnet LINK tokens for Chainlink development from faucets specific to each testnet. Here are the general steps:

Setup a Wallet: If you don't have one already, set up a Metamask or other Ethereum-compatible wallet. Make sure it's configured to connect to the appropriate Ethereum testnet (like Kovan, Rinkeby, or Ropsten).

Get Testnet Ether: You'll need testnet Ether (ETH) to pay for gas costs on the testnet. You can get this from various faucets like the Kovan faucet, Rinkeby faucet, or Ropsten faucet. You typically just need to enter your wallet address and request the testnet ETH.

Get Testnet LINK: Once you have some testnet ETH, visit a Chainlink faucet to receive testnet LINK. For example, for the Kovan testnet, you might use the Chainlink Kovan faucet. Enter your wallet address, and you'll receive testnet LINK.","
To acquire testnet LINK from Chainlink, you must first configure MetaMask to use LINK tokens. To do this, open MetaMask and click ""Import tokens"" at the bottom of the MetaMask window. Then, find the LINK token contract address for the network you want to use. Paste the token contract address into MetaMask in the Token Address input. The token symbol and decimals of precision will auto-populate. Click ""Next"" and then ""Import Tokens"" to confirm adding the new token. 

Once MetaMask is configured, you can get testnet LINK from a faucet. Go to https://faucets.chain.link/ and select the network where you want to receive testnet LINK. Click ""Connect wallet"" so the faucet app can detect the network and wallet address. If you want to receive testnet funds at a different address, paste it in the ""Wallet address"" section. In the ""Request type"" section, select the testnet funds that you want to receive. Complete the Captcha and click ""Send request"". The funds are transferred from the faucet to the wallet address that you specified. After the transaction is confirmed on-chain, the faucet app shows ""Request",right,"# Acquire testnet LINK

  * Overview
  * Configure MetaMask to use LINK tokens
  * Get testnet LINK from a faucet

The Getting Started guides show you how to send ETH on the Sepolia testnet,
but some contracts might require you to use LINK token instead. This page
shows you how to obtain testnet LINK and send it to your MetaMask wallet.

## Configure MetaMask to use LINK tokens

To see your LINK token balance in MetaMask, you must manually add the token.

  1. Open up MetaMask.

  2. At the bottom of the MetaMask windows, click **Import tokens**.

  3. Find the LINK token contract address for the network that you want to use. On Sepolia, the LINK token address is: `0x779877A7B0D9E8603169DdbD7836e478b4624789`. See the [LINK Token Contracts](/resources/link-token-contracts) page to find the addresses for different testnets.

  4. Paste the token contract address into MetaMask in the Token Address input. The token symbol and decimals of precision will auto-populate.

  5. Click **Next**. A new window will appear, showing the LINK token details.

  6. Click **Import Tokens** to confirm adding the new token.

MetaMask should now display the new LINK token balance.

## Get testnet LINK from a faucet

  1. Go to <https://faucets.chain.link/>.
  2. In Metamask, select the network where you want to receive testnet LINK.
  3. Click **Connect wallet** so the faucet app can detect the network and wallet address.
  4. If you want to receive testnet funds at a different address, paste it in the **Wallet address** section. This field defaults to your connected wallet address.
  5. In the **Request type** section, select the testnet funds that you want to receive.
  6. Complete the Captcha and click **Send request**. The funds are transferred from the faucet to the wallet address that you specified.

After the transaction is confirmed on-chain, the faucet app shows ""Request
complete"" and the transaction hash of your request.



## What's next

  * [› Deploy your first contract](/getting-started/deploy-your-first-contract)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/acquire-link.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

testnet ETH and LINK from
Ethereum Goerli to Optimistim Goerli. Select Optimism Goerli in your wallet to
access the Optimism Goerli bridge. Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 420                                        |
| Address      | 0xdc2CC710e42857672E7907CF474a69B63B93089f |
| Name         | Chainlink Token on Optimism Goerli         |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Harmony

### Harmony mainnet

ONE is used to pay for transactions on Harmony mainnet. You can use the
[Harmony Bridge](https://bridge.harmony.one/) to transfer ONE and LINK token
from Ethereum Mainnet to Harmony mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1666600000                                 |
| Address        | 0x218532a12a389a4a92fC0C5Fb22901D1c19198aA |
| Name           | Chainlink Token on Harmony Mainnet         |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | status.harmony.one                         |
## Moonriver

### Moonriver mainnet

MOVR is used to pay transaction fees on Moonriver mainnet. You can use
[bridge.multichain.org](https://bridge.multichain.org/#/router) to transfer
LINK to Moonriver mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1285                                       |
| Address        |

:::NEXT DOC:::

is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 421613                                     |
| Address      | 0xd14838A68E8AFBAdE5efb411d5871ea0011AFd28 |
| Name         | Chainlink Token on Arbitrum Goerli         |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Optimism

### Optimism mainnet

ETH is used to pay for transactions on Optimism. Use the [Optimism
Bridge](https://app.optimism.io/bridge) to transfer ETH and LINK from Ethereum
Mainnet to Optimism mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 10                                         |
| Address        | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 |
| Name           | Chainlink Token on Optimism Mainnet        |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | status.optimism.io                         |
### Optimism Goerli testnet

Testnet ETH is used to pay for transactions on Optimism. Use the [Optimism
Bridge](https://app.optimism.io/bridge) to transfer testnet ETH and LINK from
Ethereum Goerli to Optimistim Goerli. Select Optimism Goerli in your wallet to
access the Optimism Goerli bridge. Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 420

:::NEXT DOC:::

# Testnet Oracles

  * Overview
  * Operator Contracts
  * Jobs
  * Job IDs
  * Examples

The Chainlink Developer Relations team maintains several testnet oracles that
you can use to test your implementation quickly.

Link token address and Faucet details

To retrieve the LINK token address or get faucet details for your testnet of
choice, see the [LINK Token Contracts](/resources/link-token-contracts) page.

## Operator Contracts

Testnet [Operator
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
are deployed and maintained on the following networks:

| Testnet          | Oracle Address                             |
|:-----------------|:-------------------------------------------|
| Ethereum Sepolia | 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD |
| Ethereum Goerli  | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
| Avalanche Fuji   | 0x022EEA14A6010167ca026B32576D6686dD7e85d2 |
| Polygon Mumbai   | 0x40193c8518BB267228Fc409a613bDbD8eC5a97b3 |
| Binance Testnet  | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
| Fantom Testnet   | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
## Jobs

### Job IDs

To make testing simple, jobs are configured with the following properties:

  * Each request on testnets costs 0.1 LINK.
  * Each oracle will wait for 1 confirmation before processing a request.
  * Jobs have the same IDs accross testnets.
  * Parameters are required. See examples for code snippets.

| Purpose                                                                                                                                                            | Tasks                                | Job ID                           | Required Parameters                                                           |
|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------|:---------------------------------|:------------------------------------------------------------------------------|
| GET>bytes: HTTP GET to any public API parse the response return arbitrary-length raw byte data bytes. The job specs can be found here                              | Http JsonParse Ethabiencode          | 7da2702f37fd48e5b1b9a5715e3509b6 | get: stringpath: JSONPath expression with comma(,) delimited string           |
| GET>uint256: HTTP GET to any public API parse the reponse multiply the result by a multiplier return an",
What is the decentralized data model in Chainlink?,"The decentralized data model in Chainlink refers to its approach of using multiple independent nodes to provide data to smart contracts. This is in contrast to a centralized model, where a single entity or server provides the data.

In Chainlink's decentralized model, multiple independent, Sybil-resistant oracle nodes fetch data from various high-quality data sources. This approach has several advantages:

Reliability: Because multiple nodes are retrieving and reporting data, the system isn't reliant on a single point of failure. If one node goes down or reports incorrect data, the other nodes can still provide the correct data.

Security: The data provided by the nodes is more secure because it's much harder for a bad actor to manipulate. They would have to take control of or manipulate a majority of the nodes, which is significantly more difficult than attacking a single, centralized source.

Accuracy: Multiple nodes retrieving data from multiple sources allows for more accurate and reliable data. The data from all the nodes can be aggregated to provide a single, more accurate data point.

Chainlink's decentralized data model is a key feature that makes it attractive for DeFi and other decentralized applications. It allows smart contracts to interact with real-world data in a secure and reliable manner, without compromising the decentralized principles of blockchain technology.","
The decentralized data model in Chainlink is a system that connects smart contracts with external data using a decentralized oracle network. Data is aggregated from a decentralized network of independent oracle nodes and is applied to Chainlink Data Feeds, which can aggregate data such as asset price data. The decentralized data model describes how data is aggregated, and how consumer contracts can retrieve this data. Off-Chain Reporting (OCR) is an improvement on the decentralization and scalability of Chainlink networks.",right,"# Data Feeds Architecture

  * Overview
  * Basic Request Model
  * Decentralized Data Model
  * Off-Chain Reporting

## Basic Request Model

Chainlink connects smart contracts with external data using its decentralized
oracle network. Chainlink API requests are handled 1:1 by an oracle.

The [Basic Request Model](/architecture-overview/architecture-request-model)
describes the on-chain architecture of requesting data from a single oracle
source.

To learn how to make a GET request using a single oracle, see [Make a GET
Request](/any-api/get-request/introduction).

## Decentralized Data Model

For a more robust and trustworthy answer, you can aggregate data from many
oracles. With on-chain aggregation, data is aggregated from a decentralized
network of independent oracle nodes. This architecture is applied to Chainlink
Data Feeds, which can aggregate data such as asset price data.

The [Decentralized Data Model](/architecture-overview/architecture-decentralized-model) describes how data is aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Decentralized Data Model

  * Overview
  * Data Aggregation
  * Shared Data Resource
  * Decentralized Oracle Network
  * Components of a Decentralized Oracle Network
  * Consumer
  * Proxy
  * Aggregator

This page describes how data aggregation is applied to produce Chainlink Data
Feeds and provides more insight as to how Data Feeds are updated.

## Data Aggregation

Each data feed is updated by multiple, independent Chainlink oracle operators.
The
[AccessControlledOffchainAggregator](https://github.com/smartcontractkit/libocr/blob/master/contract/AccessControlledOffchainAggregator.sol)
aggregates the data on-chain.

Off-Chain Reporting (OCR) further enhances the aggregation process. To learn
more about OCR and how it works, see the [Off-Chain Reporting](/architecture-overview/off-chain-reporting) page.

## Shared Data Resource

Each data feed is built and funded by the community of users who rely on
accurate, up-to-date data in their smart contracts. As more users rely on and
contribute to a data feed, the quality of the data feed improves. For this
reason, each data feed has its own properties depending on the needs of its
community of users.

## Decentralized Oracle Network

Each data feed is updated by a decentralized oracle network. Each oracle
operator is rewarded for publishing data. The number of oracles contributing
to each feed varies. In order for an update to take place, the data feed
aggregator contract must receive responses from a minimum number of oracles or
the latest answer will not be updated. You can see the minimum number of
oracles for the corresponding feed at
[data.chain.link](https://data.chain.link).

Each oracle in the set publishes data during an aggregation round. That data
is validated and aggregated by a smart contract, which forms the feed's latest
and trusted answer.

## Components of a Decentralized Oracle Network

Data Feeds are an example of a decentralized oracle network, and include the
following components:

  * A consumer contract
  * A proxy contract
  * An aggregator contract

To learn how to create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

### Consumer

A Consumer contract is any contract that uses Chainlink Data Feeds to consume
aggregated data. Consumer contracts must reference the correct
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract and call one of the exposed functions.


    ...
    AggregatorV3Interface feed = AggregatorV3Interface(address);
    return feed.latestRoundData();

Off-chain applications can also consume data feeds. See the Javascript and
Python example code on the [Using Data Feeds](/data-feeds/price-feeds) page to
learn more.

### Proxy

Proxy contracts are on-chain proxies that point to the aggregator for a
particular data feed. Using proxies enables the underlying aggregator to be
upgraded without any service interruption to consuming contracts.

Proxy contracts can vary from one data feed to another, but the
[`AggregatorProxy.sol`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol)
on Github is a common example.

### Aggregator

An aggregator is the contract that receives periodic data updates from the
oracle network. Aggregators store aggregated data on-chain so that consumers
can retrieve it and act upon it within the same transaction.

You can access this data using the Data Feed address and

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

## Welcome to the Chainlink Documentation

##### New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide.

## Explore our products

#### [Data Feeds](data-feeds)

Decentralized and high-quality data feeds for DeFi, Reserves, NFTs, sports,
weather, and more

###### Available on:

#### [Chainlink Functions](chainlink-functions)

Connect smart contracts to a trust-minimized compute infrastructure running on
a decentralized oracle network

###### Available on:

#### [Automate Contracts](chainlink-automation/introduction)

Decentralized, highly reliable, cost-efficient and highly secure automation
for smart contracts

###### Available on:

#### [VRF v2](/vrf/v2/introduction)

Verifiable, tamper-proof random number generator for blockchain gaming and NFT
projects

###### Available on:

#### [External API Calls](/any-api/introduction)

Request and receive data from any API using the Chainlink contract library

###### Available on:

## Useful resources

### Need to run your own Chainlink Node?

See the Node Operator’s Guide to learn about starting and maintaining
Chainlink Nodes.

#### Watch tutorials

Learn more about the technology we are building. We're constantly uploading
new videos to our YouTube channel.

##### Need integration support?

##### Discord

##### Stack overflow

",
What data types are available for Rate and Volatility Feeds on Chainlink?,"The following data types are available:

Bitcoin Interest Rate Curve
ETH Staking APR
Realized Volatility","
The data types available for Rate and Volatility Feeds on Chainlink are Bitcoin Interest Rate Curve, ETH Staking APR, and Realized Volatility.",right,"# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is

:::NEXT DOC:::

is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is met.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find heartbeat and deviation information for each
feed. If you have questions or would like to request an enhancement to
Realized Volatility Feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Rate and Volatility Feeds](/data-feeds/rates-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

                                                    | Type     | Difficulty   |
|:---------------------------------------------------------------------------------------|:---------|:-------------|
| How to Calculate Price Volatility for DeFi Variance Swaps                              | DeFi     | Advanced     |
| Build a dApp on Gnosis Chain (xDai) with Secure Data Feeds                             | DeFi     | Medium       |
| Craft Whiskey Crypto Payments With Chainlink Oracles                                   | Payments | Advanced     |
| Convert a Vending Machine to Accept Cryptocurrency Payments Using Chainlink Data Feeds | Payments | Advanced     |
| Build a dApp on BNB Chain With Secure Data Feeds                                       | DeFi     | Medium       |
| How to Use Chainlink With Hardhat                                                      | DeFi     | Medium       |
| Develop a DeFi Project Using Python                                                    | DeFi     | Medium       |
| Build a DeFi Call Option Exchange With Chainlink Data Feeds                            | DeFi     | Advanced     |
| Build a DeFi Yield Farming dApp Using Chainlink Data Feeds                             | DeFi     | Advanced     |
| Build and Deploy an Avalanche Smart Contract                                           | DeFi     | Beginner     |
#### Randomness (VRF)

| Name                                         | Type     | Difficulty   |
|:---------------------------------------------|:---------|:-------------|
| How to Get a Random Number on Polygon        | DeFi     | Medium       |
| Build Your Own Dynamic NFT With Hardhat      | NFT      | Advanced     |
| Build, Deploy, and Sell Your Own Dynamic NFT | NFT      | Advanced     |
| How to Build a Blockchain Lottery            | Gambling | Advanced     |
#### API requests

| Name                                                                                    | Type       

:::NEXT DOC:::

# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like [AAVE](https://aave.com/) use Data Feeds to ensure the total
value of the collateral.

Data Feeds aggregate many data sources and publish them on-chain using a
combination of the [Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) and [Off-Chain
Reporting](/architecture-overview/off-chain-reporting?parent=dataFeeds).

To learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract",
What is a Chainlink NFT Floor Price Feed?,"Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor price estimate for an NFT collection. These feeds operate the same way as other Chainlink Data Feeds. NFT Floor Price Feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink’s oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. You can use NFT Floor Price Feeds for use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.","
A Chainlink NFT Floor Price Feed is a conservative and risk averse floor price estimate for an NFT collection. These feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink's oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. They can be used for use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.",right,"# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) =

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |

:::NEXT DOC:::

|
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price      | ETH           | 2%          |        3600 |    18 | 0x870bc8BfEe8A7Bbd63Dc1ef09F2fF37DeBCfEF35 |
| Doodles Floor Price        | ETH           | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

  |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
|",
How can I Select Quality Data Feeds on Chainlink?,"Selecting quality data feeds on Chainlink involves evaluating several factors. Here are some of the key considerations:

Number of Nodes: More nodes contributing to a data feed generally means greater decentralization and higher resistance to manipulation.

Update Frequency: How often is the data feed updated? Depending on your use case, you might need a feed that updates very frequently.

Deviation Threshold: This is the amount by which the price must change compared to the last reported price for the nodes to post a new round of data. A smaller deviation threshold can lead to more frequent updates.

Oracle Reputation: Chainlink maintains a reputation system for its oracles (nodes). Higher reputation generally means the oracle has successfully completed more jobs.

Data Source Quality: While Chainlink nodes should be getting their data from high-quality sources, it's always good to confirm this yourself. Reliable data sources increase the overall quality of the data feed.

Chainlink provides a list of Price Feeds along with detailed metrics about each feed. These metrics include the number of oracles contributing to the feed, the update frequency, the median gas price of the latest transactions, etc.","
When selecting quality data feeds on Chainlink, you should consider the accuracy, availability, and quality of the data you choose to consume. Chainlink lists decentralized data feeds in the documentation to help developers build new applications integrated with data. Data feeds are grouped into the following categories based on the level of risk from lowest to highest: Verified Feeds, Monitored Feeds, Provisional Feeds, Custom Feeds, Specialized Feeds, and Deprecating. For important updates regarding the use of Chainlink Price Feeds, users should join the official Chainlink Discord and subscribe to the data-feeds-user-notifications channel. Additionally, users should read the Risk Mitigation and Evaluating Data Sources sections when making design decisions.",right,"# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem.

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs

:::NEXT DOC:::

the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",
What are verified feeds on Chainlink?,"These are data feeds that follow a standardized data feeds workflow. Chainlink node operators each query several sources for the market price and aggregate the estimates provided by those sources.

Verified feeds have the following characteristics:

Highly resilient to disruption
Leverage many data sources
Use an extensive network of nodes
Highly liquid and well represented on a large number of markets
These feeds incorporate three layers of aggregation (at the data source, node operator, and oracle network layers), providing industry-grade security and reliability on the price data they reference. To learn more about the three layers of data aggregation, see the blog post about Data Aggregation in Chainlink Price Feeds.

Inherent risks might still exist based on your use case, the blockchain on which the feed is deployed and the conditions on that chain.","
Verified feeds on Chainlink are data feeds that follow a standardized data feeds workflow. Chainlink node operators each query several sources for the market price and aggregate the estimates provided by those sources. Verified feeds have the following characteristics: highly resilient to disruption, leverage many data sources, use an extensive network of nodes, and are highly liquid and well represented on a large number of markets. These feeds incorporate three layers of aggregation (at the data source, node operator, and oracle network layers), providing industry-grade security and reliability on the price data they reference.",right,"# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem.

:::NEXT DOC:::

Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs

:::NEXT DOC:::

# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like [AAVE](https://aave.com/) use Data Feeds to ensure the total
value of the collateral.

Data Feeds aggregate many data sources and publish them on-chain using a
combination of the [Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) and [Off-Chain
Reporting](/architecture-overview/off-chain-reporting?parent=dataFeeds).

To learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract

:::NEXT DOC:::

## Welcome to the Chainlink Documentation

##### New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide.

## Explore our products

#### [Data Feeds](data-feeds)

Decentralized and high-quality data feeds for DeFi, Reserves, NFTs, sports,
weather, and more

###### Available on:

#### [Chainlink Functions](chainlink-functions)

Connect smart contracts to a trust-minimized compute infrastructure running on
a decentralized oracle network

###### Available on:

#### [Automate Contracts](chainlink-automation/introduction)

Decentralized, highly reliable, cost-efficient and highly secure automation
for smart contracts

###### Available on:

#### [VRF v2](/vrf/v2/introduction)

Verifiable, tamper-proof random number generator for blockchain gaming and NFT
projects

###### Available on:

#### [External API Calls](/any-api/introduction)

Request and receive data from any API using the Chainlink contract library

###### Available on:

## Useful resources

### Need to run your own Chainlink Node?

See the Node Operator’s Guide to learn about starting and maintaining
Chainlink Nodes.

#### Watch tutorials

Learn more about the technology we are building. We're constantly uploading
new videos to our YouTube channel.

##### Need integration support?

##### Discord

##### Stack overflow

",
