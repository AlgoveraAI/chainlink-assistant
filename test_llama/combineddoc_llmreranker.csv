question,answer,result,retrieved_docs,right_or_wrong,rd_right_or_wrong
give me a sample solidity contract to use Chainlink price feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","Here is a sample Solidity contract that uses Chainlink price feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        (
            uint80 roundID,
            int price,
            uint startedAt,
            uint timeStamp,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
}
```

This contract obtains the latest price answer from the BTC/USD feed on the Sepolia testnet, but it can be modified to read any of the different types of data feeds.","# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
        

:::NEXT DOC:::

# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
   

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

 

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

`latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on

:::NEXT DOC:::

`latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending

:::NEXT DOC:::

token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions

:::NEXT DOC:::

with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
          ",right,
give me a sample solidity contract to use Chainlink VRF?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFD20 is VRFConsumerBaseV2 {

}
uint64 s_subscriptionId;
address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
uint32 callbackGasLimit = 40000;
uint16 requestConfirmations = 3;
uint32 numWords =  1;
)
(
give me a sample solidity contract to request data from a public API in a smart contract using chainlink?,
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req.add(
            ""get"",
            ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {""RAW"":
        //   {""ETH"":
        //    {""USD"":
        //     {
        //      ""VOLUME24HOUR"": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR""); // Chainlink nodes prior to 1.0.0 support this format
        req.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR""); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req.addInt(""times"", timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            ""Unable to transfer""
        );
    }
}","There are multiple sample Solidity contracts available for using Chainlink VRF, depending on the version and funding method. Some examples include:

- VRFv2Consumer: a contract that uses the VRF Coordinator interface and requires external funding with LINK tokens.
- VRFv2DirectFundingConsumer: a contract that uses the VRF v2 Wrapper interface and includes pre-configured values for request parameters and LINK token address, but still requires external funding with LINK tokens.
- VRFConsumerBase: a contract that uses the VRF Coordinator interface and requires external funding with LINK tokens, but is based on an earlier version of Chainlink VRF.
- VRFv1Consumer: a contract that uses the VRF Coordinator interface and requires external funding with LINK tokens, but is based on an earlier version of Chainlink VRF.

It's important to note that these contracts are provided as examples and should not be used in production without proper auditing and customization. Additionally, funding the contract with enough LINK tokens is necessary for requesting randomness from VRF.","for funding.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2Consumer is VRFConsumerBaseV2, ConfirmedOwner {
        event RequestSent(uint256 requestId, uint32 numWords);
        event RequestFulfilled(uint256 requestId, uint256[] randomWords);
    
        struct RequestStatus {
            bool fulfilled; // whether the request has been successfully fulfilled
            bool exists; // whether a requestId exists
            uint256[] randomWords;
        }
        mapping(uint256 => RequestStatus)
           

:::NEXT DOC:::

Client Contract:

The contract you are building must import and inherit the client contract. It allows your contract to send the proper requests and receive answers from the Chainlink VRF. To send requests it allows your contract to utilize a function called “RequestRandomness”. To receive answers your contract will need to have a “FulfillRandomness” function. To import the Client Contract you need only one line at the top of your Solidity code:

<Highlight class=""language-javascript"">
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
</Highlight>

And to inherit the contract you must put the following when naming your contract:

<Highlight class=""language-javascript"">
contract VRFv2Consumer is VRFConsumerBaseV2
</Highlight>

VRF Coordinator Contract:

The Coordinator contract has two main duties. Manage subscriptions to the Chainlink VRF and verify every random number alongside its proof. A VRF subscription represents a contract that wants to receive a random number, how many random numbers it wants to receive, and how many LINK tokens have been pre-paid for that contact (as for every Chainlink service LINK tokens are used to pay the Chainlink VRF for every random number requested). So it essentially coordinates the random numbers sent out by Chainlink VRF!


:::NEXT DOC:::

   import ""@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol"";
    

Open _LinkToken_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.4.24;
    
    import ""@chainlink/contracts/src/v0.4/LinkToken.sol"";
    

Open _VRFV2Wrapper_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    import ""@chainlink/contracts/src/v0.8/VRFV2Wrapper.sol"";
    

Open _RandomNumberDirectFundingConsumerV2_ and compile in Remix:


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UNAUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract RandomNumberDirectFundingConsumerV2 is
        VRFV2WrapperConsumerBase,
        ConfirmedOwner
    {
        event RequestSent(uint256

:::NEXT DOC:::

page.

## Analyzing the contract

In this example, the consuming contract uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract VRFv2DirectFundingConsumer is
        VRFV2WrapperConsumerBase,
        ConfirmedOwner
    {
        event RequestSent(uint256 requestId, uint32 numWords);
        event RequestFulfilled(
            uint256 requestId,
            uint256[] randomWords,
            uint256 payment
        );
    
        struct RequestStatus {
      

:::NEXT DOC:::

`VRFv2Consumer` contract from the contract list, and specify your `subscriptionId` so the constructor can set it.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must add this address as an approved consuming contract on your subscription account.

  6. Open the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/) and click the ID of your new subscription under the **My Subscriptions** list. The subscription details page opens.

  7. Under the **Consumers** section, click **Add consumer**.

  8. Enter the address of your consuming contract that you just deployed and click **Add consumer**. MetaMask opens and asks you to confirm the transaction.

Your example contract is deployed and approved to use your subscription
balance to pay for VRF v2 requests. Next, request random values from Chainlink
VRF.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF processes your request. Chainlink VRF fulfills the request and returns the random values to your contract in a callback to the `fulfillRandomWords()` function. At this point, a new key `requestId` is added to the mapping `s_requests`.

Depending on

:::NEXT DOC:::

the below values have to be configured correctly for VRF requests to
work. You can find the respective values for your network in the [VRF
Contracts page](/vrf/v1/supported-networks).

  * `LINK Token` \- LINK token address on the corresponding network (Ethereum, Polygon, BSC, etc)
  * `VRF Coordinator` \- address of the Chainlink VRF Coordinator
  * `Key Hash` \- public key against which randomness is generated
  * `Fee` \- fee required to fulfill a VRF request

Security Considerations

Be sure to look your contract over with [these security
considerations](/vrf/v1/security) in mind!

Remember to fund your contract with LINK!

Requesting randomness will fail unless your deployed contract has enough LINK
to pay for it. **Learn how to[Acquire testnet LINK](/resources/acquire-link)
and [Fund your contract](/resources/fund-your-contract)**.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBase.sol"";
    
    /**
     * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    


:::NEXT DOC:::

contract also includes pre-configured values for the necessary request
parameters such as `callbackGasLimit`, `requestConfirmations`, the number of
random words `numWords`, the VRF v2 Wrapper address `wrapperAddress`, and the
LINK token address `linkAddress`. You can change these parameters if you want
to experiment on different testnets.

Build and deploy the contract on Sepolia.

  1. Open the [`VRFv2DirectFundingConsumer.sol` contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2DirectFundingConsumer.sol) in Remix.

[ Open in Remix
](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2DirectFundingConsumer.sol)
[What is Remix?](/getting-started/conceptual-overview#what-is-remix)

  2. On the **Compile** tab in Remix, compile the `VRFv2DirectFundingConsumer` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Web3 Environment** and select the `VRFv2DirectFundingConsumer` contract from the contract list.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must fund your consuming contract with enough LINK tokens in order to request for randomness. Next, fund your contract.

## Fund Your Contract

Requests for randomness will fail unless your consuming contract has enough
LINK.

  1. [Acquire testnet LINK](/resources/acquire-link).
  2. [Fund your contract with testnet LINK](/resources/fund-your-contract). For this example, funding your contract

:::NEXT DOC:::

using the following tools:

  * [The Remix IDE](https://remix.ethereum.org/)
  * [MetaMask](https://metamask.io/)
  * [Sepolia testnet ETH](/resources/link-token-contracts/#sepolia-testnet)

If you are new to developing smart contracts on Ethereum, see the [Getting
Started](/getting-started/conceptual-overview) guide to learn the basics.

## Create and deploy a VRF v2 compatible contract

For this example, use the
[VRFv2DirectFundingConsumer.sol](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2DirectFundingConsumer.sol)
sample contract. This contract imports the following dependencies:

  * `VRFV2WrapperConsumerBase.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol)
  * `ConfirmedOwner.sol`[(link)](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/ConfirmedOwner.sol)

The contract also includes pre-configured values for the necessary request
parameters such as `callbackGasLimit`, `requestConfirmations`, the number of
random words `numWords`, the VRF v2 Wrapper address `wrapperAddress`, and the
LINK token address `linkAddress`. You can change these parameters if you want
to experiment on different testnets.

Build and deploy the contract on Sepolia.

  1. Open the [`VRFv2DirectFundingConsumer.sol` contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/VRF/VRFv2DirectFundingConsumer.sol) in Remix.

[ Open in

:::NEXT DOC:::

Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number.


:::NEXT DOC:::

next to the **Gas limit**
amount. Update the **Gas limit** value to _400000_ and select **Save**.
Finally, confirm the transaction.

After you approve the transaction, Chainlink VRF processes your request.
Chainlink VRF fulfills the request and returns the random values to your
contract in a callback to the `fulfillRandomWords()` function. At this point,
a new key `requestId` is added to the mapping `s_requests`. Depending on
current testnet conditions, it might take a few minutes for the callback to
return the requested random values to your contract.

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated. The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` and specify the `requestId` to display the random words.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, the consuming contract uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here:",wrong,partial
give me a sample solidity contract to use NFT Floor Price Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}","Here is a sample Solidity contract to use NFT Floor Price Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
```","Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
    

:::NEXT DOC:::

# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

 

:::NEXT DOC:::

     | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility Feeds](/data-feeds/rates-feeds)
documentation.

See the [Rate and Volatility Contract Addresses](/data-feeds/rates-feeds/addresses) page for a list of available networks and addresses.

### L2 sequencer uptime feeds

L2 sequencer feeds track the last known status of the sequencer on an L2
network at a given point in time. This helps you prevent mass liquidations by
providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds feeds, see the [L2 Sequencer
Uptime Feeds](/data-feeds/l2-sequencer-feeds) documentation.

## Components of a data feed

Data Feeds are an example of a decentralized oracle network and include the
following components:

  * **Consumer** : A consumer is an on-chain or off-chain application that uses Data Feeds. Consumer contracts use the [`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) to call functions on the proxy contract and retrieve information from the

:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
        

:::NEXT DOC:::

# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
   

:::NEXT DOC:::

`latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on

:::NEXT DOC:::

`latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending",right,
give me a sample solidity contract to use Proof of Reserve Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}","Here is a sample Solidity contract to use Proof of Reserve Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest reserve
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();
        return reserve;
    }
}
```

This contract uses the `AggregatorV3Interface` to reference the external functions implemented by Data Feeds. It also specifies the Proof of Reserve Feed Address for the WBTC PoR. The `getLatestReserve` function returns the latest reserve value.","reserves by running an
[external adapter](/chainlink-nodes/external-adapters/external-adapters) and
querying the source-chain client directly. In some instances, the reserves are
composed of a dynamic list of IDs or addresses using a composite adapter.

Cross-chain reserves provide their data using the following methods:

  * Wallet address manager: The project uses the [IPoRAddressList](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/PoRAddressList.sol) wallet address manager contract and self-attests to which addresses they own.
  * Wallet address: The project attests which addresses they own through a self-hosted API.

## Using Proof of Reserve Feeds

Read answers from Proof of Reserve Feeds the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
      

:::NEXT DOC:::

       ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
    

:::NEXT DOC:::

learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the [Proof of Reserve Contract Addresses](/data-feeds/proof-of-reserve/addresses) page for a list of available networks and addresses.

### NFT Floor Price Feeds

NFT Floor Price Feeds provide the price of the lowest priced NFT available in
a collection. These feeds operate similarly to [Price Feeds](/data-feeds/price-feeds) so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

 

:::NEXT DOC:::

1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

                                         |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions.

:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use

:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
        ",right,
Give sample code for an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","Here is the sample code for an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet:

```
pragma solidity ^0.6.0;

import ""@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {

    AggregatorV3Interface internal priceFeed;

    constructor() public {
        priceFeed = AggregatorV3Interface(0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43);
    }

    function getLatestPrice() public view returns (int) {
        (, int price, , , ) = priceFeed.latestRoundData();
        return price;
    }
}
```","`latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on

:::NEXT DOC:::

`latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending

:::NEXT DOC:::

imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

 

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint

:::NEXT DOC:::

on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint

:::NEXT DOC:::

type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new ethers.Contract(addr, aggregatorV3InterfaceABI, provider)
    priceFeed.latestRoundData().then((roundData) => {
      // Do something with roundData
      console.log(""Latest Round Data"", roundData)
    })
    

Latest Price

### Python

This example uses [Web3.py](https://web3py.readthedocs.io/en/stable/) to
retrieve feed data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES

:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
        

:::NEXT DOC:::

   # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0",right,
Give code examples to demonstrate how to deploy a consumer contract on-chain that reads a data feed and stores the value?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}",The code examples to demonstrate how to deploy a consumer contract on-chain that reads a data feed and stores the value are provided in Solidity language in the documentation of Chainlink. The consumer contract should reference the AggregatorV3Interface contract and call one of the exposed functions. The example code can be found in the Using Data Feeds documentation and the PriceConsumerV3 contract can be compiled and deployed using Remix on the Sepolia testnet.,"new message next to the `updateMessage` function.

  2. Click the `updateMessage` button to set the new message in the contract data. MetaMask opens and asks you to confirm payment to update the state of your contract.

  3. In the new MetaMask prompt, click **Confirm** to approve the transaction.

  4. Click the `message` variable again to see the updated value. It might take a few seconds before the transaction updates the variable.

Now you know how to deploy example contracts to a test network and run the
functions in those contracts. You can write your own contracts and test them
using this same process.

Next, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds)
guide to learn how to connect your smart contracts to Chainlink Data Feeds and
retrieve on-chain data that your smart contracts can act on.

## What's next

  * [› Consuming Data Feeds](/getting-started/consuming-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/deploy-your-first-contract.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

 

:::NEXT DOC:::

with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
          

:::NEXT DOC:::

token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
        

:::NEXT DOC:::

contract: You will compile and deploy this example contract to the StarkNet Goerli testnet where it can read and store values from one of the [data feed proxy contracts](https://docs.chain.link/data-feeds/price-feeds/addresses?network=starknet). The proxy address is defined in the constructor when you deploy the contract.
  * The [deployConsumer.ts](https://github.com/smartcontractkit/chainlink-starknet/tree/develop/examples/contracts/proxy-consumer/scripts/deployConsumer.ts) script: This script uses [StarkNet.js](https://www.starknetjs.com/) to identify your OpenZeppelin wallet and deploy the compiled contract.
  * The [readLatestRound.ts](https://github.com/smartcontractkit/chainlink-starknet/tree/develop/examples/contracts/proxy-consumer/scripts/readLatestRound.ts) script: This script submits an invoke transaction on the `get_stored_round` function in your contract and prints the result.

Build, deploy, and invoke the example contract:

  1. Find the account address and private key for your funded StarkNet testnet account. By default, the OpenZeppelin wallet contains these values at `~/.starknet_accounts/starknet_open_zeppelin_accounts.json`.

  2. Export your address to the `DEPLOYER_ACCOUNT_ADDRESS` environment variable and your private key to the `DEPLOYER_PRIVATE_KEY` environment variable.
    
        export DEPLOYER_ACCOUNT_ADDRESS=<YOUR_WALLET_ADDRESS>
    
        export DEPLOYER_PRIVATE_KEY=<YOUR_KEY>

  3. In the `./chainlink-starknet/examples/contracts/proxy-consumer/` directory, run `yarn build` to run Hardhat and create `./starknet-artifacts/` with the compiled contracts. The

:::NEXT DOC:::

create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

### Consumer

A Consumer contract is any contract that uses Chainlink Data Feeds to consume
aggregated data. Consumer contracts must reference the correct
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract and call one of the exposed functions.


    ...
    AggregatorV3Interface feed = AggregatorV3Interface(address);
    return feed.latestRoundData();

Off-chain applications can also consume data feeds. See the Javascript and
Python example code on the [Using Data Feeds](/data-feeds/price-feeds) page to
learn more.

### Proxy

Proxy contracts are on-chain proxies that point to the aggregator for a
particular data feed. Using proxies enables the underlying aggregator to be
upgraded without any service interruption to consuming contracts.

Proxy contracts can vary from one data feed to another, but the
[`AggregatorProxy.sol`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol)
on Github is a common example.

### Aggregator

An aggregator is the contract that receives periodic data updates from the
oracle network. Aggregators store aggregated data on-chain so that consumers
can retrieve it and act upon it within the same transaction.

You can access this data using the Data Feed address and

:::NEXT DOC:::

# Using Data Feeds on EVM Chains

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
   

:::NEXT DOC:::

imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",wrong,wrong
Write code to show how to use web3.js to retrieve feed data from a price feed?,"/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
    name: ""getRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""latestRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""version"",
    outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
]
const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log(""Latest Round Data"", roundData)
  })","Here is an example code using web3.js to retrieve feed data from a price feed:

```
const Web3 = require(""web3"")
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
    name: ""getRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""latestRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""version"",
    outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
]
const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    console.log(""Latest Round Data"", roundData)
  })
```

Note that this is example code that uses hardcoded values for clarity and un-audited code. It should not be used in production.","You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
    const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs:

:::NEXT DOC:::

       type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
    priceFeed.methods
      .latestRoundData()
      .call()
      .then((roundData) => {
        // Do something with roundData
        console.log(""Latest Round Data"", roundData)
      })
    


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const { ethers } = require(""ethers"") // for nodejs only
    const provider = new ethers.providers.JsonRpcProvider(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """",

:::NEXT DOC:::

type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new ethers.Contract(addr, aggregatorV3InterfaceABI, provider)
    priceFeed.latestRoundData().then((roundData) => {
      // Do something with roundData
      console.log(""Latest Round Data"", roundData)
    })
    

Latest Price

### Python

This example uses [Web3.py](https://web3py.readthedocs.io/en/stable/) to
retrieve feed data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES

:::NEXT DOC:::

imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

 

:::NEXT DOC:::

testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.



:::NEXT DOC:::

`latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending

:::NEXT DOC:::

       outputs: [
          { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
          { internalType: ""int256"", name: ""answer"", type: ""int256"" },
          { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
          { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
          { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
        ],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""version"",
        outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
    ]
    const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
    const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
    priceFeed.methods
      .latestRoundData()
      .call()
      .then((roundData) => {
        // Do something with roundData
        console.log(""Latest Round Data"", roundData)
      })
    


    /**
     * THIS IS EXAMPLE CODE THAT USES

:::NEXT DOC:::

           ) = priceFeed.getRoundData(roundId);
            require(timeStamp > 0, ""Round not complete"");
            return price;
        }
    }
    

### Javascript


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
    // Replace the provider URL with your own endpoint URL
    const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
    const aggregatorV3InterfaceABI = [
      {
        inputs: [],
        name: ""decimals"",
        outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [],
        name: ""description"",
        outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
        stateMutability: ""view"",
        type: ""function"",
      },
      {
        inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80""

:::NEXT DOC:::

`latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on",right,
What is the LINK token contract on ethereum mainnet?,0x514910771AF9Ca656af840dff83E8264EcF986CA,The LINK token contract on Ethereum Mainnet has the address 0x514910771AF9Ca656af840dff83E8264EcF986CA.,"# LINK Token Contracts

  * Overview
  * Ethereum
  * Ethereum Mainnet
  * Sepolia testnet
  * Goerli testnet
  * BNB Chain
  * BNB Chain mainnet
  * BNB Chain testnet
  * Polygon (Matic)
  * Polygon mainnet
  * Mumbai testnet
  * RSK
  * RSK mainnet
  * Gnosis Chain (xDai)
  * Gnosis Chain mainnet
  * Avalanche
  * Avalanche mainnet
  * Fuji testnet
  * Fantom
  * Fantom mainnet
  * Fantom testnet
  * Arbitrum
  * Arbitrum mainnet
  * Arbitrum Goerli testnet
  * Optimism
  * Optimism mainnet
  * Optimism Goerli testnet
  * Harmony
  * Harmony mainnet
  * Moonriver
  * Moonriver mainnet
  * Moonbeam
  * Moonbeam mainnet
  * Metis
  * Andromeda mainnet
  * BASE
  * BASE Goerli testnet

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=Contracts) to talk to an expert
about the networks that support the LINK token.

LINK tokens are used to pay node operators for retrieving data for smart
contracts and also for deposits placed by node operators as required by
contract creators. The smallest denomination of LINK is called a Juel, and
1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to
Wei, which is the [smallest denomination of
ETH](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations).

The LINK token is an ERC677 token that inherits functionality from the ERC20
token standard and allows token transfers to contain a data payload. Read more
about the [ERC677

:::NEXT DOC:::

Token on Fantom                  |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Arbitrum

### Arbitrum mainnet

ETH is used to pay for transactions on the Arbitrum mainnet. You can use the
[Arbitrum Bridge](https://bridge.arbitrum.io/) to transfer ETH and LINK to
from Ethereum Mainnet to Arbitrum.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 42161                                      |
| Address        | 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4 |
| Name           | Chainlink Token on Arbitrum Mainnet        |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status |

:::NEXT DOC:::

to talk to an expert
about the networks that support the LINK token.

LINK tokens are used to pay node operators for retrieving data for smart
contracts and also for deposits placed by node operators as required by
contract creators. The smallest denomination of LINK is called a Juel, and
1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to
Wei, which is the [smallest denomination of
ETH](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations).

The LINK token is an ERC677 token that inherits functionality from the ERC20
token standard and allows token transfers to contain a data payload. Read more
about the [ERC677 transferAndCall token
standard](https://github.com/ethereum/EIPs/issues/677).

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

## Ethereum

### Ethereum Mainnet

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1                                          |
| Address        | 0x514910771AF9Ca656af840dff83E8264EcF986CA |
| Name           | Chainlink Token                   

:::NEXT DOC:::

can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  *

:::NEXT DOC:::

                       |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 84531                                      |
| Address        | 0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3 |
| Name           | Chainlink Token on the BASE Goerli testnet |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | goerli.basescan.org                        |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/link-token-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1284                                       |
| Address        | 0x012414A392F9FA442a3109f1320c439C45518aC3 |
| Name           | Chainlink Token on Moonbeam Mainnet        |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | moonscan.freshstatus.io                    |
## Metis

### Andromeda mainnet

METIS is the currency that you use to pay for transactions on Metis mainnet.
You can use the [Metis Bridge](https://bridge.metis.io/) to transfer METIS and
LINK from Ethereum Mainnet to Metis mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1088                                   

:::NEXT DOC:::

your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

### Ethereum

#### Ethereum Mainnet

| Item                        | Value                                      |
|:----------------------------|:-------------------------------------------|
| Registry Address            | 0x02777053d6764996e594c3E88AF1D58D5363a2e6 |
| Registrar Address           | 0xDb8e8e2ccb5C033938736aa89Fe4fa1eDfD15a1d |
| Payment Premium %           | 20                                         |
| Block Count Per Turn        | 10                                         |
| Check Gas Limit             | 6500000                                    |
| Perform Gas Limit           | 5000000                                    |
| Gas Ceiling Multiplier      | 2               

:::NEXT DOC:::

      |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | bscscan.freshstatus.io                     |
### BNB Chain testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/chapel). Testnet BNB is
availalbe at [testnet.binance.org/faucet-
smart](https://testnet.binance.org/faucet-smart).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 97                                         |
| Address      | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06 |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18         

:::NEXT DOC:::

                                |
| Decimals     | 18                                         |
## Optimism

### Optimism mainnet

ETH is used to pay for transactions on Optimism. Use the [Optimism
Bridge](https://app.optimism.io/bridge) to transfer ETH and LINK from Ethereum
Mainnet to Optimism mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 10                                         |
| Address        | 0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6 |
| Name           | Chainlink Token on Optimism Mainnet        |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | status.optimism.io                         |
### Optimism Goerli

:::NEXT DOC:::

| 5                                          |
| Address      | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## BNB Chain

### BNB Chain mainnet

BNB is used to pay for transactions on the BNB Chain mainnet.

ERC-677 LINK on BNB Chain

The LINK provided by the [BNB Chain
Bridge](https://www.bnbchain.world/en/bridge) is not ERC-677 compatible, so
you cannot use it with Chainlink services or oracle nodes. Use the
[**Chainlink PegSwap service**](https://pegswap.chain.link/) to convert
bridged LINK to the official ERC-677 LINK token on BNB Chain.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 56                                         |
| Address       ",right,
What is the chainlink price feed address for 1INCH / ETH?,0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8,The chainlink price feed address for 1INCH / ETH is 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8.,"             | 1inch                                                    | Crypto         | 2%          | 86400s      |    18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8 |
| 🟢1INCH / USD                          | 1inch                                                    | Crypto         | 1%          | 86400s      |     8 | 0xc929ad75B72593967DE83E7F7Cda0493458261D9 |
| 🟢AAPL / USD                           | Apple                                                    | Equities       | 0.5%        | 86400s      |     8 | 0x139C8512Cde1778e9b9a8e721ce1aEbd4dD43587 |
| 🟢AAVE / ETH                           | Aave   

:::NEXT DOC:::

|
| 🟢LINK / USD                           | Chainlink                                                | Crypto         | 1%          | 3600s       |     8 | 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c |
| 🟢LON / ETH                            | Tokenlon                                                 | Crypto         | 2%          | 86400s      |    18 | 0x13A8F2cC27ccC2761ca1b21d2F3E762445f201CE |
| 🟢LRC / ETH                            | Loopring                                                 | Crypto         | 1%          | 86400s      |    18 | 0x160AC928A16C93eD4895C2De6f81ECcE9a7eB7b4 |
| 🟢LTC / USD           

:::NEXT DOC:::

       | Ripple                                                   | Crypto         | 1%          | 86400s      |     8 | 0xCed2660c6Dd1Ffd856A5A82C67f3482d88C50b12 |
| 🟢YFI / ETH                            | Yearn Finance                                            | Crypto         | 1%          | 86400s      |    18 | 0x7c5d4F8345e66f68099581Db340cd65B078C41f4 |
| 🟢YFI / USD                            | Yearn Finance                                            | Crypto         | 1%          | 3600s       |     8 | 0xA027702dbb89fbd58938e4324ac03B58d812b0E1 |
| 🟢YFII / ETH                           | YFII Finance              

:::NEXT DOC:::

0x09023c0DA49Aaf8fc3fA3ADF34C6A7016D38D5e3 |
| 🟢USDT / ETH                           | Tether                                                   | Crypto         | 1%          | 86400s      |    18 | 0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46 |
| 🟢USDT / USD                           | Tether USD                                               | Crypto         | 0.25%       | 86400s      |     8 | 0x3E7d1eAB13ad0104d2750B8863b489D65364e32D |
| 🟢WBTC / BTC                           | Wrapped Bitcoin                                          | Crypto         | 2%          | 86400s      |     8 | 0xfdFD9C85aD200c506Cf9e21F1FD8dd01932FBB23 |
|

:::NEXT DOC:::

|
| 🟢ETH / BTC                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0xAc559F25B1619171CbC396a50854A3240b6A4e99 |
| 🟢ETH / USD                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 |
| 🟢EUR / USD                            | Euro                                                     | Forex          | 0.15%       | 86400s      |     8 | 0xb49f677943BC038e9857d61E7d053CaA2C1734C1 |
| 🟢EURT / USD         

:::NEXT DOC:::

See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Pair                                   | Asset                                                    | Type           | Deviation   | Heartbeat   |   Dec | Address                                    |
|:---------------------------------------|:---------------------------------------------------------|:---------------|:------------|:------------|------:|:-------------------------------------------|
| 🟢1INCH / ETH                          | 1inch                                                    | Crypto         | 2%          | 86400s      |    18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8 |
| 🟢1INCH / USD                          | 1inch                           

:::NEXT DOC:::

                                     | Crypto         | 1%          | 86400s      |     8 | 0x9613A51Ad59EE375e6D8fa12eeef0281f1448739 |
| 🟢DOGE / USD                           | Dogecoin                                                 | Crypto         | 0.5%        | 86400s      |     8 | 0x2465CefD3b488BE410b941b1d4b2767088e2A028 |
| 🟢DOT / USD                            | Polkadot                                                 | Crypto         | 1%          | 86400s      |     8 | 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734 |
| 🔵DPI / ETH                            | DeFi Pulse Index                             

:::NEXT DOC:::

     | Polkadot                                                 | Crypto         | 1%          | 86400s      |     8 | 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734 |
| 🔵DPI / ETH                            | DeFi Pulse Index                                         | Crypto         | 2%          | 86400s      |    18 | 0x029849bbc0b1d93b85a8b6190e979fd38F5760E2 |
| 🟡DPI / USD                            | DefiPulse Index                                          | Crypto         | 1%          | 86400s      |     8 | 0xD2A593BF7594aCE1faD597adb697b5645d5edDB2 |
| 🟢ENJ / ETH                            | Enjin Coin                   

:::NEXT DOC:::

|
| LINK / ETH  |     nan |    nan | 1%          | 3600s       |    18 | 0xb4c4a493AB6356497713A78FFA6c60FB53517c63 |
| LINK / USD  |     nan |    nan | 1%          | 3600s       |     8 | 0x48731cF7e84dc94C5f84577882c14Be11a5B7456 |
| SNX / USD   |     nan |    nan | 1%          | 3600s       |     8 | 0xdC5f59e61e51b90264b38F0202156F07956E2577 |
| USDC / USD  |     nan |    nan | 1%          | 86400s      |     8 | 0xAb5c49580294Aff77670F839ea425f5b78ab3Ae7 |
| XAU / USD   |     nan |    nan | 0.3%        | 3600s       |    18 | 0x7b219F57a8e9C7303204Af681e9fA69d17ef626f |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page

:::NEXT DOC:::

|
| 🟢HIGH / USD                           | Highstreet                                               | Crypto         | 2%          | 86400s      |     8 | 0xe2F95bC12FE8a3C35684Be7586C39fD7c0E5b403 |
| 🟢ILV / ETH                            | Illuvium                                                 | Crypto         | 2%          | 86400s      |    18 | 0xf600984CCa37cd562E74E3EE514289e3613ce8E4 |
| 🟢IMX / USD                            | Immutable X                                              | Crypto         | 2%          | 86400s      |     8 | 0xBAEbEFc1D023c0feCcc047Bff42E75F15Ff213E6 |
| 🟢INJ / USD                    ",right,
What is the proof of reserve address for CacheGold PoR USD on Goerli Testnet?,Not provided in the context,The proof of reserve address for CacheGold PoR USD on Goerli Testnet is 0x5586bF404C7A22A4a4077401272cE5945f80189C.,"                      |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
|

:::NEXT DOC:::

         |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 |

:::NEXT DOC:::

name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                  

:::NEXT DOC:::

name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                

:::NEXT DOC:::

                                 |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
|

:::NEXT DOC:::

                                         |
|:------------------------|:------------|------------:|------:|:------------------------------------------------------------------------------------------------------------------------------------------------|
| Stader Labs PoR         | 1e-7%       |       86400 |    18 | 0x3de1bE9407645533CD0CbeCf88dFE5297E7125e6Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
| StakeStar PoR           | 1e-7%       |       86400 |    18 | 0xcd3BBd46c6c6354e3B03780F99E9836d3AC7740bAsset name:Ethereum LSDReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address      |
| Swell PoR               | 1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions.

:::NEXT DOC:::

name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
|

:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use

:::NEXT DOC:::

1e-7%       |       86400 |    18 | 0xDe9C980F79b636B46b9c3bc04cfCC94A29D18D19Asset name:Total balance sumReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address |
Disclaimer

Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts. [ Learn more about making responsible
data quality decisions. ](/data-feeds/selecting-data-feeds#risk-mitigation)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

[**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May",wrong,right
What is the rate and Volatility Feed Address for 30-Day ETH APR?,0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29,The rate and Volatility Feed Address for 30-Day ETH APR is 0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29.,"# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR

:::NEXT DOC:::

normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the

:::NEXT DOC:::

then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is met.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find heartbeat and deviation information for each
feed. If you have questions or would like to request an enhancement to
Realized Volatility Feeds, contact us using

:::NEXT DOC:::

nan | 50%         | 86400s      |     7 | 0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29 |
| 90-Day ETH APR                           |     nan |    nan | 50%         | 86400s      |     7 | 0x7422A64372f95F172962e2C0f371E0D9531DF276 |
| BTC Interest Rate Benchmark Curve 1 Day  |     nan |    nan | 0.01%       | 86400s      |     8 | 0x7DE89d879f581d0D56c5A7192BC9bDe3b7a9518e |
| BTC Interest Rate Benchmark Curve 1 Week |     nan |    nan | 0.01%       | 86400s      |     8 | 0x2583E47DF3F959B055F4Efa90C4927658669F499 |
| BTC Interest Rate Benchmark Curve 2 Week |     nan |    nan | 0.01%       | 86400s      |     8 | 0x39545d0c11CD62d787bB971B6a802150e1f54D8f |
| BTC-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x28f9134a15cf0aAC9e1F0CD09E17f32925254C77 |
| BTC-USD

:::NEXT DOC:::

  8 | 0x2583E47DF3F959B055F4Efa90C4927658669F499 |
| BTC Interest Rate Benchmark Curve 2 Week |     nan |    nan | 0.01%       | 86400s      |     8 | 0x39545d0c11CD62d787bB971B6a802150e1f54D8f |
| BTC-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x28f9134a15cf0aAC9e1F0CD09E17f32925254C77 |
| BTC-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%   

:::NEXT DOC:::

Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2 |
| ETH-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 |

:::NEXT DOC:::

the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is met.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find heartbeat and deviation information for each
feed. If you have questions or would like to request an enhancement to
Realized Volatility Feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Rate and Volatility Feeds](/data-feeds/rates-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 | 0xd599cEF88Bbd27F1392A544bD0F343ec8893124C |
| LINK-USD 7-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x03121C1a9e6b88f56b27aF5cc065ee1FaF3CB4A9 |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/addresses.mdx)
  * [ Join our community

:::NEXT DOC:::

# Rate and Volatility Feed Addresses

  * Overview
  * Sepolia Testnet 

To learn how to use these feeds, see the [Using Data Feeds](/data-feeds/using-data-feeds) guide.

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Track the status of this network at <https://ethstats.dev/>

## Sepolia Testnet

| Pair                                     |   Asset |   Type | Deviation   | Heartbeat   |   Dec | Address                                    |
|:-----------------------------------------|--------:|-------:|:------------|:------------|------:|:-------------------------------------------|
| 30-Day ETH APR                           |     nan |    nan | 50%         | 86400s      |     7 | 0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29 |
| 90-Day ETH APR                           |     nan |    nan | 50%         | 86400s      |     7 | 0x7422A64372f95F172962e2C0f371E0D9531DF276 |
| BTC Interest Rate Benchmark Curve 1 Day  |     nan |    nan | 0.01%       | 86400s   

:::NEXT DOC:::

                       | Forex          | 0.3%        | 86400s      |     8 | 0x971E8F1B779A5F1C36e1cd7ef44Ba1Cc2F5EeE0f |
| 🟢BTC / ETH                            | Bitcoin                                                  | Crypto         | 2%          | 86400s      |    18 | 0xdeb288F737066589598e9214E782fa5A8eD689e8 |
| 🟢BTC / USD                            | Bitcoin                                                  | Crypto         | 0.5%        | 3600s       |     8 | 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c |
| 🟢BUSD / ETH                           | Binance USD                                             ",right,
What is the NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net?,0x352f2Bc3039429fC2fe62004a1575aE74001CfcE,The NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net is 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE.," |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%  

:::NEXT DOC:::

|
| CoolCats Floor Price       | ETH           | 2%          |        3600 |    18 | 0x13F38938A18ff26394c5ac8df94E349A97AaAb4e |
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price      | ETH           | 2%          |        3600 |    18 | 0x870bc8BfEe8A7Bbd63Dc1ef09F2fF37DeBCfEF35 |
| Doodles Floor Price        | ETH           | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 |

:::NEXT DOC:::

      | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%     

:::NEXT DOC:::

                                 |
|:---------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| Azuki Floor Price          | ETH           | 2%          |        3600 |    18 | 0x9F6d70CDf08d893f0063742b51d3E9D1e18b7f74 |
| BAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xB677bfBc9B09a3469695f40477d05bc9BcB15F50 |
| CloneX Floor Price         | ETH           | 2%          |        3600 |    18 | 0xE42f272EdF974e9c70a6d38dCb47CAB2A28CED3F |
| CoolCats Floor Price       | ETH           | 2%          |        3600 |    18 | 0x13F38938A18ff26394c5ac8df94E349A97AaAb4e |
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price

:::NEXT DOC:::

  | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
| ⚫VeeFriends Floor Price                 | ETH           | 2%          |       86400 |    18 | 0x35bf6767577091E7f04707c0290b3f889e968307 |
| ⚫World of Women Floor Price             | ETH           | 2%          |

:::NEXT DOC:::

  | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           |

:::NEXT DOC:::

   | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
| ⚫VeeFriends Floor Price                 | ETH           | 2%          |       86400 |    18 | 0x35bf6767577091E7f04707c0290b3f889e968307 |
| ⚫World of Women Floor Price             | ETH           | 2%          |       86400 |    18 | 0xDdf0B85C600DAF9e308AFed9F597ACA212354764 |
## Goerli Testnet

| NFT Floor Pricing Feed     | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:---------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| Azuki Floor Price          | ETH           | 2%          |        3600 |    18 | 0x9F6d70CDf08d893f0063742b51d3E9D1e18b7f74 |
| BAYC Floor Price           | ETH           | 2%          |        3600 |    18 |

:::NEXT DOC:::

     | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH         

:::NEXT DOC:::

# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma",right,
What is Chainlink?,"Chainlink is a decentralized oracle network that enables smart contracts on Ethereum to securely connect to external data sources, APIs, and payment systems.

Smart contracts are self-executing contracts with the terms of the agreement directly written into code. They're hosted on blockchain platforms, like Ethereum, and provide many advantages such as trustless execution, efficiency, and transparency. However, one limitation of smart contracts is that they cannot access off-chain data (data outside of the blockchain) directly due to the blockchain's deterministic nature.

Chainlink solves this problem by providing reliable and secure bridges between smart contracts and off-chain data sources. This connection is achieved through a network of decentralized oracle nodes, which fetch and verify real-world data before delivering it to smart contracts.

For example, a smart contract for a decentralized weather betting application could use Chainlink to access real-world weather data. Chainlink nodes retrieve the necessary data from weather APIs and deliver it to the smart contract, which then executes based on the provided data.

Chainlink also has its own native cryptocurrency called LINK, which is used to pay for services within the ecosystem.",Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. It allows developers to create and customize any type of Decentralized Oracle Network (DONs) that a smart contract might need. Chainlink is used to create a price oracle that isn’t just one person but a group of trusted and expert crypto price data aggregators.,"Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.


:::NEXT DOC:::

# Chainlink Introduction

<GradientTextWrapp>
  Chainlink, smart contracts, blockchains, and the entire world of cryptocurrency have been a hot topic of discussion for several years now.
</GradientTextWrapp>

Whether it’s companies like EY and Microsoft looking to use smart contracts to improve their business processes, artists and athletes like LaMelo Ball creating their own “NFTs,” or up and coming companies looking to disrupt long-standing establishments such as the insurance industry, Chainlink and smart contracts are working to become the backbone for world-changing applications.

 


:::NEXT DOC:::

Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.


:::NEXT DOC:::

Name                      | Description                                                                                    | GitHub   |
|:--------------------------|:-----------------------------------------------------------------------------------------------|:---------|
| InsuraLink 🥇             | Data-driven insurance agreements that use Chainlink oracles to bridge IoT and smart contracts. | Go       |
| 1x.ag 🥈                  | Build leveraged trade positions across different lending platforms.                            | Go       |
| We Watch in Public Spaces | Tracking system for calculating event attendance.                                              | Go       |
## Chainlink Virtual Hackathon 2019

Read our [blog post here](https://blog.chain.link/winners-of-the-chainlink-virtual-hackathon/).

| Name                      | Description                                                                                    | GitHub  

:::NEXT DOC:::

special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform. Finally, with Chainlink, developers can build smart contracts that can interact with the outside world to preserve the decentralized nature of smart contracts.

<Spacer>

## How Chainlink Works

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      Curious how Chainlink works? Read below! With Chainlink, any type of data the exists can be brought on chain, and the conditions on which that data is delivered can be customized! 
    </div>
  </div>
</ContentWrapp>

Chainlink allows developers to build and customize DONs. Chainlink allows DONs to work and assures that node operators are incentivized not to collude or act

:::NEXT DOC:::

in the best interest of everyone. But what if we had a decentralized middleware solution, one where Jim doesn’t control everything (sorry Jim), so we didn’t have to trust him?

Finally we are here…...enter Chainlink!

<Spacer>

## Chainlink and Decentralized Oracles

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Using a Chainlink Decentralized Oracle Network (DON) as the Oracle for your dNFT can give you strong guarantees that your artwork will truly update with the latest, most acurate data and remain decentralized. 
    </div>
  </div>
</ContentWrapp>

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform.

:::NEXT DOC:::

## Welcome to the Chainlink Documentation

##### New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide.

## Explore our products

#### [Data Feeds](data-feeds)

Decentralized and high-quality data feeds for DeFi, Reserves, NFTs, sports,
weather, and more

###### Available on:

#### [Chainlink Functions](chainlink-functions)

Connect smart contracts to a trust-minimized compute infrastructure running on
a decentralized oracle network

###### Available on:

#### [Automate Contracts](chainlink-automation/introduction)

Decentralized, highly reliable, cost-efficient and highly secure automation
for smart contracts

###### Available on:

#### [VRF v2](/vrf/v2/introduction)

Verifiable, tamper-proof random number generator for blockchain gaming and NFT
projects

###### Available on:

#### [External API Calls](/any-api/introduction)

Request and receive data from any API using the Chainlink contract library

###### Available on:

## Useful resources

### Need to run your own Chainlink Node?

See the Node Operator’s Guide to learn about starting and maintaining
Chainlink Nodes.

#### Watch tutorials

Learn more about the technology we are building. We're constantly uploading
new videos to our YouTube channel.

##### Need integration support?

##### Discord

##### Stack overflow



:::NEXT DOC:::

in our
previous hackathons. There is also a link to the Marketplace where you can
find the latest data provider nodes and explore the network.

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past Hackathon Winning Projects](/resources/example-projects)

## Outreach

The Chainlink community is an inviting group of engineers that is always
looking to help users expand their knowledge on Chainlink and solve related
issues. Refer back to the [Getting Help](/resources/getting-help) page for the
latest information about how to get support.

### Get support

  * [Stack Overflow](https://stackoverflow.com/questions/tagged/chainlink)
  * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

### Join the community

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/other-tutorials.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

can also be written to interact with other contracts on
the blockchain.

## What is a LINK token?

The LINK token is an ERC677 token that inherits functionality from the [ERC20
token
standard](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/)
and allows token transfers to contain a data payload. It is used to pay node
operators for retrieving data for smart contracts and also for deposits placed
by node operators as required by contract creators.

Any wallet that handles ERC20 tokens can store LINK tokens. The ERC677 token
standard that the LINK token implements still retains all functionality of
ERC20 tokens.

## What are oracles?

**Oracles** provide a bridge between the real-world and on-chain smart
contracts by being a source of data that smart contracts can rely on, and act
upon.

Oracles play a critical role in facilitating the full potential of smart
contract utility. Without a reliable connection to real-world conditions,
smart contracts cannot effectively serve the real-world.

## How do smart contracts use oracles?

Oracles are most popularly used with [_Data Feeds_](/data-feeds). DeFi
platforms like [AAVE](https://aave.com/) and
[Synthetix](https://www.synthetix.io/) use Chainlink data feed oracles to
obtain accurate real-time asset prices in their smart contracts.

Chainlink data feeds are sources of data [aggregated from many independent
Chainlink node operators](/architecture-overview/architecture-decentralized-model). Each data feed has an on-chain address and functions that enable
contracts to read from that address. For example, the [ETH / USD
feed](https://data.chain.link/eth-usd/).



Smart contracts also use oracles to get other capabilities on-chain:

  *",right,
What is a runlog initiator in chainlink?,"The RunLog initiator is an integral component of the Chainlink Node job specifications. It is specifically designed to listen for Ethereum log events (in this case, the Chainlink-specific event ""RunRequest"") that are emitted by the Chainlink Oracle contract when someone requests data from a Chainlink Node.

This initiator responds to requests for external data made by smart contracts on the Ethereum blockchain. When a smart contract emits a RunRequest event, this is picked up by the RunLog initiator, which then triggers a job run on the Chainlink node.

The RunLog initiator allows smart contracts to specify the data they want to retrieve and also helps in the preparation of data before it is sent back to the requesting contract. The data request and delivery process is handled securely and trustlessly, maintaining the decentralization and security principles of blockchain technology.

The Chainlink Oracle contract is an Ethereum smart contract that serves as an intermediary between the Chainlink node and the smart contract requesting data. It manages requests for data and the delivery of responses back to the requesting contract.",A RunLog initiator is an initiator in Chainlink that watches the blockchain for any log events that include a job's ID and parses the data out of that log to pass it into a new log run. It is used to integrate Chainlink with on-chain contracts. The address and requesters parameters can be added to make the event filter of the RunLog initiator more restrictive and only allow requests to come from specific addresses.,"  ""time"": ""2019-09-20T12:20:00.000Z""
            }
        }
    ]

## RunLog

The `RunLog` initiator is the easiest initiator to use when integrating
Chainlink with on-chain contracts. It works similarly to EthLog, but adds some
helpful glue in to stitch together the off-chain job with the on-chain
contracts.

When a `RunLog` job is created, Chainlink begins watching the blockchain for
any log events that include that job’s ID. If any of the events that come back
match the log event signature of the Chainlink oracle contract, then the
Chainlink node parses the data out of that log and passes it into a new log
run.

A new run created by a `RunLog` is automatically given the parameters needed
for an `EthTx` task to report the run back to the contract that originally
created the event log.

### RunLog Parameters

`RunLog` initiators take an optional `address` parameter and `requesters`
parameter. The `address` parameter is a single Ethereum address and the
`requesters` parameter is an array of Ethereum addresses. By adding the
`address` parameter, you make the event filter of the RunLog initiator more
restrictive, only listening for events from that address, instead of any
address. By adding the `requesters` parameter, you only allow requests to come
from an address within the array.

### Example


    ""initiators"": [
        {
            ""type"": ""runlog"",
            ""params"": {
                ""address"": ""0xCAFE000000000000000000000000000000000001"",
              

:::NEXT DOC:::

}
    ]

## EthLog

The `EthLog` initiator creates an Ethereum log filter, and when any log comes
in it is passed on as the input to the a new job run.

### EthLog Parameters

`EthLog` takes the same parameters as an [Ethereum log
filter](https://github.com/ethereum/go-ethereum/wiki/RPC-PUB-SUB).

### Example


    ""initiators"": [
        {
            ""type"": ""ethlog"",
            ""address"": ""0xCAFE000000000000000000000000000000000001""
        }
    ]

## External

The external initiator works like the [web](/chainlink-nodes/oracle-jobs/v1/initiators/#web) initiator, but is given its own credentials along
with a name and URL.

You can create an external initiator by running the `chainlink initiators
create NAME URL` command. This will give you an access key and secret pair,
which will be used for incoming requests to invoke a job with this external
initiator, and an outgoing token and secret pair which optionally can be used
to help the Chainlink node authenticate with external services. Any incoming
requests must provide the access key and secret in order to invoke the job
run.

### External Parameters

`external` requires a `name` to be set to handle authentication in order to
invoke the job run.

### Example


    ""initiators"": [
        {
            ""type"": ""external"",
            ""params"": {
                ""name"": ""myexternalservice""
           

:::NEXT DOC:::

# Building External Initiators

  * Overview
  * JSON jobs (REMOVED)

An external initiator can trigger a run for any webhook job that it has been
linked to.

The URL for triggering a run is such:


    curl -X POST -H ""Content-Type: application/json"" --data '{""myKey"": ""myVal""}' http://localhost:6688/v2/jobs/<job external UUID>/runs

You will need to specify two headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

## JSON jobs (REMOVED)

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

We will be using the [Chainlink external
initiator](https://github.com/smartcontractkit/external-initiator) repo for
reference. You can see some examples of existing initiators in the
[blockchain](https://github.com/smartcontractkit/external-initiator/tree/master/blockchain) folder.

External initiators are simple web initiators that can be activated by any job
instead of just one. To set one up, you need to have a service similar to an
external adapter that sends an `HTTPPost` message runs API call to your
chainlink node service. Here is a sample URL for a web job could look like:


    curl -b cookiefile -X POST -H ""Content-Type: application/json"" --data '{""myKey"":""myVal""}' http://localhost:6688/v2/jobs/%s/runs

Where

:::NEXT DOC:::

         ""type"": ""RunLog"",
          ""params"": {
            ""address"": ""0x51DE85B0cD5B3684865ECfEedfBAF12777cd0Ff8""
          }
        }
      ],
      ""tasks"": [
        {
          ""type"": ""HTTPGet"",
          ""params"": {
            ""get"": ""https://bitstamp.net/api/ticker/""
          }
        },
        {
          ""type"": ""JSONParse"",
          ""params"": {
            ""path"": [""last""]
          }
        },
        {
          ""type"": ""Multiply"",
          ""params"": {
            ""times"": 100
          }
        },
        {
          ""type"": ""EthUint256""
        },
        {
          ""type"": ""EthTx""
        }
      ],
      ""startAt"": ""2020-02-09T15:13:03Z"",
      ""endAt"": null,
     

:::NEXT DOC:::

 ],
        ""threshold"": 1,
        ""absoluteThreshold"": 0,
        ""precision"": 18,
        ""pollTimer"": {
          ""period"": ""1m0s""
        },
        ""idleTimer"": {
          ""duration"": ""24h0m0s""
        }
      }
    }

## RunAt

The `RunAt` initiator triggers a one off job run at the time specified.

### RunAt Parameters

`RunAt` takes one parameter, `time`. `time` accepts a ISO8601 string or a Unix
timestamp.

### Example


    ""initiators"": [
        {
            ""type"": ""runat"",
            ""params"": {
                ""time"": ""2019-09-20T12:20:00.000Z""
            }
        }
    ]

## RunLog

The `RunLog` initiator is the easiest initiator to use when integrating
Chainlink with on-chain contracts. It works similarly to EthLog, but adds some
helpful glue in to stitch together the off-chain job with the on-chain
contracts.

When a `RunLog` job is created, Chainlink begins watching the blockchain for
any log events that include that job’s ID. If any of the events that come back
match the log event signature of the Chainlink oracle contract, then the
Chainlink node parses the data out of that log and passes it into a new

:::NEXT DOC:::

repo for
reference. You can see some examples of existing initiators in the
[blockchain](https://github.com/smartcontractkit/external-initiator/tree/master/blockchain) folder.

External initiators are simple web initiators that can be activated by any job
instead of just one. To set one up, you need to have a service similar to an
external adapter that sends an `HTTPPost` message runs API call to your
chainlink node service. Here is a sample URL for a web job could look like:


    curl -b cookiefile -X POST -H ""Content-Type: application/json"" --data '{""myKey"":""myVal""}' http://localhost:6688/v2/jobs/%s/runs

Where `%s` is the jobId.

External initiators make the same API call, with 2 added headers:

  1. ""X-Chainlink-EA-AccessKey""
  2. ""X-Chainlink-EA-Secret""

These are keys generated when you register your external initiator with your
node.

Triggering a run through an external initiator is as simple as making this API
call to your node. All jobs with this EI configured will then be kicked off in
this way. A simple external initiator in psedo code could look like this:


    while(True):
        send_api_call_with_external_initiator_access_key_headers()
        sleep(4)

And have this job run on the same machine as your node.

## What's next

  * [› Adding External Initiators to Nodes](/chainlink-nodes/external-initiators/external-initiators-in-nodes)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-initiators/building-external-initiators.mdx)
  * [ Join

:::NEXT DOC:::

# Introduction

  * Overview

External initiators allow jobs in a node to be initiated depending on some
external condition. The ability to create and add external initiators to
Chainlink nodes enables blockchain agnostic cross-chain compatibility.

note

At this time of writing, external initiators do not show up in the bridges
tab. However, they act exactly the same as if they did.

note

External initiators are disabled on nodes by default. Set the
`FEATURE_EXTERNAL_INITIATORS=true` [configuration variable](/chainlink-nodes/v1/configuration/#feature_external_initiators) to enable this feature.

Initiator Bridges handle the authentication to and from the External Initiator
and where to send the messages. When creating a Bridge two parameters are
required:

Only the [webhook](/chainlink-nodes/oracle-jobs/all-jobs/#webhook-jobs) job
type can be initiated using an External Initiator.

The external initiator must be created before the webhook job, and must be
referenced by name (whitelisted) in order for that external initiator to be
allowed to trigger the given webhook job.

When the External Initiator is created it generates two pairs of credentials:
Outgoing and Incoming. The Outgoing Access Key and Secret are used to
authenticate messages sent from the Core to the External Initiator. The
Incoming Access Key and Secret are used to authenticate messages sent from the
External Initiator to the Core.

Then, once you've created the name, bridge, and have the correct access keys
for the URL, you can proceed to use the external initiator as if it's a
regular initiator in future job specs.

For how to create an external initiator see [adding external initiators

:::NEXT DOC:::

  ]
            }
        }
    ]

## Web

The `Web` initiator enables jobs to be triggered via web requests,
specifically `POST`s to `/v2/specs/:jobID/runs`. Requests coming in to create
new job runs must be authenticated by cookie.

note

For convenience, there is a ""Run"" button in the operator web UI for the job
which will trigger a job run.

### Web Parameters

`Web` currently takes no parameters.

### Example


    ""initiators"": [
        {
            ""type"": ""web""
        }
    ]

## What's next

  * [› Introduction to External Initiators](/chainlink-nodes/external-initiators/external-initiators-introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/initiators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Initiators [v1]

  * Overview
  * Initiators
  * Cron
  * Cron Parameters
  * Example
  * EthLog
  * EthLog Parameters
  * Example
  * External
  * External Parameters
  * Example
  * FluxMonitor
  * FluxMonitor Parameters
  * Example
  * RunAt
  * RunAt Parameters
  * Example
  * RunLog
  * RunLog Parameters
  * Example
  * Web
  * Web Parameters
  * Example

# REMOVED

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

## Initiators

## Cron

The `Cron` initiator is a simple way to schedule recurring job runs, using
[standard cron syntax](https://en.wikipedia.org/wiki/Cron#Overview).

### Cron Parameters

`Cron` takes one parameter, `schedule` which is a cron like schedule string.
The `Cron`‘s `schedule` is follows [standard cron
syntax](https://en.wikipedia.org/wiki/Cron#Overview) but prepends an timezone
to be specified with `CRON_TZ`, with an optional field for seconds. For
example: `CRON_TZ=UTC */10 * * * *` would run every 10 minutes with the
timezone set to UTC. `CRON_TZ=UTC */30 * * * * *` would run every 30 seconds.

### Example


    ""initiators"": [
        {
           

:::NEXT DOC:::

The `address` parameter is a single Ethereum address and the
`requesters` parameter is an array of Ethereum addresses. By adding the
`address` parameter, you make the event filter of the RunLog initiator more
restrictive, only listening for events from that address, instead of any
address. By adding the `requesters` parameter, you only allow requests to come
from an address within the array.

### Example


    ""initiators"": [
        {
            ""type"": ""runlog"",
            ""params"": {
                ""address"": ""0xCAFE000000000000000000000000000000000001"",
                ""requesters"": [
                    ""0xCAFE000000000000000000000000000000000002"",
                    ""0xCAFE000000000000000000000000000000000003""
                ]
            }
        }
    ]

## Web

The `Web` initiator enables jobs to be triggered via web requests,
specifically `POST`s to `/v2/specs/:jobID/runs`. Requests coming in to create
new job runs must be authenticated by cookie.

note

For convenience, there is a ""Run"" button in the operator web UI for the job
which will trigger a job run.

### Web Parameters

`Web` currently takes no parameters.

### Example


    ""initiators"": [
        {
            ""type"": ""web""
        }
   ",right,
What are Chainlink data feeds?,"Chainlink Price Feeds, often just called Chainlink data feeds, are decentralized oracle networks that provide smart contracts with access to high-quality, tamper-proof data.

These data feeds are primarily used to provide real-time price information for various cryptocurrencies, commodities, and other assets. They allow smart contracts to access the current market price of assets without having to interact with external APIs themselves, thus enhancing security, reliability, and transparency.

Here's how Chainlink data feeds work:

Multiple independent, Sybil-resistant oracle nodes fetch data from various high-quality data sources.

Each oracle node retrieves the data independently, which eliminates the risk of a single point of failure.

The individual data points are then aggregated into a single data point, which is written onto the blockchain.

This final, aggregated data point is the one that smart contracts interact with.

The data feeds use a decentralization approach at both the data source and oracle levels, ensuring the data is reliable and resistant to manipulation. This way, even if one data source or one oracle node reports incorrect data, the impact on the overall feed is minimal, ensuring the integrity of the data.

Chainlink data feeds are used widely across the decentralized finance (DeFi) space, powering various protocols, lending platforms, stablecoins, and more. As of my training cut-off in September 2021, Chainlink is one of the most prominent providers of decentralized oracle solutions.","Chainlink Data Feeds are a way to connect smart contracts to real-world data such as asset prices, reserve balances, NFT floor prices, and L2 sequencer health. They provide different types of data feeds, including Price Feeds, Proof of Reserve Feeds, NFT Floor Price Feeds, Rate and Volatility Feeds, and L2 sequencer uptime feeds. The feeds are categorized as Monitored Feeds, Provisional Feeds, Custom Feeds, and Specialized Feeds, each with their own level of risk and suitability for different use cases.","# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
 

:::NEXT DOC:::

🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as

:::NEXT DOC:::

#####Chapter 6:

# Chainlink Data Feeds

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Now that you understood how to connect the off-chain world you can utilize this knowledge now for your NFT. Imagine a NFT that reacts to the price of Ethereum. It could rain when the price falls and it could be sunny when the price rises.
    </div>
  </div>
</ContentWrapp>

As discussed in the previous lesson, Chainlink gives developers the ability to create extremely powerful DON’s that provide smart contracts with the highest quality data from outside the blockchain. As a smart contract developer, how can you take advantage of these DONs in your own smart contracts? Chainlink is open source so there’s always the option of making your own DON, but creating a DON is a complex and nuanced process. Instead, in the spirit of the old developer adage “Never build something twice”, use existing DONs if possible.

Luckily, many of the largest and highest quality node operators in the blockchain industry have already combined their knowledge and prowess to create DONs that serve the most in-demand data for smart contract developers to take advantage of. These data serving DONs are called <ColorWord>Chainlink Data Feeds</ColorWord>. Currently most of the data feeds provide data on various currency and cryptocurrency pairs, as that was initially what smart contract developers needed, but data feeds can be used to retrieve any type of data.

You can see these data feeds updating

:::NEXT DOC:::

To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs

:::NEXT DOC:::

the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify

:::NEXT DOC:::

and documentation.

To help you prepare for unforeseen market events, you should take additional
steps for custom or specialized feeds to protect your application or protocol.
This might also be worth considering in all categories based on the value that
your application secures. This tooling is put in place to mitigate extreme
market events, possible malicious activity on third-party venues or contracts,
potential delays, performance degradation, and outages.

Below are some examples of tooling that Chainlink users have put in place:

  * **Circuit breakers:** In the case of an extreme price event, the contract would pause operations for a limited period of time. [Chainlink Automation](/chainlink-automation/introduction) is able to monitor data feeds to identify unexpected events. If an event were to occur, the Automation network can send an on-chain transaction to pause or halt contract functionality.
  * **Contract update delays:** Contracts would not update until the protocol had received a recent fresh input from the data feed.
  * **Manual kill switch:** If a vulnerability or bug is discovered in one of the upstream contracts, the user can manually cease operation and temporarily sever the connection to the data feed.
  * **Monitoring:** Some users create their own monitoring alerts based on deviations in the data feeds that they are using.
  * **Soak testing:** Users are strongly advised to thoroughly test price feed integrations and incorporate a [soak period](https://en.wikipedia.org/wiki/Soak_testing) prior to providing access to end users or securing value.

For more detailed information about some of these examples, see the
[Monitoring data feeds](/data-feeds/#monitoring-data-feeds) documentation.

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the data-feeds-user-
notifications channel:

:::NEXT DOC:::

## Welcome to the Chainlink Documentation

##### New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide.

## Explore our products

#### [Data Feeds](data-feeds)

Decentralized and high-quality data feeds for DeFi, Reserves, NFTs, sports,
weather, and more

###### Available on:

#### [Chainlink Functions](chainlink-functions)

Connect smart contracts to a trust-minimized compute infrastructure running on
a decentralized oracle network

###### Available on:

#### [Automate Contracts](chainlink-automation/introduction)

Decentralized, highly reliable, cost-efficient and highly secure automation
for smart contracts

###### Available on:

#### [VRF v2](/vrf/v2/introduction)

Verifiable, tamper-proof random number generator for blockchain gaming and NFT
projects

###### Available on:

#### [External API Calls](/any-api/introduction)

Request and receive data from any API using the Chainlink contract library

###### Available on:

## Useful resources

### Need to run your own Chainlink Node?

See the Node Operator’s Guide to learn about starting and maintaining
Chainlink Nodes.

#### Watch tutorials

Learn more about the technology we are building. We're constantly uploading
new videos to our YouTube channel.

##### Need integration support?

##### Discord

##### Stack overflow



:::NEXT DOC:::

but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on.",right,
What is a Chainlink subscription account?,An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.,"A Chainlink subscription account is an account used to manage subscriptions for Chainlink Functions. It can be created and funded with LINK, and can have consumer contracts added to it.","different systems and
applications.

Subscription Manager

Read the [Subcription Manager UI](/vrf/v2/subscription/ui/) page to learn how
to use all the features of the VRF v2 user interface. To learn how to
troubleshoot your VRF requests, read the
[pending](/vrf/v2/subscription/ui/#pending) and [failed
requests](/vrf/v2/subscription/ui/#failed-requests) sections.

Go to [vrf.chain.link](https://vrf.chain.link) to open the Subscription
Manager.

Subscriptions have the following core concepts:

  * **Subscription id:** 64-bit unsigned integer representing the unique identifier of the subscription.
  * **Subscription accounts:** An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.
  * **Subscription owner:** The wallet address that creates and manages a subscription account. Any account can add LINK to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * **Consumers:** Consuming contracts that are approved to use funding from your subscription account.
  * **Subscription balance:** The amount of LINK maintained on your subscription account. Requests from consuming contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your subscription balance to pay for the requests and keep your applications running.

For Chainlink VRF v2 to fulfill your requests, you must maintain a sufficient
amount of LINK in your subscription balance. Gas cost calculation includes the
following variables:

  * **Gas price:** The current gas price, which fluctuates depending on network conditions.

  * **Callback gas:** The amount of gas used for the callback request that returns your requested random values.

  * **Verification gas:** The amount of gas used to verify randomness on-chain.

The gas price depends

:::NEXT DOC:::

Create a subscription for our contract when we deploy it and create a variable of type address to store the wallet address of the wallet that owns the subscription.


:::NEXT DOC:::

   []

### Create and fund a subscription

Run the `functions-sub-create` task with the `amount` parameter to create a
new subscription account and fund it. The `amount` is in LINK.

Optionally, you can also add your consumer contract by including the
`--contract` flag with the address of your consumer contract. You can always
add more consumer contracts later.


    npx hardhat functions-sub-create --amount REPLACE_LINK_AMOUNT --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-create --amount 0.5 --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Creating Functions billing subscription
    Waiting 1 blocks for transaction 0xc5990756f7728da53d8fdce3c715ef47b29094ad2a895435c1d871e2d2c5f725 to be confirmed...
    Subscription created with ID: 28
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 0.5 LINK
    Waiting 2 blocks for transaction 0x822a0d667d8b4ba0849e486b65a7a7d495cb322528d15254dbc7a7a01b7e1458 to be confirmed...
    Subscription 28 funded with 0.5 LINK
    
    Created subscription with ID: 28
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.5 LINK
    0 authorized consumer contracts:
    []

### Get Subscription details

Run the `functions-sub-info` task with the `subid` (subscription ID) parameter
to fetch the following

:::NEXT DOC:::

Contract_. **Note** : The _Subscriptions App_ is not available now, we recommend using the [functions hardhat starter kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit) to interact with the _Subscriptions Contract_.
  * Subscriptions Contract (aka [Functions Billing Registry Contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsBillingRegistry.sol)): The contract that holds user funds to pay for _Chainlink Functions_ requests.
  * subscription account: An account that holds LINK tokens and makes them available to fund requests to Chainlink DON. A _Subscription ID_ uniquely IDentifies each account.
  * Subscription ID: 64-bit unsigned integer representing the unique IDentifier of the _Subscription account_.
  * Subscription owner: The wallet address that creates and manages a _Subscription account_. Any account can add LINK tokens to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * Subscription balance: The amount of LINK maintained on your _Subscription account_. Requests from consumer contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your _Subscription balance_ to pay for the requests and keep your applications running.
  * Subscription reservation: The amount of LINK blocked on the _Subscription balance_. It corresponds to the total LINK amount to be paid by in-flight requests.
  * Effective balance: The amount of LINK available on your _Subscription account_. `Effective balance = Subscription balance - Subscription reservation`.
  * Subscription consumers: Consumer contracts are approved to use funding from your _Subscription account_ while making _Chainlink Functions_ requests. The consumers receive response data in a callback.

## What's next

  * [› Architecture](/chainlink-functions/resources/architecture)

  * [ Edit this

:::NEXT DOC:::

   Funding with 0.5 LINK
    Waiting 2 blocks for transaction 0x822a0d667d8b4ba0849e486b65a7a7d495cb322528d15254dbc7a7a01b7e1458 to be confirmed...
    Subscription 28 funded with 0.5 LINK
    
    Created subscription with ID: 28
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.5 LINK
    0 authorized consumer contracts:
    []

### Get Subscription details

Run the `functions-sub-info` task with the `subid` (subscription ID) parameter
to fetch the following items:

  * Subscription balance
  * Subscription owner
  * A list of authorized client contract addresses


    npx hardhat functions-sub-info --subid REPLACE_SUBSCRIPTION_ID --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-info --subid 28 --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    
    Subscription 28 owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.5 LINK
    0 authorized consumer contracts:
    [

### Fund a Subscription

Run the `functions-sub-fund` task with `subid` (subscription ID) and `amount`
parameters. Note that `amount` is in LINK.


    npx hardhat functions-sub-fund --subid REPLACE_SUBSCRIPTION_ID --amount REPLACE_LINK_AMOUNT --network REPLACE_NETWORK

Example:


    $ npx hardhat

:::NEXT DOC:::

# Managing Subscriptions

  * Overview
  * Before you begin
  * Subscriptions
  * Create a subscription
  * Create and fund a subscription
  * Get Subscription details
  * Fund a Subscription
  * Add a consumer contract to a Subscription
  * Remove a consumer contract from a Subscription
  * Transfer ownership of a Subscription
  * Cancel a Subscription

This guide explains how to manage Chainlink Functions subscriptions.
Currently, the best way to create and manage subscriptions is by using the
[Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-subscription-management-commands) commands.

## Before you begin

**[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set
up your environment with the necessary tools for creating and managing
subscriptions and completing the tutorials.

## Subscriptions

You can find Subscription Management commands, descriptions, and parameters in
the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-subscription-management-commands) reference documentation.

### Create a subscription

Run the `functions-sub-create` task to create a new subscription account:


    npx hardhat functions-sub-create --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-create --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Creating Functions billing subscription
    Waiting 2 blocks for transaction 0x018a04da4d1a3e8c14ceb8fbca786a897566a37c0b4cb9a9a36ca35a43806a3b to be confirmed...
    Subscription created with

:::NEXT DOC:::

reference documentation.

### Create a subscription

Run the `functions-sub-create` task to create a new subscription account:


    npx hardhat functions-sub-create --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-create --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Creating Functions billing subscription
    Waiting 2 blocks for transaction 0x018a04da4d1a3e8c14ceb8fbca786a897566a37c0b4cb9a9a36ca35a43806a3b to be confirmed...
    Subscription created with ID: 27
    
    Created subscription with ID: 27
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.0 LINK
    0 authorized consumer contracts:
    []

### Create and fund a subscription

Run the `functions-sub-create` task with the `amount` parameter to create a
new subscription account and fund it. The `amount` is in LINK.

Optionally, you can also add your consumer contract by including the
`--contract` flag with the address of your consumer contract. You can always
add more consumer contracts later.


    npx hardhat functions-sub-create --amount REPLACE_LINK_AMOUNT --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-create --amount 0.5 --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Creating Functions billing subscription
    Waiting 1 blocks for transaction

:::NEXT DOC:::

                                         | No subscription account required                                                                                                                                                                            |
| Supported on Arbitrum                                                                                                                                                  | Not yet supported on Arbitrum                                                                                                                      

:::NEXT DOC:::

28 --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    
    Subscription 28 owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.5 LINK
    0 authorized consumer contracts:
    [

### Fund a Subscription

Run the `functions-sub-fund` task with `subid` (subscription ID) and `amount`
parameters. Note that `amount` is in LINK.


    npx hardhat functions-sub-fund --subid REPLACE_SUBSCRIPTION_ID --amount REPLACE_LINK_AMOUNT --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-fund --subid 28 --amount 0.1  --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Funding subscription 28 with 0.1 LINK
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Waiting 2 blocks for transaction 0x2940a9c8d5cbe521f68552f53c329de0261b179baeb40cafe1b7a1dc3d3bde24 to be confirmed...
    
    Subscription 28 has a total balance of 0.6 LINK

### Add a consumer contract to a Subscription

#### Prerequisites

You must deploy a Chainlink Functions consumer contract before you can add it
to your subscription. You can skip on-chain contract verification with the
`--verify false` flag.

If you do need to [verify](https://blog.chain.link/how-to-verify-a-smart-contract-on-etherscan) your contract on-chain, sign up for a free API key for
your network scanner and include it in your

:::NEXT DOC:::

Open MetaMask and set it to use the Sepolia testnet. The [Subscription Manager](/vrf/v2/subscription/ui) detects your network based on the active network in MetaMask.

  2. Check MetaMask to make sure you have testnet ETH and LINK on Sepolia. You can get testnet ETH and LINK at [faucets.chain.link](https://faucets.chain.link/sepolia/).

  3. Open the Subscription Manager at [vrf.chain.link](https://vrf.chain.link).

[Open the Subscription Manager](https://vrf.chain.link)

  4. Click **Create Subscription** and follow the instructions to create a new subscription account. MetaMask opens and asks you to confirm payment to create the account on-chain. After you approve the transaction, the network confirms the creation of your subscription account on-chain.

  5. After the subscription is created, click **Add funds** and follow the instructions to fund your subscription.

    * For your request to go through, you need to fund your subscription with enough LINK to meet your [minimum subscription balance](/vrf/v2/subscription#minimum-subscription-balance) to serve as a buffer against gas volatility. For this example, a balance of 12 LINK is sufficient. (After your request is processed, it costs around 3 LINK, and that amount will be deducted from your subscription balance.)
    * MetaMask opens to confirm the LINK transfer to your subscription. After you approve the transaction, the network confirms the transfer of your LINK token to your subscription account.
  6. After you add funds, click **Add consumer**. A page opens with your account details and subscription ID.

  7. Record your subscription ID, which you need for your consuming contract. You will add the consuming contract to your subscription later.

You can always find your subscription IDs, balances, and consumers",right,
How can i request data from a public API in a smart contract using chainlink?,"Here are the general steps to request data from a public API using Chainlink within a smart contract:

Install Chainlink: First, you need to have Chainlink installed and properly configured. This would typically involve running a Chainlink Node or using nodes provided by others.

Create a Smart Contract: Write a smart contract in Solidity (the programming language for Ethereum smart contracts) that includes the Chainlink library and uses its functions to make a data request.

Request Data: Within the smart contract, make a request to Chainlink, specifying the public API you want to fetch data from and the Chainlink node that will fulfill the request. You would typically do this using Chainlink's buildChainlinkRequest function, and then sending it via the sendChainlinkRequestTo function.

Handle the Response: Write a callback function in your smart contract to receive and handle the data from the Chainlink oracle. This function is specified when you make the data request.

Fund Your Contract: Since Chainlink nodes require payment in LINK tokens for data requests, you'll need to transfer some LINK to your smart contract.","You can request data from a public API in a smart contract using Chainlink by importing ChainlinkClient.sol and using the Chainlink.Request struct to build the API request, which must include parameters such as Link token address, Oracle address, Job id, Request fee, Task parameters, and Callback function signature. There are multiple ways to connect smart contracts to off-chain data feeds, including making an HTTP GET request and parsing the JSON response to retrieve the value of one single attribute."," 1. Deploy your APIConsumer contract to a testnet and make use of an already deployed operator contract. A list can be found on chainlinks website [https://docs.chain.link/any-api/testnet-oracles/]. Then select a jobId for a node job that can provide the API data you need e.g. bytes32, Int, multi words etc. The jobId can be specified in your APIConsumer contract.
  2. Deploy your own operator contract, setup your own node (chainlink has an option for setting up temporary development nodes), and then create a custom job for your API. You will then need to put you node address as an authorised sender in your operator contract to permit data to be returned from your node.
  3. For local testing you will need to write a function in your test script that sends a mock response to your mock operator contract. Make sure you setAuthorisedSenders for the account you use to send the fulfillOracleRequest transaction, to test properly I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:



:::NEXT DOC:::

# Chainlink Any API Documentation

  * Overview
  * Requesting off-chain data
  * Building external adapters

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=AnyAPI) to talk to an expert
about using Chainlink Any API to get your data on chain.

**Connecting to any API** with Chainlink enables your contracts to access to
_any_ external data source through our decentralized oracle network. We
understand making smart contracts compatible with off-chain data adds to the
complexity of building smart contracts. We created a framework with minimal
requirements, yet unbounded flexibility, so developers can focus more on the
functionality of smart contracts rather than what feeds them. Chainlink’s
decentralized oracle network provides smart contracts with the ability to push
and pull data, facilitating the interoperability between on-chain and off-
chain applications.

Whether your contract requires sports results, the latest weather, or any
other publicly available data, the [Chainlink contract
library](https://github.com/smartcontractkit/chainlink/tree/master/contracts)
provides the tools required for your contract to consume it.

Prerequisites

You should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                 

:::NEXT DOC:::

should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                                                                                                                                                                                                                                                |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                      

:::NEXT DOC:::

Question: (Asked on: 2022-12-21 18:30:42)
ChainLink general API get request Example not working
URL: https://stackoverflow.com/questions/74880366/chainlink-general-api-get-request-example-not-working

Question Body:


I'm developing a project with using a smartcontract that have to make an API
call. I'm tring to follow the ChainLink guide at this
[link](https://docs.chain.link/getting-started/advanced-tutorial). I'd like to
call the requestRiskData() from another function an than use the output (risk
variable updated) to do some stuff. But since it takes like 30 seconds to
update the risk value after the oracle call how i can wait to the risk
variable to be updated?

Can someone send help? Thx

I will attach the code here:

    
    
    //SPDX-License-Identifier: UNLICENSED
    pragma solidity ^0.8.0;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    contract APIConsumer is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public risk;
        bytes32 private jobId;
        uint256 private fee;
        string public a= ""0x6e1db9836521977ee93651027768f7e0d5722a33"";
    
        event RequestRisk(bytes32 indexed requestId, uint256 risk);
    
        /**
         * @notice

:::NEXT DOC:::

which your contract
should use to build the API request. The request should include the following
parameters:

  * Link token address
  * Oracle address
  * Job id
  * Request fee
  * Task parameters
  * Callback function signature

Note on Funding Contracts

Making a GET request will fail unless your deployed contract has enough LINK
to pay for it. **Learn how to[Acquire testnet LINK](/resources/acquire-link)
and [Fund your contract](/resources/fund-your-contract)**.

Assume that a user wants to call the API above and retrieve only the 24h ETH
trading volume from the response.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * THIS EXAMPLE USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract APIConsumer is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
        bytes32 private jobId;
  

:::NEXT DOC:::

full example can be found [here](/any-api/get-request/examples/large-responses).

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('7da2702f37fd48e5b1b9a5715e3509b6', address(this), this.fulfill.selector);
      req.add(
          'get',
          'https://ipfs.io/ipfs/QmZgsvrA1o1C8BGCrx6mHTqR1Ui1XqbCrtbMVrRLHtuPVD?filename=big-api-response.json'
      );
      req.add('path', 'image');
      sendChainlinkRequest(req, (1 * LINK_DIVISIBILITY) / 10); // 0,1*10**18 LINK
    }

##### Callback method


    bytes public data;
    string public imageUrl;
    function fulfill(bytes32 requestId, bytes memory bytesData) public recordChainlinkFulfillment(requestId) {
        data = bytesData;
        imageUrl = string(data);
    }

#### Get > uint256

A full example can be found [here](/any-api/get-request/examples/single-word-response).

##### Request method


    function request() public {
      Chainlink.Request memory req = buildChainlinkRequest('ca98366cc7314957b8c012c72f05aeeb', address(this), this.fulfill.selector);
      req.add(
          'get',
         

:::NEXT DOC:::

run this command in your terminal:


    curl -X 'GET' \
      'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false' \
      -H 'accept: application/json'

The response should be similar to the following:


    [
      {
        ""id"": ""bitcoin"",
        ""symbol"": ""btc"",
        ""name"": ""Bitcoin"",
        ""image"": ""https://assets.coingecko.com/coins/images/1/large/bitcoin.png?1547033579"",
        ""current_price"": 42097,
        ""market_cap"": 802478449872,
        ...
      },
      {
        ...
      }
    ]

Fetch the _id_ of the first element. To consume an API, your contract must
import
[ChainlinkClient.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol).
This contract exposes a struct named `Chainlink.Request`, which your contract
can use to build the API request. The request must include the following
parameters:

  * Link token address
  * Oracle address
  * Job id
  * Request fee
  * Task parameters
  * Callback function signature

Note on Funding Contracts

Making a GET request will fail unless your deployed contract has enough LINK
to pay for it. **Learn how to[Acquire testnet LINK](/resources/acquire-link)
and [Fund your

:::NEXT DOC:::

       for(uint256 i=0; i<=31; i++){
          firstDataWord[i] = _data[i];
        }
        requestIdToBytes = string(abi.encodePacked(requestId));
        requestIdFromCalldata = string(abi.encodePacked(firstDataWord));
    
        require(keccak256(abi.encodePacked(requestIdToBytes)) == keccak256(abi.encodePacked(requestIdFromCalldata)), ""First word must be requestId"");
        _;
      }
    
    
    //Typescript snippet for test script 
    //If local network - Set Authorised senders on Mock Oracle to account[1]
        const [owner, mockNode] = await ethers.getSigners();
        const mockNodeAccount = mockNode.address
        await mockOracle.setAuthorizedSenders([mockNodeAccount])
        
        
        const transaction: ContractTransaction = await apiConsumer.requestWithWords(ANY_ARGS_FOR_API)
        const transactionReceipt: ContractReceipt = await transaction.wait(1)
        const requestId = transactionReceipt.events[0].topics[1]
    
        const apiFilter = apiConsumer.filters.ChainlinkRequested()
        const apiEvents = await apiConsumer.queryFilter(apiFilter)
        console.log(apiEvents)
    
      

:::NEXT DOC:::

   
            req.add(""get"",""https://demo.anchainai.com/api/address_risk_score?proto=eth&address=0x6e1db9836521977ee93651027768f7e0d5722a33&apikey=demo_api_key"");
            req.add(""path"", ""data,0x6e1db9836521977ee93651027768f7e0d5722a33,risk,score"");
    
            return sendChainlinkRequest(req, fee);
        }
    
        function fulfill(
            bytes32 _requestId,
            uint256 _risk
            
        ) public recordChainlinkFulfillment(_requestId) {
            emit RequestRisk(_requestId, _risk);
            risk = _risk;
        }
    
        function withdrawLink() public onlyOwner {
            LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
            require(
                link.transfer(msg.sender, link.balanceOf(address(this))),
                ""Unable to transfer""
            );
        }
        function myStuff() public payable{
        requestRiskData();
  

:::NEXT DOC:::

by network and job)
        }
        // Set the path to find the desired data in the API response, where the response format is:
        // {
        //""data"":{
        //  ""0x6e1db9836521977ee93651027768f7e0d5722a33"":{
        //      ""risk"":{
        //          ""score"":....
        //              }
        //      }
        //    }
        // }
        function requestRiskData() public returns (bytes32 requestId) {
            Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);
            
            req.add(""get"",""https://demo.anchainai.com/api/address_risk_score?proto=eth&address=0x6e1db9836521977ee93651027768f7e0d5722a33&apikey=demo_api_key"");
            req.add(""path"", ""data,0x6e1db9836521977ee93651027768f7e0d5722a33,risk,score"");
    
            return sendChainlinkRequest(req, fee);
        }
    
        function fulfill(
            bytes32",right,
What is an adapter in chainlink?,"Core adapters are the built-in functionality that every Chainlink node supports. Strung together, they act as tasks that need to be performed to complete a Job.

Adapters that are prefixed with ""Eth"" refer to tasks that post data onto the chain.","An adapter in Chainlink is a service that enables easy integration of custom computations and specialized APIs. It allows the core of the Chainlink node to communicate via its API with a simple JSON specification. External adapters can be written in any language and can even run on separate machines, including serverless functions. There are three main categories of information on external adapters: contract creators, developers, and node operators. Contract creators need to know how to specify an external adapter in their request for external data, developers need to know how to implement an external adapter for an API, and node operators need to know how to add an external adapter to their node so that they can provide specialized services to smart contracts.","# External Adapters Introduction

  * Overview

External adapters are how Chainlink enables easy integration of custom
computations and specialized APIs. External adapters are services which the
core of the Chainlink node communicates via its API with a simple JSON
specification. If you want a step by step, be sure to check out our [blog
post](https://blog.chain.link/build-and-use-external-adapters/).

Information on external adapters is broken up into three main categories:
contract creators, developers, and node operators.

  * [Contract Creators](/chainlink-nodes/external-adapters/contract-creators) will need to know how to specify an external adapter in their request for external data.
  * [Developers](/chainlink-nodes/external-adapters/developers) will need to know how to implement an external adapter for an API.
  * [Node Operators](/chainlink-nodes/external-adapters/node-operators) will need to know how to add an external adapter to their node so that they can provide specialized services to smart contracts.

## What's next

  * [› External Adapters in Solidity](/chainlink-nodes/external-adapters/contract-creators)
  * [› Building External Adapters](/chainlink-nodes/external-adapters/developers)
  * [› Bridges: Adding External Adapters to Nodes](/chainlink-nodes/external-adapters/node-operators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/external-adapters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Game Using a Chainlink External Adapter         | Sports               | Medium       |
| Fetch IPFS Data in Smart Contracts Using a Chainlink External Adapter                   | Audius               | Medium       |
| How to Connect a Two-Factor Authentication (2FA) API to a Smart Contract With Chainlink | Security             | Medium       |
| Build a Marine Insurance Smart Contract With Chainlink                                  | Insurance            | Medium       |
| How to Build a Parametric Insurance Smart Contract                                      | Insurance            | Advanced     |
| Connect a Smart Contract to the Twitter API                                             | Social Media         | Advanced     |
| Build an RFID Blockchain Integration With Chainlink External Adapters                   | Identification       | Advanced     |
| How to Connect a Tesla Vehicle API to a Smart Contract Via a Chainlink External Adapter | Transportation       | Advanced     |
| OAuth and API Authentication in Smart Contracts                                  

:::NEXT DOC:::

# Bridges: Adding External Adapters to Nodes

  * Overview
  * Testing External Adapters and Bridges

You can add external adapters to a Chainlink node by creating a bridge in the
Node Operators Interface. Each bridge must have a unique name and a URL for
the external adapter. If a job has a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task), the node searches for a bridge by name and uses
that bridge as your external adapter. Bridge names are case insensitive.

To create a bridge on the node, go to the **Create Bridge** tab in the Node
Operators Interface. Specify a name for the bridge, the URL for your external
adapter, and optionally specify the minimum contract payment and number of
confirmations for the bridge. Minimum contract payment is a fee paid in LINK
for the Chainlink node making a call to the external adapter via the bridge.
This fee is in addition to the fee specified at the global node level for
processing job requests.



The bridge name must be unique to the local node. The bridge URL is the URL of
your external adapter, which can be local or on a separate machine.

To add jobs that use the bridge, add a [Bridge Task](/chainlink-nodes/oracle-jobs/all-tasks/#bridge-task) to your job. The `bridge` task defined in the
example below is defined as `fetch` and the name of the bridge is `soccer-
data`.


    type = ""directrequest""
    schemaVersion = 1
    name = ""Soccer-Data-EA""
    contractAddress = ""0xA74F1E1Bb6204B9397Dac33AE970E68F8aBC7651""
    maxTaskDuration = ""0s""
    observationSource = """"""
        decode_log   [type=ethabidecodelog
                

:::NEXT DOC:::

# Core Adapters [v1]

  * Overview
  * Adapters
  * Compare
  * Copy
  * EthBool
  * EthBytes32
  * EthInt256
  * EthTx
  * EthUint256
  * HttpGet
  * HttpPost
  * JsonParse
  * Multiply
  * NoOp
  * NoOpPend
  * Quotient
  * Sleep

# REMOVED

v1 Jobs are removed

The initiators for v1 Jobs are removed for Chainlink nodes running version
1.0.0 and later. Use [v2 job types](/chainlink-nodes/oracle-jobs/jobs)
instead.

See the [v2 jobs migration page](/chainlink-nodes/oracle-jobs/migration-v1-v2)
to learn how to migrate to v2 jobs.

## Adapters

Core adapters are the built-in functionality that every Chainlink node
supports. Strung together, they act as tasks that need to be performed to
complete a Job.

Adapters that are prefixed with ""Eth"" refer to tasks that post data onto the
chain. Here are some examples of the data types that adapters convert data to.

| Name              | Core Adapter   | Ethereum Data Type   |
|:------------------|:---------------|:---------------------|
| Signed Integers   | EthInt256      | int256               |
| Unsigned Integers | EthUint256     | uint256              |
| Bytes             | EthBytes32     | bytes32              |
| Boolean           | EthBool        | bool    

:::NEXT DOC:::

Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.


:::NEXT DOC:::

#####Chapter 7:

# Conclusion

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp>

Congratulation on making it through the Chainlink 101 course. You now know enough to begin your journey into the world of connected smart contracts. The [official Chainlink documentation](https://docs.chain.link/) would be a great place to go next in your journey. There are great tutorials walking you through where and how to start developing smart contracts, and detailed information on Chainlink services (there are more than just Data Feeds)!

Keep your eyes out for more content on this Academy. If you are a web developer and want to help, feel free to checkout our GitHub repository where you can open pull requests. If you are notice a bug or want to request a new feature, feel free to open an issue on the repo and label it accordingly. Now, enjoy your minting your own completion certificate with NFT and get out there and program the future of the internet and agreements! With Chainlink and Smart Contracts, you can program the next big application.


:::NEXT DOC:::

Smart Contract to the Twitter API                                             | Social Media         | Advanced     |
| Build an RFID Blockchain Integration With Chainlink External Adapters                   | Identification       | Advanced     |
| How to Connect a Tesla Vehicle API to a Smart Contract Via a Chainlink External Adapter | Transportation       | Advanced     |
| OAuth and API Authentication in Smart Contracts                                         | Security             | Advanced     |
| Connect APIs to your Smart Contracts using Chainlink                                    | NFT                  | Advanced     |
#### Automation (Keepers)

| Name                                                                       | Type       | Difficulty   |
|:---------------------------------------------------------------------------|:-----------|:-------------|
| Automation Introduction Video                                              | Automation | Beginner     |
| Smart Contract Automation Master Class Module #1       

:::NEXT DOC:::

                                           | Type                 | Difficulty   |
|:----------------------------------------------------------------------------------------|:---------------------|:-------------|
| Build a Real Estate dApp With Chainlink Oracles                                         | Real-Estate          | Medium       |
| Off-Chain Computation: Statistical Analysis With Chainlink                              | Statistical Analysis | Advanced     |
| Blockchain Fintech Tutorial: Lending and Borrowing With Python                          | Lending              | Medium       |
| Build a Blockchain-Based Fantasy Sports Game Using a Chainlink External Adapter         | Sports               | Medium       |
| Fetch IPFS Data in Smart Contracts Using a Chainlink External Adapter                   | Audius               | Medium       |
| How to Connect a Two-Factor Authentication (2FA) API to a Smart Contract With Chainlink | Security             | Medium       |
| Build a Marine Insurance Smart Contract With Chainlink                                  | Insurance    

:::NEXT DOC:::

the [External Adapters](/chainlink-nodes/external-adapters/external-adapters) documentation.

To understand different use cases for using any API, refer to [Other
Tutorials](/getting-started/other-tutorials).

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› API Reference](/any-api/api-reference/)
  * [› Find Existing Jobs](/any-api/find-oracle/)
  * [› Testnet Oracles](/any-api/testnet-oracles/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/any-api/introduction.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Building External Adapters

  * Overview
  * Requesting data
  * Returning Data
  * Returning Errors
  * Asynchronous callbacks
  * Example

Developers of external adapters will need to know how the Chainlink node
requests data from it, and how the data should be formatted for a response.
External adapters can be written in any language, and even run on separate
machines, to include serverless functions.

The [**Official Chainlink External Adapter Monorepo
(NodeJS)**](https://github.com/smartcontractkit/external-adapters-js) contains
many examples to help get you started.

### Requesting data

When an external adapter receives a request from the Chainlink node, the JSON
payload will include the following objects:

  * `data` (guaranteed to be present but may be empty)
  * `meta` (optional, depends on job type)
  * `responseURL` (optional, will be supplied if job supports asynchronous callbacks)
  * `id` (optional, can be nice to use for EA logging to help debug job runs)

#### Examples


    { ""data"": {} }


    {
      ""data"": {},
      ""responseURL"": ""http://localhost:6688/v2/runs/278c97ffadb54a5bbb93cfec5f7b5503""
    }


    {
      ""data"": { ""foo"": 42 },
      ""meta"": { ""bar"": ""baz"" },
      ""id"": ""2d38ecdb-975c-4f99-801c-b916a429947c""
    }

Additional data may be specified in the spec to be utilized by the adapter.
This can be useful for requesting data from a REST endpoint where the keys and
values can be specified by the requester. For example, if the REST",right,
What is a task in chainlink?,"In the Chainlink ecosystem, a ""task"" refers to a specific action or a series of actions that a Chainlink node performs as part of a job.

A job in Chainlink is defined by a Job Specification, which is a list of tasks that the Chainlink node is to perform. These tasks can range from fetching data from an API endpoint, parsing JSON data, performing computations, or even making a transaction on the blockchain.

For example, a Job Specification could have the following tasks:

HttpGet: Fetch data from a specific URL.
JsonParse: Parse the returned JSON data.
Multiply: Multiply the parsed number to account for decimal places.
EthUint256: Convert the resulting number to a format that's suitable for Ethereum.
EthTx: Send the resulting data to a specific function in a smart contract on the Ethereum network.
Each task is performed in the order specified in the Job Specification, and the output of one task is passed as the input to the next task in the list.

Chainlink nodes are compensated in LINK tokens for the computational resources used to perform these tasks. This incentivizes Chainlink nodes to reliably execute jobs and provide accurate data to smart contracts.","In Chainlink, a task is a replacement for core adapters that is more flexible and can be composed in arbitrary order into pipelines. Tasks can be built-in or created as external adapters accessed through a bridge. All tasks share common attributes such as index and timeout.","# Tasks

  * Overview
  * What is a Task?
  * Shared attributes
  * Writing pipelines

## What is a Task?

Tasks

Tasks replace the [core adapters](/chainlink-nodes/oracle-jobs/v1/adapters)
from v1 jobs.

Tasks are a replacement for core adapters that is more flexible. Tasks can be
composed in arbitrary order into pipelines. Pipelines consist of one or more
threads of execution where tasks are executed in a well-defined order.

You can use Chainlink's [built-in tasks](/chainlink-nodes/oracle-jobs/all-tasks), or you can create your own [external adapters](/chainlink-nodes/external-adapters/external-adapters) for tasks which are accessed
through a `bridge`.

## Shared attributes

All tasks share a few common attributes:

`index`: when a task has more than one input (or the pipeline overall needs to
support more than one final output), and the ordering of the values matters,
the index parameter can be used to specify that ordering.


    data_1 [type=""http"" method=GET url=""https://chain.link/eth_usd""       index=0]
    data_2 [type=""http"" method=GET url=""https://chain.link/eth_dominance"" index=1]
    multiword_abi_encode [type=""eth_abi_encode"" method=""fulfill(uint256,uint256)""]
    
    data_1 -> multiword_abi_encode
    data_2 -> multiword_abi_encode

`timeout`: The maximum duration that the task is allowed to run before it is
considered to be errored. Overrides the `maxTaskDuration` value in the job
spec.

## Writing pipelines

Pipelines are composed of tasks

:::NEXT DOC:::

complete when it is run.
These tasks are split into two subcategories:

  * [**Tasks**](/chainlink-nodes/oracle-jobs/all-tasks) \- These are tasks that come built-in to each node. (examples: http, ethabidecode, etc).
  * [**External Adapters**](/chainlink-nodes/external-adapters/external-adapters) \- These are custom adapters built by node operators and community members, which perform specific tasks like calling a particular endpoint with a specific set of parameters (like authentication secrets that shouldn't be publicly visible).

### Tasks

If a job needs to make a GET request to an API, find a specific unsigned
integer field in a JSON response, then submit that back to the requesting
contract, it would need a job containing the following Tasks:

  * [HTTP](/chainlink-nodes/oracle-jobs/all-tasks/#http-task) calls the API. the `method` must be set to _GET_.
  * [JSON Parse](/chainlink-nodes/oracle-jobs/all-tasks/#json-parse-task) parses the JSON and extracts a value at a given keypath.
  * [Multiply](/chainlink-nodes/oracle-jobs/all-tasks/#multiply-task) multiplies the input by a multiplier. Used to remove the decimals.
  * [ETH ABI Encode](/chainlink-nodes/oracle-jobs/all-tasks/#eth-abi-encode-task) converts the data to a bytes payload according to ETH ABI encoding.
  * [ETH Tx](/chainlink-nodes/oracle-jobs/all-tasks/#eth-tx-task) submits the transaction to the chain, completing the cycle.

The job specs example can be found [here](/chainlink-nodes/job-specs/direct-request-get-uint256). Let's walk through a real example, where you will
retrieve 24 volumes

:::NEXT DOC:::

  my_fetch_task [type=""http"" method=GET url=""https://chain.link/eth_usd""]

The edges between tasks define how data flows from one task to the next. Some
tasks can have multiple inputs, such as `median`. Other tasks are limited to 0
(`http`) or 1 (`jsonparse`).


    data_source_1  [type=""http"" method=GET url=""https://chain.link/eth_usd""]
    data_source_2  [type=""http"" method=GET url=""https://coingecko.com/eth_usd""]
    medianize_data [type=""median""]
    submit_to_ea   [type=""bridge"" name=""my_bridge""]
    
    data_source_1 -> medianize_data
    data_source_2 -> medianize_data
    medianize_data -> submit_to_ea



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/tasks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

to the open API that they want each node to
retrieve. The Chainlink node will use [tasks](/chainlink-nodes/oracle-jobs/tasks) to fulfill the request.

Some APIs require authentication by providing request headers for the
operator's API key, which the Chainlink node supports. If you would like to
provide access to an API that requires authentication, you must create a job
that is specific for that API either using an [external adapter](/chainlink-nodes/external-adapters/external-adapters) or by using the parameters of the
[HTTP task](/chainlink-nodes/oracle-jobs/all-tasks/#http-task).

## Requirements

Before you begin this guide, complete the following tasks to make sure you
have all of the tools that you need:

  * [Set up MetaMask](/getting-started/deploy-your-first-contract/#install-and-fund-your-metamask-wallet) and [obtain testnet LINK](/resources/acquire-link).

  * [Run a Chainlink Node](/chainlink-nodes/v1/running-a-chainlink-node).

  * Fund the Ethereum address that your Chainlink node uses. You can find the address in the node Operator GUI under the **Key Management** configuration. The address of the node is the `Regular` type. You can obtain test ETH from several [faucets](/resources/link-token-contracts). For this tutorial to work, you will have to fund the node's Ethereum address with Sepolia ETH. Here is an example:

## Address Types

Your node works with several different types of addresses. Each address type
has a specific function:

  * **Node address:** This is the address for your Chainlink node wallet. The node requires native blockchain tokens at all times to respond to requests. For this example, the node uses Sepolia ETH. When you start a Chainlink node, it automatically generates this address. You can find this address on the Node Operator GUI under **Key Management

:::NEXT DOC:::

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.


:::NEXT DOC:::

contracts that use [Chainlink VRF](/vrf/v2/introduction), you request
randomness from a VRF oracle and then await the response. The fulfillment
function is already given to us from the `VRFConsumerBase` contract, so
oracles already know where to send the response to. However, with API calls,
the contract itself _defines_ which function it wants to receive the response
to.

Before creating any code, you should understand how Oracle jobs can get data
on-chain.

## What are jobs?

Chainlink nodes require [**Jobs**](/chainlink-nodes/oracle-jobs/jobs) to do
anything useful. In the case of a Request and Receive job, the [Direct
Request](/chainlink-nodes/oracle-jobs/all-jobs#direct-request-jobs) job
monitors the blockchain for a request from a smart contract. Once it catches a
request, it runs the tasks (both core and external adapters) that the job is
configured to run and eventually returns the response to the requesting
contract.

## What are tasks?

Each oracle job has a configured set of tasks it must complete when it is run.
These tasks are split into two subcategories:

  * [**Tasks**](/chainlink-nodes/oracle-jobs/all-tasks) \- These are tasks that come built-in to each node. (examples: http, ethabidecode, etc).
  * [**External Adapters**](/chainlink-nodes/external-adapters/external-adapters) \- These are custom adapters built by node operators and community members, which perform specific tasks like calling a particular endpoint with a specific set of parameters (like authentication secrets that shouldn't be publicly visible).

### Tasks

If a job needs to make a GET request to an API, find a specific unsigned
integer field in a JSON response, then submit that back to the requesting
contract, it would need a job containing the following

:::NEXT DOC:::

Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.


:::NEXT DOC:::

Name                      | Description                                                                                    | GitHub   |
|:--------------------------|:-----------------------------------------------------------------------------------------------|:---------|
| InsuraLink 🥇             | Data-driven insurance agreements that use Chainlink oracles to bridge IoT and smart contracts. | Go       |
| 1x.ag 🥈                  | Build leveraged trade positions across different lending platforms.                            | Go       |
| We Watch in Public Spaces | Tracking system for calculating event attendance.                                              | Go       |
## Chainlink Virtual Hackathon 2019

Read our [blog post here](https://blog.chain.link/winners-of-the-chainlink-virtual-hackathon/).

| Name                      | Description                                                                                    | GitHub  

:::NEXT DOC:::

                                           | Type                 | Difficulty   |
|:----------------------------------------------------------------------------------------|:---------------------|:-------------|
| Build a Real Estate dApp With Chainlink Oracles                                         | Real-Estate          | Medium       |
| Off-Chain Computation: Statistical Analysis With Chainlink                              | Statistical Analysis | Advanced     |
| Blockchain Fintech Tutorial: Lending and Borrowing With Python                          | Lending              | Medium       |
| Build a Blockchain-Based Fantasy Sports Game Using a Chainlink External Adapter         | Sports               | Medium       |
| Fetch IPFS Data in Smart Contracts Using a Chainlink External Adapter                   | Audius               | Medium       |
| How to Connect a Two-Factor Authentication (2FA) API to a Smart Contract With Chainlink | Security             | Medium       |
| Build a Marine Insurance Smart Contract With Chainlink                                  | Insurance    

:::NEXT DOC:::

#####Chapter 7:

# Conclusion

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Chainlink can be used for a lot more than dynamic NFTs. Whenever you need to connect the off-chain world to the on-chain world, Chainlink is the perfect solution.  
    </div>
  </div>
</ContentWrapp>

Congratulation on making it through the Chainlink 101 course. You now know enough to begin your journey into the world of connected smart contracts. The [official Chainlink documentation](https://docs.chain.link/) would be a great place to go next in your journey. There are great tutorials walking you through where and how to start developing smart contracts, and detailed information on Chainlink services (there are more than just Data Feeds)!

Keep your eyes out for more content on this Academy. If you are a web developer and want to help, feel free to checkout our GitHub repository where you can open pull requests. If you are notice a bug or want to request a new feature, feel free to open an issue on the repo and label it accordingly. Now, enjoy your minting your own completion certificate with NFT and get out there and program the future of the internet and agreements! With Chainlink and Smart Contracts, you can program the next big application.
",right,
What is The request and receive cycle in chainlink?,"The request and receive cycle in Chainlink describes the process of how a smart contract requests data from an off-chain source and receives the result. This cycle is facilitated by Chainlink nodes and involves several steps:

Request: A smart contract makes a data request to a Chainlink node. This request is typically encoded in a function call and includes the specific data being requested, and a callback function in the smart contract to receive the data. The contract also sends LINK tokens to the Chainlink node to pay for the data request.

Chainlink Node Receives the Request: The Chainlink node listens for these requests. When it detects one, it initiates the process to fulfill it.

Data Retrieval: The Chainlink node retrieves the requested data from the specified off-chain source. This could be a web API, a different blockchain, a database, or any other data source.

Aggregation (optional): If multiple Chainlink nodes are used to retrieve the same data (to increase data reliability), an aggregation contract might be used to calculate the final result from multiple responses. This could be a simple average, a weighted average, or any other method of combining the data.

Response: The Chainlink node (or aggregation contract) sends the data back to the smart contract. This is done by calling the callback function specified in the original request. The data is now available for the smart contract to use in its logic.

This cycle allows smart contracts to interact with the outside world in a decentralized and trustless manner, greatly expanding their potential use-cases. By using Chainlink, a smart contract can incorporate real-world data into its logic, make decisions based on this data, and even interact with systems outside of the blockchain.",The request and receive cycle in Chainlink describes how a smart contract requests data from an oracle and receives the response in a separate transaction. This cycle is used for API calls and for requesting randomness from a VRF oracle.,"# API Calls: Using Any API

  * Overview
  * How does the request and receive cycle work for API calls?
  * What are jobs?
  * What are tasks?
  * Tasks
  * Contract example
  * External adapters
  * Further reading

Requirements

This guide requires basic knowledge about smart contracts. If you are new to
smart contract development, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds) and [Random Numbers](/getting-started/intermediates-tutorial) guides before you begin.

In this guide, you will learn how to request data from a public API in a smart
contract. This includes understanding what Tasks and External adapters are and
how Oracle Jobs use them. You will also learn how to find the Oracle Jobs and
Tasks for your contract and how to request data from an Oracle Job.

## How does the request and receive cycle work for API calls?

The request and receive cycle describes how a smart contract requests data
from an oracle and receives the response in a separate transaction. If you
need a refresher, check out the [Basic Request Model](/architecture-overview/architecture-request-model).

For contracts that use [Chainlink VRF](/vrf/v2/introduction), you request
randomness from a VRF oracle and then await the response. The fulfillment
function is already given to us from the `VRFConsumerBase` contract, so
oracles already know where to send the response to. However, with API calls,
the contract itself _defines_ which function it wants to receive the response
to.

Before creating any code, you should understand how Oracle jobs can get data
on-chain.

## What are jobs?

Chainlink nodes require [**Jobs**](/chainlink-nodes/oracle-jobs/jobs) to do
anything useful. In the case of a Request and Receive job, the

:::NEXT DOC:::

Question: (Asked on: 2022-12-12 21:30:02)
Why is our Chainlink node not catching any OracleRequest events from our Arbitrum Operator? Requests are never fulfilled / v2 jobs never executed
URL: https://stackoverflow.com/questions/74777534/why-is-our-chainlink-node-not-catching-any-oraclerequest-events-from-our-arbitru

Question Body:


We're trying to get our Chainlink AnyAPI stack to work with an Arbitrum
Chainlink node. The same stack is being used on Ethereum, Polygon and
Avalanche without issue.

Chainlink AnyAPI empowers some of the use cases of DSLA Protocol, a middleware
for adding consumer protection capabilities to any monitorable marketplace
(e.g. OpenSea) using peer-to-peer service level agreements (SLA).

## Request Lifecycle

Here are the different steps involved in verifying that a SLA contract has
been respected, using Chainlink:

  1. A user calls the verification function on the Messenger smart contract that implements Chainlink.

  2. The `Messenger` smart contract sends the request the `PreCoordinator` smart contract .

  3. The `PreCoordinator` forwards the request to the Oracles defined in a Service Agreement (proxy of Oracles).

  4. Upon receiving LINK, each Oracle sends the request to the Chainlink node, by emitting an `OracleRequest` event with the id of the job to be executed.

  5. The Chainlink node captures such event, and executes the corresponding job.

  6. Once the job is executed, the Chainlink node calls the `fulfillOracleRequest2` function to return the result from the external adapter to the PreCoordinator.

  7. The PreCoordinator takes the mean of all Oracle results and ultimately registers the SLI in the messenger.

 

:::NEXT DOC:::

# Chainlink Functions Architecture

  * Overview
  * Request and Receive Data
  * Subscription Management
  * Create Subscription
  * Fund Subscription
  * Add Consumer
  * Remove Consumer
  * Cancel Subscription
  * Transferring ownership of a Subscription

Prerequisites

Read the Chainlink Functions [introduction](/chainlink-functions) to
understand all the concepts discussed on this page.

## Request and Receive Data

Requests to _Chainlink Functions_ follow the [Request & Receive
Data](/chainlink-functions/resources/concepts) cycle.

  1. A [EOA (Externally Owned Account)](https://ethereum.org/en/developers/docs/accounts/#types-of-account) initiates the transaction by calling the consumer contract.
  2. The consumer contract must inherit [FunctionsClient](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsClient.sol) to send the request to the [FunctionsOracle](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsOracle.sol) contract.
  3. The _FunctionsOracle_ contract: 
    1. Calls the [FunctionsBillingRegistry](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/functions/dev/0_0_0/FunctionsBillingRegistry.sol) 's `startBilling` function to estimate the fulfillment costs and block the amount in the _Reservation balance_ (To learn more, read [Cost simulation](/chainlink-functions/resources/billing#cost-simulation-reservation)).
    2. Emits an `OracleRequest` event containing information about the request.
  4. On reception of the event, each _DON_ 's

:::NEXT DOC:::

should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                                                                                                                                                                                                                                                |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                      

:::NEXT DOC:::

how to consume random numbers with Chainlink VRF in smart
contracts.

## How is randomness generated on blockchains? What is Chainlink VRF?

Randomness is very difficult to generate on blockchains. This is because every
node on the blockchain must come to the same conclusion and form a consensus.
Even though random numbers are versatile and useful in a variety of blockchain
applications, they cannot be generated natively in smart contracts. The
solution to this issue is [**Chainlink VRF**](/vrf/v2/introduction), also
known as Chainlink Verifiable Random Function.

## What is the Request and Receive cycle?

The [previous guide](/getting-started/consuming-data-feeds) explained how to
consume Chainlink Data Feeds, which consist of reference data posted on-chain
by oracles. This data is stored in a contract and can be referenced by
consumers until the oracle updates the data again.

Randomness, on the other hand, cannot be reference data. If the result of
randomness is stored on-chain, any actor could retrieve the value and predict
the outcome. Instead, randomness must be requested from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation

:::NEXT DOC:::

from an oracle, which
generates a number and a cryptographic proof. Then, the oracle returns that
result to the contract that requested it. This sequence is known as the
**[Request and Receive cycle](/architecture-overview/architecture-request-model)**.

## What is the payment process for generating a random number?

VRF requests receive funding from subscription accounts. The [Subscription
Manager](https://vrf.chain.link) lets you create an account and pre-pay for
VRF requests, so that funding of all your application requests are managed in
a single location. To learn more about VRF requests funding, see
[Subscriptions limits](/vrf/v2/subscription#subscription-limits).

## How can I use Chainlink VRF?

To see a basic implementation of Chainlink VRF, see [Get a Random
Number](/vrf/v2/subscription/examples/get-a-random-number). In this section,
you will create an application that uses Chainlink VRF to generate randomness.
The contract used in this application has a [_Game of
Thrones_](https://en.wikipedia.org/wiki/Game_of_Thrones) theme.

After the contract requests randomness from Chainlink VRF, the result of the
randomness will transform into a number between 1 and 20, mimicking the
rolling of a 20 sided die. Each number represents a _Game of Thrones_ house.
If the dice land on the value 1, the user is assigned house Targaryan, 2 for
Lannister, and so on. A full list of houses can be found
[here](https://gameofthrones.fandom.com/wiki/Great_House).

When rolling the dice, it uses an `address` variable to track which address is
assigned to each house.

The contract has the following functions:

  * `rollDice`: This submits a randomness request to Chainlink VRF
  * `fulfillRandomWords`: The function that the Oracle uses to

:::NEXT DOC:::

the original request.

### Off-Chain Oracle Node

The off-chain oracle node is responsible for listening for events emitted by
its corresponding on-chain smart contract. Once it detects an `OracleRequest`
event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API,
retrieve some data from it, parse the response, convert the result into
blockchain compatible data, then submit it in a transaction back to the oracle
contract, using the `fulfillOracleRequest` function.

For more information on how to become a node operator, learn how to [run a
Chainlink node](/chainlink-nodes/v1/running-a-chainlink-node).

## Consumer UML

Below is a UML diagram describing the contract structure of
`ATestnetConsumer`, a deployed example contract implementing
`ChainlinkClient`.

## What's next

  * [› Make a GET Request](/any-api/get-request/introduction/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-request-model.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Just like all Chainlink powered services, we must pay the Chainlink VRF for the work completed by using the LINK token. In the past, in version one of Chainlink VRF, this involved sending a set amount of LINK tokens alongside each request. And because a contract itself sends out the requests, this meant that smart contracts had to be sent LINK before they could request a random number.


:::NEXT DOC:::

Chainlink.

  2. The `Messenger` smart contract sends the request the `PreCoordinator` smart contract .

  3. The `PreCoordinator` forwards the request to the Oracles defined in a Service Agreement (proxy of Oracles).

  4. Upon receiving LINK, each Oracle sends the request to the Chainlink node, by emitting an `OracleRequest` event with the id of the job to be executed.

  5. The Chainlink node captures such event, and executes the corresponding job.

  6. Once the job is executed, the Chainlink node calls the `fulfillOracleRequest2` function to return the result from the external adapter to the PreCoordinator.

  7. The PreCoordinator takes the mean of all Oracle results and ultimately registers the SLI in the messenger.

  8. The SLA is verified (real vs goal) by comparing the SLI (real) and the SLO (goal).

## Fulfillment Issue

It appears our node doesn't pick the OracleRequest event of our PreCoordinator
v0.6 / Operator v0.7 setup.

The request is never fulfilled so we've been wondering if our job id syntax is
correct in the PreCoordinator service agreements (among other things) and if,
perhaps, there's a peculiar configuration to apply to the node / v2 job specs.

## AnyAPI Stack

  * PreCoordinator.sol: a proxy for using multiple Chainlink oracles using service agreements

  * v0.6 Chainlink contracts:

    
    
    import '@chainlink/contracts/src/v0.6/ChainlinkClient.sol';
    import '@chainlink/contracts/src/v0.6/LinkTokenReceiver.sol';
    import '@chainlink/contracts/src/v0.6/Median.sol';
  

:::NEXT DOC:::

# Chainlink Functions Concepts

  * Overview
  * Request and Receive Data
  * Decentralized Oracle Network (DON)
  * Subscriptions

_Chainlink Functions_ do not require your consumer contracts to hold LINK
tokens and send them to oracles when making requests. Instead, you must create
a subscription account and fund it to pre-pay for your _Chainlink Functions_
requests, so your consumer contracts don't need to hold LINK when calling
_Chainlink Functions_.

Before you explore how Chainlink Functions works in the
[Architecture](/chainlink-functions/resources/architecture) guide, it is best
to understand the core concepts in this guide.

## Request and Receive Data

This model is similar to the [Basic Request Model](/architecture-overview/architecture-request-model): Consumer contracts initiate the cycle by
creating requests to Functions Oracle contracts. Oracle nodes watch for events
emitted by the [Functions Oracle
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsOracle.sol)
and run the computation off-chain. Finally, oracle nodes use the [Chainlink
OCR](/architecture-overview/off-chain-reporting) protocol to aggregate all the
responses before passing the aggregated responses to the consumer contracts in
callbacks. Note: As long as you use vanilla Node.js (no modules imports), you
can decentralize any computation you want such as API calls, computing maths
operations, etc.

## Decentralized Oracle Network (DON)

_Chainlink Functions_ are powered by a [Decentralized Oracle
Network](https://chain.link/education/blockchain-oracles#decentralized-oracles). The oracle nodes are independent of each other and are responsible
for running the same function such as API calls, computing maths",right,
What are jobs in Chainlink?,"In the Chainlink ecosystem, a ""job"" refers to a specific series of tasks that a Chainlink node is assigned to perform. Each job is defined by a Job Specification, which is written in JSON format and details the specific tasks a node should complete.

Chainlink jobs are generally used to fetch data from an off-chain API, perform certain operations on the data, and then deliver the data to a smart contract on the blockchain.

A typical Chainlink job might look something like this:

HTTP GET: This task instructs the Chainlink node to make a GET request to a specific API endpoint.

JSON Parse: After the HTTP GET task, the Chainlink node will have a JSON response from the API. This task instructs the node to parse the JSON and extract a specific piece of data.

Multiply: Often, the data received needs to be multiplied to convert it into a format suitable for the blockchain (since blockchains cannot handle decimal numbers).

ETHUint256: This task is used to convert the multiplied number to an Ethereum-compatible data type.

ETH TX: This task instructs the Chainlink node to send the final data to a smart contract on the Ethereum blockchain.

Each task in the job is performed in the specified order, and the output of one task is passed as the input to the next task in the chain.

Chainlink nodes are rewarded in LINK tokens for executing jobs. This provides an incentive for node operators to reliably fulfill data requests, and contributes to the decentralized and trustless nature of the Chainlink network.",None,"Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed

:::NEXT DOC:::

in our
previous hackathons. There is also a link to the Marketplace where you can
find the latest data provider nodes and explore the network.

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past Hackathon Winning Projects](/resources/example-projects)

## Outreach

The Chainlink community is an inviting group of engineers that is always
looking to help users expand their knowledge on Chainlink and solve related
issues. Refer back to the [Getting Help](/resources/getting-help) page for the
latest information about how to get support.

### Get support

  * [Stack Overflow](https://stackoverflow.com/questions/tagged/chainlink)
  * [Stack Exchange Ethereum](https://ethereum.stackexchange.com/questions/tagged/chainlink)
  * [Hackathon Discord](https://discord.gg/h3AvTHj)
  * [Developer Discord](https://discord.gg/2YHSAey)

### Join the community

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/other-tutorials.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

various platforms. This
increases knowledge and awareness of Chainlink solutions across the wider
community and builds the contributor's personal skills and brand in the
community.

Some examples of the content generated from the community:

  * Document your experience in using Chainlink as part of your project
  * Do a deep dive blog post or video on a Chainlink solution
  * Write up technical tutorials showcasing Chainlink being used in various use cases

## Becoming a Developer Expert

Chainlink Developer Experts are smart contract and blockchain developers with
deep experience building applications using Chainlink. They are passionate
about sharing their technical knowledge with the world. As a developer expert,
you will receive recognition in the community, previews of new Chainlink
features, exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually

:::NEXT DOC:::

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.


:::NEXT DOC:::

Name                      | Description                                                                                    | GitHub   |
|:--------------------------|:-----------------------------------------------------------------------------------------------|:---------|
| InsuraLink 🥇             | Data-driven insurance agreements that use Chainlink oracles to bridge IoT and smart contracts. | Go       |
| 1x.ag 🥈                  | Build leveraged trade positions across different lending platforms.                            | Go       |
| We Watch in Public Spaces | Tracking system for calculating event attendance.                                              | Go       |
## Chainlink Virtual Hackathon 2019

Read our [blog post here](https://blog.chain.link/winners-of-the-chainlink-virtual-hackathon/).

| Name                      | Description                                                                                    | GitHub  

:::NEXT DOC:::

that may be helpful if you're starting your Chainlink
learning journey or if you're looking for interesting ways to apply Chainlink
to your project:

  * [Two-Minute Explainers](https://www.youtube.com/playlist?list=PLVP9aGDn-X0Q3qBME3T9sBMw66xPsglMA)
  * [Chainlink Developer Workshops](https://www.youtube.com/playlist?list=PLVP9aGDn-X0SPHromvpiGvoNDpH7YErmf)
  * [Chainlink Engineering Tutorials](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J)
  * [Solidity, Blockchain, and Smart Contract Python Course](https://www.youtube.com/watch?v=M576WGiDBdQ)
  * [Chainlink Engineering YouTube](https://www.youtube.com/playlist?list=PLVP9aGDn-X0QwJVbQvuKr-zrh2_DV5M6J)
  * [Dapp University](https://www.youtube.com/watch?v=YLmMNocc1ys)
  * [Austin Griffith](https://www.youtube.com/watch?v=ffU96UhlA0A)
  * [Patrick Collins](https://www.youtube.com/watch?v=p36tXHX1JD8)
  * [Nader Dabit](https://www.youtube.com/watch?v=nS9xP1hxg3w)
  * [Alchemy University](https://university.alchemy.com/)

### Applications

Below is a list of applications of Chainlink's products and services sorted by
difficulty and type to help you navigate and search for projects that you
might find interesting. See the [Chainlink Blog](https://blog.chain.link/) to
stay up to date with new ways to use Chainlink.

#### Data

:::NEXT DOC:::

# Chainlink Introduction

<GradientTextWrapp>
  Chainlink, smart contracts, blockchains, and the entire world of cryptocurrency have been a hot topic of discussion for several years now.
</GradientTextWrapp>

Whether it’s companies like EY and Microsoft looking to use smart contracts to improve their business processes, artists and athletes like LaMelo Ball creating their own “NFTs,” or up and coming companies looking to disrupt long-standing establishments such as the insurance industry, Chainlink and smart contracts are working to become the backbone for world-changing applications.

 


:::NEXT DOC:::

Smart Contracts](https://blog.chain.link/testing-chainlink-smart-contracts/)
  * [NFTs and Chainlink](https://blog.chain.link/build-deploy-and-sell-your-own-dynamic-nft/)
  * [Build an external adapter](/chainlink-nodes/external-adapters/developers)

## Inspiration

  * [77 Use Cases by Chainlink](https://blog.chain.link/44-ways-to-enhance-your-smart-contract-with-chainlink/)
  * [Past winners & code](/resources/example-projects)

## Join the community

The Chainlink community is some of the most inviting groups of engineers
always looking to help you grow to the next stage.

  * [Twitter](https://mobile.twitter.com/chainlink)
  * [Reddit](https://www.reddit.com/r/Chainlink/)
  * [Telegram](https://t.me/chainlinkofficial)
  * [Blog](https://blog.chain.link)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/hackathon-resources.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

 * [Austin Griffith](https://www.youtube.com/watch?v=ffU96UhlA0A)
  * [Patrick Collins](https://www.youtube.com/watch?v=p36tXHX1JD8)
  * [Nader Dabit](https://www.youtube.com/watch?v=nS9xP1hxg3w)
  * [Alchemy University](https://university.alchemy.com/)

### Applications

Below is a list of applications of Chainlink's products and services sorted by
difficulty and type to help you navigate and search for projects that you
might find interesting. See the [Chainlink Blog](https://blog.chain.link/) to
stay up to date with new ways to use Chainlink.

#### Data feeds

| Name                                                                                   | Type     | Difficulty   |
|:---------------------------------------------------------------------------------------|:---------|:-------------|
| How to Calculate Price Volatility for DeFi Variance Swaps                              | DeFi     | Advanced     |
| Build a dApp on Gnosis Chain (xDai) with Secure Data Feeds                             | DeFi     | Medium       |
| Craft Whiskey Crypto Payments With Chainlink Oracles                                   | Payments | Advanced     |
| Convert a Vending",wrong,wrong
How can i Acquire testnet LINK from Chainlink?,"you can acquire testnet LINK tokens for Chainlink development from faucets specific to each testnet. Here are the general steps:

Setup a Wallet: If you don't have one already, set up a Metamask or other Ethereum-compatible wallet. Make sure it's configured to connect to the appropriate Ethereum testnet (like Kovan, Rinkeby, or Ropsten).

Get Testnet Ether: You'll need testnet Ether (ETH) to pay for gas costs on the testnet. You can get this from various faucets like the Kovan faucet, Rinkeby faucet, or Ropsten faucet. You typically just need to enter your wallet address and request the testnet ETH.

Get Testnet LINK: Once you have some testnet ETH, visit a Chainlink faucet to receive testnet LINK. For example, for the Kovan testnet, you might use the Chainlink Kovan faucet. Enter your wallet address, and you'll receive testnet LINK.","To acquire testnet LINK from Chainlink, you can use a faucet by following the steps provided in the ""Get testnet LINK from a faucet"" section of the Chainlink documentation. Additionally, you must configure MetaMask to use LINK tokens by adding the token contract address for the network you want to use.","A new window will appear, showing the LINK token details.

  6. Click **Import Tokens** to confirm adding the new token.

MetaMask should now display the new LINK token balance.

## Get testnet LINK from a faucet

  1. Go to <https://faucets.chain.link/>.
  2. In Metamask, select the network where you want to receive testnet LINK.
  3. Click **Connect wallet** so the faucet app can detect the network and wallet address.
  4. If you want to receive testnet funds at a different address, paste it in the **Wallet address** section. This field defaults to your connected wallet address.
  5. In the **Request type** section, select the testnet funds that you want to receive.
  6. Complete the Captcha and click **Send request**. The funds are transferred from the faucet to the wallet address that you specified.

After the transaction is confirmed on-chain, the faucet app shows ""Request
complete"" and the transaction hash of your request.



## What's next

  * [› Deploy your first contract](/getting-started/deploy-your-first-contract)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/acquire-link.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Acquire testnet LINK

  * Overview
  * Configure MetaMask to use LINK tokens
  * Get testnet LINK from a faucet

The Getting Started guides show you how to send ETH on the Sepolia testnet,
but some contracts might require you to use LINK token instead. This page
shows you how to obtain testnet LINK and send it to your MetaMask wallet.

## Configure MetaMask to use LINK tokens

To see your LINK token balance in MetaMask, you must manually add the token.

  1. Open up MetaMask.

  2. At the bottom of the MetaMask windows, click **Import tokens**.

  3. Find the LINK token contract address for the network that you want to use. On Sepolia, the LINK token address is: `0x779877A7B0D9E8603169DdbD7836e478b4624789`. See the [LINK Token Contracts](/resources/link-token-contracts) page to find the addresses for different testnets.

  4. Paste the token contract address into MetaMask in the Token Address input. The token symbol and decimals of precision will auto-populate.

  5. Click **Next**. A new window will appear, showing the LINK token details.

  6. Click **Import Tokens** to confirm adding the new token.

MetaMask should now display the new LINK token balance.

## Get testnet LINK from a faucet

  1. Go to <https://faucets.chain.link/>.
  2. In Metamask, select the network where you want to receive testnet LINK.
  3. Click **Connect wallet** so the faucet app can detect the network and wallet address.
  4. If you want to receive testnet funds at a different address, paste it in the **Wallet address** section. This field defaults to your connected wallet address.
  5. In the **Request type** section, select the testnet funds that you want to receive.
  6. Complete the Captcha and click

:::NEXT DOC:::

# Testnet Oracles

  * Overview
  * Operator Contracts
  * Jobs
  * Job IDs
  * Examples

The Chainlink Developer Relations team maintains several testnet oracles that
you can use to test your implementation quickly.

Link token address and Faucet details

To retrieve the LINK token address or get faucet details for your testnet of
choice, see the [LINK Token Contracts](/resources/link-token-contracts) page.

## Operator Contracts

Testnet [Operator
contracts](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/Operator.sol)
are deployed and maintained on the following networks:

| Testnet          | Oracle Address                             |
|:-----------------|:-------------------------------------------|
| Ethereum Sepolia | 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD |
| Ethereum Goerli  | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
| Avalanche Fuji   | 0x022EEA14A6010167ca026B32576D6686dD7e85d2 |
| Polygon Mumbai   | 0x40193c8518BB267228Fc409a613bDbD8eC5a97b3 |
| Binance Testnet  | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
| Fantom Testnet   | 0xCC79157eb46F5624204f47AB42b3906cAA40eaB7 |
## Jobs

### Job IDs

To make testing simple, jobs are configured with the following properties:

  * Each request on testnets costs 0.1 LINK.


:::NEXT DOC:::

 1. Deploy your APIConsumer contract to a testnet and make use of an already deployed operator contract. A list can be found on chainlinks website [https://docs.chain.link/any-api/testnet-oracles/]. Then select a jobId for a node job that can provide the API data you need e.g. bytes32, Int, multi words etc. The jobId can be specified in your APIConsumer contract.
  2. Deploy your own operator contract, setup your own node (chainlink has an option for setting up temporary development nodes), and then create a custom job for your API. You will then need to put you node address as an authorised sender in your operator contract to permit data to be returned from your node.
  3. For local testing you will need to write a function in your test script that sends a mock response to your mock operator contract. Make sure you setAuthorisedSenders for the account you use to send the fulfillOracleRequest transaction, to test properly I'd recommend using a second account from you local testing environment for testing purposes instead on the one used for deployment. You will need to listen to the initial request data transaction event from your APIConsumer contract to get the requestId value and also if you are using fulfillOracleRequest2 for a multi value API call listen for the the chainlink requested event from your mock operator contract to retrieve any other values you might need such as 'expiration', to enable you to create a transaction for the fulfill function on the mock operator contract.   
If using fulfillOracleRequest2 for multi response, may need to modify your
mock operator validateMultiWordResponseId function a bit to enable the
modifier to pass (Solidity doesnt like comparing strings or different data
types), trick is to remove the .offset (my compiler does not like this as it
only works with storage values) assignment to the new variable and just
keccak256 abi.encodePacked both requestIds from the fulfill arguments and
calldata then compare them together. See below:



:::NEXT DOC:::

here](https://docs.chain.link/data-feeds/price-feeds/addresses/) get the
`ETH/USD` goerli testnet address:""0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e""

  * Now in order to call chainlink oracle you have to have `LINK` token in your contract. Get some link token to your conract address [from the faucet](https://faucets.chain.link/)

  * Import the token in metamask. you will see the amount

  * send link token from your metamask to your contract

  * deploy your contract. if you are using `Remix IDE` chose the `injected provider` to connect to metamask. Because chainlink contract is on goerli, so you need to be on Goerli testnet. Once deployment goes through you can call the `fund` function.

  * Since the `fund` function has no argument, you need to send the value alongside the transaction. That is why inside the function you have `msg.value` to access to the sent amount.

  * In `Remix` ide, under ""GAS LIMIT`input there is`VALUE`input. you need to pass the amount in there before you call the`fund` function.





:::NEXT DOC:::

|
| Name           | Chainlink Token on Optimism Mainnet        |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | status.optimism.io                         |
### Optimism Goerli testnet

Testnet ETH is used to pay for transactions on Optimism. Use the [Optimism
Bridge](https://app.optimism.io/bridge) to transfer testnet ETH and LINK from
Ethereum Goerli to Optimistim Goerli. Select Optimism Goerli in your wallet to
access the Optimism Goerli bridge. Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 420                                        |
| Address      |

:::NEXT DOC:::

Open [ATestnetConsumer.sol in Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/APIRequests/ATestnetConsumer.sol).

  2. Note that `setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789)` is configured for _Sepolia_.

  3. On the **Compiler** tab, click the **Compile** button for `ATestnetConsumer.sol`.

  4. On the **Deploy and Run** tab, configure the following settings:

    * Select _Injected Provider_ as your environment. Make sure your metamask is connected to Sepolia.
    * Select _ATestnetConsumer_ from the **Contract** menu.
  5. Click **Deploy**. MetaMask prompts you to confirm the transaction.

  6. Fund the contract by sending LINK to the contract's address. See the [Fund your contract](/resources/fund-your-contract) page for instructions. The address for the `ATestnetConsumer` contract is on the list of your deployed contracts in Remix. You can fund your contract with 1 LINK.

  7. After you fund the contract, create a request. Input your operator contract address and the job ID for the `Get > Uint256` job into the `requestEthereumPrice` request method **without dashes**. The job ID is the `externalJobID` parameter, which you can find on your job's definition page in the Node Operators UI.

  8. Click the **transact** button for the `requestEthereumPrice` function and approve the transaction in Metamask. The `requestEthereumPrice` function asks the node to retrieve `uint256` data specifically from [https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD](https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD).

  9. After the transaction

:::NEXT DOC:::

to Arbitrum Goerli. Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 421613                                     |
| Address      | 0xd14838A68E8AFBAdE5efb411d5871ea0011AFd28 |
| Name         | Chainlink Token on Arbitrum Goerli         |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Optimism

### Optimism mainnet

ETH is used to pay for transactions on Optimism. Use the [Optimism
Bridge](https://app.optimism.io/bridge) to transfer ETH and LINK from Ethereum
Mainnet to Optimism mainnet.

| Parameter      | Value                                     

:::NEXT DOC:::

testnet

Goerli Faucets

Testnet LINK is available from <https://faucets.chain.link/goerli>

Testnet ETH is available from <https://goerlifaucet.com/> or faucets listed at
<https://faucetlink.to/goerli>

| Item                       | Value                                      |
|:---------------------------|:-------------------------------------------|
| LINK Token                 | 0x326C977E6efc84E512bB9C30f76E30c160eD06FB |
| VRF Wrapper                | 0x708701a1DfF4f478de54383E49a627eD4852C816 |
| VRF Coordinator            | 0x2ca8e0c643bde4c2e08ab1fa0da3401adad7734d |
| Wrapper Premium Percentage | 0                                          |
| Coordinator Flat Fee       | 0.25 LINK                                  |
| Minimum Confirmations      | 3                                          |
| Maximum Confirmations      | 200            

:::NEXT DOC:::

      |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | bscscan.freshstatus.io                     |
### BNB Chain testnet

Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/chapel). Testnet BNB is
availalbe at [testnet.binance.org/faucet-
smart](https://testnet.binance.org/faucet-smart).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 97                                         |
| Address      | 0x84b9B910527Ad5C03A9Ca831909E21e236EA7b06 |
| Name         | Chainlink Token                            |
| Symbol       | LINK                                       |
| Decimals     | 18         ",right,
What is the decentralized data model in Chainlink?,"The decentralized data model in Chainlink refers to its approach of using multiple independent nodes to provide data to smart contracts. This is in contrast to a centralized model, where a single entity or server provides the data.

In Chainlink's decentralized model, multiple independent, Sybil-resistant oracle nodes fetch data from various high-quality data sources. This approach has several advantages:

Reliability: Because multiple nodes are retrieving and reporting data, the system isn't reliant on a single point of failure. If one node goes down or reports incorrect data, the other nodes can still provide the correct data.

Security: The data provided by the nodes is more secure because it's much harder for a bad actor to manipulate. They would have to take control of or manipulate a majority of the nodes, which is significantly more difficult than attacking a single, centralized source.

Accuracy: Multiple nodes retrieving data from multiple sources allows for more accurate and reliable data. The data from all the nodes can be aggregated to provide a single, more accurate data point.

Chainlink's decentralized data model is a key feature that makes it attractive for DeFi and other decentralized applications. It allows smart contracts to interact with real-world data in a secure and reliable manner, without compromising the decentralized principles of blockchain technology.","The decentralized data model in Chainlink involves multiple independent oracle operators updating data feeds, which are then aggregated on-chain by the AccessControlledOffchainAggregator. The data feeds are built and funded by the community of users who rely on accurate, up-to-date data in their smart contracts, and each feed has its own properties depending on the needs of its community of users. The decentralized oracle network rewards oracle operators for publishing data, and a minimum number of oracles must contribute to each feed for an update to take place.","# Data Feeds Architecture

  * Overview
  * Basic Request Model
  * Decentralized Data Model
  * Off-Chain Reporting

## Basic Request Model

Chainlink connects smart contracts with external data using its decentralized
oracle network. Chainlink API requests are handled 1:1 by an oracle.

The [Basic Request Model](/architecture-overview/architecture-request-model)
describes the on-chain architecture of requesting data from a single oracle
source.

To learn how to make a GET request using a single oracle, see [Make a GET
Request](/any-api/get-request/introduction).

## Decentralized Data Model

For a more robust and trustworthy answer, you can aggregate data from many
oracles. With on-chain aggregation, data is aggregated from a decentralized
network of independent oracle nodes. This architecture is applied to Chainlink
Data Feeds, which can aggregate data such as asset price data.

The [Decentralized Data Model](/architecture-overview/architecture-decentralized-model) describes how data is aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  *

:::NEXT DOC:::

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.


:::NEXT DOC:::

in the best interest of everyone. But what if we had a decentralized middleware solution, one where Jim doesn’t control everything (sorry Jim), so we didn’t have to trust him?

Finally we are here…...enter Chainlink!

<Spacer>

## Chainlink and Decentralized Oracles

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Using a Chainlink Decentralized Oracle Network (DON) as the Oracle for your dNFT can give you strong guarantees that your artwork will truly update with the latest, most acurate data and remain decentralized. 
    </div>
  </div>
</ContentWrapp>

Smart contracts have special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform.

:::NEXT DOC:::

# Decentralized Data Model

  * Overview
  * Data Aggregation
  * Shared Data Resource
  * Decentralized Oracle Network
  * Components of a Decentralized Oracle Network
  * Consumer
  * Proxy
  * Aggregator

This page describes how data aggregation is applied to produce Chainlink Data
Feeds and provides more insight as to how Data Feeds are updated.

## Data Aggregation

Each data feed is updated by multiple, independent Chainlink oracle operators.
The
[AccessControlledOffchainAggregator](https://github.com/smartcontractkit/libocr/blob/master/contract/AccessControlledOffchainAggregator.sol)
aggregates the data on-chain.

Off-Chain Reporting (OCR) further enhances the aggregation process. To learn
more about OCR and how it works, see the [Off-Chain Reporting](/architecture-overview/off-chain-reporting) page.

## Shared Data Resource

Each data feed is built and funded by the community of users who rely on
accurate, up-to-date data in their smart contracts. As more users rely on and
contribute to a data feed, the quality of the data feed improves. For this
reason, each data feed has its own properties depending on the needs of its
community of users.

## Decentralized Oracle Network

Each data feed is updated by a decentralized oracle network. Each oracle
operator is rewarded for publishing data. The number of oracles contributing
to each feed varies. In order for an update to take place, the data feed
aggregator contract must receive responses from a minimum number of oracles or
the latest answer will not be updated. You can see the minimum number of
oracles for the corresponding feed at
[data.chain.link](https://data.chain.link).

Each oracle in the set publishes data during an aggregation round. That data
is validated and aggregated by a smart contract, which forms the feed's

:::NEXT DOC:::

special properties and need decentralized oracles to carry out functions. This is where Chainlink comes in. <ColorWord>Chainlink is a platform for creating decentralized oracle networks that provide various smart contract services</ColorWord>. So using Chainlink, we can create a price oracle that isn’t just Jim but Jim and 30 other of the most trusted and expert crypto price data aggregators out there and make them come to an agreement.

Chainlink allows developers to create and customize any type of <ColorWord>Decentralized Oracle Network</ColorWord>, or DONs, a smart contract might need. Developers can choose which nodes are a part of a network, what type of data each node is looking for, how nodes come to an agreement, when nodes should post updates, and any other computation nodes should perform. Finally, with Chainlink, developers can build smart contracts that can interact with the outside world to preserve the decentralized nature of smart contracts.

<Spacer>

## How Chainlink Works

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
      Curious how Chainlink works? Read below! With Chainlink, any type of data the exists can be brought on chain, and the conditions on which that data is delivered can be customized! 
    </div>
  </div>
</ContentWrapp>

Chainlink allows developers to build and customize DONs. Chainlink allows DONs to work and assures that node operators are incentivized not to collude or act

:::NEXT DOC:::

a data feed, the quality of the data feed improves. For this
reason, each data feed has its own properties depending on the needs of its
community of users.

## Decentralized Oracle Network

Each data feed is updated by a decentralized oracle network. Each oracle
operator is rewarded for publishing data. The number of oracles contributing
to each feed varies. In order for an update to take place, the data feed
aggregator contract must receive responses from a minimum number of oracles or
the latest answer will not be updated. You can see the minimum number of
oracles for the corresponding feed at
[data.chain.link](https://data.chain.link).

Each oracle in the set publishes data during an aggregation round. That data
is validated and aggregated by a smart contract, which forms the feed's latest
and trusted answer.

## Components of a Decentralized Oracle Network

Data Feeds are an example of a decentralized oracle network, and include the
following components:

  * A consumer contract
  * A proxy contract
  * An aggregator contract

To learn how to create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

### Consumer

A Consumer contract is any contract that uses Chainlink Data Feeds to consume
aggregated data. Consumer contracts must reference the correct
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract and call one of the exposed functions.


    ...
    AggregatorV3Interface feed = AggregatorV3Interface(address);
    return feed.latestRoundData();

Off-chain applications can also consume data feeds. See the Javascript and
Python example code on the [Using Data

:::NEXT DOC:::

should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                                                                                                                                                                                                                                                |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                      

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Functions Concepts

  * Overview
  * Request and Receive Data
  * Decentralized Oracle Network (DON)
  * Subscriptions

_Chainlink Functions_ do not require your consumer contracts to hold LINK
tokens and send them to oracles when making requests. Instead, you must create
a subscription account and fund it to pre-pay for your _Chainlink Functions_
requests, so your consumer contracts don't need to hold LINK when calling
_Chainlink Functions_.

Before you explore how Chainlink Functions works in the
[Architecture](/chainlink-functions/resources/architecture) guide, it is best
to understand the core concepts in this guide.

## Request and Receive Data

This model is similar to the [Basic Request Model](/architecture-overview/architecture-request-model): Consumer contracts initiate the cycle by
creating requests to Functions Oracle contracts. Oracle nodes watch for events
emitted by the [Functions Oracle
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/dev/functions/FunctionsOracle.sol)
and run the computation off-chain. Finally, oracle nodes use the [Chainlink
OCR](/architecture-overview/off-chain-reporting) protocol to aggregate all the
responses before passing the aggregated responses to the consumer contracts in
callbacks. Note: As long as you use vanilla Node.js (no modules imports), you
can decentralize any computation you want such as API calls, computing maths
operations, etc.

## Decentralized Oracle Network (DON)

_Chainlink Functions_ are powered by a [Decentralized Oracle
Network](https://chain.link/education/blockchain-oracles#decentralized-oracles). The oracle nodes are independent of each other and are responsible
for running the same function such as API calls, computing maths

:::NEXT DOC:::

friend Jim (trust me, he is good!) is an expert in cryptocurrency prices, and he even has a server set up that we can access for price data. Awesome, we'll make Jim our oracle and he will provide price data to our NFT smart contract.

But wait….didn’t all the great properties of smart contracts and blockchains come from their decentralized nature? What if Jim wanted to maliciously send our smart contract bad price data so he could manipulate it in his favor? What if his server goes offline when the NFT needs to update and thus can’t? What if Jim isn’t even malicious but gets hacked by a malicious actor? This single oracle solution isn’t solving much of the oracle problem because it isn’t <i>decentralized</i>, and thus provides a weak link that ruins all of those awesome smart contract properties. You need to trust that Jim, and my word on Jim, that he is a great person and will act in the best interest of everyone. But what if we had a decentralized middleware solution, one where Jim doesn’t control everything (sorry Jim), so we didn’t have to trust him?

Finally we are here…...enter Chainlink!

<Spacer>

## Chainlink and Decentralized Oracles

<ContentWrapp>
  <div class=""imgContainer"">
    <img alt=""story_image_2_0"" src=""/images/chapter/man.svg"" width=""150px"" height=""150px"">
  </div>

  <div class=""itemsContainer"">
    <div class=""item-text"">
     Using a Chainlink Decentralized Oracle Network (DON) as the Oracle for your dNFT can give you strong guarantees that your artwork will truly update with the latest,",right,
What data types are available for Rate and Volatility Feeds on Chainlink?,"The following data types are available:

Bitcoin Interest Rate Curve
ETH Staking APR
Realized Volatility","The available data types for Rate and Volatility Feeds on Chainlink are Bitcoin Interest Rate Curve, ETH Staking APR, and Realized Volatility.","# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR

:::NEXT DOC:::

the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is met.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find heartbeat and deviation information for each
feed. If you have questions or would like to request an enhancement to
Realized Volatility Feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Rate and Volatility Feeds](/data-feeds/rates-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2 |
| ETH-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 |

:::NEXT DOC:::

  8 | 0x2583E47DF3F959B055F4Efa90C4927658669F499 |
| BTC Interest Rate Benchmark Curve 2 Week |     nan |    nan | 0.01%       | 86400s      |     8 | 0x39545d0c11CD62d787bB971B6a802150e1f54D8f |
| BTC-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x28f9134a15cf0aAC9e1F0CD09E17f32925254C77 |
| BTC-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%   

:::NEXT DOC:::

# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like

:::NEXT DOC:::

then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is met.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find heartbeat and deviation information for each
feed. If you have questions or would like to request an enhancement to
Realized Volatility Feeds, contact us using

:::NEXT DOC:::

How to Calculate Price Volatility for DeFi Variance Swaps                              | DeFi     | Advanced     |
| Build a dApp on Gnosis Chain (xDai) with Secure Data Feeds                             | DeFi     | Medium       |
| Craft Whiskey Crypto Payments With Chainlink Oracles                                   | Payments | Advanced     |
| Convert a Vending Machine to Accept Cryptocurrency Payments Using Chainlink Data Feeds | Payments | Advanced     |
| Build a dApp on BNB Chain With Secure Data Feeds                                       | DeFi     | Medium       |
| How to Use Chainlink With Hardhat                                                      | DeFi     | Medium       |
| Develop a DeFi Project Using Python                                                    | DeFi     | Medium       |
| Build a DeFi Call Option Exchange With Chainlink Data Feeds                            | DeFi     | Advanced  

:::NEXT DOC:::

so you can use the
[AggregatorV3Interface.sol](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract to retrieve price answers.

To learn more, see the [NFT Floor Price Feeds](/data-feeds/nft-floor-price)
documentation.

See the [NFT Floor Price Contract Addresses](/data-feeds/nft-floor-price/addresses) page for a list of available networks and addresses.

### Rate and Volatility Feeds

Several feeds provide interest rate curve data, APY data, and realized asset
price volatility.

To learn more, see the [Rate and Volatility Feeds](/data-feeds/rates-feeds)
documentation.

See the [Rate and Volatility Contract Addresses](/data-feeds/rates-feeds/addresses) page for a list of available networks and addresses.

### L2 sequencer uptime feeds

L2 sequencer feeds track the last known status of the sequencer on an L2
network at a given point in time. This helps you prevent mass liquidations by
providing a grace period to allow customers to react to these events.

To learn how to use L2 sequencer uptime feeds feeds, see the [L2 Sequencer
Uptime Feeds](/data-feeds/l2-sequencer-feeds) documentation.

## Components of a data feed

Data Feeds are an example of a decentralized oracle network and include the
following components:

  * **Consumer** : A consumer is an on-chain or off-chain application that uses Data Feeds. Consumer contracts use the [`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) to call functions on the proxy contract and retrieve information from the

:::NEXT DOC:::

NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like [AAVE](https://aave.com/) use Data Feeds to ensure the total
value of the collateral.

Data Feeds aggregate many data sources and publish them on-chain using a
combination of the [Decentralized Data Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) and [Off-Chain
Reporting](/architecture-overview/off-chain-reporting?parent=dataFeeds).

To learn how to use Price Feeds, see the [Price Feeds](/data-feeds/price-feeds) documentation.

See the [Data Feeds Contract Addresses](/data-feeds/price-feeds/addresses)
page for a list of available networks and addresses.

### Proof of Reserve Feeds

Proof of Reserves feeds provide the status of reserves for stablecoins,
wrapped assets, and real world assets. Proof of Reserve Feeds operate
similarly to Price Feeds, but provide answers in units of measurement such as
ounces (oz) or number of tokens.

To learn more about Proof of Reserve Feeds, see the [Proof of Reserve](/data-feeds/proof-of-reserve) documentation.

See the

:::NEXT DOC:::

nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 | 0xd599cEF88Bbd27F1392A544bD0F343ec8893124C |
| LINK-USD 7-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x03121C1a9e6b88f56b27aF5cc065ee1FaF3CB4A9 |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/addresses.mdx)
  * [ Join our community",right,
What is a Chainlink NFT Floor Price Feed?,"Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor price estimate for an NFT collection. These feeds operate the same way as other Chainlink Data Feeds. NFT Floor Price Feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink’s oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. You can use NFT Floor Price Feeds for use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.","A Chainlink NFT Floor Price Feed is a data feed that provides a conservative and risk averse floor price estimate for an NFT collection, supported by Coinbase Cloud's aggregation algorithm and Chainlink's oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. It can be used for various use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma

:::NEXT DOC:::

                                 |
|:---------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| Azuki Floor Price          | ETH           | 2%          |        3600 |    18 | 0x9F6d70CDf08d893f0063742b51d3E9D1e18b7f74 |
| BAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xB677bfBc9B09a3469695f40477d05bc9BcB15F50 |
| CloneX Floor Price         | ETH           | 2%          |        3600 |    18 | 0xE42f272EdF974e9c70a6d38dCb47CAB2A28CED3F |
| CoolCats Floor Price       | ETH           | 2%          |        3600 |    18 | 0x13F38938A18ff26394c5ac8df94E349A97AaAb4e |
| CryptoPunks Floor Price    | ETH           | 2%          |        3600 |    18 | 0x5c13b249846540F81c093Bc342b5d963a7518145 |
| Cryptoadz Floor Price

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data

:::NEXT DOC:::

     | 2%          |        3600 |    18 | 0xEDA76D1C345AcA04c6910f5824EC337C8a8F36d2 |
| MAYC Floor Price           | ETH           | 2%          |        3600 |    18 | 0xCbDcc8788019226d09FcCEb4C727C48A062D8124 |
| VeeFriends Floor Price     | ETH           | 2%          |        3600 |    18 | 0x4b531A318B0e44B549F3b2f824721b3D0d51930A |
| World of Women Floor Price | ETH           | 2%          |        3600 |    18 | 0x2748A42aBd328835DFDA748bdD1D77Ce3c3312EE |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

      | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%     

:::NEXT DOC:::

testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH         

:::NEXT DOC:::

  | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
| ⚫VeeFriends Floor Price                 | ETH           | 2%          |       86400 |    18 | 0x35bf6767577091E7f04707c0290b3f889e968307 |
| ⚫World of Women Floor Price             | ETH           | 2%          |

:::NEXT DOC:::

 |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%  

:::NEXT DOC:::

  | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           |

:::NEXT DOC:::

    (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = nftFloorPriceFeed.latestRoundData();
            return nftFloorPrice;
        }
    }
    

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for NFT Floor Price Feeds](/data-feeds/nft-floor-price/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/nft-floor-price/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right,
How can I Select Quality Data Feeds on Chainlink?,"Selecting quality data feeds on Chainlink involves evaluating several factors. Here are some of the key considerations:

Number of Nodes: More nodes contributing to a data feed generally means greater decentralization and higher resistance to manipulation.

Update Frequency: How often is the data feed updated? Depending on your use case, you might need a feed that updates very frequently.

Deviation Threshold: This is the amount by which the price must change compared to the last reported price for the nodes to post a new round of data. A smaller deviation threshold can lead to more frequent updates.

Oracle Reputation: Chainlink maintains a reputation system for its oracles (nodes). Higher reputation generally means the oracle has successfully completed more jobs.

Data Source Quality: While Chainlink nodes should be getting their data from high-quality sources, it's always good to confirm this yourself. Reliable data sources increase the overall quality of the data feed.

Chainlink provides a list of Price Feeds along with detailed metrics about each feed. These metrics include the number of oracles contributing to the feed, the update frequency, the median gas price of the latest transactions, etc.","To select quality data feeds on Chainlink, one should consider the different categories of data feeds based on the level of risk, including Verified Feeds, Monitored Feeds, Provisional Feeds, Custom Feeds, Specialized Feeds, and Deprecating Feeds. Each feed goes through a rigorous assessment process when implemented, and all feeds contain some inherent risk. It is the responsibility of the user to identify and assess the accuracy, availability, and quality of data that they choose to consume via the Chainlink Network. The Risk Mitigation and Evaluating Data Sources sections should be read when making design decisions. Chainlink lists decentralized data feeds in the documentation to help developers build new applications integrated with data.","# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

developing the
ecosystem, so we continue to develop our software and tooling for anyone to
use. Users have a wide variety of options for choosing how to deliver data on-
chain. They can deploy Chainlink nodes themselves or via the extensive network
of node operators that offer services and access one of the community-managed
oracle networks that support the supply of various types of data on-chain.
Chainlink Labs does not take responsibility for the use of Chainlink node
software.

It is always recommended that you conduct a thorough analysis of your
requirements and carry out appropriate due diligence on any partners you wish
to use with your project.

**The Chainlink Labs team does not monitor community deployments** and users
should use best practices in observability, monitoring, and risk mitigation as
appropriate for your application's stage of development and use case.

As your usage of data feeds evolves and requirements for higher availability
and greater security increases, such as securing substantive value, the
reliability properties of your data feed will become crucial. [Contact
Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) for services
to ensure deployments meet the highest levels of availability and security.

**High Risk: Forked, modified, or custom software:**

As Chainlink is open source, independent forks and modifications may exist.
Chainlink Labs and development teams are not involved in these and do not
track or maintain visibility on them. Chainlink Labs is not responsible for
updates, enhancements, or bug fixes for these versions, and Chainlink Labs
does not monitor them. Their use might pose risks that can do harm to your
project. Users are responsible for thoroughly vetting and validating such
deployments and determining their suitability.

## Evaluating Data Sources and Risks

If your smart contracts use data feeds, assess those data feeds for the
following characteristics:

  * Liquidity and its Distribution
 

:::NEXT DOC:::

🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as

:::NEXT DOC:::

To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs

:::NEXT DOC:::

but are specific to
cryptocurrency and blockchain projects, such as token renaming, token swaps,
redenominations, splits, network upgrades, and other migrations that teams who
govern the blockchain or token might undertake

Sustaining data quality is dependent on data sources implementing the
necessary adjustments related to such actions. For example, when a project
upgrades to a new version of their token, this results in a _token migration_.
When token migrations occur, they require building a new price feed to ensure
that the token price is accurately reported. Similarly, actions by blockchain
project teams, such as forks or upgrades to the network, may require new Price
Feeds to ensure continuity and data quality. When considering a token
migration, fork, network upgrade, or other crypto action, projects should
proactively reach out to relevant stakeholders to ensure the asset price is
accurately reported throughout the process.

### Market Failures Resulting from Extreme Events

Users are strongly advised to set up monitoring and alerts in the event of
unexpected market failures. Black swan events, hacks, coordinated attacks, or
extreme market conditions may trigger unanticipated outcomes such as liquidity
pools becoming unbalanced, unexpected re-weighting of indices, abnormal
behavior by centralized or decentralized exchanges, or the de-pegging of
synthetic assets, stablecoins, and currencies from their intended exchange
rates.

Circuit breakers can be created using [Chainlink Automation](/chainlink-automation/introduction). Circuit breakers are safety measures that monitor
data feeds for unexpected scenarios such as stale prices, drastic price
changes, or prices approaching a predetermined min/max threshold. If an
unexpected scenario occurs, the circuit breaker can send an on-chain
transaction to pause or halt contract functionality.

### Periods of High Network Congestion

Data Feed performance relies on the chains they are deployed on.

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data

:::NEXT DOC:::

feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to

:::NEXT DOC:::

high levels of
data quality and reliability over latency.

To mitigate the risk associated with front running, users building highly
latency-dependent applications should assess whether the configuration of data
feeds meets their needed specifications for speed and frequency.

### Fast Gas Reliability

The [Fast Gas Data Feed](https://data.chain.link/ethereum/mainnet/gas/fast-gas-gwei) provides a simple way to determine the price of gas so you can
estimate how much gas you need to make a transaction execute quickly. Fast gas
prices can be manipulated, so you should design your applications to detect
gas price volatility or malicious activity that might affect the costs of your
transactions.

note

The best practices above are provided for informational purposes only. You are
responsible for reviewing the quality of the data that you integrate into your
smart contracts.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/selecting-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

the quality of the data that you use. [Learn more about making
responsible data quality decisions](/data-feeds/selecting-data-feeds).

## The Chainlink Data Feeds Store Program

The program that contains the logic required for the storing and retrieval of
Chainlink Data Feeds data on both Devnet and Mainnet is
[cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ](https://solscan.io/account/cjg3oHmg9uuPsP8D6g29NWvhySJkdYdAo9D25PRbKXJ?cluster=devnet).
This is the program ID that you use to read price data from off-chain. You can
find the source code for this program in the [smartcontractkit/chainlink-
solana](https://github.com/smartcontractkit/chainlink-solana/tree/develop/contracts/programs/store/src) on GitHub.

You can add data feeds to an existing off-chain project or use the Solana
Starter Kit.

## Adding Data Feeds to an existing off-chain project

You can read Chainlink Data Feeds off-chain in your existing project by using
the [Chainlink Solana NPM
library](https://www.npmjs.com/package/@chainlink/solana-sdk).

Reading feed data

Although you can directly query the data feed accounts, you should not rely on
the memory layout always being the same as it currently is. Based on this, the
recommendation is to always use the consumer library.

Install the necessary components and include the example code in your project.
Optionally, you can run the example code by itself to learn how it works
before you integrate it with your project.

  1. Install the latest Mainnet version of [the Solana CLI](https://github.com/solana-labs/solana/releases) and export the path to the",right,
What are verified feeds on Chainlink?,"These are data feeds that follow a standardized data feeds workflow. Chainlink node operators each query several sources for the market price and aggregate the estimates provided by those sources.

Verified feeds have the following characteristics:

Highly resilient to disruption
Leverage many data sources
Use an extensive network of nodes
Highly liquid and well represented on a large number of markets
These feeds incorporate three layers of aggregation (at the data source, node operator, and oracle network layers), providing industry-grade security and reliability on the price data they reference. To learn more about the three layers of data aggregation, see the blog post about Data Aggregation in Chainlink Price Feeds.

Inherent risks might still exist based on your use case, the blockchain on which the feed is deployed and the conditions on that chain.","Verified feeds on Chainlink are data feeds that follow a standardized data feeds workflow, are highly resilient to disruption, leverage many data sources, use an extensive network of nodes, and are highly liquid and well represented on a large number of markets. They incorporate three layers of aggregation, providing industry-grade security and reliability on the price data they reference.","🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as

:::NEXT DOC:::

do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds

:::NEXT DOC:::

feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to

:::NEXT DOC:::

the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed) to
understand their use cases, properties, and associated risks.

**Examples of Specialized feeds:**

  * **Off-chain Single Source Feeds:** Some data providers use a single data source, which might be necessary if only one source exists off-chain for a specific type of data.
  * **Off-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify

:::NEXT DOC:::

To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs

:::NEXT DOC:::

🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| Proof of Reserve Feed                      | Deviation   |   Heartbeat |   Dec | Address and Info                                    

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data

:::NEXT DOC:::

# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time

:::NEXT DOC:::

# Proof of Reserve Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [Proof Of Reserve Feeds
documentation.](/data-feeds/proof-of-reserve/)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Risks for Proof of Reserve feeds using the wallet address manager

Cross-chain Proof of Reserve feeds using wallet address manager contracts can
vary in their configurations. If the wallet address manager is self-attested,
these feeds might include reserve balances from on-chain addresses that have
not been cryptographically verified to show ownership or control. In
circumstances where cryptographically verified ownership is not provided,
there is a risk that token issuers could manipulate the value of a Proof of
Reserve feed by adding more addresses to the address list even if they do not
directly control these addresses. Each feed’s specific configuration is
documented in the contract address section.

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use

:::NEXT DOC:::

# Chainlink Data Feeds

  * Overview
  * Types of data feeds
  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds
  * Components of a data feed
  * Reading proxy and aggregator configurations
  * Components of an aggregator
  * Updates to proxy and aggregator contracts
  * Monitoring data feeds
  * Check the latest answer against reasonable limits
  * Check the timestamp of the latest answer

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=DataFeed) to talk to an expert
about integrating Chainlink Data Feeds with your applications.

Chainlink Data Feeds are the quickest way to connect your smart contracts to
the real-world data such as asset prices, reserve balances, NFT floor prices,
and L2 sequencer health.

If you already started a project and need to integrate Chainlink, you can [add
Chainlink to your existing project](/resources/create-a-chainlinked-project?parent=dataFeeds#installing-into-existing-projects) with the
[`@chainlink/contracts` NPM
package](https://www.npmjs.com/package/@chainlink/contracts).

## Types of data feeds

Data feeds provide many different types of data for your applications.

  * Price Feeds
  * Proof of Reserve Feeds
  * NFT Floor Price Feeds
  * Rate and Volatility Feeds
  * L2 sequencer uptime feeds

### Price Feeds

Smart contracts often act in real-time on data such as prices of assets. This
is especially true in [DeFi](https://defi.chain.link/).

For example, [Synthetix](https://www.synthetix.io/) uses Data Feeds to
determine prices on their derivatives platform. Lending and borrowing
platforms like",right,
