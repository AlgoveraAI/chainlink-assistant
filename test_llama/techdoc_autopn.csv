question,answer,result,retrieved_docs,right_or_wrong,rd_right_or_wrong
give me a sample solidity contract to use Chainlink price feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","
contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint
price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Random Numbers: Using Chainlink VRF](/getting-started/intermediates-tutorial)
  * [› Connect contracts to Any API](/getting-started/advanced-tutorial)
  * [› Chainlink Automation](/chainlink-automation/introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/getting-started/consuming-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right,
give me a sample solidity contract to use Chainlink VRF?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFD20 is VRFConsumerBaseV2 {

}
uint64 s_subscriptionId;
address vrfCoordinator = 0x2Ca8E0C643bDe4C2E08ab1fA0da3401AdAD7734D;
bytes32 s_keyHash = 0x79d3d8832d904592c0bf9818b621522c988bb8b0c05cdc3b15aea1b6e8db0c15;
uint32 callbackGasLimit = 40000;
uint16 requestConfirmations = 3;
uint32 numWords =  1;
)
(
give me a sample solidity contract to request data from a public API in a smart contract using chainlink?,
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";

/**
 * Request testnet LINK and ETH here: https://faucets.chain.link/
 * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
 */

/**
 * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
 * THIS EXAMPLE USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract APIConsumer is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    /**
     * @notice Initialize the link token and target oracle
     *
     * Sepolia Testnet details:
     * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
     * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
     * jobId: ca98366cc7314957b8c012c72f05aeeb
     *
     */
    constructor() ConfirmedOwner(msg.sender) {
        setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
        setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
        jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    /**
     * Create a Chainlink request to retrieve API response, find the target
     * data, then multiply by 1000000000000000000 (to remove decimal places from data).
     */
    function requestVolumeData() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(
            jobId,
            address(this),
            this.fulfill.selector
        );

        // Set the URL to perform the GET request on
        req.add(
            ""get"",
            ""https://min-api.cryptocompare.com/data/pricemultifull?fsyms=ETH&tsyms=USD""
        );

        // Set the path to find the desired data in the API response, where the response format is:
        // {""RAW"":
        //   {""ETH"":
        //    {""USD"":
        //     {
        //      ""VOLUME24HOUR"": xxx.xxx,
        //     }
        //    }
        //   }
        //  }
        // request.add(""path"", ""RAW.ETH.USD.VOLUME24HOUR""); // Chainlink nodes prior to 1.0.0 support this format
        req.add(""path"", ""RAW,ETH,USD,VOLUME24HOUR""); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 10 ** 18;
        req.addInt(""times"", timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(
        bytes32 _requestId,
        uint256 _volume
    ) public recordChainlinkFulfillment(_requestId) {
        emit RequestVolume(_requestId, _volume);
        volume = _volume;
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(
            link.transfer(msg.sender, link.balanceOf(address(this))),
            ""Unable to transfer""
        );
    }
}","
// SPDX-License-Identifier: MIT
// An example of a consumer contract that directly pays for each request.
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";

contract VRFv2DirectFundingConsumer is ConfirmedOwner, VRFConsumerBaseV2 {
    constructor() public {
        // Set the coordinator address
        VRFConsumerBaseV2.initialize(
            VRFCoordinatorV2Interface.address()
        );
    }

    // Request randomness from the coordinator
    function requestRandomWords() public {
        // Set the payment amount
        uint256 paymentAmount = 2 * LINK;
        // Request randomness
        VRFConsumerBaseV2.requestRandomness(paymentAmount);
    }

    // Callback function to","`VRFv2Consumer.sol` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Provider** environment, select the `VRFv2Consumer` contract from the contract list, and specify your `subscriptionId` so the constructor can set it.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must add this address as an approved consuming contract on your subscription account.

  6. Open the Subscription Manager at [vrf.chain.link](https://vrf.chain.link/) and click the ID of your new subscription under the **My Subscriptions** list. The subscription details page opens.

  7. Under the **Consumers** section, click **Add consumer**.

  8. Enter the address of your consuming contract that you just deployed and click **Add consumer**. MetaMask opens and asks you to confirm the transaction.

Your example contract is deployed and approved to use your subscription
balance to pay for VRF v2 requests. Next, request random values from Chainlink
VRF.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction. After you approve the transaction, Chainlink VRF processes your request. Chainlink VRF fulfills the request and returns the random values to your contract in a callback to the `fulfillRandomWords()` function. At this point, a new key `requestId` is added to the mapping `s_requests`.

Depending on current testnet conditions, it might take a few minutes for the
callback to return the requested random values to your contract. You can see a
list of pending requests for your subscription ID at
[vrf.chain.link](https://vrf.chain.link/).

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated: The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` specifying the `requestId` to display the random words.

You deployed a simple contract that can request and receive random values from
Chainlink VRF. To see more advanced examples where the contract can complete
the entire process including subscription setup and management, see the
[Programmatic Subscription](/vrf/v2/subscription/examples/programmatic-subscription) page.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, your MetaMask wallet is the subscription owner and you
created a consuming contract to use that subscription. The consuming contract
uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that relies on a subscription for funding.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol"";
    import ""@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol"";
    import

:::NEXT DOC:::

in Remix, compile the `VRFv2DirectFundingConsumer` contract.

  3. Configure your deployment. On the **Deploy** tab in Remix, select the **Injected Web3 Environment** and select the `VRFv2DirectFundingConsumer` contract from the contract list.

  4. Click the **Deploy** button to deploy your contract on-chain. MetaMask opens and asks you to confirm the transaction.

  5. After you deploy your contract, copy the address from the **Deployed Contracts** list in Remix. Before you can request randomness from VRF v2, you must fund your consuming contract with enough LINK tokens in order to request for randomness. Next, fund your contract.

## Fund Your Contract

Requests for randomness will fail unless your consuming contract has enough
LINK.

  1. [Acquire testnet LINK](/resources/acquire-link).
  2. [Fund your contract with testnet LINK](/resources/fund-your-contract). For this example, funding your contract with 2 LINK should be sufficient.

## Request random values

The deployed contract requests random values from Chainlink VRF, receives
those values, builds a struct `RequestStatus` containing them, and stores the
struct in a mapping `s_requests`. Run the `requestRandomWords()` function on
your contract to start the request.

  1. Return to Remix and view your deployed contract functions in the **Deployed Contracts** list.

  2. Click the `requestRandomWords()` function to send the request for random values to Chainlink VRF. MetaMask opens and asks you to confirm the transaction.

Set your gas limit in MetaMask

Remix IDE doesn't set the right gas limit, so you must [edit the gas limit in
MetaMask](https://support.metamask.io/hc/en-us/articles/360022895972) within
the **Advanced gas controls** settings.

For this example to work, set the gas limit to _400,000_ in MetaMask.

First, [enable **Advanced gas controls** in your MetaMask
settings](https://support.metamask.io/hc/en-us/articles/360022895972).

Before confirming your transaction in MetaMask, navigate to the screen where
you can edit the gas limit: Select **Site suggested** > **Advanced** >
**Advanced gas controls** and select **Edit** next to the **Gas limit**
amount. Update the **Gas limit** value to _400000_ and select **Save**.
Finally, confirm the transaction.

After you approve the transaction, Chainlink VRF processes your request.
Chainlink VRF fulfills the request and returns the random values to your
contract in a callback to the `fulfillRandomWords()` function. At this point,
a new key `requestId` is added to the mapping `s_requests`. Depending on
current testnet conditions, it might take a few minutes for the callback to
return the requested random values to your contract.

  3. To fetch the request ID of your request, call `lastRequestId()`.

  4. After the oracle returns the random values to your contract, the mapping `s_requests` is updated. The received random values are stored in `s_requests[_requestId].randomWords`.

  5. Call `getRequestStatus()` and specify the `requestId` to display the random words.

Note on Requesting Randomness

Do not re-request randomness. For more information, see the [VRF Security
Considerations](/vrf/v2/security) page.

## Analyzing the contract

In this example, the consuming contract uses static configuration parameters.


    // SPDX-License-Identifier: MIT
    // An example of a consumer contract that directly pays for each request.
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    import",partial,partial
give me a sample solidity contract to use NFT Floor Price Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = nftFloorPriceFeed.latestRoundData();
        return nftFloorPrice;
    }
}","
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract NFTFloorPriceConsumerV3 {
    AggregatorV3Interface internal nftFloorPriceFeed;

    /**
     * Network: Goerli - No Sepolia feeds available at this time
     * Aggregator: CryptoPunks
     * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
     */
    constructor() {
        nftFloorPriceFeed = AggregatorV3Interface(
            0x5c13b249846540F81c093Bc342b5d963a7518145
       );
    }

    /**
     * Returns the latest price
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int nftFloorPrice","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) =

:::NEXT DOC:::

On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",partial,wrong
give me a sample solidity contract to use Proof of Reserve Feeds?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
            0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = reserveFeed.latestRoundData();

        return reserve;
    }
}","
The following is a sample Solidity contract to use Proof of Reserve Feeds:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract ReserveConsumerV3 {
    AggregatorV3Interface internal reserveFeed;

    /**
     * Network: Ethereum Mainnet
     * Aggregator: WBTC PoR
     * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
     */
    constructor() {
        reserveFeed = AggregatorV3Interface(
           0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
        );
    }

    /**
     * Returns the latest price
     */
    function getLatestReserve() public view returns (int) {
        // prettier-ignore
        (
            /*uint80 roundID*/,
            int reserve,
            /*","the same way that you read other Data
Feeds. Specify the [Proof of Reserve Feed Address](/data-feeds/proof-of-reserve/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract ReserveConsumerV3 {
        AggregatorV3Interface internal reserveFeed;
    
        /**
         * Network: Ethereum Mainnet
         * Aggregator: WBTC PoR
         * Address: 0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
         */
        constructor() {
            reserveFeed = AggregatorV3Interface(
                0xa81FE04086865e63E12dD3776978E49DEEa2ea4e
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestReserve() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int reserve,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = reserveFeed.latestRoundData();
    
            return reserve;
        }
    }
    

Disclaimer



Proof of Reserve feeds can vary in their configurations. Please be careful
with the configuration of the feeds used by your smart contracts. You are
solely responsible for reviewing the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page

:::NEXT DOC:::

the quality of the data (e.g., a Proof of
Reserve feed) that you integrate into your smart contracts and assume full
responsibility for any damage, injury, or any other loss caused by your use of
the feeds used by your smart contracts.

Learn more about making responsible data quality decisions.



## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Proof of Reserve Feeds](/data-feeds/proof-of-reserve/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/proof-of-reserve/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",partial,right
Give sample code for an example contract that obtains the latest price answer from the BTC / USD feed on the Sepolia testnet?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","
pragma solidity ^0.8.0;
import ""https://docs.chain.link/samples/PriceFeeds/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface priceFeed;

    constructor() public {
        // Price Feed address
        address addr = 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43;
        // Set up contract instance
        priceFeed = AggregatorV3Interface(addr);
    }

    function getLatestPrice() public view returns (int256 price) {
        (
            /*uint80 roundId*/,
            price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","the Sepolia testnet.


    # THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
    # THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
    # DO NOT USE THIS CODE IN PRODUCTION.
    
    from web3 import Web3
    
    # Change this to use your own RPC URL
    web3 = Web3(Web3.HTTPProvider('https://rpc.ankr.com/eth_sepolia'))
    # AggregatorV3Interface ABI
    abi = '[{""inputs"":[],""name"":""decimals"",""outputs"":[{""internalType"":""uint8"",""name"":"""",""type"":""uint8""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""description"",""outputs"":[{""internalType"":""string"",""name"":"""",""type"":""string""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[{""internalType"":""uint80"",""name"":""_roundId"",""type"":""uint80""}],""name"":""getRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""latestRoundData"",""outputs"":[{""internalType"":""uint80"",""name"":""roundId"",""type"":""uint80""},{""internalType"":""int256"",""name"":""answer"",""type"":""int256""},{""internalType"":""uint256"",""name"":""startedAt"",""type"":""uint256""},{""internalType"":""uint256"",""name"":""updatedAt"",""type"":""uint256""},{""internalType"":""uint80"",""name"":""answeredInRound"",""type"":""uint80""}],""stateMutability"":""view"",""type"":""function""},{""inputs"":[],""name"":""version"",""outputs"":[{""internalType"":""uint256"",""name"":"""",""type"":""uint256""}],""stateMutability"":""view"",""type"":""function""}]'
    # Price Feed address
    addr = '0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43'
    
    # Set up contract instance
    contract = web3.eth.contract(address=addr, abi=abi)
    # Make call to latestRoundData()
    latestData = contract.functions.latestRoundData().call()
    print(latestData)
    

### Golang

You can find an example with all the source files
[here](https://github.com/smartcontractkit/smart-contract-examples/tree/main/pricefeed-golang). This example uses [go-
ethereum](https://github.com/ethereum/go-ethereum) to retrieve feed data from
the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet. To learn how to run the example, see the
[README](https://github.com/smartcontractkit/smart-contract-examples/blob/main/pricefeed-golang/README.md).

New Feed Registry

You can use the [Feed Registry](/data-feeds/feed-registry) to reference data
feed assets by name or currency identifier instead of by pair/proxy address.

## Getting a different price denomination

Chainlink Data Feeds can be used in combination to derive denominated price
pairs in other currencies.

If you require a denomination other than what is provided, you can use two
data feeds to derive the pair that you need. For example, if you needed a BTC
/ EUR price, you could take the BTC / USD feed and the EUR / USD feed and
derive BTC / EUR using division.



Important

If your contracts require Solidity versions that are `>=0.6.0 <0.8.0`, use
[OpenZeppelin's SafeMath

:::NEXT DOC:::

/*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete code](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol) for the `AggregatorV3Interface` on GitHub.

  * The `constructor() {}` initializes an interface object named `priceFeed` that uses `AggregatorV3Interface` and connects specifically to a proxy aggregator contract that is already deployed at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`. The interface allows your contract to run functions on that deployed aggregator contract.

  * The `getLatestPrice()` function calls your `priceFeed` object and runs the `latestRoundData()` function. When you deploy the contract, it initializes the `priceFeed` object to point to the aggregator at `0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43`, which is the proxy address for the Sepolia BTC / USD data feed. Your contract connects to that address and executes the function. The aggregator connects with several oracle nodes and aggregates the pricing data from those nodes. The response from the aggregator includes several variables, but `getLatestPrice()` returns only the `price` variable.

## Compile, deploy, and run the contract

Configure and fund your wallet

If you have not already configured your MetaMask wallet and funded it with
testnet ETH, follow the instructions in [Deploy Your First Smart
Contract](/getting-started/deploy-your-first-contract#install-and-fund-your-metamask-wallet) to set that up. You can get testnet ETH at one of the
available [Sepolia faucets](/resources/link-token-contracts/#sepolia-testnet).

Deploy the `PriceConsumerV3` smart contract on the Sepolia testnet.

  1. [Open the example contract](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol) in Remix. Remix opens and shows the contents of the smart contract.

[Open the contract in
Remix](https://remix.ethereum.org/#url=https://docs.chain.link/samples/PriceFeeds/PriceConsumerV3.sol)

  2. Because the code is already written, you can start the compile step. On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct",right,
Give code examples to demonstrate how to deploy a consumer contract on-chain that reads a data feed and stores the value?,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */,
            int price,
            /*uint startedAt*/,
            /*uint timeStamp*/,
            /*uint80 answeredInRound*/
        ) = priceFeed.latestRoundData();
        return price;
    }
}","
The following code example demonstrates how to deploy a consumer contract on-chain that reads a data feed and stores the value:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";

contract PriceConsumerV3 {
    AggregatorV3Interface internal priceFeed;

    /**
     * Network: Sepolia
     * Aggregator: BTC/USD
     * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
     */
    constructor() {
        priceFeed = AggregatorV3Interface(
            0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
        );
    }

    /**
     * Returns the latest price.
     */
    function getLatestPrice() public view returns (int) {
        // prettier-ignore
        (
            /* uint80 roundID */","# Code Examples

  * Overview
  * Reading data feeds on-chain
  * Solidity
  * Vyper
  * Reading data feeds off-chain
  * Javascript
  * Python
  * Golang
  * Getting a different price denomination
  * More Aggregator Functions

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same. To read a
feed, specify the following variables:

  * **RPC endpoint URL:** This determines which network that your smart contracts will run on. You can use a [node provider service](https://ethereum.org/en/developers/docs/nodes-and-clients/nodes-as-a-service/) or point to your own [client](https://ethereum.org/en/developers/docs/nodes-and-clients/). If you are using a Web3 wallet, it is already configured with the RPC endpoints for several networks and the [Remix IDE](https://remix-project.org/) will automatically detect them for you.
  * **LINK token contract address:** The address for the LINK token contract is different for each network. You can find the full list of addresses for all supported networks on the [LINK Token Contracts](/resources/link-token-contracts?parent=dataFeeds) page.
  * **Feed contract address:** This determines which data feed your smart contract will read. Contract addresses are different for each network. You can find the availble contract addresses on the following pages: 
    * [Price Feed Addresses](/data-feeds/price-feeds/addresses)
    * [Proof of Reserve Feed Addresses](/data-feeds/proof-of-reserve/addresses)
    * [NFT Floor Price Feed Addresses](/data-feeds/nft-floor-price/addresses)

The examples in this document indicate these variables, but you can modify the
examples to work on different networks and read different feeds.

This guide shows example code that reads data feeds using the following
languages:

  * On-chain consumer contracts: 
    * Solidity
    * Vyper
  * Off-chain reads using Web3 packages: 
    * Javascript with [web3.js](https://web3js.readthedocs.io/)
    * Python with [Web3.py](https://web3py.readthedocs.io/en/stable/)
    * Golang with [go-ethereum](https://github.com/ethereum/go-ethereum)

## Reading data feeds on-chain

These code examples demonstrate how to deploy a consumer contract on-chain
that reads a data feed and stores the value.

### Solidity

To consume price data, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
    

:::NEXT DOC:::

# Consuming Data Feeds

  * Overview

New to smart contracts?

This tutorial assumes that you know how to create and deploy basic smart
contracts. If you are new to smart contract development, learn how to [Deploy
Your First Smart Contract](/getting-started/deploy-your-first-contract/)
before you start this guide.

When you connect a smart contract to real-world services or off-chain data,
you create a _hybrid smart contract_. For example, you can use Chainlink Data
Feeds to connect your smart contracts to asset pricing data like the [ETH /
USD feed](https://data.chain.link/eth-usd). These data feeds use the data
aggregated from many independent Chainlink node operators. Each price feed has
an on-chain address and functions that enable contracts to read pricing data
from that address.

The code for reading Data Feeds is the same across all EVM-compatible
blockchains and Data Feed types. You choose different types of feeds for
different uses, but the request and response format are the same.

## Examine the sample contract

This example contract obtains the latest price answer from the [BTC / USD
feed](/data-feeds/price-feeds/addresses) on the Sepolia testnet, but you can
modify it to read any of the different [Types of Data Feeds](/data-feeds#types-of-data-feeds).


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The contract has the following components:

  * The `import` line imports an interface named `AggregatorV3Interface`. Interfaces define functions without their implementation, which leaves inheriting contracts to define the actual implementation themselves. In this case, `AggregatorV3Interface` defines that all v3 Aggregators have the function `latestRoundData`. You can [see the complete",partial,right
Write code to show how to use web3.js to retrieve feed data from a price feed?,"/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only
const web3 = new Web3(""https://rpc.ankr.com/eth_sepolia"")
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: ""decimals"",
    outputs: [{ internalType: ""uint8"", name: """", type: ""uint8"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""description"",
    outputs: [{ internalType: ""string"", name: """", type: ""string"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [{ internalType: ""uint80"", name: ""_roundId"", type: ""uint80"" }],
    name: ""getRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""latestRoundData"",
    outputs: [
      { internalType: ""uint80"", name: ""roundId"", type: ""uint80"" },
      { internalType: ""int256"", name: ""answer"", type: ""int256"" },
      { internalType: ""uint256"", name: ""startedAt"", type: ""uint256"" },
      { internalType: ""uint256"", name: ""updatedAt"", type: ""uint256"" },
      { internalType: ""uint80"", name: ""answeredInRound"", type: ""uint80"" },
    ],
    stateMutability: ""view"",
    type: ""function"",
  },
  {
    inputs: [],
    name: ""version"",
    outputs: [{ internalType: ""uint256"", name: """", type: ""uint256"" }],
    stateMutability: ""view"",
    type: ""function"",
  },
]
const addr = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43""
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr)
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log(""Latest Round Data"", roundData)
  })","
/**
 * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

const Web3 = require(""web3"") // for nodejs only

const web3 = new Web3(new Web3.providers.HttpProvider(""<YOUR_NODE_URL>""));

const priceFeedAddress = ""0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43"";
const priceFeedABI = [
  {
    constant: true,
    inputs: [
      {
        name: ""roundId"",
        type: ""uint80""
      }
    ],
    name: ""latestRoundData"",
    outputs: [
      {
        name: """",
        type: ""uint80""
      },
      {
        name: """",
        type: ""int256""
      },
      {
        name: """",
        type: ""uint256","On the left side of Remix, click the **Solidity Compiler** tab to view the compiler settings.

  3. Use the default compiler settings. Click the **Compile PriceConsumerV3.sol** button to compile the contract. Remix automatically detects the correct compiler version depending on the `pragma` that you specify in the contract. You can ignore warnings about unused local variables in this example.

  4. On the **Deploy** tab, select the **Injected Provider** environment. This contract specifically requires Web3 because it connects with another contract on the blockchain. Running in a JavaScript VM will not work.

  5. Because the example contract has several imports, Remix might select another contract to deploy by default. In the **Contract** section, select the `PriceConsumerV3` contract to make sure that Remix deploys the correct contract.

  6. Click **Deploy** to deploy the contract to the Sepolia testnet. MetaMask opens and asks you to confirm payment for deploying the contract. Make sure MetaMask is set to the Sepolia network before you accept the transaction. Because these transactions are on the blockchain, they are not reversible.

  7. In the MetaMask prompt, click **Confirm** to approve the transaction and spend your testnet ETH required to deploy the contract.

  8. After a few seconds, the transaction completes and your contract appears under the **Deployed Contracts** list in Remix. Click the contract dropdown to view its variables and functions.

  9. Click **getLatestPrice** to show the latest price from the aggregator contract. The latest price appears just below the button. The returned price is an integer, so it is missing its decimal point.

You can run your own oracle networks that provide data to smart contracts
similar to the `AggregatorV3Interface`, but first, you should learn how to
configure your contracts to pay oracles using LINK tokens. Follow the
[Generate Random Numbers](/getting-started/intermediates-tutorial/) to learn
how.

## What's next

  * [› Code examples](/data-feeds/examples)
  * [› Historical Price Data](/data-feeds/historical-data)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/using-data-feeds.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract PriceConsumerV3 {
        AggregatorV3Interface internal priceFeed;
    
        /**
         * Network: Sepolia
         * Aggregator: BTC/USD
         * Address: 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
         */
        constructor() {
            priceFeed = AggregatorV3Interface(
                0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43
            );
        }
    
        /**
         * Returns the latest price.
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /* uint80 roundID */,
                int price,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) = priceFeed.latestRoundData();
            return price;
        }
    }
    

The `latestRoundData` function returns five values representing information
about the latest price data. See the [Data Feeds API Reference](/data-feeds/api-reference) for more details.

### Vyper

To consume price data, your smart contract should import
`AggregatorV3Interface` which defines the external functions implemented by
Data Feeds. You can find it
[here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/interfaces/AggregatorV3Interface.vy). You can find a
`PriceConsumer` example [here](https://github.com/smartcontractkit/apeworx-starter-kit/blob/main/contracts/PriceConsumer.vy). Read the _**apeworx-
starter-kit**_ [README](https://github.com/smartcontractkit/apeworx-starter-kit) to learn how to run the example.

## Reading data feeds off-chain

These code examples demonstrate how to read data feeds directly off chain
using Web3 packages for each language.

### Javascript

This example uses [web3.js](https://web3js.readthedocs.io/) to retrieve feed
data from the [BTC / USD
feed](https://sepolia.etherscan.io/address/0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43)
on the Sepolia testnet.


    /**
     * THIS IS EXAMPLE CODE THAT USES HARDCODED VALUES FOR CLARITY.
     * THIS IS EXAMPLE CODE THAT USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    const Web3 = require(""web3"") // for nodejs only
   ",partial,partial
What is the LINK token contract on ethereum mainnet?,0x514910771AF9Ca656af840dff83E8264EcF986CA,"
The LINK token contract on Ethereum mainnet is located at address 0x514910771AF9Ca656af840dff83E8264EcF986CA. It has a name of ""Chainlink Token"", a symbol of ""LINK"", and 18 decimals. The network status is ethstats.dev.","# LINK Token Contracts

  * Overview
  * Ethereum
  * Ethereum Mainnet
  * Sepolia testnet
  * Goerli testnet
  * BNB Chain
  * BNB Chain mainnet
  * BNB Chain testnet
  * Polygon (Matic)
  * Polygon mainnet
  * Mumbai testnet
  * RSK
  * RSK mainnet
  * Gnosis Chain (xDai)
  * Gnosis Chain mainnet
  * Avalanche
  * Avalanche mainnet
  * Fuji testnet
  * Fantom
  * Fantom mainnet
  * Fantom testnet
  * Arbitrum
  * Arbitrum mainnet
  * Arbitrum Goerli testnet
  * Optimism
  * Optimism mainnet
  * Optimism Goerli testnet
  * Harmony
  * Harmony mainnet
  * Moonriver
  * Moonriver mainnet
  * Moonbeam
  * Moonbeam mainnet
  * Metis
  * Andromeda mainnet
  * BASE
  * BASE Goerli testnet

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=Contracts) to talk to an expert
about the networks that support the LINK token.

LINK tokens are used to pay node operators for retrieving data for smart
contracts and also for deposits placed by node operators as required by
contract creators. The smallest denomination of LINK is called a Juel, and
1,000,000,000,000,000,000 (1e18) Juels are equal to 1 LINK. This is similar to
Wei, which is the [smallest denomination of
ETH](https://ethereum.org/en/developers/docs/intro-to-ether/#denominations).

The LINK token is an ERC677 token that inherits functionality from the ERC20
token standard and allows token transfers to contain a data payload. Read more
about the [ERC677 transferAndCall token
standard](https://github.com/ethereum/EIPs/issues/677).

:::caution[Understand Risks associated with Bridges] If you are using a cross-
chain bridge to transfer your LINK tokens, read the [Bridges and Associated
Risks](/resources/bridge-risks) guide to understand what cross-chain bridges
are and the risks associated with using them. :::

## Ethereum

### Ethereum Mainnet

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1                                          |
| Address        | 0x514910771AF9Ca656af840dff83E8264EcF986CA |
| Name           | Chainlink Token                            |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | ethstats.dev                               |
### Sepolia testnet

Testnet LINK and ETH are available at
[faucets.chain.link](https://faucets.chain.link/sepolia). Testnet ETH is also
available from several public

:::NEXT DOC:::

and
LINK from Ethereum Mainnet to Metis mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1088                                       |
| Address        | 0x79892E8A3Aea66C8F6893fa49eC6208ef07EC046 |
| Name           | Chainlink Token on Metis Mainnet           |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | andromeda-explorer.metis.io                |
## BASE

### BASE Goerli testnet

Testnet ETH is used to pay for transactions on BASE. Testnet ETH is available
from one of the [BASE Network Faucets](https://docs.base.org/tools/network-faucets). Alternatively, you can get testnet ETH from the faucets listed at
[faucetlink.to/goerli](https://faucetlink.to/goerli) and use the [BASE
Bridge](https://bridge.base.org/deposit) to transfer testnet ETH from Ethereum
Goerli to BASE Goerli.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 84531                                      |
| Address        | 0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3 |
| Name           | Chainlink Token on the BASE Goerli testnet |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | goerli.basescan.org                        |
  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/link-token-contracts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right,
What is the chainlink price feed address for 1INCH / ETH?,0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8,ERROR,"        |
|:---------------------------------------|:---------------------------------------------------------|:---------------|:------------|:------------|------:|:-------------------------------------------|
| 🟢1INCH / ETH                          | 1inch                                                    | Crypto         | 2%          | 86400s      |    18 | 0x72AFAECF99C9d9C8215fF44C77B94B99C28741e8 |
| 🟢1INCH / USD                          | 1inch                                                    | Crypto         | 1%          | 86400s      |     8 | 0xc929ad75B72593967DE83E7F7Cda0493458261D9 |
| 🟢AAPL / USD                           | Apple                                                    | Equities       | 0.5%        | 86400s      |     8 | 0x139C8512Cde1778e9b9a8e721ce1aEbd4dD43587 |
| 🟢AAVE / ETH                           | Aave                                                     | Crypto         | 2%          | 86400s      |    18 | 0x6Df09E975c830ECae5bd4eD9d90f3A95a4f88012 |
| 🟢AAVE / USD                           | Aave                                                     | Crypto         | 1%          | 3600s       |     8 | 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9 |
| 🟢ADA / USD                            | Cardano                                                  | Crypto         | 1%          | 86400s      |     8 | 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55 |
| 🟢ADX / USD                

:::NEXT DOC:::

                              | Crypto         | 1%          | 86400s      |     8 | 0x10a43289895eAff840E8d45995BBa89f9115ECEe |
| 🟢ERN / USD                            | Ethernity Chain                                          | Crypto         | 2%          | 86400s      |     8 | 0x0a87e12689374A4EF49729582B474a1013cceBf8 |
| 🟢ETH / BTC                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0xAc559F25B1619171CbC396a50854A3240b6A4e99 |
| 🟢ETH / USD                            | Ethereum                                                 | Crypto         | 0.5%        | 3600s       |     8 | 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 |
| 🟢EUR / USD                            | Euro                                                     | Forex          | 0.15%       | 86400s      |     8 | 0xb49f677943BC038e9857d61E7d053CaA2C1734C1 |
| 🟢EURT / USD                           | Tether Euro                                              | Crypto         | 2%          | 86400s      |     8 | 0x01D391A48f4F7339aC64CA2c83a07C22F95F587a |
| 🟢FARM / ETH                           | Harvest Finance                                          | Crypto         | 2%          | 86400s      |    18 |",wrong,right
What is the proof of reserve address for CacheGold PoR USD on Goerli Testnet?,Not provided in the context,ERROR,"                                                                                |
|:-------------------------------------------|:------------|------------:|------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 🔵CacheGold PoR USD                        | 0.1%        |       86400 |     8 | 0x5586bF404C7A22A4a4077401272cE5945f80189CAsset name:Gold in grams (g)Reserve type:Off-chainData source:GramChainAttestation:Custodian API                      |
| ⭕EURS RESERVESDeprecating: May 10th, 2023 | 10%         |      432000 |     8 | 0xbcD05A3E0c11f340cCcD9a4Efe05eEB2b33AB67AAsset name:Euro (EUR)Reserve type:Off-chainData source:SelfAttestation:Self-attested                                  |
| ⚫Fluent US+ PoR                           | 10%         |       28800 |     8 | 0xf623562437735E297C63B73c9e4417614147505CAsset name:USDReserve type:Off-chainData source:CustodianAttestation:                                                 |
| 🔵GBPT PoR                                 | 2%          |       86400 |    18 | 0xF6f5b570aB6E39E55558AfD8E1E30c5f20E6527EAsset name:British Pound (GBP)Reserve type:Off-chainData source:Bank Frick (Custodian)Attestation:Custodian API       |
| 🔵HBTC PoR                                 | 1e-7%       |      259200 |    18 | 0x0A8cD0115B1EE87EbA5b8E06A9a15ED93e230f7aAsset name:BTCReserve type:Cross-chainData source:Cross-chainAttestation:Wallet Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES        

:::NEXT DOC:::

Address Manager                       |
| ⚫PAX / RESERVES                           | 2%          |       86400 |     8 | 0xf482Ed35406933F321f293aC0e4c6c8f59a22fA5Asset name:US Dollar (USD)Reserve type:Off-chainData source:SelfAttestation:Self-attested                             |
| ⚫PAXG / RESERVES                          | 2%          |       86400 |     8 | 0x716BB8c60D409e54b8Fb5C4f6aBC50E794DA048aAsset name:Gold in troy ounces (oz t)Reserve type:Off-chainData source:SelfAttestation:Self-attested                  |
| 🔵Swell ETH PoR                            | 2%          |       86400 |    18 | 0x60cbE8D88EF519cF3C62414D76f50818D211fea1Asset name:Staked ETHReserve type:Cross-chainData source:Beacon Chain / Cross-chainAttestation:Wallet Address Manager |
| ⚫TUSD Reserves                            | 5%          |       86400 |    18 | 0xBE456fd14720C3aCCc30A2013Bffd782c9Cb75D5Asset name:US Dollar (USD) total reservesReserve type:Off-chainData source:The Network FirmAttestation:Third-party    |
| 🔵WBTC PoR                                 | 1e-7%       |       86400 |     8 | 0xa81FE04086865e63E12dD3776978E49DEEa2ea4eAsset name:Bitcoin (BTC)Reserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                     |
| 🔵eFIL PoR                                 | 2%          |      432000 |    18 | 0x8917800a6BDd8fA8b7c94E25aE2219Db28050622Asset name:Wrapped FilecoinReserve type:Cross-chainData source:Cross-chainAttestation:Wallet address                  |
## Goerli Testnet

| Proof of Reserve Feed   | Deviation   |   Heartbeat |   Dec | Address and Info                                                                                                                        ",wrong,right
What is the rate and Volatility Feed Address for 30-Day ETH APR?,0xceA6Aa74E6A86a7f85B571Ce1C34f1A60B77CD29,"
The Rate and Volatility Feed Address for 30-Day ETH APR is 0x8e604308BD61d975bc6aE7903747785Db7dE97e2.","# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is

:::NEXT DOC:::

nan | 50%         | 3600s       |     5 | 0xabfe1e28F54Ac40776DfCf2dF0874D37254D5F59 |
| BTC-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0x88163626786Ee98AA1De65BD2A76599e71598FD9 |
| ETH-USD 24hr Realized Volatility         |     nan |    nan | 50%         | 3600s       |     5 | 0x31D04174D0e1643963b38d87f26b0675Bb7dC96e |
| ETH-USD 30-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x8e604308BD61d975bc6aE7903747785Db7dE97e2 |
| ETH-USD 7-Day Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xF3140662cE17fDee0A6675F9a511aDbc4f394003 |
| LINK-USD 24hr Realized Volatility        |     nan |    nan | 50%         | 3600s       |     5 | 0xfD59B51F25E0Ab790a4F0c483BaC194FA0479D29 |
| LINK-USD 30-Day Realized Volatility      |     nan |    nan | 50%         | 3600s       |     5 | 0xd599cEF88Bbd27F1392A544bD0F343ec8893124C |
| LINK-USD 7-Day Realized Volatility       |     nan |    nan | 50%         | 3600s       |     5 | 0x03121C1a9e6b88f56b27aF5cc065ee1FaF3CB4A9 |
caution

Please be careful with the feeds used by your smart contracts. The feeds
listed in our official documentation have been reviewed; feeds built for
custom deployments by other community members might have additional risks.
Please do close diligence on your feeds before implementing them in your
contracts. [ Learn more about making responsible data quality
decisions.](/data-feeds/selecting-data-feeds)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/addresses.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",wrong,wrong
What is the NFT floor price address for Bored Ape Yacht Club Floor Price / ETH on ethereum main net?,0x352f2Bc3039429fC2fe62004a1575aE74001CfcE,"
0x352f2Bc3039429fC2fe62004a1575aE74001CfcE","  |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 | 0x021264d59DAbD26E7506Ee7278407891Bb8CDCCc |
| ⚫CoolCats Floor Price                   | ETH           | 2%          |       86400 |    18 | 0xF49f8F5b931B0e4B4246E4CcA7cD2083997Aa83d |
| ⚫CryptoPunks Floor Price / ETH          | ETH           | 2%          |       86400 |    18 | 0x01B6710B01cF3dd8Ae64243097d91aFb03728Fdd |
| ⚫Cryptoadz Floor Price                  | ETH           | 2%          |       86400 |    18 | 0xFaA8F6073845DBe5627dAA3208F78A3043F99bcA |
| ⚫Doodles Floor Price                    | ETH           | 2%          |       86400 |    18 | 0x027828052840a43Cc2D0187BcfA6e3D6AcE60336 |
| ⚫MAYC Floor Price                       | ETH           | 2%          |       86400 |    18 | 0x1823C89715Fe3fB96A24d11c917aCA918894A090 |
| ⚫Moonbirds Floor Price                  | ETH           | 2%          |       86400 |    18 | 0x9cd36E0E8D3C27d630D00406ACFC3463154951Af |
| ⚫Otherdeed for Otherside Floor Price    | ETH           | 2%          |       86400 |    18 | 0x6e3A4376B4C8D3ba49602f8542D9D3C4A87ba901 |
| ⚫Pudgy Penguins Floor Price             | ETH           | 2%          |       86400 |    18 | 0x9f2ba149c2A0Ee76043d83558C4E79E9F3E5731B |
|

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |",right,
What is Chainlink?,"Chainlink is a decentralized oracle network that enables smart contracts on Ethereum to securely connect to external data sources, APIs, and payment systems.

Smart contracts are self-executing contracts with the terms of the agreement directly written into code. They're hosted on blockchain platforms, like Ethereum, and provide many advantages such as trustless execution, efficiency, and transparency. However, one limitation of smart contracts is that they cannot access off-chain data (data outside of the blockchain) directly due to the blockchain's deterministic nature.

Chainlink solves this problem by providing reliable and secure bridges between smart contracts and off-chain data sources. This connection is achieved through a network of decentralized oracle nodes, which fetch and verify real-world data before delivering it to smart contracts.

For example, a smart contract for a decentralized weather betting application could use Chainlink to access real-world weather data. Chainlink nodes retrieve the necessary data from weather APIs and deliver it to the smart contract, which then executes based on the provided data.

Chainlink also has its own native cryptocurrency called LINK, which is used to pay for services within the ecosystem.","
Chainlink is a decentralized network that enables developers to build hybrid smart contracts and access real-world data and services. It provides products such as data feeds, Chainlink functions, contract automation, and a verifiable random number generator. It also provides tutorials and documentation to help users set up and run their own Chainlink nodes, fulfill job requests, and add external adapters.","## Welcome to the Chainlink Documentation

##### New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide.

## Explore our products

#### [Data Feeds](data-feeds)

Decentralized and high-quality data feeds for DeFi, Reserves, NFTs, sports,
weather, and more

###### Available on:

#### [Chainlink Functions](chainlink-functions)

Connect smart contracts to a trust-minimized compute infrastructure running on
a decentralized oracle network

###### Available on:

#### [Automate Contracts](chainlink-automation/introduction)

Decentralized, highly reliable, cost-efficient and highly secure automation
for smart contracts

###### Available on:

#### [VRF v2](/vrf/v2/introduction)

Verifiable, tamper-proof random number generator for blockchain gaming and NFT
projects

###### Available on:

#### [External API Calls](/any-api/introduction)

Request and receive data from any API using the Chainlink contract library

###### Available on:

## Useful resources

### Need to run your own Chainlink Node?

See the Node Operator’s Guide to learn about starting and maintaining
Chainlink Nodes.

#### Watch tutorials

Learn more about the technology we are building. We're constantly uploading
new videos to our YouTube channel.

##### Need integration support?

##### Discord

##### Stack overflow



:::NEXT DOC:::

# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right,
What is a runlog initiator in chainlink?,"The RunLog initiator is an integral component of the Chainlink Node job specifications. It is specifically designed to listen for Ethereum log events (in this case, the Chainlink-specific event ""RunRequest"") that are emitted by the Chainlink Oracle contract when someone requests data from a Chainlink Node.

This initiator responds to requests for external data made by smart contracts on the Ethereum blockchain. When a smart contract emits a RunRequest event, this is picked up by the RunLog initiator, which then triggers a job run on the Chainlink node.

The RunLog initiator allows smart contracts to specify the data they want to retrieve and also helps in the preparation of data before it is sent back to the requesting contract. The data request and delivery process is handled securely and trustlessly, maintaining the decentralization and security principles of blockchain technology.

The Chainlink Oracle contract is an Ethereum smart contract that serves as an intermediary between the Chainlink node and the smart contract requesting data. It manages requests for data and the delivery of responses back to the requesting contract.","
A RunLog initiator is an initiator in Chainlink that triggers a one-off job run when a log event with the job's ID is detected on the blockchain. It works similarly to EthLog, but adds some helpful glue in to stitch together the off-chain job with the on-chain contracts. A new run created by a RunLog is automatically given the parameters needed for an EthTx task to report the run back to the contract that originally created the event log.","         ""type"": ""runlog"",
            ""params"": {
                ""address"": ""0xCAFE000000000000000000000000000000000001"",
                ""requesters"": [
                    ""0xCAFE000000000000000000000000000000000002"",
                    ""0xCAFE000000000000000000000000000000000003""
                ]
            }
        }
    ]

## Web

The `Web` initiator enables jobs to be triggered via web requests,
specifically `POST`s to `/v2/specs/:jobID/runs`. Requests coming in to create
new job runs must be authenticated by cookie.

note

For convenience, there is a ""Run"" button in the operator web UI for the job
which will trigger a job run.

### Web Parameters

`Web` currently takes no parameters.

### Example


    ""initiators"": [
        {
            ""type"": ""web""
        }
    ]

## What's next

  * [› Introduction to External Initiators](/chainlink-nodes/external-initiators/external-initiators-introduction)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/v1/initiators.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

        },
          {
            ""bridge"": ""amberdata_cl_ea""
          },
          {
            ""bridge"": ""coinapi_cl_ea""
          }
        ],
        ""threshold"": 1,
        ""absoluteThreshold"": 0,
        ""precision"": 18,
        ""pollTimer"": {
          ""period"": ""1m0s""
        },
        ""idleTimer"": {
          ""duration"": ""24h0m0s""
        }
      }
    }

## RunAt

The `RunAt` initiator triggers a one off job run at the time specified.

### RunAt Parameters

`RunAt` takes one parameter, `time`. `time` accepts a ISO8601 string or a Unix
timestamp.

### Example


    ""initiators"": [
        {
            ""type"": ""runat"",
            ""params"": {
                ""time"": ""2019-09-20T12:20:00.000Z""
            }
        }
    ]

## RunLog

The `RunLog` initiator is the easiest initiator to use when integrating
Chainlink with on-chain contracts. It works similarly to EthLog, but adds some
helpful glue in to stitch together the off-chain job with the on-chain
contracts.

When a `RunLog` job is created, Chainlink begins watching the blockchain for
any log events that include that job’s ID. If any of the events that come back
match the log event signature of the Chainlink oracle contract, then the
Chainlink node parses the data out of that log and passes it into a new log
run.

A new run created by a `RunLog` is automatically given the parameters needed
for an `EthTx` task to report the run back to the contract that originally
created the event log.

### RunLog Parameters

`RunLog` initiators take an optional `address` parameter and `requesters`
parameter. The `address` parameter is a single Ethereum address and the
`requesters` parameter is an array of Ethereum addresses. By adding the
`address` parameter, you make the event filter of the RunLog initiator more
restrictive, only listening for events from that address, instead of any
address. By adding the `requesters` parameter, you only allow requests to come
from an address within the array.

### Example


    ""initiators"": [
        {
            ""type"": ""runlog"",
            ""params"": {
                ""address"": ""0xCAFE000000000000000000000000000000000001"",
                ""requesters"": [
                    ""0xCAFE000000000000000000000000000000000002"",
                    ""0xCAFE000000000000000000000000000000000003""
                ]
            }
        }
    ]

## Web

The `Web` initiator enables jobs",right,
What are Chainlink data feeds?,"Chainlink Price Feeds, often just called Chainlink data feeds, are decentralized oracle networks that provide smart contracts with access to high-quality, tamper-proof data.

These data feeds are primarily used to provide real-time price information for various cryptocurrencies, commodities, and other assets. They allow smart contracts to access the current market price of assets without having to interact with external APIs themselves, thus enhancing security, reliability, and transparency.

Here's how Chainlink data feeds work:

Multiple independent, Sybil-resistant oracle nodes fetch data from various high-quality data sources.

Each oracle node retrieves the data independently, which eliminates the risk of a single point of failure.

The individual data points are then aggregated into a single data point, which is written onto the blockchain.

This final, aggregated data point is the one that smart contracts interact with.

The data feeds use a decentralization approach at both the data source and oracle levels, ensuring the data is reliable and resistant to manipulation. This way, even if one data source or one oracle node reports incorrect data, the impact on the overall feed is minimal, ensuring the integrity of the data.

Chainlink data feeds are used widely across the decentralized finance (DeFi) space, powering various protocols, lending platforms, stablecoins, and more. As of my training cut-off in September 2021, Chainlink is one of the most prominent providers of decentralized oracle solutions.","
Chainlink Data Feeds are decentralized data sources that provide aggregated data from multiple sources. They are categorized into Highly Liquid and Well Represented, Monitored, Provisional, Custom, and Specialized Feeds. Each category has different levels of liquidity, stability, and risk associated with it.","Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right,
What is a Chainlink subscription account?,An account that holds LINK tokens and makes them available to fund requests to Chainlink VRF v2 coordinators.,"
A Chainlink subscription account is an address that creates and manages a balance of LINK tokens. The account owner can add approved consuming contracts or withdraw funds, and the subscription balance is the amount of LINK maintained on the account. The subscription reservation is the amount of LINK blocked on the account, and the effective balance is the amount of LINK available on the account. Consumer contracts are approved to use funding from the subscription account while making Chainlink Functions requests.","address that creates and manages a _Subscription account_. Any account can add LINK tokens to the subscription balance, but only the owner can add approved consuming contracts or withdraw funds.
  * Subscription balance: The amount of LINK maintained on your _Subscription account_. Requests from consumer contracts will continue to be funded until the balance runs out, so be sure to maintain sufficient funds in your _Subscription balance_ to pay for the requests and keep your applications running.
  * Subscription reservation: The amount of LINK blocked on the _Subscription balance_. It corresponds to the total LINK amount to be paid by in-flight requests.
  * Effective balance: The amount of LINK available on your _Subscription account_. `Effective balance = Subscription balance - Subscription reservation`.
  * Subscription consumers: Consumer contracts are approved to use funding from your _Subscription account_ while making _Chainlink Functions_ requests. The consumers receive response data in a callback.

## What's next

  * [› Architecture](/chainlink-functions/resources/architecture)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-functions/resources/concepts.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Managing Subscriptions

  * Overview
  * Before you begin
  * Subscriptions
  * Create a subscription
  * Create and fund a subscription
  * Get Subscription details
  * Fund a Subscription
  * Add a consumer contract to a Subscription
  * Remove a consumer contract from a Subscription
  * Transfer ownership of a Subscription
  * Cancel a Subscription

This guide explains how to manage Chainlink Functions subscriptions.
Currently, the best way to create and manage subscriptions is by using the
[Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-subscription-management-commands) commands.

## Before you begin

**[Complete the setup steps in the Getting Started guide](/chainlink-functions/getting-started):** The Getting Started Guide shows you how to set
up your environment with the necessary tools for creating and managing
subscriptions and completing the tutorials.

## Subscriptions

You can find Subscription Management commands, descriptions, and parameters in
the [Chainlink Functions Starter
Kit](https://github.com/smartcontractkit/functions-hardhat-starter-kit#functions-subscription-management-commands) reference documentation.

### Create a subscription

Run the `functions-sub-create` task to create a new subscription account:


    npx hardhat functions-sub-create --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-create --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Creating Functions billing subscription
    Waiting 2 blocks for transaction 0x018a04da4d1a3e8c14ceb8fbca786a897566a37c0b4cb9a9a36ca35a43806a3b to be confirmed...
    Subscription created with ID: 27
    
    Created subscription with ID: 27
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.0 LINK
    0 authorized consumer contracts:
    []

### Create and fund a subscription

Run the `functions-sub-create` task with the `amount` parameter to create a
new subscription account and fund it. The `amount` is in LINK.

Optionally, you can also add your consumer contract by including the
`--contract` flag with the address of your consumer contract. You can always
add more consumer contracts later.


    npx hardhat functions-sub-create --amount REPLACE_LINK_AMOUNT --network REPLACE_NETWORK

Example:


    $ npx hardhat functions-sub-create --amount 0.5 --network polygonMumbai
    secp256k1 unavailable, reverting to browser version
    Creating Functions billing subscription
    Waiting 1 blocks for transaction 0xc5990756f7728da53d8fdce3c715ef47b29094ad2a895435c1d871e2d2c5f725 to be confirmed...
    Subscription created with ID: 28
    Duplicate definition of Transfer (Transfer(address,address,uint256,bytes), Transfer(address,address,uint256))
    Funding with 0.5 LINK
    Waiting 2 blocks for transaction 0x822a0d667d8b4ba0849e486b65a7a7d495cb322528d15254dbc7a7a01b7e1458 to be confirmed...
    Subscription 28 funded with 0.5 LINK
    
    Created subscription with ID: 28
    Owner: 0x9d087fC03ae39b088326b67fA3C788236645b717
    Balance: 0.5 LINK
    0",right,
How can i request data from a public API in a smart contract using chainlink?,"Here are the general steps to request data from a public API using Chainlink within a smart contract:

Install Chainlink: First, you need to have Chainlink installed and properly configured. This would typically involve running a Chainlink Node or using nodes provided by others.

Create a Smart Contract: Write a smart contract in Solidity (the programming language for Ethereum smart contracts) that includes the Chainlink library and uses its functions to make a data request.

Request Data: Within the smart contract, make a request to Chainlink, specifying the public API you want to fetch data from and the Chainlink node that will fulfill the request. You would typically do this using Chainlink's buildChainlinkRequest function, and then sending it via the sendChainlinkRequestTo function.

Handle the Response: Write a callback function in your smart contract to receive and handle the data from the Chainlink oracle. This function is specified when you make the data request.

Fund Your Contract: Since Chainlink nodes require payment in LINK tokens for data requests, you'll need to transfer some LINK to your smart contract.","
To request data from a public API in a smart contract using Chainlink, you must import the ChainlinkClient contract, create a Chainlink.Request struct with the necessary parameters (Link token address, Oracle address, Job id, Request fee, Task parameters, Callback function signature), and set the Chainlink token and Oracle address. Additionally, you must ensure that the contract has enough LINK to pay for the request.","# Chainlink Any API Documentation

  * Overview
  * Requesting off-chain data
  * Building external adapters

Talk to an expert

[Contact us](https://chain.link/contact?ref_id=AnyAPI) to talk to an expert
about using Chainlink Any API to get your data on chain.

**Connecting to any API** with Chainlink enables your contracts to access to
_any_ external data source through our decentralized oracle network. We
understand making smart contracts compatible with off-chain data adds to the
complexity of building smart contracts. We created a framework with minimal
requirements, yet unbounded flexibility, so developers can focus more on the
functionality of smart contracts rather than what feeds them. Chainlink’s
decentralized oracle network provides smart contracts with the ability to push
and pull data, facilitating the interoperability between on-chain and off-
chain applications.

Whether your contract requires sports results, the latest weather, or any
other publicly available data, the [Chainlink contract
library](https://github.com/smartcontractkit/chainlink/tree/master/contracts)
provides the tools required for your contract to consume it.

Prerequisites

You should be familiar with the [Chainlink Basic Request Model](/architecture-overview/architecture-request-model/). If you are new to developing smart
contracts on Ethereum, see the [Getting Started](/getting-started/conceptual-overview/) guide to learn the basics.

Note on Price Feed Data

If your smart contracts need access to price feed data, try using [Chainlink
Data Feeds](/data-feeds).

### Requesting off-chain data

Outlined below are multiple ways developers can connect smart contracts to
off-chain data feeds. Click a request type to learn more about it:

| Request Type                       | Description                                                                                                                                                                                                                                                |
|:-----------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| HTTP GET Single Word Response      | This guide explains how to make an HTTP GET request and parse the json response to retrieve the value of one single attribute.                                                                                                                             |
| HTTP GET Multi-Variable Responses  | This guide explains how to make an HTTP GET request and parse the json response to retrieve the values of multiple attributes.                                                                          

:::NEXT DOC:::

your contract must import
[ChainlinkClient](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol).
This contract exposes a struct called `Chainlink.Request`, which your contract
should use to build the API request. The request should include the following
parameters:

  * Link token address
  * Oracle address
  * Job id
  * Request fee
  * Task parameters
  * Callback function signature

Note on Funding Contracts

Making a GET request will fail unless your deployed contract has enough LINK
to pay for it. **Learn how to[Acquire testnet LINK](/resources/acquire-link)
and [Fund your contract](/resources/fund-your-contract)**.

Assume that a user wants to call the API above and retrieve only the 24h ETH
trading volume from the response.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/ChainlinkClient.sol"";
    import ""@chainlink/contracts/src/v0.8/ConfirmedOwner.sol"";
    
    /**
     * Request testnet LINK and ETH here: https://faucets.chain.link/
     * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/
     */
    
    /**
     * THIS IS AN EXAMPLE CONTRACT WHICH USES HARDCODED VALUES FOR CLARITY.
     * THIS EXAMPLE USES UN-AUDITED CODE.
     * DO NOT USE THIS CODE IN PRODUCTION.
     */
    
    contract APIConsumer is ChainlinkClient, ConfirmedOwner {
        using Chainlink for Chainlink.Request;
    
        uint256 public volume;
        bytes32 private jobId;
        uint256 private fee;
    
        event RequestVolume(bytes32 indexed requestId, uint256 volume);
    
        /**
         * @notice Initialize the link token and target oracle
         *
         * Sepolia Testnet details:
         * Link Token: 0x779877A7B0D9E8603169DdbD7836e478b4624789
         * Oracle: 0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD (Chainlink DevRel)
         * jobId: ca98366cc7314957b8c012c72f05aeeb
         *
         */
        constructor() ConfirmedOwner(msg.sender) {
            setChainlinkToken(0x779877A7B0D9E8603169DdbD7836e478b4624789);
            setChainlinkOracle(0x6090149792dAAeE9D1D568c9f9a6F6B46AA29eFD);
            jobId = ""ca98366cc7314957b8c012c72f05aeeb"";
            fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
        }
    
        /**
      ",right,
What is an adapter in chainlink?,"Core adapters are the built-in functionality that every Chainlink node supports. Strung together, they act as tasks that need to be performed to complete a Job.

Adapters that are prefixed with ""Eth"" refer to tasks that post data onto the chain.","
An adapter in Chainlink is a service that enables the core of the Chainlink node to communicate with external APIs via a simple JSON specification. Adapters are used to integrate custom computations and specialized APIs into the Chainlink node.","# External Adapters Introduction

  * Overview

External adapters are how Chainlink enables easy integration of custom
computations and specialized APIs. External adapters are services which the
core of the Chainlink node communicates via its API with a simple JSON
specification. If you want a step by step, be sure to check out our [blog
post](https://blog.chain.link/build-and-use-external-adapters/).

Information on external adapters is broken up into three main categories:
contract creators, developers, and node operators.

  * [Contract Creators](/chainlink-nodes/external-adapters/contract-creators) will need to know how to specify an external adapter in their request for external data.
  * [Developers](/chainlink-nodes/external-adapters/developers) will need to know how to implement an external adapter for an API.
  * [Node Operators](/chainlink-nodes/external-adapters/node-operators) will need to know how to add an external adapter to their node so that they can provide specialized services to smart contracts.

## What's next

  * [› External Adapters in Solidity](/chainlink-nodes/external-adapters/contract-creators)
  * [› Building External Adapters](/chainlink-nodes/external-adapters/developers)
  * [› Bridges: Adding External Adapters to Nodes](/chainlink-nodes/external-adapters/node-operators)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/external-adapters/external-adapters.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

Blockchain Integration With Chainlink External Adapters                   | Identification       | Advanced     |
| How to Connect a Tesla Vehicle API to a Smart Contract Via a Chainlink External Adapter | Transportation       | Advanced     |
| OAuth and API Authentication in Smart Contracts                                         | Security             | Advanced     |
| Connect APIs to your Smart Contracts using Chainlink                                    | NFT                  | Advanced     |
#### Automation (Keepers)

| Name                                                                       | Type       | Difficulty   |
|:---------------------------------------------------------------------------|:-----------|:-------------|
| Automation Introduction Video                                              | Automation | Beginner     |
| Smart Contract Automation Master Class Module #1                           | Automation | Beginner     |
| Smart Contract Automation Master Class Module #2                           | Automation | Beginner     |
| Smart Contract Automation Master Class Module #3                           | Automation | Beginner     |
| Smart Contract Automation Master Class Module #4                           | Automation | Beginner     |
| Entropyfi Saves Engineering Hours with Chainlink Keepers                   | Gaming     | Medium       |
| Enabling Limit Orders on CivTrade With Chainlink Keepers                   | Trading    | Medium       |
| Pickle Finance UniV3 Jars Powered by Chainlink Keepers                     | Finance    | Medium       |
| JamonSwap Introduces New Limit Order Functionality Using Chainlink Keepers | DeFi       | Medium       |
| How Cratos used Chainlink Keepers to automate the token vesting process    | DeFi       | Medium       |
| Enabling automated NFT lotteries with Chainlink Keepers and VRF            | NFT        | Medium       |
| How ApeSwap Integrated Chainlink Keepers for BANANA Maximizer Vaults       | DeFi       | Medium       |
### Game resources

  * [CryptoZombies](https://cryptozombies.io/)
  * [DamnVulnerableDefi](https://damnvulnerabledefi.xyz/challenges/8.html)
  * [Ethernaut](https://ethernaut.openzeppelin.com/)

### Coding bootcamps

  *",right,
What is a task in chainlink?,"In the Chainlink ecosystem, a ""task"" refers to a specific action or a series of actions that a Chainlink node performs as part of a job.

A job in Chainlink is defined by a Job Specification, which is a list of tasks that the Chainlink node is to perform. These tasks can range from fetching data from an API endpoint, parsing JSON data, performing computations, or even making a transaction on the blockchain.

For example, a Job Specification could have the following tasks:

HttpGet: Fetch data from a specific URL.
JsonParse: Parse the returned JSON data.
Multiply: Multiply the parsed number to account for decimal places.
EthUint256: Convert the resulting number to a format that's suitable for Ethereum.
EthTx: Send the resulting data to a specific function in a smart contract on the Ethereum network.
Each task is performed in the order specified in the Job Specification, and the output of one task is passed as the input to the next task in the list.

Chainlink nodes are compensated in LINK tokens for the computational resources used to perform these tasks. This incentivizes Chainlink nodes to reliably execute jobs and provide accurate data to smart contracts.","
A task in Chainlink is a replacement for core adapters that is more flexible. Tasks can be composed in arbitrary order into pipelines and consist of one or more threads of execution where tasks are executed in a well-defined order. Tasks share a few common attributes, such as an index and a timeout. They are expressed in DOT syntax and each node in the graph is a task with a user-specified ID and a set of configuration parameters and attributes.","# Tasks

  * Overview
  * What is a Task?
  * Shared attributes
  * Writing pipelines

## What is a Task?

Tasks

Tasks replace the [core adapters](/chainlink-nodes/oracle-jobs/v1/adapters)
from v1 jobs.

Tasks are a replacement for core adapters that is more flexible. Tasks can be
composed in arbitrary order into pipelines. Pipelines consist of one or more
threads of execution where tasks are executed in a well-defined order.

You can use Chainlink's [built-in tasks](/chainlink-nodes/oracle-jobs/all-tasks), or you can create your own [external adapters](/chainlink-nodes/external-adapters/external-adapters) for tasks which are accessed
through a `bridge`.

## Shared attributes

All tasks share a few common attributes:

`index`: when a task has more than one input (or the pipeline overall needs to
support more than one final output), and the ordering of the values matters,
the index parameter can be used to specify that ordering.


    data_1 [type=""http"" method=GET url=""https://chain.link/eth_usd""       index=0]
    data_2 [type=""http"" method=GET url=""https://chain.link/eth_dominance"" index=1]
    multiword_abi_encode [type=""eth_abi_encode"" method=""fulfill(uint256,uint256)""]
    
    data_1 -> multiword_abi_encode
    data_2 -> multiword_abi_encode

`timeout`: The maximum duration that the task is allowed to run before it is
considered to be errored. Overrides the `maxTaskDuration` value in the job
spec.

## Writing pipelines

Pipelines are composed of tasks arranged in a DAG (directed acyclic graph).
Pipelines are expressed in [DOT
syntax](https://en.wikipedia.org/wiki/DOT_%28graph_description_language%29#Directed_graphs).

Each node in the graph is a task with a user-specified ID and a set of
configuration parameters and attributes:


    my_fetch_task [type=""http"" method=GET url=""https://chain.link/eth_usd""]

The edges between tasks define how data flows from one task to the next. Some
tasks can have multiple inputs, such as `median`. Other tasks are limited to 0
(`http`) or 1 (`jsonparse`).


    data_source_1  [type=""http"" method=GET url=""https://chain.link/eth_usd""]
    data_source_2  [type=""http"" method=GET url=""https://coingecko.com/eth_usd""]
    medianize_data [type=""median""]
    submit_to_ea   [type=""bridge"" name=""my_bridge""]
    
    data_source_1 -> medianize_data
    data_source_2 -> medianize_data
    medianize_data -> submit_to_ea



  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes/oracle-jobs/tasks.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# API Calls: Using Any API

  * Overview
  * How does the request and receive cycle work for API calls?
  * What are jobs?
  * What are tasks?
  * Tasks
  * Contract example
  * External adapters
  * Further reading

Requirements

This guide requires basic knowledge about smart contracts. If you are new to
smart contract development, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds) and [Random Numbers](/getting-started/intermediates-tutorial) guides before you begin.

In this guide, you will learn how to request data from a public API in a smart
contract. This includes understanding what Tasks and External adapters are and
how Oracle Jobs use them. You will also learn how to find the Oracle Jobs and
Tasks for your contract and how to request data from an Oracle Job.

## How does the request and receive cycle work for API calls?

The request and receive cycle describes how a smart contract requests data
from an oracle and receives the response in a separate transaction. If you
need a refresher, check out the [Basic Request Model](/architecture-overview/architecture-request-model).

For contracts that use [Chainlink VRF](/vrf/v2/introduction), you request
randomness from a VRF oracle and then await the response. The fulfillment
function is already given to us from the `VRFConsumerBase` contract, so
oracles already know where to send the response to. However, with API calls,
the contract itself _defines_ which function it wants to receive the response
to.

Before creating any code, you should understand how Oracle jobs can get data
on-chain.

## What are jobs?

Chainlink nodes require [**Jobs**](/chainlink-nodes/oracle-jobs/jobs) to do
anything useful. In the case of a Request and Receive job, the [Direct
Request](/chainlink-nodes/oracle-jobs/all-jobs#direct-request-jobs) job
monitors the blockchain for a request from a smart contract. Once it catches a
request, it runs the tasks (both core and external adapters) that the job is
configured to run and eventually returns the response to the requesting
contract.

## What are tasks?

Each oracle job has a configured set of tasks it must complete when it is run.
These tasks are split into two subcategories:

  * [**Tasks**](/chainlink-nodes/oracle-jobs/all-tasks) \- These are tasks that come built-in to each node. (examples: http, ethabidecode, etc).
  * [**External Adapters**](/chainlink-nodes/external-adapters/external-adapters) \- These are custom adapters built by node operators and community members, which perform specific tasks like calling a particular endpoint with a specific set of parameters (like authentication secrets that shouldn't be publicly visible).

### Tasks

If a job needs to make a GET request to an API, find a specific unsigned
integer field in a JSON response, then submit that back to the requesting
contract, it would need a job containing the following Tasks:

  * [HTTP](/chainlink-nodes/oracle-jobs/all-tasks/#http-task) calls the API. the `method` must be set to _GET_.
  * [JSON Parse](/chainlink-nodes/oracle-jobs/all-tasks/#json-parse-task) parses the JSON and extracts a value at a given keypath.
  * [Multiply](/chainlink-nodes/oracle-jobs/all-tasks/#multiply-task) multiplies the input by a multiplier. Used to remove the decimals.
  * [ETH ABI Encode](/chainlink-nodes/oracle-jobs/all-tasks/#eth-abi-encode-task) converts the data to a bytes payload according to ETH ABI encoding.
  * [ETH",right,
What is The request and receive cycle in chainlink?,"The request and receive cycle in Chainlink describes the process of how a smart contract requests data from an off-chain source and receives the result. This cycle is facilitated by Chainlink nodes and involves several steps:

Request: A smart contract makes a data request to a Chainlink node. This request is typically encoded in a function call and includes the specific data being requested, and a callback function in the smart contract to receive the data. The contract also sends LINK tokens to the Chainlink node to pay for the data request.

Chainlink Node Receives the Request: The Chainlink node listens for these requests. When it detects one, it initiates the process to fulfill it.

Data Retrieval: The Chainlink node retrieves the requested data from the specified off-chain source. This could be a web API, a different blockchain, a database, or any other data source.

Aggregation (optional): If multiple Chainlink nodes are used to retrieve the same data (to increase data reliability), an aggregation contract might be used to calculate the final result from multiple responses. This could be a simple average, a weighted average, or any other method of combining the data.

Response: The Chainlink node (or aggregation contract) sends the data back to the smart contract. This is done by calling the callback function specified in the original request. The data is now available for the smart contract to use in its logic.

This cycle allows smart contracts to interact with the outside world in a decentralized and trustless manner, greatly expanding their potential use-cases. By using Chainlink, a smart contract can incorporate real-world data into its logic, make decisions based on this data, and even interact with systems outside of the blockchain.","
The request and receive cycle in Chainlink is the process by which a smart contract requests data from an oracle and receives the response in a separate transaction. This cycle begins with the smart contract creating a request with the oracle address, job ID, and callback function. The request is then sent to the oracle contract through the LINK token's `transferAndCall` function. The oracle contract then emits an `OracleRequest` event, which is monitored by the off-chain oracle node. The node then performs the job, retrieves the data, and sends it back to the oracle contract using the `fulfillOracleRequest` function. Finally, the oracle contract returns the result to the smart contract using the callback function defined in the original request.","# API Calls: Using Any API

  * Overview
  * How does the request and receive cycle work for API calls?
  * What are jobs?
  * What are tasks?
  * Tasks
  * Contract example
  * External adapters
  * Further reading

Requirements

This guide requires basic knowledge about smart contracts. If you are new to
smart contract development, read the [Consuming Data Feeds](/getting-started/consuming-data-feeds) and [Random Numbers](/getting-started/intermediates-tutorial) guides before you begin.

In this guide, you will learn how to request data from a public API in a smart
contract. This includes understanding what Tasks and External adapters are and
how Oracle Jobs use them. You will also learn how to find the Oracle Jobs and
Tasks for your contract and how to request data from an Oracle Job.

## How does the request and receive cycle work for API calls?

The request and receive cycle describes how a smart contract requests data
from an oracle and receives the response in a separate transaction. If you
need a refresher, check out the [Basic Request Model](/architecture-overview/architecture-request-model).

For contracts that use [Chainlink VRF](/vrf/v2/introduction), you request
randomness from a VRF oracle and then await the response. The fulfillment
function is already given to us from the `VRFConsumerBase` contract, so
oracles already know where to send the response to. However, with API calls,
the contract itself _defines_ which function it wants to receive the response
to.

Before creating any code, you should understand how Oracle jobs can get data
on-chain.

## What are jobs?

Chainlink nodes require [**Jobs**](/chainlink-nodes/oracle-jobs/jobs) to do
anything useful. In the case of a Request and Receive job, the [Direct
Request](/chainlink-nodes/oracle-jobs/all-jobs#direct-request-jobs) job
monitors the blockchain for a request from a smart contract. Once it catches a
request, it runs the tasks (both core and external adapters) that the job is
configured to run and eventually returns the response to the requesting
contract.

## What are tasks?

Each oracle job has a configured set of tasks it must complete when it is run.
These tasks are split into two subcategories:

  * [**Tasks**](/chainlink-nodes/oracle-jobs/all-tasks) \- These are tasks that come built-in to each node. (examples: http, ethabidecode, etc).
  * [**External Adapters**](/chainlink-nodes/external-adapters/external-adapters) \- These are custom adapters built by node operators and community members, which perform specific tasks like calling a particular endpoint with a specific set of parameters (like authentication secrets that shouldn't be publicly visible).

### Tasks

If a job needs to make a GET request to an API, find a specific unsigned
integer field in a JSON response, then submit that back to the requesting
contract, it would need a job containing the following Tasks:

  * [HTTP](/chainlink-nodes/oracle-jobs/all-tasks/#http-task) calls the API. the `method` must be set to _GET_.
  * [JSON Parse](/chainlink-nodes/oracle-jobs/all-tasks/#json-parse-task) parses the JSON and extracts a value at a given keypath.
  * [Multiply](/chainlink-nodes/oracle-jobs/all-tasks/#multiply-task) multiplies the input by a multiplier. Used to remove the decimals.
  * [ETH ABI Encode](/chainlink-nodes/oracle-jobs/all-tasks/#eth-abi-encode-task) converts the data to a bytes payload according to ETH ABI encoding.
  * [ETH

:::NEXT DOC:::

# Basic Request Model

  * Overview
  * Contracts Overview
  * ChainlinkClient
  * LINK Token
  * Oracle Contract
  * Off-Chain Oracle Node
  * Consumer UML

## Contracts Overview

All source code is open source and available in the [Chainlink Github
repository](https://github.com/smartcontractkit/chainlink).

### ChainlinkClient

[`ChainlinkClient`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/ChainlinkClient.sol)
is a parent contract that enables smart contracts to consume data from
oracles. It's available in the Chainlink smart contract library which can be
[installed using the latest package managers](/resources/create-a-chainlinked-project).

The client constructs and makes a request to a known Chainlink oracle through
the `transferAndCall` function, implemented by the LINK token. This request
contains encoded information that is required for the cycle to succeed. In the
`ChainlinkClient` contract, this call is initiated with a call to
`sendChainlinkRequestTo`.

To build your own client contract using `ChainlinkClient`, see [Introduction
to Using Any API](/any-api/introduction), or view the [ChainlinkClient API
Reference](/any-api/api-reference) for the `ChainlinkClient` contract.

### LINK Token

LINK is an [ERC-677](https://github.com/ethereum/EIPs/issues/677) compliant
token which implements `transferAndCall`, a function that allows tokens to be
transferred whilst also triggering logic in the receiving contract within a
single transaction.

Learn more about [ERC-677 and the LINK token](/resources/link-token-contracts).

### Oracle Contract

[`Oracle`
contracts](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/Oracle.sol)
are owned by oracle node operators, which run alongside off-chain oracle
nodes.

#### Request

The client contract that initiates this cycle must create a request with the
following items:

  * The oracle address.
  * The job ID, so the oracle knows which tasks to perform.
  * The callback function, which the oracle sends the response to.

To learn about how to find oracles to suit your needs, see [Find Existing
Jobs](/any-api/find-oracle).

Oracle contracts are responsible for handling on-chain requests made through
the LINK token, by implementing `onTokenTransfer` as a
[`LinkTokenReceiver`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.6/LinkTokenReceiver.sol).
Upon execution of this function, the oracle contract **emits an`OracleRequest`
event** containing information about the request. This event is crucial, as it
is monitored by the off-chain oracle node which acts upon it.

#### Fulfillment

For fulfillment, the oracle contract has a `fulfillOracleRequest` function
which is used by the node to fulfill a request once it has the result of the
job. This function returns the result to the `ChainlinkClient` using the
callback function defined in the original request.

### Off-Chain Oracle Node

The off-chain oracle node is responsible for listening for events emitted by
its corresponding on-chain smart contract. Once it detects an `OracleRequest`
event, it uses the data emitted to perform a job.

The most common job type for a Node is to make a GET request to an API,
retrieve some data from it, parse the response, convert the result into
blockchain compatible data, then submit it in a transaction back to the oracle
contract, using the `fulfillOracleRequest` function.

For more information on how to become a node operator, learn how to [run a
Chainlink node](/chainlink-nodes/v1/running-a-chainlink-node).

## Consumer",right,
What are jobs in Chainlink?,"In the Chainlink ecosystem, a ""job"" refers to a specific series of tasks that a Chainlink node is assigned to perform. Each job is defined by a Job Specification, which is written in JSON format and details the specific tasks a node should complete.

Chainlink jobs are generally used to fetch data from an off-chain API, perform certain operations on the data, and then deliver the data to a smart contract on the blockchain.

A typical Chainlink job might look something like this:

HTTP GET: This task instructs the Chainlink node to make a GET request to a specific API endpoint.

JSON Parse: After the HTTP GET task, the Chainlink node will have a JSON response from the API. This task instructs the node to parse the JSON and extract a specific piece of data.

Multiply: Often, the data received needs to be multiplied to convert it into a format suitable for the blockchain (since blockchains cannot handle decimal numbers).

ETHUint256: This task is used to convert the multiplied number to an Ethereum-compatible data type.

ETH TX: This task instructs the Chainlink node to send the final data to a smart contract on the Ethereum blockchain.

Each task in the job is performed in the specified order, and the output of one task is passed as the input to the next task in the chain.

Chainlink nodes are rewarded in LINK tokens for executing jobs. This provides an incentive for node operators to reliably fulfill data requests, and contributes to the decentralized and trustless nature of the Chainlink network.","
Jobs in Chainlink are tasks that are requested by developers to be completed by Chainlink nodes. These tasks can include deploying Oracle contracts, making job requests to nodes, adding external adapters to nodes, and bringing high-quality data and premium web APIs to contract developers.","exclusive access to Chainlink events, and opportunities to level up
your technical and soft skills. You can apply to become a developer expert on
the [Chainlink Developer Experts page](https://chain.link/developers/experts).

## Joining the Chainlink Community Advocate program

The [Chainlink Community Advocate Program](https://blog.chain.link/expanding-the-chainlink-community-advocate-program/) is a program designed to help
accelerate the awareness and adoption of Chainlink. Chainlink community
advocates are passionate members of the Chainlink community that help to
achieve this by running virtual and in-person meetups, connecting with
partners and sponsors, creating content, and working directly with the teams
that are making Chainlink-powered smart contracts. Many Advocates have gone on
to have rewarding careers in the blockchain industry, and some of them work on
Chainlink specifically.

To become a community advocate, you can apply via the [community advocates web
page](https://chain.link/community/advocates).

## Running a Chainlink Focused Developer Bootcamp

In June 2021, Chainlink [virtually hosted](https://blog.chain.link/smart-contract-developer-bootcamp-on-demand/) the first [Chainlink Developer
Bootcamp](http://chain.link/bootcamp). If you're passionate about educating
others about smart contracts and Chainlink, you can contribute by running your
own developer Bootcamp. You can also contribute by translating an existing
Bootcamp and running it in another language. Before you run your own Bootcamp,
[reach out to the team](mailto:devrel@smartcontract.com) so we can make sure
you have the support that you need.

## Running an In-Person Meetup or Watch Party

If you're passionate about helping to grow the awareness and adoption of
Chainlink, you can contribute by running an in-person meetup or watch party
for a Chainlink event such as [SmartCon](https://www.smartcontractsummit.io/).
Meetups are a great way to meet others also passionate about how hybrid smart
contracts can create an economically fair world.

If you're interested in running an in-person meetup or watch party, [reach out
to the team](mailto:community@smartcontract.com) so we can make sure you have
the support that you need.

## Participate in a Hackathon

Chainlink runs hackathons multiple times per year and often sponsors other
hackathons across the blockchain ecosystem. Participating in a hackathon that
Chainlink is a part of is a great way to learn how to use Chainlink. It is
also a great way to showcase your skills to the Chainlink team and the wider
community. Hackathons are a popular place for recruiting talent into the
blockchain ecosystem.

To stay up to date on the hackathons that Chainlink is running or sponsoring,
keep an eye out on the official Chainlink social media channels, and sign up
for our [developer newsletter](/resources/developer-communications).

## Applying for a Grant

The [Chainlink grant program](https://chain.link/community/grants) encourages
the community to create critical developer tooling, add high-quality data, and
the launch key services around the Chainlink Network. Grant categories include
community, integration, bug bounty, research, and social impact grants. If you
have a great idea that fits into one of these categories, you can apply for a
grant. If successful, you will receive the funding and support needed to
successfully build and implement your idea.

For more information about the grant program, go to the [Chainlink Grants web
page](https://chain.link/community/grants).

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/contributing-to-chainlink.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Chainlink Nodes

  * Overview

Operating a Chainlink node allows you to be part of the Chainlink Network,
helping developers build hybrid smart contracts, giving them access to real-
world data and services.

Learn more about Chainlink nodes with our step-by-step tutorials and
documentation:

### Set Up a Chainlink Node



Install and Run your own node on a local machine or remote server.



### Fulfill Your First Job Request



Deploy an Oracle contract and make job requests to your node.



### Add External Adapters to Your Node



Bring high-quality data and premium web APIs to contract developers.



## New to Chainlink and Smart Contracts?

Learn the basics in the Getting Started Guide. Build your first smart contract
on Ethereum.

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/chainlink-nodes.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right,
How can i Acquire testnet LINK from Chainlink?,"you can acquire testnet LINK tokens for Chainlink development from faucets specific to each testnet. Here are the general steps:

Setup a Wallet: If you don't have one already, set up a Metamask or other Ethereum-compatible wallet. Make sure it's configured to connect to the appropriate Ethereum testnet (like Kovan, Rinkeby, or Ropsten).

Get Testnet Ether: You'll need testnet Ether (ETH) to pay for gas costs on the testnet. You can get this from various faucets like the Kovan faucet, Rinkeby faucet, or Ropsten faucet. You typically just need to enter your wallet address and request the testnet ETH.

Get Testnet LINK: Once you have some testnet ETH, visit a Chainlink faucet to receive testnet LINK. For example, for the Kovan testnet, you might use the Chainlink Kovan faucet. Enter your wallet address, and you'll receive testnet LINK.","
To acquire testnet LINK from Chainlink, you can use the faucets available at https://faucets.chain.link/. You can also configure your MetaMask wallet to use LINK tokens and get testnet LINK from a faucet. To do this, open up MetaMask, click ""Import tokens"" at the bottom of the MetaMask window, paste the LINK token contract address for the network you want to use, click ""Next"", click ""Import Tokens"", and then go to https://faucets.chain.link/, select the network where you want to receive testnet LINK, click ""Connect wallet"" so the faucet app can detect the network and wallet address, and then complete the Captcha and click ""Send request"" to receive the funds.","# Acquire testnet LINK

  * Overview
  * Configure MetaMask to use LINK tokens
  * Get testnet LINK from a faucet

The Getting Started guides show you how to send ETH on the Sepolia testnet,
but some contracts might require you to use LINK token instead. This page
shows you how to obtain testnet LINK and send it to your MetaMask wallet.

## Configure MetaMask to use LINK tokens

To see your LINK token balance in MetaMask, you must manually add the token.

  1. Open up MetaMask.

  2. At the bottom of the MetaMask windows, click **Import tokens**.

  3. Find the LINK token contract address for the network that you want to use. On Sepolia, the LINK token address is: `0x779877A7B0D9E8603169DdbD7836e478b4624789`. See the [LINK Token Contracts](/resources/link-token-contracts) page to find the addresses for different testnets.

  4. Paste the token contract address into MetaMask in the Token Address input. The token symbol and decimals of precision will auto-populate.

  5. Click **Next**. A new window will appear, showing the LINK token details.

  6. Click **Import Tokens** to confirm adding the new token.

MetaMask should now display the new LINK token balance.

## Get testnet LINK from a faucet

  1. Go to <https://faucets.chain.link/>.
  2. In Metamask, select the network where you want to receive testnet LINK.
  3. Click **Connect wallet** so the faucet app can detect the network and wallet address.
  4. If you want to receive testnet funds at a different address, paste it in the **Wallet address** section. This field defaults to your connected wallet address.
  5. In the **Request type** section, select the testnet funds that you want to receive.
  6. Complete the Captcha and click **Send request**. The funds are transferred from the faucet to the wallet address that you specified.

After the transaction is confirmed on-chain, the faucet app shows ""Request
complete"" and the transaction hash of your request.



## What's next

  * [› Deploy your first contract](/getting-started/deploy-your-first-contract)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/resources/acquire-link.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

testnet ETH and LINK from
Ethereum Goerli to Optimistim Goerli. Select Optimism Goerli in your wallet to
access the Optimism Goerli bridge. Testnet LINK is available at
[faucets.chain.link](https://faucets.chain.link/goerli). Testnet ETH is
available at [goerlifaucet.com](https://goerlifaucet.com/) or the faucets
listed at [faucetlink.to/goerli](https://faucetlink.to/goerli).

| Parameter    | Value                                      |
|:-------------|:-------------------------------------------|
| ETH_CHAIN_ID | 420                                        |
| Address      | 0xdc2CC710e42857672E7907CF474a69B63B93089f |
| Name         | Chainlink Token on Optimism Goerli         |
| Symbol       | LINK                                       |
| Decimals     | 18                                         |
## Harmony

### Harmony mainnet

ONE is used to pay for transactions on Harmony mainnet. You can use the
[Harmony Bridge](https://bridge.harmony.one/) to transfer ONE and LINK token
from Ethereum Mainnet to Harmony mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1666600000                                 |
| Address        | 0x218532a12a389a4a92fC0C5Fb22901D1c19198aA |
| Name           | Chainlink Token on Harmony Mainnet         |
| Symbol         | LINK                                       |
| Decimals       | 18                                         |
| Network status | status.harmony.one                         |
## Moonriver

### Moonriver mainnet

MOVR is used to pay transaction fees on Moonriver mainnet. You can use
[bridge.multichain.org](https://bridge.multichain.org/#/router) to transfer
LINK to Moonriver mainnet.

| Parameter      | Value                                      |
|:---------------|:-------------------------------------------|
| ETH_CHAIN_ID   | 1285                                       |
| Address        |",right,
What is the decentralized data model in Chainlink?,"The decentralized data model in Chainlink refers to its approach of using multiple independent nodes to provide data to smart contracts. This is in contrast to a centralized model, where a single entity or server provides the data.

In Chainlink's decentralized model, multiple independent, Sybil-resistant oracle nodes fetch data from various high-quality data sources. This approach has several advantages:

Reliability: Because multiple nodes are retrieving and reporting data, the system isn't reliant on a single point of failure. If one node goes down or reports incorrect data, the other nodes can still provide the correct data.

Security: The data provided by the nodes is more secure because it's much harder for a bad actor to manipulate. They would have to take control of or manipulate a majority of the nodes, which is significantly more difficult than attacking a single, centralized source.

Accuracy: Multiple nodes retrieving data from multiple sources allows for more accurate and reliable data. The data from all the nodes can be aggregated to provide a single, more accurate data point.

Chainlink's decentralized data model is a key feature that makes it attractive for DeFi and other decentralized applications. It allows smart contracts to interact with real-world data in a secure and reliable manner, without compromising the decentralized principles of blockchain technology.","
The decentralized data model in Chainlink is a system that aggregates data from multiple, independent Chainlink oracle operators. The data is validated and aggregated by a smart contract, which forms the feed's latest and trusted answer. The data feed is updated by a decentralized oracle network, and each oracle operator is rewarded for publishing data. The data feed is built and funded by the community of users who rely on accurate, up-to-date data in their smart contracts.","# Data Feeds Architecture

  * Overview
  * Basic Request Model
  * Decentralized Data Model
  * Off-Chain Reporting

## Basic Request Model

Chainlink connects smart contracts with external data using its decentralized
oracle network. Chainlink API requests are handled 1:1 by an oracle.

The [Basic Request Model](/architecture-overview/architecture-request-model)
describes the on-chain architecture of requesting data from a single oracle
source.

To learn how to make a GET request using a single oracle, see [Make a GET
Request](/any-api/get-request/introduction).

## Decentralized Data Model

For a more robust and trustworthy answer, you can aggregate data from many
oracles. With on-chain aggregation, data is aggregated from a decentralized
network of independent oracle nodes. This architecture is applied to Chainlink
Data Feeds, which can aggregate data such as asset price data.

The [Decentralized Data Model](/architecture-overview/architecture-decentralized-model) describes how data is aggregated, and how consumer
contracts can retrieve this data.

## Off-Chain Reporting

Off-Chain Reporting (OCR) is an improvement on the decentralization and
scalability of Chainlink networks. With our Off-Chain Reporting aggregators,
all nodes communicate using a peer to peer network. During the communication
process, a lightweight consensus algorithm runs where each node reports its
price observation and signs it. A single aggregate transaction is then
transmitted, which saves a significant amount of gas.

To learn more about OCR and how it works, see the [Off-Chain
Reporting](/architecture-overview/off-chain-reporting) page.

## What's next

  * [› Basic Request Model](/architecture-overview/architecture-request-model/)
  * [› Decentralized Data Model](/architecture-overview/architecture-decentralized-model/)
  * [› Off-Chain Reporting](/architecture-overview/off-chain-reporting/)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/architecture-overview/architecture-overview.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)



:::NEXT DOC:::

# Decentralized Data Model

  * Overview
  * Data Aggregation
  * Shared Data Resource
  * Decentralized Oracle Network
  * Components of a Decentralized Oracle Network
  * Consumer
  * Proxy
  * Aggregator

This page describes how data aggregation is applied to produce Chainlink Data
Feeds and provides more insight as to how Data Feeds are updated.

## Data Aggregation

Each data feed is updated by multiple, independent Chainlink oracle operators.
The
[AccessControlledOffchainAggregator](https://github.com/smartcontractkit/libocr/blob/master/contract/AccessControlledOffchainAggregator.sol)
aggregates the data on-chain.

Off-Chain Reporting (OCR) further enhances the aggregation process. To learn
more about OCR and how it works, see the [Off-Chain Reporting](/architecture-overview/off-chain-reporting) page.

## Shared Data Resource

Each data feed is built and funded by the community of users who rely on
accurate, up-to-date data in their smart contracts. As more users rely on and
contribute to a data feed, the quality of the data feed improves. For this
reason, each data feed has its own properties depending on the needs of its
community of users.

## Decentralized Oracle Network

Each data feed is updated by a decentralized oracle network. Each oracle
operator is rewarded for publishing data. The number of oracles contributing
to each feed varies. In order for an update to take place, the data feed
aggregator contract must receive responses from a minimum number of oracles or
the latest answer will not be updated. You can see the minimum number of
oracles for the corresponding feed at
[data.chain.link](https://data.chain.link).

Each oracle in the set publishes data during an aggregation round. That data
is validated and aggregated by a smart contract, which forms the feed's latest
and trusted answer.

## Components of a Decentralized Oracle Network

Data Feeds are an example of a decentralized oracle network, and include the
following components:

  * A consumer contract
  * A proxy contract
  * An aggregator contract

To learn how to create a consumer contract that uses an existing data feed,
read the [Using Data Feeds](/data-feeds/price-feeds) documentation.

### Consumer

A Consumer contract is any contract that uses Chainlink Data Feeds to consume
aggregated data. Consumer contracts must reference the correct
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)
contract and call one of the exposed functions.


    ...
    AggregatorV3Interface feed = AggregatorV3Interface(address);
    return feed.latestRoundData();

Off-chain applications can also consume data feeds. See the Javascript and
Python example code on the [Using Data Feeds](/data-feeds/price-feeds) page to
learn more.

### Proxy

Proxy contracts are on-chain proxies that point to the aggregator for a
particular data feed. Using proxies enables the underlying aggregator to be
upgraded without any service interruption to consuming contracts.

Proxy contracts can vary from one data feed to another, but the
[`AggregatorProxy.sol`
contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol)
on Github is a common example.

### Aggregator

An aggregator is the contract that receives periodic data updates from the
oracle network. Aggregators store aggregated data on-chain so that consumers
can retrieve it and act upon it within the same transaction.

You can access this data using the Data Feed address and",right,
What data types are available for Rate and Volatility Feeds on Chainlink?,"The following data types are available:

Bitcoin Interest Rate Curve
ETH Staking APR
Realized Volatility","
The data types available for Rate and Volatility Feeds on Chainlink are Bitcoin Interest Rate Curve, ETH Staking APR, and Realized Volatility.","# Rate and Volatility Feeds

  * Overview
  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized volatility

Chainlink rate and volatility feeds provide data for interest rates, interest
rate curves, and asset volatility. You can read these feeds the same way that
you read other Data Feeds. Specify the [Rate or Volatility Feed
Address](/data-feeds/rates-feeds/addresses) that you want to read instead of
specifying a Price Feed address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to learn more.

The following data types are available:

  * Bitcoin Interest Rate Curve
  * ETH Staking APR
  * Realized Volatility

## Bitcoin Interest Rate Curve

Lenders and borrowers use base rates to evaluate interest rate risk for
lending and borrowing contracts, asset valuation for derivatives contracts,
and an underlying rate for interest rate swap contracts. Bitcoin Interest Rate
Curve Data Feeds provide a base rate to assist with market decisions and
quantify the risks of using certain protocols and products based on current
and predicted baseline interest rates. The curve’s normalized methodology and
daily rates introduce more consistency and predictability to the ebb and flow
of digital asset markets. Bitcoin Interest Rate Curve Feeds incorporate a wide
range of data sources such as OTC lending desks, DeFi lending pools, and
perpetual futures markets.

To learn more about the use of these interest rate curves in the industry,
read the [Bitcoin Interest Rate Curve (CF BIRC)](https://blog.chain.link/cf-bitcoin-interest-rate-curve-cf-birc/) blog post.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the Bitcoin Interest Rate Curve feeds that are
currently available.

## ETH Staking APR

The ETH Staking APR feeds provide a trust-minimized and tamper-proof source of
truth for the global rate of return from staking as a validator to secure the
Ethereum network. The annualized rate of return is calculated over 30-day and
90-day rolling windows. Data providers use off-chain computation to calculate
returns at an epoch level, reach consensus on the APR, and then write the
results on-chain to be used by decentralized protocols and Web 3 applications.
Feeds are currently configured to update at a minimum of once per day.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find the ETH Staking APR feeds that are currently
available. If you have questions or would like to request an enhancement to
ETH Staking APR feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## Realized volatility

Realized volatility measures asset price movement over a specific time
interval. This value is expressed as a percent of the asset price. The more an
asset price moves up or down over time, the higher the realized volatility is
for that asset. Please note that realized volatility is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is

:::NEXT DOC:::

is not the same as
implied volatility, which measures the market’s expectation about future
volatility typically derived from options markets.

Each data feed reflects the volatility of an asset over a specific rolling
window of time. For example, some data feeds provide volatility data for the
last 24 hours, 7 days, and 30 days of time. You can compare the data across
these windows to infer whether the volatility of an asset is trending up or
down. For example, if realized volatility for the 24-hour window is higher
than the 7-day window, volatility might increase.

The same high-quality data providers used in Chailink’s price feeds sample
price data every 10 minutes to refresh volatility estimates. On-chain values
are updated when the feed heartbeat or deviation threshold is met.

See the [Rate and Volatility Feed Addresses](/data-feeds/rates-feeds/addresses) page to find heartbeat and deviation information for each
feed. If you have questions or would like to request an enhancement to
Realized Volatility Feeds, contact us using [this
form](https://forms.gle/Jc1MGY5ry1ceYH1X6).

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/price-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Rate and Volatility Feeds](/data-feeds/rates-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/rates-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right,
What is a Chainlink NFT Floor Price Feed?,"Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor price estimate for an NFT collection. These feeds operate the same way as other Chainlink Data Feeds. NFT Floor Price Feeds are supported by Coinbase Cloud's aggregation algorithm and Chainlink’s oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. You can use NFT Floor Price Feeds for use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.","
A Chainlink NFT Floor Price Feed is a data feed that provides a conservative and risk averse floor price estimate for an NFT collection. It is supported by Coinbase Cloud's aggregation algorithm and Chainlink's oracle infrastructure to help eliminate extreme price outliers and make these feeds resistant to market manipulation. This data feed can be used for use cases that rely on high-quality NFT data, including lending and borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products, prediction markets, and more.","# NFT Floor Price Feeds

  * Overview
  * Using NFT Floor Price Feeds

Chainlink NFT Floor Price Feeds provide a conservative and risk averse floor
price estimate for an NFT collection. These feeds operate the same way as
other Chainlink Data Feeds. NFT Floor Price Feeds are supported by [Coinbase
Cloud's](https://www.coinbase.com/cloud/) aggregation algorithm and
Chainlink’s oracle infrastructure to help eliminate extreme price outliers and
make these feeds resistant to market manipulation. You can use NFT Floor Price
Feeds for use cases that rely on high-quality NFT data, including lending and
borrowing, on-chain derivatives, dynamic NFTs, gaming guilds, CeFi products,
prediction markets, and more.

Find the list of testnet feeds on the [Contract Addresses](/data-feeds/nft-floor-price/addresses) page. To sign up for access to NFT Floor Price feeds on
Ethereum Mainnet, [use this
TypeForm](https://chainlinkcommunity.typeform.com/nft-price-feeds).

## Using NFT Floor Price Feeds

Read answers from NFT Floor Price Feeds the same way that you read other Data
Feeds. Specify the [NFT Floor Price Feed Address](/data-feeds/nft-floor-price/addresses) that you want to read instead of specifying a Price Feed
address. See the [Using Data Feeds](/data-feeds/using-data-feeds) page to
learn more.

Using Solidity, your smart contract should reference
[`AggregatorV3Interface`](https://github.com/smartcontractkit/chainlink/blob/master/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol),
which defines the external functions implemented by Data Feeds.


    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.7;
    
    import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol"";
    
    contract NFTFloorPriceConsumerV3 {
        AggregatorV3Interface internal nftFloorPriceFeed;
    
        /**
         * Network: Goerli - No Sepolia feeds available at this time
         * Aggregator: CryptoPunks
         * Address: 0x5c13b249846540F81c093Bc342b5d963a7518145
         */
        constructor() {
            nftFloorPriceFeed = AggregatorV3Interface(
                0x5c13b249846540F81c093Bc342b5d963a7518145
            );
        }
    
        /**
         * Returns the latest price
         */
        function getLatestPrice() public view returns (int) {
            // prettier-ignore
            (
                /*uint80 roundID*/,
                int nftFloorPrice,
                /*uint startedAt*/,
                /*uint timeStamp*/,
                /*uint80 answeredInRound*/
            ) =

:::NEXT DOC:::

# NFT Floor Price Feed Addresses

  * Overview
  * Ethereum Mainnet 
  * Goerli Testnet 

To learn how to use these feeds, see the [NFT Floor Price Feeds
documentation.](/data-feeds/nft-floor-price)

For LINK token and Faucet details, see the [LINK Token
Contracts](/resources/link-token-contracts?parent=dataFeeds) page.

Talk to an expert

#### Data feed categories

  * 🟢 [**Verified Feeds**](/data-feeds/selecting-data-feeds/#-verified-feeds) : Feeds that follow a standardized data feeds workflow
  * 🟡 [**Monitored Feeds**](/data-feeds/selecting-data-feeds/#-monitored-feeds) : Feeds under review by the Chainlink Labs team to support the stability of the broader ecosystem
  * 🟠 [**Provisional Feeds**](/data-feeds/selecting-data-feeds/#-provisional-feeds) : Newly released feeds on a 90-day probationary testing period
  * 🔵 [**Custom Feeds**](/data-feeds/selecting-data-feeds/#-custom-feeds) : Feeds built to serve a specific use case and might not be suitable for general use
  * ⚫ [**Specialized Feeds**](/data-feeds/selecting-data-feeds/#-specialized-feeds) : Purpose-built feeds that might rely on contracts maintained by external entities and require in-depth understanding of composition methodology before use
  * ⭕ [**Deprecating**](/data-feeds/deprecating-feeds) : These feeds are scheduled for deprecation. See the [Deprecation](/data-feeds/deprecating-feeds) page to learn more.

See the [Selecting Quality Data Feeds](/data-feeds/selecting-data-feeds) page
for complete details about each category.

Track the status of this network at <https://ethstats.dev/>

## Ethereum Mainnet

| NFT Floor Pricing Feed                   | Price units   | Deviation   |   Heartbeat |   Dec | Address                                    |
|:-----------------------------------------|:--------------|:------------|------------:|------:|:-------------------------------------------|
| ⚫Azuki Floor Price / ETH                | ETH           | 2%          |       86400 |    18 | 0xA8B9A447C73191744D5B79BcE864F343455E1150 |
| ⚫BEANZ Official Floor Price             | ETH           | 2%          |       86400 |    18 | 0xA97477aB5ab6ED2f6A2B5Cbe59D71e88ad334b90 |
| ⚫Bored Ape Yacht Club Floor Price / ETH | ETH           | 2%          |       86400 |    18 | 0x352f2Bc3039429fC2fe62004a1575aE74001CfcE |
| ⚫CloneX Floor Price                     | ETH           | 2%          |       86400 |    18 |",right,
How can I Select Quality Data Feeds on Chainlink?,"Selecting quality data feeds on Chainlink involves evaluating several factors. Here are some of the key considerations:

Number of Nodes: More nodes contributing to a data feed generally means greater decentralization and higher resistance to manipulation.

Update Frequency: How often is the data feed updated? Depending on your use case, you might need a feed that updates very frequently.

Deviation Threshold: This is the amount by which the price must change compared to the last reported price for the nodes to post a new round of data. A smaller deviation threshold can lead to more frequent updates.

Oracle Reputation: Chainlink maintains a reputation system for its oracles (nodes). Higher reputation generally means the oracle has successfully completed more jobs.

Data Source Quality: While Chainlink nodes should be getting their data from high-quality sources, it's always good to confirm this yourself. Reliable data sources increase the overall quality of the data feed.

Chainlink provides a list of Price Feeds along with detailed metrics about each feed. These metrics include the number of oracles contributing to the feed, the update frequency, the median gas price of the latest transactions, etc.","
When selecting quality data feeds on Chainlink, you should read the Risk Mitigation and Evaluating Data Sources sections to understand the inherent risks associated with each feed. Chainlink lists decentralized data feeds in the documentation to help developers build new applications integrated with data. Data feeds are grouped into the following categories based on the level of risk from lowest to highest: Verified Feeds, Monitored Feeds, Provisional Feeds, Custom Feeds, Specialized Feeds, and Deprecating. For important updates regarding the use of Chainlink Price Feeds, users should join the official Chainlink Discord and subscribe to the data-feeds-user-notifications channel.","# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem.

:::NEXT DOC:::

# Price Feeds

  * Overview

Chainlink Data Feeds provide data that is aggregated from many data sources by
a decentralized set of independent node operators. The [Decentralized Data
Model](/architecture-overview/architecture-decentralized-model?parent=dataFeeds) describes this in detail. However, there are some
exceptions where data for a feed can come only from a single data source or
where data values are calculated. Read the [Selecting Quality Data
Feeds](/data-feeds/selecting-data-feeds) to learn about the different data
feed categories and how to identify them.

## What's next

  * [› Learn how to read answers from Data Feeds](/data-feeds/using-data-feeds)
  * [› Learn how to get Historical Price Data](/data-feeds/historical-data)
  * [› Find contract addresses for Price Feeds](/data-feeds/price-feeds/addresses)
  * [› Data Feeds API Reference](/data-feeds/api-reference)

  * [ Edit this page ](https://github.com/smartcontractkit/documentation/tree/main/src/pages/data-feeds/price-feeds/index.mdx)
  * [ Join our community ](https://discord.com/invite/aSK4zew)

",right,
What are verified feeds on Chainlink?,"These are data feeds that follow a standardized data feeds workflow. Chainlink node operators each query several sources for the market price and aggregate the estimates provided by those sources.

Verified feeds have the following characteristics:

Highly resilient to disruption
Leverage many data sources
Use an extensive network of nodes
Highly liquid and well represented on a large number of markets
These feeds incorporate three layers of aggregation (at the data source, node operator, and oracle network layers), providing industry-grade security and reliability on the price data they reference. To learn more about the three layers of data aggregation, see the blog post about Data Aggregation in Chainlink Price Feeds.

Inherent risks might still exist based on your use case, the blockchain on which the feed is deployed and the conditions on that chain.","
Verified feeds on Chainlink are data feeds that follow a standardized data feeds workflow. Chainlink node operators each query several sources for the market price and aggregate the estimates provided by those sources. Verified feeds incorporate three layers of aggregation (at the data source, node operator, and oracle network layers), providing industry-grade security and reliability on the price data they reference. These feeds are highly resilient to disruption, leverage many data sources, use an extensive network of nodes, and are highly liquid and well represented on a large number of markets.","# Selecting Quality Data Feeds

  * Overview
  * Data Feed Categories
  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating
  * Risk Mitigation
  * Chainlink Community Deployments
  * Evaluating Data Sources and Risks
  * Liquidity and its Distribution
  * Single Source Data Providers
  * Crypto and Blockchain Actions
  * Market Failures Resulting from Extreme Events
  * Periods of High Network Congestion
  * Unknown and Known Users
  * Evaluating Wrapped or Bridged Assets
  * Assessing how to Price Wrapped or Bridged Assets
  * Extreme Events Causing Price Deviations in Wrapped or Bridged Assets
  * Front Running Risk
  * Fast Gas Reliability

When you design your applications, consider the quality of the data that you
use in your smart contracts. Ultimately you are responsible for identifying
and assessing the accuracy, availability, and quality of data that you choose
to consume via the Chainlink Network. Note that all feeds contain some
inherent risk. Read the Risk Mitigation and Evaluating Data Sources sections
when making design decisions. Chainlink lists decentralized data feeds in the
documentation to help developers build new applications integrated with data.

## Data Feed Categories

This categorization is put in place to inform users about the intended use
cases of feeds and help to highlight some of the inherent market risks
surrounding the data quality of these feeds.

All feeds published on [docs.chain.link](http://docs.chain.link) are monitored
and maintained to the same levels and standards. Each feed goes through a
rigorous assessment process when implemented. The assessment criteria can
change depending on the product type of feed being deployed.

Feeds do though evolve over time and we regularly monitor their market
fundamentals and will proactively communicate any upcoming changes or issues
we identify with a feed, these categories are designed to act as a mechanism
in order to assist in accomplishing that task.

Data feeds are grouped into the following categories based on the level of
risk from lowest to highest:

  * 🟢 Verified Feeds
  * 🟡 Monitored Feeds
  * 🟠 Provisional Feeds
  * 🔵 Custom Feeds
  * ⚫ Specialized Feeds
  * ⭕ Deprecating

note

For important updates regarding the use of Chainlink Price Feeds, users should
join the official Chainlink Discord and subscribe to the [data-feeds-user-
notifications channel](https://discord.gg/Dqy5N9UbsR).

### 🟢 Verified Feeds

These are data feeds that follow a standardized data feeds workflow. Chainlink
node operators each query several sources for the market price and aggregate
the estimates provided by those sources.

Verified feeds have the following characteristics:

  * Highly resilient to disruption
  * Leverage many data sources
  * Use an extensive network of nodes
  * Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem.

:::NEXT DOC:::

Highly liquid and well represented on a large number of markets

These feeds incorporate three layers of aggregation (at the data source, node
operator, and oracle network layers), providing industry-grade security and
reliability on the price data they reference. To learn more about the three
layers of data aggregation, see the blog post about [Data Aggregation in
Chainlink Price Feeds](https://blog.chain.link/levels-of-data-aggregation-in-chainlink-price-feeds/).

Inherent risks might still exist based on your use case, the blockchain on
which the feed is deployed and the conditions on that chain.

### 🟡 Monitored Feeds

Feeds under the monitored category are _under review_ by the Chainlink Labs
team to support the stability of the broader ecosystem. While generally
resilient and distributed, these feeds carry additional risk.

Data feeds might be under review for the following reasons:

  * The token project or asset is in early development
  * The project is going through a market event such as a token or liquidity migration
  * The token or project is being deprecated in the market
  * The asset has a high spread between data providers or low liquidity in the market

### 🟠 Provisional Feeds

Provisional feeds are released on an initial 90-day probationary testing
period. Underlying assets of provisional feeds do not yet meet the same
liquidity and stability standards as verified feeds, and users must understand
the additional market and volatility risks inherent with such assets. Users of
provisional feeds are responsible for independently verifying the liquidity
and stability of the feeds that they use. The use of a provisional feed is at
your own risk.

At the end of the 90-day probationary period, the status of provisional feeds
may be adjusted to verified, monitored, or be deprecated entirely.

### 🔵 Custom Feeds

Custom Feeds are built to serve a specific use case and might not be suitable
for general use or your use case's risk parameters. Users must evaluate the
properties of a feed to make sure it aligns with their intended use case.
[Contact the Chainlink Labs team](https://chain.link/contact?ref_id=DataFeed)
if you want more detail on any specific feeds in this category.

Custom feeds have the following categories and compositions:

  * **On-chain single source feeds:** These feeds take their data from an on-chain source, however the feed has only a single data provider currently supporting the feed.
  * **On-chain Proof of Reserve Feeds:** Chainlink Proof of Reserve uses the largest decentralized collection of security-reviewed and Sybil-resistant node operators in the industry to acquire and verify reserve data. In this use case, reserves reside on-chain.
  * **Technical Feeds:** Feeds within this category measure a particular technical metric from a specified blockchain. For example, Fast Gas or Block Difficulty.
  * **Total Value Locked Feeds:** These feeds measure the total value locked in a particular protocol.
  * **Custom Index Feeds:** An index calculates a function of the values for multiple underlying assets. The function is specific to that index and is typically calculated by node operators following an agreed formula.

If you plan on using one of these feeds and would like to get a more detailed
understanding, [contact the Chainlink Labs
team](https://chain.link/contact?ref_id=DataFeed).

### ⚫ Specialized Feeds

These are purpose-built feeds that might rely heavily on contracts maintained
by external entities. Typical users of these feeds are large institutional
users with deep expertise in the market space they operate in.

These feeds are monitored and well-supported, but they might not meet the same
levels of resiliency as the above categories. We strongly advise you to [speak
with the Chainlink Labs",right,
